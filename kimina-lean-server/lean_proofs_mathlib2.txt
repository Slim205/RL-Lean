===== Proof 1 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [Cauchy, Cauchy, hf.uniformity_eq, show Prod.map f f = map (fun x : Œ± √ó Œ± => (f x.1, f x.2)) by rfl,
    hf.inducing.nhds_eq_comap, map_map]

===== Proof 2 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  refine' ‚ü®fun h => _, fun h => h.map hf.uniformContinuous‚ü©
  have := h.uniformContinuous_of_discreteTopology
  exact hf.cauchy_map_iff.1 this

===== Proof 3 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have := hf.uniformContinuous.cauchy_map_iff
  simp only [cauchy_map_iff, exists_prop, hf.uniformContinuous.comp_left_uniformContinuous,
    and_true_iff] at this
  exact this

===== Proof 4 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [cauchy_map_iff, (UniformInducing.uniformContinuous_iff.2 hf.1), ‚Üê map_le_iff_le_comap,
    Cauchy.map_iff_exists_mem_map]
  aesop

===== Proof 5 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have : UniformInducing f ‚Üí UniformContinuous f := by intro; simp [UniformContinuous, *]
  simp [cauchy_map_iff, this hf, hf.1.symm, hf.2.1.symm, preimage_setOf_eq, hf.2.2]

===== Proof 6 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [Cauchy, Cauchy, hf.filter_eq]

===== Proof 7 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [Cauchy, Cauchy, hf.uniformity_comap, map_map]
  rfl

===== Proof 8 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have := hf.uniformContinuous.cauchy_map_iff
  exact this

===== Proof 9 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [hf.uniformContinuous.cauchy_map_iff, ‚Üê Filter.comap_comap]
  rfl

===== Proof 10 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [cauchy_map_iff_exists_cauchy_map_id,
    hf.uniformContinuous.cauchy_map_iff_exists_cauchy_map_id]
  exact ‚ü®fun ‚ü®F', hF', hF'map‚ü© ‚Ü¶ ‚ü®F', hF', hF'map.map hf.uniformContinuous‚ü©,
    fun ‚ü®F', hF', hF'map‚ü© ‚Ü¶ ‚ü®F', hF', hF'map.map hf.uniformContinuous‚ü©‚ü©

===== Proof 11 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [cauchy_map_iff_exists_cauchy_map_subtype, cauchy_map_iff_exists_cauchy_map_subtype]
  exact
    ‚ü®fun ‚ü®y, _, F', hF', h‚ü© =>
      ‚ü®y, hf.uniformContinuous.comp_tendsto hF', _, hF', by
        simpa only [(¬∑ ‚àò ¬∑), hf.uniformContinuous.comp_tendsto hF'] using h‚ü©,
      fun ‚ü®y, F', hF', h‚ü© =>
      ‚ü®y, F', hF', _, hF', by
        simpa only [(¬∑ ‚àò ¬∑), hf.uniformContinuous.comp_tendsto hF'] using h‚ü©‚ü©

===== Proof 12 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  constructor <;> intro <;>
  apply cauchy_map_iff.2
  <;> constructor
  <;> intro s hs
  <;> rcases cauchy_iff.1 ‚Äπ_‚Ä∫ with ‚ü®t, ht, hts‚ü©
  <;> use f ‚Åª¬π' t, hf.continuous.continuousAt.preimage_mem_nhds ht
  <;> intro x hx y hy
  <;> apply hts
  <;> use x, hx, y, hy

===== Proof 13 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have : uniformity Œ± = comap (fun p : Œ± √ó Œ± => (f p.1, f p.2)) (ùì§ Œ≤) := hf.comap_uniformity
  simp only [Cauchy, map_neBot_iff, prod_map_map_eq, map_map, ‚Üê uniformity_eq_symm]
  simp only [this, Filter.map_comap, inf_uniformity, le_inf_iff, mem_uniformity, forall_exists_index,
    and_imp]
  exact ‚ü®fun h U hU => h U hU, fun h U hU => h U hU‚ü©

===== Proof 14 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [cauchy_iff_exists_le_nhds, cauchy_iff_exists_le_nhds]
  simp_rw [Filter.map_neBot_iff, map_le_iff_le_comap, ‚Üê hf.comap_uniformity,
    ‚Üê tendsto_iff_comap, exists_and_left, exists_and_right, exists_prop, and_assoc]

===== Proof 15 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  refine' ‚ü®fun H => _, fun H => hf.1.cauchy.map H‚ü©
  obtain ‚ü®t, hzt, ht‚ü© := H.1.bounded
  refine' ‚ü®fun s hs => _‚ü©
  obtain ‚ü®t', ht', hts'‚ü© := hf.1.cauchy.1 hs
  obtain ‚ü®t'', ht'', hts''‚ü© := hf.1.cauchy.1 hzt
  refine' ‚ü®t'' ‚à™ t', ht''.union ht', _‚ü©
  rintro x ‚ü®h1, h2‚ü© y ‚ü®h3, h4‚ü©
  exact hts'' (hts' h1 h3) (hts' h2 h4)

===== Proof 16 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have := hf.uniformContinuous.cauchy_map_iff
  exact this

===== Proof 17 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [CAuchy, CAUCHY, hf.uniformity_comap, tendsto_map'_iff]; rfl

===== Proof 18 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  refine' ‚ü®fun h => _, fun h => h.map _‚ü©
  rw [Cauchy, ‚Üê hf.comap_uniformity] at h ‚ä¢
  exact h.comap _

===== Proof 19 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have := (uniformContinuous_iff_uniformInducing.mp hf.uniformContinuous)
  rw [cauchy_map_iff this, cauchy_map_iff hf.uniformContinuous.continuous]

===== Proof 20 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have := hf.comap_uniformity
  rw [cauchy_map_iff_exists_mem_uniformity]
  rw [cauchy_map_iff_exists_mem_uniformity]
  simp_rw [this]
  constructor <;> rintro ‚ü®s, hs, hF‚ü© <;> exact ‚ü®s, hs, F, hF, rfl‚ü©

===== Proof 21 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have : (map f F).NeBot ‚Üí F.NeBot := fun h => hf.comap_nhds_neBot ‚ñ∏ comap_neBot fun a ha => h (ha.map _)
  exact ‚ü®fun h => ‚ü®h.1, this h.2‚ü©, fun h => ‚ü®h.1, h.2.map hf.1‚ü©‚ü©

===== Proof 22 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [cauchy_map_iff_exists_cauchy_map_subtype, cauchy_map_iff_exists_cauchy_map_subtype]
  refine' ‚ü®fun ‚ü®U, hU, h‚ü© => ‚ü®U ‚à© range f, ‚ü®hU.1, hU.2.preimage hf.uniformContinuous‚ü©, _‚ü©,
    fun ‚ü®U, hU, h‚ü© => ‚ü®U ‚à© range f, ‚ü®hU.1, hU.2.preimage hf.uniformContinuous‚ü©, _‚ü©‚ü©
  ¬∑ rwa [‚Üê hf.comap_uniformity] at h
  ¬∑ rwa [‚Üê hf.comap_uniformity]

===== Proof 23 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  refine' ‚ü®fun h => _, fun h => h.map _‚ü©
  rw [cauchy_iff] at h
  rw [cauchy_iff, hf.inducing.nhds_eq_comap] at h
  simpa [hf.comap_uniformity] using h.2

===== Proof 24 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  /-
  The theorem 
===== Proof 25 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  cases' F with F hF
  simp only [Cauchy, map_neBot_iff, neBot_iff] at *
  simp [hf.inducing.nhds_eq_comap, hF]

===== Proof 26 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  refine' ‚ü®fun H => _, fun H => hf.uniformContinuous.cauchy_map H‚ü©
  have : UniformContinuous f := (uniformInducing_iff.1 hf).2
  exact cauchy_map_of_comp this H

===== Proof 27 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [cauchy_map_iff_exists_antitone_basis, cauchy_map_iff_exists_antitone_basis]
  refine' ‚ü®fun h => _, fun h => _‚ü©
  ¬∑ obtain ‚ü®U, h1, h2‚ü© := h
    use F.basisOf hf.1, fun i j hij => h1 (le_trans hij hij),
      fun i j hij => hf.2.preimage (h2 (le_trans hij hij))
  ¬∑ obtain ‚ü®U, h1, h2‚ü© := h
    use hf.1.comp F.basisOf hf.1, fun i j hij => h1 (le_trans hij hij), fun i j hij =>
      h2 (le_trans hij hij)

===== Proof 28 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  rw [UniformInducing, cauchy_map_iff, cauchy_iff_exists_tendsto] at hf
  exact Iff.intro
    (fun ‚ü®_, hx‚ü© => let ‚ü®_, _, hF‚ü© := hf; ‚ü®_, hF‚ü©) fun ‚ü®_, hx‚ü© =>
    let ‚ü®_, _, hF‚ü© := hf; ‚ü®_, hx‚ü©

===== Proof 29 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have : (fun x y : Œ± => (f x, f y)) = Prod.map f f := by ext; rfl
  rw [this, hf.cauchy_map_iff, hf.uniformity_comap]

===== Proof 30 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have : (fun f : Œ± ‚Üí Œ≤ ‚Ü¶ Map f F) = fun f ‚Ü¶ map f F := by ext; rfl
  rw [this]
  exact hf.uniformContinuous.cauchy_map_iff

===== Proof 31 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  have := hf.uniformContinuous.cauchy_map_iff
  exact this

===== Proof 32 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : Œ± ‚Üí Œ≤} (hf : UniformInducing f) {F : Filter Œ±} :
    Cauchy (map f F) ‚Üî Cauchy F := by
  delta UniformInducing
  rw [cauchy_map_iff, cauchy_map_iff, hf.1]

===== Proof 33 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  rw [mul_comm]
  field_simp

===== Proof 34 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 35 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  rw [mul_comm]
  field_simp

===== Proof 36 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  simp_all [div_eq_mul_inv]
  ring

===== Proof 37 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 38 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  rw [mul_comm]
  field_simp [mul_comm]

===== Proof 39 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  simp [div_eq_mul_inv, mul_comm, mul_assoc, mul_left_comm]

===== Proof 40 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 41 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 42 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 43 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 44 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 45 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 46 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 47 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 48 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  cases b <;> cases c <;> simp_all

===== Proof 49 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 50 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 51 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 52 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 53 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 54 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 55 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 56 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 57 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 58 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 59 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 60 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp [mul_comm]

===== Proof 61 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  simp [mul_comm, div_eq_mul_inv]

===== Proof 62 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp [mul_comm]

===== Proof 63 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 64 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  field_simp
  ring

===== Proof 65 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction n <;> simp_all [Nat.factorial, padicValNat]
  ring_nf
  omega

===== Proof 66 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  cases n <;> simp_all [padicValNat, factorial]

===== Proof 67 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  cases' n with n
  simp
  simp [hp, Nat.mul_sub_left_distrib, Nat.sub_eq_zero_of_le, Nat.succ_le_iff,
    Nat.le_add_left, Nat.sub_add_eq_add_sub, Nat.sub_sub_sub_cancel_right,
    Nat.sub_eq_iff_eq_add, Nat.factorial_succ]

===== Proof 68 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  eta_reduce at *
  induction' n with n hn
  ¬∑ simp
  ¬∑ rw [Nat.factorial_succ, Nat.mul_comm, Nat.mul_assoc]
    rw [padicValNat.mul (Nat.Prime.ne_one hp.out) <| factorial_ne_zero n]
    rw [Nat.succ_eq_add_one, Nat.digits_def' hp.out.two_le, Nat.sum_digits_def' hp.out.two_le,
      add_comm, add_tsub_assoc_of_le, add_comm]
    ¬∑ rfl
    ¬∑ exact Nat.le_mul_of_pos_left hp.out.pos

===== Proof 69 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  eta_reduce at *
  cases n <;> simp [padicValNat, Nat.factorial_succ, Nat.mul_sub_left_distrib,
    Nat.sub_sub_self (Nat.succ_le_of_lt (Nat.Prime.pos hp.out))]

===== Proof 70 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction n with
  | zero =>
    simp [hp.out.pos]
  | succ n hn =>
    simp_all [padicValNat, Nat.factorial_succ, Nat.mul_sub_left_distrib, Nat.sum_digits_succ]
    omega

===== Proof 71 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  rcases n with (_ | _ | n)
  all_goals simp
  all_goals simp_all [Nat.factorial]
  all_goals simp [Nat.digits_zero]
  all_goals simp [Nat.mul_sub_left_distrib]
  all_goals apply Eq.refl

===== Proof 72 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  rcases n with _ | n
  next => simp
  next =>
    simp_all [digits]
    rw [mul_comm]
    ring_nf
    apply Eq.symm
    apply Nat.succ.inj
    rw [mul_comm]
    apply Nat.sub_sub_self
    apply Nat.le_mul_of_pos_left
    linarith

===== Proof 73 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  cases n <;> simp_all
  rfl

===== Proof 74 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction' n with n hn
  simp [padicValNat]
  rw [Nat.factorial_succ, Nat.mul_comm]
  simp only [hn, Nat.cast_add, Nat.cast_one, padicValNat.mul]
  rw [Nat.add_comm, Nat.mul_comm]
  simp [Nat.mul_sub_left_distrib, Nat.mul_assoc]

===== Proof 75 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  ¬∑ induction n with
    | zero => simp
    | succ n hn =>
      simp_all [Nat.mul_sub_left_distrib, Nat.mul_sub_right_distrib, Nat.mul_add,
        Nat.add_mul, Nat.sub_mul, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc,
        Nat.sub_sub, Nat.add_sub_cancel, Nat.sub_add_cancel, Nat.add_sub_cancel,
        Nat.sub_add_cancel, Nat.sub_sub, Nat.add_sub_cancel, Nat.sub_add_cancel,
        Nat.add_sub_cancel, Nat.sub_add_cancel, Nat.sub_sub, Nat.add_sub_cancel,
        Nat.sub_add_cancel, Nat.add_sub_cancel, Nat.sub_add_cancel]

===== Proof 76 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  cases n with
  | zero => simp
  | succ n =>
    rw [Nat.factorial_succ, Nat.mul_comm]
    simp [Nat.succ_sub_succ_eq_sub, Nat.mul_comm]
    rfl

===== Proof 77 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction' n with n hn
  ¬∑ simp
  ¬∑ simp_all [Nat.mul_succ, add_comm, add_assoc, add_left_comm, add_sub_cancel]
    rfl

===== Proof 78 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  by_cases hn : n = 0
  ¬∑ simp_all
  rw [padicValNat,dif_neg]
  ¬∑ simp_all
    rfl
  ¬∑ simp [hn]

===== Proof 79 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  cases n with
  | zero => simp
  | succ n =>
    rw [Nat.factorial_succ, Nat.mul_comm]
    simp [Nat.sub_mul, Nat.mul_sub_left_distrib, Nat.sum_digits_eq_sum_digits_add_sum_digits_div_p]

===== Proof 80 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction' n with n hn
  ¬∑ simp
  ¬∑ simp only [Nat.factorial_succ, Nat.mul_sub_left_distrib, mul_one, Nat.sub_sub,
      padicValNat.mul (Nat.factorial_pos _) (Nat.prime_iff.1 hp.out).ne_zero, hn]
    rw [‚Üê Nat.mod_add_div n p]
    simp [Nat.add_comm, Nat.add_left_comm]

===== Proof 81 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction' n with n ih
  ¬∑ simp [hp.out.pos]
  ¬∑ simp_all [Nat.factorial]
  ¬∑ rw [Nat.succ_eq_add_one, mul_add, mul_one, mul_comm]
    simp_all

===== Proof 82 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  by_cases h : n = 0
  all_goals simp_all [hp.out.mul_sub_one_mul_padicValNat_factorial, Nat.factorial]

===== Proof 83 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  cases n <;> simp [Nat.factorial, Nat.mul_div_cancel_left]
  <;> simp_all [Nat.Prime.one_lt]
  <;> apply Nat.eq_zero_of_le_zero
  <;> apply Nat.le_of_lt_succ
  <;> apply Nat.succ_lt_succ
  <;> apply Nat.zero_lt_one
  <;> apply Nat.lt_of_succ_lt
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.lt_succ_self
  <;> apply Nat.add_lt_add_right
  <;> apply Nat.

===== Proof 84 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction' n with n hn
  case zero => simp
  case succ =>
  simp_all [Nat.factorial, Nat.succ_eq_add_one, Nat.mul_comm]
  rw [Nat.mul_comm]
  omega

===== Proof 85 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  cases n
  simp [hp.out.pos]
  simp [digits_def' hp.out.pos]
  rfl

===== Proof 86 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction n <;> simp [*, Nat.factorial_succ, Nat.mul_sub_left_distrib,
    Nat.sub_sub, Nat.add_comm, Nat.mul_comm] at *
  norm_num
  omega

===== Proof 87 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  match n with
  | 0 => simp
  | 1 => simp
  | n + 2 =>
    simp [padicValNat, hp.out.one_lt, Nat.factorial_succ, mul_add, mul_one, add_mul]
    omega

===== Proof 88 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction n with
  | zero => simp
  | succ n hn =>
    simp_all [factorial_succ, Nat.mul_comm, padicValNat, Nat.sub_sub, Nat.mul_sub_left_distrib,
      Nat.mul_sub_right_distrib, Nat.mul_add]

===== Proof 89 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction' n with n ih
  ¬∑ simp [hp.out.pos]
  ¬∑ rw [Nat.factorial_succ, Nat.mul_comm, mul_comm p]
    simp only [mul_comm, Nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one, ‚Üê padicValNat.mul]
    rw [ih]
    simp [digits_def' hp.out n.succ_pos, Nat.add_comm, Nat.add_left_comm]

===== Proof 90 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction' n with n hn
  simp [Nat.factorial]
  cases' n with n
  simp [Nat.factorial]
  simp [Nat.factorial, Nat.mul_mod, Nat.add_mod, Nat.mod_eq_of_lt]
  omega

===== Proof 91 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction' n with n hn
  ¬∑ simp
  rw [Nat.factorial_succ, Nat.succ_sub_succ_eq_sub, mul_comm, ‚Üê hn]
  simp [padicValNat.mul hp.out.ne_one, Nat.succ_sub_succ_eq_sub, digits_succ, sum_digits_succ]

===== Proof 92 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  rfl

===== Proof 93 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction n <;> simp_all [Nat.factorial, Nat.padicValNat, Nat.sum_digits, Nat.mul_sub_left_distrib]
  <;> try omega

===== Proof 94 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  rcases n with (_ | _ | n) <;> simp [*, Nat.factorial, hp.out.one_lt]
  <;>
    ring_nf <;> norm_num <;> decide

===== Proof 95 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  cases n
  case zero => simp [hp.out.pos]
  case succ n' =>
    simp [padicValNat, hp.out.pos, factorial, Nat.mul_left_comm]
    rfl

===== Proof 96 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ‚Ñï):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by
  induction' n with k hk; norm_num
  rw [Nat.factorial_succ, Nat.succ_eq_add_one, Nat.mul_comm]
  rw [padicValNat.mul (Nat.Prime.ne_one hp.out)]
  rw [padicValNat.prime_sub_one_mul hp.out (Nat.succ_pos k)]
  rw [Nat.succ_eq_add_one, Nat.mul_comm]
  simp_all

===== Proof 97 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  case h.intro
  axis := Œ∂" output axis
  exact ‚ü®r, Nat.lt_succ_self r, Or.inl rfl‚ü©

===== Proof 98 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  exact (hŒ∂.isUnit hno).unit_mem_norm_triv' ‚ü®x, hx‚ü©

===== Proof 99 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  intro
  simp_all

===== Proof 100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  exact (hIsGood :: _)

===== Proof 101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  apply Exists.intro', rw [pow_add, pow_mul, pow_mul, neg_pow_bit0, neg_neg, pow_two]
  rw [‚Üê mul_one (2 : ‚Ñï), ‚Üê mul_assoc, mul_comm 2, hb]
  rw [‚Üê this, neg_one_mul, ‚Üê neg_mul_eq_neg_mul]) : x = -Œ∂ ^ (r / 2)
  apply Exists.intro'
  rw [pow_add, pow_mul, pow_mul, neg_pow_bit0, neg_neg, pow_two]
  rw [‚Üê mul_one (2 : ‚Ñï), ‚Üê mul_assoc, mul_comm 2, hb]
  rw [‚Üê this, neg_one_mul, ‚Üê neg_mul_eq_neg_mul]

===== Proof 102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  tfae
  <;> simpa (config := { contextual := true }) only [pow_eq_one_iff_of_pos hno.pos, ‚Üê
    orderOf_pos_iff (hŒ∂ := hŒ∂), Nat.even_iff, isOfFinOrder_iff_pow_eq_one] using (Nat.mod_mod ¬∑
    n)

===== Proof 103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  norm_num [Finset.sum_range_succ, IsPrimitiveRoot.pow_eq_pow_iff_modEq hŒ∂.pow_eq_one,
      Finset.sum_range_succ, IsPrimitiveRoot.pow_eq_pow_iff_modEq hŒ∂.pow_eq_one,
      Finset.sum_range_succ, IsPrimitiveRoot.pow_eq_pow_iff_modEq hŒ∂.pow_eq_one,
      Finset.sum_range_succ, IsPrimitiveRoot.pow_eq_pow_iff_modEq hŒ∂.pow_eq_one]

===== Proof 104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  omega

===== Proof 105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by sorry

===== Proof 106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  eta_reduce at hr ‚ä¢
  obtain ‚ü®r, hr'‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr']
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by rintro b ‚ü®hb, h‚ü©; nth_rw 2 [‚Üê h]; loop

===== Proof 109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  intro
  omega

===== Proof 110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by aesop

===== Proof 112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  have hn : 3 ‚â§ n := by
    revert n hno
    decide
  obtain ‚ü®k, hk‚ü© := n.exists_eq_add_of_le hn
  rw [hk] at hno hŒ∂
  revert k hk
  rw [Nat.odd_iff_not_even] at hno
  refine of_contra fun ‚ü®k, hk, hnk‚ü© ‚Ü¶ ?_
  rw [Nat.even_add, hno] at hk
  contrapose! hnk
  rw [hk]
  exact ‚ü®1, by norm_num [Nat.one_add]‚ü©

===== Proof 113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  intro
  ring_nf
  <;> norm_num
  <;> ring_nf
  <;> norm_num
  <;> ring_nf
  <;> norm_num

===== Proof 116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  /-
  The theorem states that for a number field \( K \) which is a cyclotomic extension of \(\mathbb{Q}\) by an odd integer \( n \), if \( \zeta \) is a primitive \( n \)-th root of unity and \( x \) is an element of finite order in \( K \), then there exists an integer \( r \) less than \( n \) such that \( x \) is either \( \zeta^r \) or \( -\zeta^r \).
  
  The proof proceeds as follows:
  1. Since \( \zeta \) is a primitive \( n \)-th root of unity, by the property of primitive roots, there exists an integer \( r \) such that \( x = \zeta^r \) or \( x = -\zeta^r \).
  2. To find such an \( r \), we consider the integer modulo \( n \). Specifically, we take \( r \mod n \), which ensures that the exponent is less than \( n \).
  3. By the properties of modular arithmetic and the power of a primitive root, we know that \( \zeta^{r \mod n} = \zeta^r \).
  4. Therefore, we conclude that \( x = \zeta^{r \mod n} \) or \( x = -\zeta^{r \mod n} \), with \( r \mod n \) being less than \( n \).
  -/
  show IsPrimitiveRoot Œ∂ n
  exact hŒ∂

===== Proof 119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by simpa [mul_pow] using hŒ∂.pow_ne_one_of_pos_of_lt one_pos (lt_of_le_of_lt (Nat.le_of_dvd hno.pos hr.1)
      (Nat.lt_of_succ_le hr.2))

===== Proof 120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by aesop

===== Proof 121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  constructor
  exact flour_position
  sorry

===== Proof 123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by infer_instance

===== Proof 124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by cases @hno
   simp_all [hno]

===== Proof 125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  /-
  Given a number field \( K \) and a cyclotomic extension \( K \) of the rationals with respect to \( n \), and assuming \( n \) is odd, we need to show that for any primitive root of unity \( \zeta \) and any element \( x \) of finite order in \( K \), there exists a natural number \( r \) less than \( n \) such that \( x \) is either \( \zeta ^ r \) or \( -\zeta ^ r \).
  
  1. **Existence of \( r \)**: By the property of primitive roots of unity, there exists a natural number \( r \) such that \( x = -\zeta^r \).
  2. **Modulo Operation**: We consider \( r \) modulo \( n \), which gives us \( r \mod n \). Since \( r \mod n < n \), this satisfies the condition \( r < n \).
  3. **Power Representation**: Using the property of primitive roots, we know that \( \zeta^{r \mod n} = \zeta^r \).
  4. **Negation Case**: If \( r \) is even, \( \zeta^r \) is positive, and if \( r \) is odd, \( \zeta^r \) is negative. Thus, \( x = -\zeta^r \) can be rewritten as \( x = \zeta^{r \mod n} \) or \( x = -\zeta^{r \mod n} \).
  
  This completes the proof that there exists an \( r < n \) such that \( x = \zeta^r \) or \( x = -\zeta^r \).
  -/
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  have hn‚ÇÅ : ¬¨n = 1 := fun h => by simp_all
  exact hno.neg_one_pow

===== Proof 127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  aesop

===== Proof 128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ‚Ñö K]
    (hno : Odd (n : ‚Ñï)) {Œ∂ x : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (hx : IsOfFinOrder x) :
    ‚àÉ r : ‚Ñï, r < n ‚àß (x = Œ∂ ^ r ‚à® x = -Œ∂ ^ r) :=  by
  obtain ‚ü®r, hr‚ü© := hŒ∂.exists_neg_pow_of_isOfFinOrder hno hx
  refine ‚ü®r % n, Nat.mod_lt _ n.2, ?_‚ü©
  rw [show Œ∂ ^ (r % ‚Üën) = Œ∂ ^ r from (IsPrimitiveRoot.eq_orderOf hŒ∂).symm ‚ñ∏ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  sorry

===== Proof 129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  simp [DFinsupp.mem_splitSupport_iff_nonzero]

===== Proof 130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  simp [sigmaFinsuppEquivDFinsupp, Finsupp.splitSupport]
  <;> congr <;> ext <;> simp

===== Proof 131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  classical
    ext m
    simp_rw [splitSupport, sigmaFinsuppEquivDFinsupp, Equiv.coe_fn_mk, DFinsupp.finset_sum_apply]
    simp [Finsupp.sum, Finsupp.mem_support_iff]

===== Proof 132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  simp [Finset.mem_biUnion, splitSupport]

===== Proof 133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  rfl

===== Proof 134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  rw [sigmaFinsuppEquivDFinsupp, Equiv.coe_trans, Function.comp_def]
  dsimp
  ext
  simp

===== Proof 135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  simp only [sigmaFinsuppEquivDFinsupp, Equiv.coe_fn_mk, NE.def, Finsupp.splitSupport,
    Finset.mem_coe, Finset.mem_mk, Sigma.forall, Ne, Finset.mem_filter, Finset.mem_univ,
    true_and]
  rfl

===== Proof 136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  convert_to f.support = Finsupp.splitSupport f using 1
  ext
  simp

===== Proof 137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext i
  simp only [Finsupp.mem_splitSupport_iff_nonzero, sigmaFinsuppEquivDFinsupp_apply,
    Equiv.coe_trans, Function.comp_apply, Finsupp.mem_support_iff, Ne]

===== Proof 138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext ‚ü®i, x‚ü©
  simp only [sigmaFinsuppEquivDFinsupp_apply, mem_support_iff, Finsupp.mem_splitSupport_iff_ne, Ne]
  rw [Finsupp.sigma_apply, Finsupp.sigmaFinsuppEquivDFinsupp_apply, DFinsupp.mem_support_iff,
    Finsupp.mem_splitSupport_iff_ne]
  simp

===== Proof 139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext i
  simp only [sigmaFinsuppEquivDFinsupp_apply, Finsupp.mem_splitSupport_iff_nonzero,
    Finsupp.mem_support_iff, Sigma.forall, Ne]
  rw [Function.funext_iff]
  aesop

===== Proof 140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  classical
  simp_rw [sigmaFinsuppEquivDFinsupp, Equiv.coe_fn_mk, Embedding.coeFn_mk,
    Equiv.coe_fn_trans, Function.Embedding.coeFn_trans]
  simp only [Finset.map_val, Finset.range_val, Function.comp_apply, Finset.map_map]
  congr 1
  ext ‚ü®i, a‚ü©
  simp [Finsupp.mem_splitSupport_iff_nonzero]

===== Proof 141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  simp

===== Proof 142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  simp only [sigmaFinsuppEquivDFinsupp_apply, splitSupport, Function.support_dite,
    Finset.mem_def]
  rfl

===== Proof 143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  simp_rw [sigmaFinsuppEquivDFinsupp, Equiv.coe_trans, Function.comp_apply,
    ofFinsupp_support, DFinsupp.support_addMonoidHom,
    DFinsupp.support_sigma_curry_ofFinsupp]

===== Proof 144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by fast

===== Proof 145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  refine' Finset.ext fun _ => _
  simp only [sigmaFinsuppEquivDFinsupp, Equiv.coe_fn_mk, Finsupp.splitSupport, Ne, Finset.mem_map,
    Finset.mem_range, Function.comp_apply, Sigma.exists, Finset.mem_range_succ_iff]
  constructor
  ¬∑ rintro ‚ü®a, ha‚ü©
    obtain ‚ü®b, ‚ü®hb, rfl‚ü©‚ü© := Finset.mem_map.1 ha
    exact ‚ü®b, hb, apply_eq_zero_iff.1 (Equiv.symm b)‚ü©
  ¬∑ rintro ‚ü®a, ha, hab‚ü©
    exact Finset.mem_map.2 ‚ü®a.2, Finset.mem_range.2 ha, hab‚ü©

===== Proof 146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext; simp [sigmaFinsuppEquivDFinsupp, Finsupp.splitSupport]
  aesop

===== Proof 147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  simp_rw [sigmaFinsuppEquivDFinsupp, Equiv.coe_fn_mk, DFinsupp.support]
  congr 1
  ext i
  congr 1
  ext x
  simp [Finsupp.mem_splitSupport_iff_nonzero]

===== Proof 148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext ‚ü®i, j‚ü©
  -- simp only [sigmaFinsuppEquivDFinsupp_apply, Finsupp.mem_sigma_support]
  simp only [sigmaFinsuppEquivDFinsupp_apply, Finsupp.mem_splitSupport_iff_nonzero]

===== Proof 149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  if hf : f = 0 then
    simp_all
  else
    simp [splitSupport_eq_preimage, hf]

===== Proof 150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  simp [sigmaFinsuppEquivDFinsupp, Finsupp.mem_splitSupport_iff_nonzero]

===== Proof 151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  simp [sigmaFinsuppEquivDFinsupp, Finsupp.mem_splitSupport_iff_nonzero]
  aesop

===== Proof 152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  simp [DFunLike.ext_iff, sigmaFinsuppEquivDFinsupp, Finsupp.equivFunOnFinite,
    Finsupp.splitSupport, - Finsupp.mem_support_iff]

===== Proof 153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  simp

===== Proof 154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext : 2
  refine' Finset.ext_iff.2 fun i ‚Ü¶ _
  refine' Finsupp.ext fun j ‚Ü¶ _
  simp

===== Proof 155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  simp [sigmaFinsuppEquivDFinsupp, Finsupp.splitSupport, sigma_mk_injective.mem_set_image]

===== Proof 156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  simp only [sigmaFinsuppEquivDFinsupp, Finsupp.splitSupport, Finsupp.mem_support_iff, Ne,
    Finset.mem_biUnion, Sigma.exists, Finset.mem_range, exists_prop]
  ext i
  simp only [DFinsupp.mem_support_toFinsupp, Finset.mem_filter]
  aesop

===== Proof 157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  simp only [sigmaFinsuppEquivDFinsupp, Equiv.coe_fn_mk, DFinsupp.support_ofFinsupp]
  congr with x

===== Proof 158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext i
  simp [splitSupport, sigmaFinsuppEquivDFinsupp, Finsupp.mem_support_iff]
  aesop

===== Proof 159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  simp [sigmaFinsuppEquivDFinsupp, Finsupp.mem_splitSupport_iff_nonzero]

===== Proof 160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq Œπ] [Zero N]
    [‚àÄ (i : Œπ) (x : Œ∑ i ‚Üí‚ÇÄ N), Decidable (x ‚â† 0)] (f : (Œ£i, Œ∑ i) ‚Üí‚ÇÄ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  ext
  dsimp only [sigmaFinsuppEquivDFinsupp, Finsupp.splitSupport, Finsupp.mem_support_iff]
  simp

===== Proof 161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  cases' h‚ÇÇ with h‚ÇÅ h‚ÇÇ <;> simp_all
  <;> rename_i a b <;> simp_all

===== Proof 162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by simp [not_and, not_forall, exists_prop]

===== Proof 163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  aesop

===== Proof 164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  intros
  aesop

===== Proof 165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by unfold zip; aesop

===== Proof 166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  aesop

===== Proof 167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by intros; aesop

===== Proof 168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by simp_all

===== Proof 169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by aesop

===== Proof 170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  aesop

===== Proof 171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  simp only [mem_zip, mem_zipWith, mem_filter, Prod.mem, exists_and_left, exists_eq_left,
    and_imp]
  aesop

===== Proof 172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by library_search

===== Proof 173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  rcases h with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
  rcases h‚ÇÅ with ‚ü®rfl, h‚ÇÅ‚ü©
  simp_all

===== Proof 174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by aesop

===== Proof 175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by aesop

===== Proof 176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by simp (config := { contextual := true }) [Forall‚ÇÇ, eq_comm]

===== Proof 177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  aesop

===== Proof 178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  have h‚ÇÅ := forall‚ÇÇ_length_eq_of_forall‚ÇÇ all_pairs_matching_lhs
  have h‚ÇÇ := forall‚ÇÇ_length_eq_of_forall‚ÇÇ all_pairs_matching_rhs
  have h‚ÇÉ : length (forAllUnorderedPairs matching_lhs) = length (forAllUnorderedPairs matching_rhs) := by simp [h‚ÇÅ, h‚ÇÇ]
  exact h‚ÇÉ

===== Proof 179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by goal_completion

===== Proof 180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  aesop

===== Proof 181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  cases' c with a l <;> cases' d with a' l' <;>
  simp only [Forall‚ÇÇ, zip, zipWith, find?, mem_cons, Prod.mk.injEq] at *
  simp_all

===== Proof 182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  simp only [Force, have, Rec.mk, Long.cast, ite_true,
    ite_eq_left_iff, zero_ne_one, mul_eq_mul_left_iff, Nat.cast_eq_zero, mul_one, false_and,
    or_false, Nat.cast_succ]
  aesop

===== Proof 183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  cases' l‚ÇÅ with a l‚ÇÅ <;> cases' l‚ÇÇ with b l‚ÇÇ <;>
  simp_all [zip, find?, mem_cons, Forall‚ÇÇ.nil, Forall‚ÇÇ.cons,
    length_eq_zero, Nat.succ_inj', not_or]
  <;> aesop

===== Proof 184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  intros
  aesop

===== Proof 185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  simp only [le_antisymm_iff]
  aesop

===== Proof 186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by simp [length, Nat.add_eq_zero_iff]

===== Proof 187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by aesop

===== Proof 188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by simp_rw [‚Üê iff_eq_eq]

===== Proof 189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  exact Iff.intro
    (fun hl => ‚ü®hl.1, hl.2‚ü©)
    (fun h => ‚ü®h.1, h.2‚ü©)

===== Proof 190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by aesop

===== Proof 191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by decide

===== Proof 192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall‚ÇÇ_iff_zip {l‚ÇÅ l‚ÇÇ} :
    Forall‚ÇÇ R l‚ÇÅ l‚ÇÇ ‚Üî length l‚ÇÅ = length l‚ÇÇ ‚àß ‚àÄ {a b}, (a, b) ‚àà zip l‚ÇÅ l‚ÇÇ ‚Üí R a b :=
  ‚ü®fun h => ‚ü®Forall‚ÇÇ.length_eq h, @forall‚ÇÇ_zip _ _ _ _ _ h‚ü©, fun h => by
    cases' h with h‚ÇÅ h‚ÇÇ
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    ¬∑ cases length_eq_zero.1 h‚ÇÅ.symm
      constructor
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      ¬∑ simp at h‚ÇÅ
      ¬∑ simp only [length_cons, succ.injEq] at h‚ÇÅ
        exact Forall‚ÇÇ.cons (h‚ÇÇ <| by simp [zip])
          (IH h‚ÇÅ fun h => h‚ÇÇ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)‚ü©
:= by
  aesop

===== Proof 193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  ext i
  rw [Matrix.vecMul_apply, coords_apply, Finset.sum_eq_single i]
  all_goals aesop

===== Proof 194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  rw [vecMul_eq_sum_left]
  simp_rw [Matrix.mul_apply]
  simp [Finset.sum_congr, mul_comm]

===== Proof 195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp_all [Matrix.vecMul, Matrix.toMatrix, coords]

===== Proof 196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  ext i
  simp [Matrix.vecMul_apply, toMatrix_apply, coords_apply]

===== Proof 197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  rw [Vector.vecMul_eq_sum_left]
  simp_all [Matrix.mul_apply, Matrix.sum_apply]

===== Proof 198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul, Matrix.dotProduct]
  rfl

===== Proof 199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  ext i
  simp [Matrix.vecMul, Matrix.mul_apply, coords, bij_toMatrix]

===== Proof 200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul, Matrix.dotProduct]
  rfl

===== Proof 201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [coords, vecMul]
  rw [Matrix.mul_apply, Finset.sum_congr rfl]
  intros
  rfl

===== Proof 202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [coords, Matrix.vecMul, Matrix.dotProduct]
  rw [Finset.sum_comm]
  rfl

===== Proof 203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [vecMul, Matrix.mul_apply, coords, basis_toMatrix_mul_basis, comp_apply]

===== Proof 204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul, Matrix.dotProduct]
  aesop

===== Proof 205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [vecMul, Matrix.mul_apply, b.coord_apply, b‚ÇÇ.coord_apply]
  rw [Finset.sum_comm]
  rfl

===== Proof 206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul, Matrix.dotProduct]
  rfl

===== Proof 207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp only [coords, vecMul, toMatrix_apply, mul_boole]
  ext i
  simp [Finset.sum_boole, ite_and]

===== Proof 208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul, Matrix.dotProduct]
  repeat' rw [Finset.sum_fin_eq_sum_range]
  simp_all only [Finset.sum_range_succ, Finset.sum_range_zero, Nat.cast_zero, add_zero]
  rfl

===== Proof 209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul, toMatrix_apply, coords]

===== Proof 210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul_apply, Matrix.mul_apply, coords, toMatrix_apply]
  rw [Finset.sum_congr rfl]
  simp [smul_eq_mul]

===== Proof 211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  rw [vecMul_eq_sum_left]
  simp [Matrix.mul_apply, coords, -vecMul_eq_sum_left]
  rw [Finset.sum_eq_single_of_mem 0 (Finset.mem_univ _)]
  simp
  intro i _ h
  simp [h]

===== Proof 212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [coords, toMatrix_apply, Matrix.mul_apply, Finset.sum_apply]

===== Proof 213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul, Matrix.dotProduct]

===== Proof 214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  ext i
  simp [Matrix.vecMul, Matrix.mul_apply, coords, basis_toMatrix_mul_basis_coords]

===== Proof 215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul, Matrix.dotProduct]
  rfl

===== Proof 216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  rw [Matrix.vecMul_eq_mulVec, toMatrix_mul_coords]

===== Proof 217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  ext i
  simp [Matrix.vecMul, Matrix.dotProduct]

===== Proof 218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  rw [Vector.vecMul_eq_sum_left]
  simp_all only [Basis.toMatrix_apply, Basis.coord_apply, Matrix.mul_apply]
  rw [Finset.sum_congr rfl]
  simp_all only [mul_comm]

===== Proof 219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  rw [Matrix.vecMul_eq_mul_vec, ‚Üê @Matrix.vecMul_vecMul _ _ _ _ _ _ b.basis, toMatrix_basisFun]
  simp

===== Proof 220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  ext i
  simp only [Matrix.vecMul, Matrix.toMatrix_apply, coords_apply]
  rfl

===== Proof 221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  rw [vecMul_eq_sum_left]
  simp [Matrix.mul_apply, toMatrix_apply, coords]

===== Proof 222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  rw [vecMul_eq_mul_vec]
  simp [Matrix.mul_vec, Matrix.dotProduct]

===== Proof 223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  apply Matrix.vecMul_injective b‚ÇÇ <;> simp [Matrix.vecMul_mul_vecMul]

===== Proof 224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b‚ÇÇ.coords x ·µ•* b.toMatrix b‚ÇÇ = b.coords x := by
  simp [Matrix.vecMul, coords, Matrix.mul_apply, Finset.sum_apply]
  rfl

===== Proof 225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
  dsimp; rw [Seminorm.coe_sSup_eq'
H, iSup_apply]; rcases
H with ‚ü®q,
h‚ü©; exact hq (mem_image_of_mem _ hp) _‚ü©‚ü©

===== Proof 226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        specialize hq ‚ü®p, hp‚ü©
        rw [mem_image] at hq
        obtain ‚ü®y, hy, rfl‚ü© := hq
        csimp only [coe_mk, mem_upperBounds, mem_image, dite_eq_ite, ite_true, ‚Üê SeminormClass.linearIsometry_apply]
        dsimp only [Seminorm.linearIsometry_apply, id_eq]
        refine iSup_le fun i => ?_
        cases le_total 0 i
        ¬∑ aesop
        ¬∑ aesop‚ü©‚ü©‚ü©

===== Proof 227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
          dsimp at sq_le
          simp_rw [sq_le]
          rfl‚ü©‚ü©

===== Proof 228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        exact iSup_le fun p => iSup_le fun hp => hq hp x‚ü©‚ü©

===== Proof 229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
  refine' ciSup_le fun p => ciSup_le fun hp => _
      exact
le_ciSup hq hp
      ‚ü©‚ü©

===== Proof 230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        refine' le_csSup_of_le _ ‚ü®p, hp‚ü© _
        simpa using hq hp‚ü©‚ü©
 
theorem bddAbove_range_of_bounded {r : ‚Ñù} {f : Œπ ‚Üí Seminorm ùïú E} (hr : 0 ‚â§ r)
    (hf : ‚àÄ i, f i ‚â§ r ‚Ä¢ normSeminorm ùïú E) : BddAbove (range f) := by
  rw [bddAbove_iff]
  refine' ‚ü®r, _‚ü©
  rintro _ ‚ü®i, rfl‚ü©
  rw [‚Üê smul_le_smul_iff_of_neg (neg_lt_zero.2 hr)]
  simpa using hf i
  <;> rfl

===== Proof 231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        revert hp
        simp_rw [BddAbove, forall_mem_image, ‚Üê forall_update_iff 0 (¬∑ ‚â§ q x)]
        aesop‚ü©‚ü©

===== Proof 232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        refine' le_ciSup _ _
        ¬∑ use q
          intro y hy
          exact hq hy
        ¬∑ exact hp‚ü©‚ü©

===== Proof 233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        refine le_ciSup ‚ü®q x, ?_‚ü© (_ : { y : ‚Ñù | ‚àÉ p : Seminorm ùïú E, ‚àÉ (_ : p ‚àà s), y = ‚Üëp x} .Nonempty)
        ..., hq hp‚ü©‚ü©‚ü©

===== Proof 234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        have := hq hp
        dsimp at this
        exact ciSup_le fun p => this p‚ü©‚ü©

===== Proof 235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
  apply le_iSup (fun i : s => (i : Seminorm ùïú E) x) p‚ü©‚ü©

protected theorem bddBelow_iff {s : Set <| Seminorm ùïú E} :
    BddBelow s ‚Üî BddBelow ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  Seminorm.bddAbove_iff (ùïú := ùïú) (E := E)

===== Proof 236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by simpa using hq hp x‚ü©‚ü©

===== Proof 237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
  rw [iSup_apply]
  exact le_ciSup ‚ü®q x, forall_mem_range.2 fun f ‚ü®f', hf'‚ü© => hf'.symm ‚ñ∏ (hq f' f.2) x‚ü©
          ‚ü®p, hp‚ü©‚ü©‚ü©

===== Proof 238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        refine' ciSup_le fun i => ciSup_le fun hi => (hq <| mem_image_of_mem _ hi).trans _
        exact le_iSup‚ÇÇ (fun i _ => (i : Seminorm ùïú E) x) q hi‚ü©‚ü©‚ü©

===== Proof 239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        dsimp
        rw [iSup_apply]
        exact le_ciSup hq ‚ü®p, hp‚ü© ‚ü©‚ü©

===== Proof 240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        dsimp at hq
        have := hq hp
        rwa [hq hp] at this
      ‚ü©‚ü©

===== Proof 241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
  dsimp
  rw [Seminorm.coe_sSup_eq' H, iSup_apply]
  rcases H with ‚ü®q, hq‚ü©
  exact (hq (‚ü®p, hp‚ü© : s) : _)‚ü©‚ü©

===== Proof 242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
  refine le_ciSup (‚ü®q x, ?_‚ü© : BddAbove (?_ : Set ‚Ñù)) hp‚ü©

===== Proof 243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
            refine' ciSup_le fun p => ciSup_le fun hp => hq _ hp _‚ü©‚ü©

===== Proof 244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by apply_rules [csSup_le, forall_mem_apply, zero_le, hp]
‚ü©‚ü©

===== Proof 245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
    dsimp
    exact
      hq hp x‚ü©‚ü©

===== Proof 246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
  apply ciSup_le fun p => hq p.2 x‚ü©‚ü©

===== Proof 247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by aesop ‚¶Éai‚¶Ñ‚ü©

===== Proof 248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
          refine ciSup_le fun p => ciSup_le' <| hq p.2‚ü©‚ü©

===== Proof 249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
  rcases IsEmpty.false ùïú with ‚ü®‚ü®k, _‚ü©, ‚ü®‚ü©‚ü©
  haveI : Nonempty ùïú := ‚ü®k‚ü©
  apply hq hp‚ü©‚ü©

===== Proof 250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        refine' ciSup_le fun p => ciSup_le fun h => _
        exact hq h p hp‚ü©‚ü©

===== Proof 251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        apply ciSup_le
        rintro i
        apply hq
        exact hp‚ü©‚ü©

===== Proof 252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by apply csSup_le ‚ü®q x, _‚ü© hq; exact fun p hp y => (hq hp).trans <| le_csSup H hp (q x)‚ü©‚ü©

===== Proof 253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        refine' le_ciSup_set_id _ _ _
        convert hq hp‚ü©‚ü©

===== Proof 254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
          apply_rules [csSup_le, zero_le']
          ¬∑ exact ‚ü®q, hq‚ü©
          ¬∑ exact hp‚ü©‚ü©

===== Proof 255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by

===== Proof 256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm ùïú E} :
    BddAbove s ‚Üî BddAbove ((‚Üë) '' s : Set (E ‚Üí ‚Ñù)) :=
  ‚ü®fun ‚ü®q, hq‚ü© => ‚ü®q, forall_mem_image.2 fun p hp => hq hp‚ü©, fun H =>
    ‚ü®sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ‚ü®q, hq‚ü©
      exact
:= by
        refine' ciSup_le fun i => le_ciSup ‚ü®q x, _‚ü© _
        obtain ‚ü®p, hp, rfl‚ü© := i.prop
        exact hq hp _‚ü©‚ü©‚ü©

===== Proof 257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  rw [‚Üê cancel_epi (leftDistributor X f).hom]
  ext
  dsimp
  simp [comp_sum, sum_comp]
  rfl

===== Proof 258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  ext
  dsimp [leftDistributor, biproduct.bicone]
  erw [comp_sum, sum_comp]
  simp only [comp_id, id_comp, Finset.sum_apply, Finset.sum_dite_eq', Finset.mem_univ,
    ite_true, comp_biproduct_Œπ, Category.assoc]
  rw [‚Üê biproduct.total]
  dsimp
  simp

===== Proof 259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  ext
  dsimp [leftDistributor]
  simp [biproduct.matrix_mul_œÄ, biproduct.Œπ_œÄ_assoc, Category.assoc]

===== Proof 260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  ext
  dsimp [leftDistributor]
  simp [Œπ_leftDistributor_assoc, biproduct.project_œÄ]

===== Proof 261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  simp [leftDistributor_inv, biproduct.bicone_œÄ, biproduct.bicone_Œπ,
    biproduct.Œπ_desc_assoc, biproduct.lift_œÄ]

===== Proof 262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  rw [leftDistributor_eq_lift_desc]
  aesop_cat

===== Proof 263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  ext
  simp [leftDistributor_inv, biproduct.Œπ_œÄ, comp_dite]

===== Proof 264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  apply biproduct.hom_ext
  aesop_cat

===== Proof 265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  simp [leftDistributor, biproduct.bicone, Fintype.unop_equiv]

===== Proof 266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  apply Eq.symm
  simp
  rfl

===== Proof 267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  ext
  dsimp [leftDistributor]
  simp [leftDistributor]
  rfl

===== Proof 268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  ext
  simp [leftDistributor_hom, Iso.inv]

===== Proof 269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  apply biproduct.hom_ext
  intro j
  simp [leftDistributor_inv, biproduct.proj_œÄ, biproduct.Œπ_desc]

===== Proof 270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  simp [leftDistributor, biproduct.bicone]
  aesop

===== Proof 271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  simp [leftDistributor_inv, biproduct.bicone_œÄ_eq_œÄ, biproduct.bicone_Œπ_eq_Œπ]

===== Proof 272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  ext
  dsimp [leftDistributor]
  simp [comp_sum, sum_comp]

===== Proof 273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  refine' biproduct.hom_ext _ _ (fun j => _)
  dsimp
  simp [Finset.sum_dite_irrel, Finset.sum_comp]

===== Proof 274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  ext
  simp [leftDistributor_inv]

===== Proof 275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  dsimp only [leftDistributor]
  aesop

===== Proof 276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  simp [leftDistributor_eq_rightDistributor, rightDistributor, biproduct.bicone_œÄ, biproduct.bicone_Œπ,
    Category.assoc]

===== Proof 277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  simp [leftDistributor_inv, biproduct.bicone_œÄ, biproduct.bicone_Œπ, Category.assoc]

===== Proof 278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  simp [leftDistributor_inv]

===== Proof 279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  apply Eq.symm
  ext
  dsimp [leftDistributor]
  simp

===== Proof 280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  apply biproduct.hom_ext
  intro j
  simp [leftDistributor_inv]

===== Proof 281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  dsimp [leftDistributor]
  simp

===== Proof 282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  dsimp [leftDistributor, Functor.mapBiproduct, Functor.mapBicone]
  apply biproduct.hom_ext
  intro j
  dsimp
  simp [biproduct.Œπ_œÄ, leftDistributor, Functor.mapBiproduct, Functor.mapBicone]

===== Proof 283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  simp [‚Üê Iso.sum_comp, Iso.symm_comp]

===== Proof 284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  apply Eq.symm
  apply biproduct.hom_ext
  intro j
  simp [leftDistributor_hom, biproduct.Œπ_œÄ, comp_sum_assoc]
  apply Eq.symm
  apply Finset.sum_eq_single_of_mem _ (Finset.mem_univ j)
  intro j' _ hj'
  simp [biproduct.Œπ_œÄ, hj'.symm]

===== Proof 285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  simp only [leftDistributor, Category.assoc, biproduct.lift_œÄ, biproduct.Œπ_desc, biproduct.Œπ_œÄ,
    ‚Üê Category.assoc, eqToHom_refl, eqToHom_trans]
  simp only [leftDistributor, Finset.sum_const, Finset.card_univ, ‚Üê mul_smul, one_smul,
    eqToHom_refl, eqToHom_trans]
  rfl

===== Proof 286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  dsimp [leftDistributor]
  apply biproduct.hom_ext
  intro j
  simp [biproduct.Œπ_desc, biproduct.lift_œÄ, comp_dite]

===== Proof 287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  ext
  dsimp [leftDistributor, leftDistributor_hom]
  simp [biproduct.Œπ_œÄ]

===== Proof 288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :
    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by
  dsimp [leftDistributor]
  rw [Iso.inv_eq_of_hom_inv_id]
  simp only [Iso.hom_inv_id, Category.id_comp, Category.assoc, biproduct.Œπ_œÄ, comp_sum, sum_comp]
  simp only [comp_id, id_comp, eqToHom_refl, eqToHom_trans, Fintype.sum_apply,
    Fintype.sum_apply]
  simp [Finset.sum_dite_eq, Finset.sum_dite_eq, Finset.mem_univ, Finset.sum_const, Finset.card]

===== Proof 289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  simp_all
  aesop

===== Proof 290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  /-
  We aim to show that if \( f \) is a function from \( \beta \times \gamma \) to \( E \) that is almost everywhere strongly measurable with respect to the measure induced by the composition-product of two kernels \( \kappa \) and \( \eta \), then the function \( x \mapsto \int y, f(x, y) \, d\eta(a, x) \) is also almost everywhere strongly measurable with respect to the measure induced by \( \kappa \).
  
  Given that \( f \) is almost everywhere equal to a strongly measurable function \( \text{mk}(f) \) with respect to the composition-product measure, we can use the properties of the integral and the fact that \( \text{mk}(f) \) is strongly measurable to conclude that the integral of \( f \) over \( y \) is also strongly measurable. Specifically, we use the fact that the integral of a strongly measurable function is strongly measurable and that the integral preserves almost everywhere equality.
  -/
  -- We start by approximating 
===== Proof 291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  intro hI hz
  contrapose! hI
  linarith

===== Proof 292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  aesop

===== Proof 293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  /-
  The theorem states that if \( f \) is a function from \( \beta \times \gamma \) to \( E \) that is almost everywhere strongly measurable with respect to the composition product of two kernels \( \kappa \) and \( \eta \), then the function \( g(x) = \int y, f(x, y) \, d\eta(a, x) \) is also almost everywhere strongly measurable with respect to the kernel \( \kappa \).
  
  The proof involves constructing a strongly measurable function \( h \) such that \( g(x) = h(x) \) almost everywhere. This is achieved by taking the integral of the almost everywhere strongly measurable function \( f \) over \( \eta \) and showing that the result is also almost everywhere strongly measurable.
  -/
  -- Use the 
===== Proof 294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  aesop

===== Proof 295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  /-
  To prove that the function \( \mu \) defined by \( \mu(b) = \int_{\gamma} f(b, y) \, d\eta(y) \) is almost everywhere strongly measurable with respect to the measure \( \kappa \), we proceed as follows:
  
  1. **Construct a sequence of simple functions converging pointwise to \( \mu \)**:
     - For each \( n \), define \( \mu_n(b) = \int_{\gamma} f_n(b, y) \, d\eta(y) \), where \( f_n \) is a simple function approximating \( f \) in \( L^p \).
  
  2. **Show that \( \mu_n \) is strongly measurable**:
     - Since \( f_n \) is simple, \( \mu_n \) is a finite sum of terms of the form \( \int_{\gamma} g_i(b, y) \, d\eta(y) \), where \( g_i \) is bounded and \( \eta \)-measurable.
  
  3. **Prove the convergence of \( \mu_n \) to \( \mu \)**:
     - By the dominated convergence theorem, \( \mu_n \to \mu \) in \( L^p \), and hence pointwise almost everywhere.
  
  4. **Verify that \( \mu \) is almost everywhere strongly measurable**:
     - Since \( \mu_n \) are simple and measurable, and they converge pointwise almost everywhere, \( \mu \) is almost everywhere strongly measurable.
  -/
  -- Define the function \mu as the integral of f with respect to Œ∑.
  let Œº := fun b => ‚à´ y, f (b, y) ‚àÇŒ∑ (a, b)
  -- Show that each \mu_n is strongly measurable.
  have h1 : ‚àÄ b, StronglyMeasurable (fun b => ‚à´ y, f (b, y) ‚àÇŒ∑ (a, b)) := fun b =>
    Integrable.stronglyMeasurable (Integrable.integral_kernel_prod_right'' hf)
  -- Show that \mu is almost everywhere strongly measurable by using the fact that \mu_n converges pointwise almost everywhere.
  exact AEStronglyMeasurable.integral_kernel_compProd hf

===== Proof 296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  simpa only [AEStronglyMeasurable, nullMeasurable_compProd_mk_left] using
    hf.nullMeasurable_compProd_mk_left

===== Proof 297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  exact fun x ‚Ü¶ by simp_all

===== Proof 298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  simpa using hf.compProd_mk_left_ae_eq

===== Proof 299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  sorry

===== Proof 300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  /-
  We need to show that if \( f \) is a function on \( \beta \times \gamma \) that is almost everywhere strongly measurable with respect to the product measure of \( \kappa \) and \( \eta \) at \( a \), then the function \( x \mapsto \int y, f(x, y) \, d\eta(a, x) \) is also almost everywhere strongly measurable with respect to \( \kappa \) at \( a \).
  
  1. **Identify the function and its properties**: Let \( f : \beta \times \gamma \to E \) be a function such that \( f \) is almost everywhere strongly measurable with respect to the product measure of \( \kappa \) and \( \eta \) at \( a \). This means there exists a strongly measurable function \( g \) such that \( f = g \) almost everywhere.
  
  2. **Construct the function**: Define \( h(x) = \int y, f(x, y) \, d\eta(a, x) \). We need to show that \( h \) is almost everywhere strongly measurable with respect to \( \kappa \) at \( a \).
  
  3. **Use the integral property**: Since \( f \) is almost everywhere equal to \( g \), we can use the integral property of \( g \) to show that \( h \) is almost everywhere equal to the integral of \( g \). Specifically, for any \( x \),
     \[
     h(x) = \int y, f(x, y) \, d\eta(a, x) = \int y, g(x, y) \, d\eta(a, x)
     \]
     because the integral respects almost everywhere equality.
  
  4. **Apply the strong measurability**: Since \( g \) is strongly measurable in both \( x \) and \( y \), the integral \( \int y, g(x, y) \, d\eta(a, x) \) is also strongly measurable in \( x \). Therefore, \( h \) is almost everywhere strongly measurable with respect to \( \kappa \) at \( a \).
  
  Thus, we have shown that the function \( x \mapsto \int y, f(x, y) \, d\eta(a, x) \) is almost everywhere strongly measurable with respect to \( \kappa \) at \( a \).
  -/
  -- Use the fact that f is almost everywhere equal to its ae_strongly_measurable representative
  let h := fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)
  -- Show that the integral of the representative is ae_strongly_measurable
  have : AEStronglyMeasurable (fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
    hf.stronglyMeasurable_mk.integral_kernel_prod_right''
  -- Use the fact that the integral of f is almost everywhere equal to the integral of its representative
  exact this.congr (by filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using
    integral_congr_ae hx)

===== Proof 301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  exact (continuous_setToFun B hcœÜ hm).comp <| continuous_swap_smul s.continuous_toReal

===== Proof 302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  rcases eq_or_ne (Œ∫ a) 0 with rfl | h
  ¬∑ rfl
  rcases eq_or_ne (Œ∫ a) 1 with rfl | h'
  ¬∑ rfl
  rw [‚Üê one_mul (Œ∫ a)] at h
  convert h.elim
  aesop

===== Proof 303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by aesop

===== Proof 304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  intro h‚ÇÅ
  rw [h‚ÇÅ]
  simp

===== Proof 305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  /-
  We need to show that if \( f \) is almost everywhere strongly measurable with respect to the measure induced by the composition-product of two kernels \( \kappa \) and \( \eta \) at a point \( a \), then the function \( x \mapsto \int y, f(x, y) \, d\eta(a, x) \) is almost everywhere strongly measurable with respect to the measure induced by the kernel \( \kappa \) at \( a \).
  
  Given that \( f \) is almost everywhere equal to a strongly measurable function \( g \) with respect to the measure induced by the composition-product of \( \kappa \) and \( \eta \) at \( a \), we can use this equality to show that the integral of \( f \) over \( y \) is almost everywhere equal to the integral of \( g \) over \( y \), which is itself strongly measurable.
  -/
  -- We use the fact that 
===== Proof 306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  ((_ : MeasureTheory.AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    MeasureTheory.AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a))
  exact .integral_kernel_compProd

===== Proof 307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  /-
  We aim to show that if \( f \) is a function from \( \beta \times \gamma \) to \( E \) and is almost everywhere strongly measurable with respect to the measure induced by the composition-product of two kernels \( \kappa \) and \( \eta \), then the function \( x \mapsto \int y, f(x, y) \, d\eta(a, x) \) is also almost everywhere strongly measurable with respect to \( \kappa(a) \).
  
  Given \( f \) is almost everywhere strongly measurable with respect to \( (\kappa \otimes \eta) a \), there exists a strongly measurable function \( f' \) such that \( f = f' \) almost everywhere. We then construct a function \( \kappa' \) as the integral of \( f' \) with respect to \( \eta(a, x) \), which is strongly measurable. Finally, we show that \( \kappa' \) is equal to the integral of \( f \) with respect to \( \eta(a, x) \) almost everywhere, thus proving the desired result.
  -/
  -- We use the fact that f is almost everywhere strongly measurable to find a strongly measurable function f' such that f = f' almost everywhere.
  have hf.1 : AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) := by
    refine' AEStronglyMeasurable.integral_kernel_compProd hf
  -- We then show that the function x ‚Ü¶ ‚à´ y, f' (x, y) ‚àÇŒ∑ (a, x) is also almost everywhere strongly measurable.
  exact hf.1

===== Proof 308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  /-
  We need to show that if \( f \) is almost everywhere strongly measurable with respect to the product measure of two kernels \( \kappa \) and \( \eta \), then the function \( x \mapsto \int y, f(x, y) \, d\eta(a, x) \) is also almost everywhere strongly measurable with respect to \( \kappa \).
  
  Given \( f : \beta \times \gamma \to E \) and the assumption that \( f \) is almost everywhere strongly measurable with respect to the product measure \( (\kappa \otimes \eta) a \), we can find a strongly measurable function \( g \) such that \( f = g \) almost everywhere. We then define a new function \( h \) as the integral of \( g \) with respect to \( \eta \). By the properties of the integral and the almost everywhere equality, we can show that \( h \) is strongly measurable and that \( h = \int y, f(x, y) \, d\eta(a, x) \) almost everywhere.
  -/
  -- Define the function 
===== Proof 309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  simp_rw [compProd_apply]
  exact hf

===== Proof 310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  exact ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x),
    hf.stronglyMeasurable_mk.integral_kernel_prod_right'',
    by filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©

===== Proof 311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  rw [show (priorityToWin +winProbability) / (priorityToWin +winProbability+giveUpProbability) = 1 / 2 by norm_num]
  norm_num

===== Proof 312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  exact MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd hf

===== Proof 313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by aesop

===== Proof 314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  apply MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd
  <;> aesop

===== Proof 315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  revert hf
  apply AEStronglyMeasurable.convolution_integrable

===== Proof 316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  intros a b
  simp only [elim_injects, forall_const]

===== Proof 317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  intro h_ch ‚ü®I, h_in‚ü© ‚ü®y, hy‚ü©
  simpa using h_ch I

===== Proof 318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  simp [Nat.factorial]
  decide

===== Proof 319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  /-
  The theorem states that if a function \( f \) is almost everywhere strongly measurable with respect to the composition product of two kernels \( \kappa \) and \( \eta \), then the function obtained by integrating \( f \) over one of the variables is also almost everywhere strongly measurable with respect to the corresponding kernel. The proof constructs a strongly measurable function by taking the integral of the almost everywhere equal function and uses the fact that the integral of this function is also almost everywhere equal to the original function.
  -/
  -- Construct a strongly measurable function by taking the integral of the almost everywhere equal function.
  refine' ‚ü®_, hf.stronglyMeasurable_mk.integral_kernel_prod_right'', _‚ü©
  -- Use the fact that the integral of the strongly measurable function is almost everywhere equal to the original function.
  filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx

===== Proof 320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ‚Ñù E]
    ‚¶Éf : Œ≤ √ó Œ≥ ‚Üí E‚¶Ñ (hf : AEStronglyMeasurable f ((Œ∫ ‚äó‚Çñ Œ∑) a)) :
    AEStronglyMeasurable (fun x => ‚à´ y, f (x, y) ‚àÇŒ∑ (a, x)) (Œ∫ a) :=
  ‚ü®fun x => ‚à´ y, hf.mk f (x, y) ‚àÇŒ∑ (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx‚ü©
:= by
  split <;> aesop

===== Proof 321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  norm_num
  ring
  omega

===== Proof 322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with p hp; simp only [hp, Nat.mul_succ, Nat.mul_one]
  ring_nf
  rw [‚Üê Nat.succ_eq_add_one]
  ring
  omega

===== Proof 323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  norm_num
  ring
  omega

===== Proof 324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; simp only [hk, mul_add, add_mul, mul_one, one_mul, pow_add, pow_one,
    pow_two]; norm_num
  ring
  field_simp
  ring

===== Proof 325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk
  subst hk
  norm_num
  ring
  omega

===== Proof 326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  rcases hp with ‚ü®k, rfl‚ü©
  norm_num
  ring_nf
  field_simp
  ring_nf

===== Proof 327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk
  subst hk
  field_simp
  ring

===== Proof 328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  norm_num at hp ‚ä¢
  cases' hp with k hk; subst hk
  ring_nf
  omega

===== Proof 329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  norm_num
  ring
  norm_num
  omega

===== Proof 330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  ring_nf
  omega

===== Proof 331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  have hb : b ‚â† 1 := by linarith
  norm_num at hb
  rw [Nat.pow_succ, Nat.pow_succ]
  ring

===== Proof 332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  norm_num
  ring
  omega

===== Proof 333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  rcases hp with ‚ü®k, rfl‚ü©
  ring_nf
  omega

===== Proof 334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  simp only [mul_add, mul_one, add_right_comm, ‚Üê mul_assoc,
    show 2 * 2 = 4 by norm_num, pow_mul]
  norm_num
  ring
  norm_num
  rfl

===== Proof 335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; simp only [hk, Nat.mul_comm, Nat.mul_succ] at hk ‚ä¢;
    norm_num at hk ‚ä¢; ring_nf at hk ‚ä¢
  omega

===== Proof 336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; simp only [hk, add_assoc] at hk ‚ä¢; rw [hk]
  ring
  norm_num
  omega

===== Proof 337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  ring_nf
  field_simp
  ring

===== Proof 338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; simp only [hk, Nat.succ_eq_add_one, Nat.add_right_comm, Nat.add_sub_cancel]
  ring_nf
  norm_num
  omega

===== Proof 339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  have h‚ÇÄ : p = 1 := by
    cases' hp with k hk
    omega
  subst h‚ÇÄ
  simp [Nat.mul_comm]

===== Proof 340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  norm_num at *
  ring_nf at *
  field_simp at *
  ring_nf at *
  omega

===== Proof 341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  obtain ‚ü®k, rfl‚ü© := hp
  all_goals
    norm_num
    ring
    omega

===== Proof 342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  simp only [Nat.pow_succ, Nat.mul_succ]
  ring_nf
  norm_num
  omega

===== Proof 343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  have hb := hp.pos
  cases' p with p
  all_goals simp_all [Nat.pow_succ, Nat.pow_mul, Nat.mul_sub_left_distrib]
  all_goals
    omega

===== Proof 344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  have hb‚ÇÄ : 0 < b := by linarith
  have hb‚ÇÅ : 0 < b ^ 2 - 1 := by
    cases' hp with k hk
    rw [hk]
    nlinarith
  rw [Nat.div_mul_cancel]
  cases' hp with k hk
  rw [hk]
  ring_nf
  rw [Nat.div_eq_of_eq_mul_left (by linarith : 0 < b ^ 2 - 1)]
  ring_nf
  omega

===== Proof 345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  norm_num [Nat.mul_succ, Nat.pow_succ, Nat.add_assoc]
  ring_nf
  omega

===== Proof 346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  norm_num
  ring
  omega

===== Proof 347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  rcases hp with ‚ü®k, rfl‚ü©
  rw [Nat.pow_succ]
  ring_nf
  field_simp
  ring

===== Proof 348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk
  subst hk
  norm_num
  ring_nf
  field_simp
  ring_nf

===== Proof 349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk
  subst hk
  simp only [add_sub_cancel, one_mul, add_zero, mul_one, add_right_inj]
  ring_nf
  omega

===== Proof 350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  rcases hp with ‚ü®k, rfl‚ü©
  simp only [add_assoc, Nat.pow_succ, Nat.pow_mul, Nat.pow_two]
  ring_nf
  field_simp
  ring

===== Proof 351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  rcases hp with ‚ü®k, rfl‚ü©
  norm_num
  ring_nf
  omega

===== Proof 352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ‚Ñï) (_ : 2 ‚â§ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  cases' hp with k hk; subst hk
  ring_nf
  norm_num
  omega

===== Proof 353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  have := hs.isOpen_coe.nhds_basis h's
  have := Filter.HasBasis.le_cardinal_of_isOpen this (fun _ ‚Ü¶ hs) fun _ ‚Ü¶ h's
  simpa only [Cardinal.mk_coe_set] using this

===== Proof 354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  rw [show #s = #(s : Set E) from rfl]
  rw [Cardinal.mk_fintype s]
  exact le_of_eq (by simpa using hs.cardinal_mk_eq_lift)

===== Proof 355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  exact (mk_le_of_injective (fun n => x + n ‚Ä¢ (1 : E))
    (fun _ _ h => by
      simpa only [add_left_inj, one_smul, add_right_inj] using h)).trans
    ((mk_iUnion_le_lift _).trans_eq (by simp_rw [mk_real, continuum_eq_ùî†, lift_id]))

===== Proof 356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have : ‚àÉ (f : ùïú ‚Üí E), Continuous f ‚àß range f = s := by
    refine ‚ü®fun x => x ‚Ä¢ x, ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ exact
        hs.continuous_iff.2 fun e =>
          mul_comm (x - x) e ‚ñ∏ (continuous_sub (continuous_id.smul continuous_const)
            (continuous_id.smul continuous_const : Continuous fun x => x ‚Ä¢ x)).mul continuous_const
    ¬∑ ext y
      constructor
      ¬∑ rintro ‚ü®x, rfl‚ü©
        exact ‚ü®x, rfl‚ü©
      ¬∑ exact fun hy => ‚ü®y, hy‚ü©
  cases' this with f hf
  simpa using
    Cardinal.mk_le_of_injective (hf.2 ‚ñ∏ (injective_iff_map_eq_zero f).2 fun _ => mul_self_eq_zero)

===== Proof 357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  exact (mk_le_of_injective (fun _ => x) fun _ _ _ => hx).trans_eq
    (Cardinal.mk_ordConnectedComponent hs x)

===== Proof 358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  rw [show #s = #(‚Ü•s) by simp]
  have : #(‚Ü•s) ‚â§ ùî† := by
    apply mk_le_of_injective
    exact Set.injective_subtype s
  apply le_trans this
  apply le_of_eq
  rw [Cardinal.mk_eq_mk_of_injective Set.injective_subtype]

===== Proof 359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  rw [show #s = #(s √óÀ¢ (‚ä§ : Set ùïú)) by
    rw [‚Üê mk_univ ùïú]; exact (mk_prod s _).symm]
  have := hs.prod isOpen_univ
  rw [show s √óÀ¢ (‚ä§ : Set ùïú) = s by
    rw [‚Üê mk_univ ùïú]; simp] at this
  apply le_of_lt
  exact mk_lt_aleph0_of_finite this.toFinite

===== Proof 360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have h := hs.mem_nhds hx
  have h'' := h.exists_isOpen_lt_mem
  clear hx h
  obtain ‚ü®u, hu, h'u, h''u, hu'‚ü© := h''
  have h''' := (hu'.card_lt_aleph0).le
  apply le_trans _ (Cardinal.mk_ord_le_aleph0 ((‚Üë) : { x // x ‚àà s } ‚Üí E) ‚ü®‚ü®x, hu'.mem_to_sub_family‚ü©, h''u‚ü©)
  rw [Cardinal.mk_fintype]
  rfl

===== Proof 361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  let F : Type _ ‚Üí Type _ := fun _ ‚Ü¶ E
  let f : ‚àÄ n : ‚Ñï, F n ‚Üí F (n + 1) := fun n _ ‚Ü¶ (0 : E)
  let g : F 0 ‚Üí F 1 := fun _ ‚Ü¶ (0 : E)
  let f' : ‚àÄ n : ‚Ñï, F (n + 1) ‚Üí F n := fun n _ ‚Ü¶ (0 : E)
  let g' : F 1 ‚Üí F 0 := fun _ ‚Ü¶ (0 : E)
  let A : Set (‚àÄ n, F n) := {f | ‚àÄ n, f n ‚àà s}
  let A' : Set (‚àÄ n, F n) := {f | ‚àÄ n, f n ‚àà s}
  let B : Set (‚àÄ n, F n) := {f | ‚àÄ n, f n ‚àà s}
  let B' : Set (‚àÄ n, F n) := {f | ‚àÄ n, f n ‚àà s}
  have : #s ‚â§ #A := by
    apply Cardinal.mk_le_of_surjective
    intro f
    exact ‚ü®fun _ ‚Ü¶ f, rfl‚ü©
  have : #A = #A' := rfl
  have : #A' ‚â§ #B := by
    apply Cardinal.mk_le_of_surjective
    intro f
    exact ‚ü®fun _ ‚Ü¶ f, rfl‚ü©
  have : #B = #B' := rfl
  have : #B' ‚â§ ùî† := by
    apply Cardinal.mk_le_of_surjective
    intro f
    exact ‚ü®fun _ ‚Ü¶ f, rfl‚ü©
  convert le_trans this (le_trans this this)
  rfl

===== Proof 362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  cases' h's with x hx
  letI := Fintype.complete ùïú
  cases' continuum_le_cardinal_of_mem_nhds (ùïú := ùïú) (E := E) hs hx with h h
  exact h

===== Proof 363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have := hs.exists_mem_open isOpen_univ univ_mem
  have := exists_pos_forall_sum_lt E zero_lt_one
  let f : ‚Ñï ‚Üí E := fun n => Classical.choose this n
  have hf : ‚àÄ n : ‚Ñï, 0 < ‚àë i ‚àà range (n + 1), f i ‚àß ‚àë i ‚àà range (n + 1), f i < 1 := fun n =>
    Classical.choose_spec this n
  let C : Set E := range f
  have hC : #C = ùî† := mk_range_eq_of_injective (fun _ _ h => (hf _).1.ne (by simpa using h))
  have : #C ‚â§ #s :=
    power_nat_le _ hC ‚ñ∏ mk_le_of_surjective fun x => ‚ü®x, rfl‚ü©
  exact this.trans (mk_le_of_subset (subset_univ _))

===== Proof 364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  rw [show #s = #(s √óÀ¢ {0}) by rw [mk_prod_singleton]]
  apply le_mk_of_le
  simpa using hs.prod isOpen_singleton_zero

===== Proof 365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  rw [isOpen_iff_mem_nhds] at hs
  obtain ‚ü®x, hx‚ü© := h's
  letI := hx.nhds.neBot
  apply le_of_forall_le_of_dense
  intro n hn
  let k := hx.choose
  let F := (linearIsometryEquiv (ùïú := ùïú) (E := E) (F := ùïú)).symm
  have hF : F '' s ‚äÜ ùïú := by
    rintro _ ‚ü®y, hy, rfl‚ü©
    exact F.isLinearMap y
  have hF' : #(F '' s) ‚â§ #ùïú := by
    exact Cardinal.mk_le_of_injective F.injective
  have hF'' : #(F '' s) ‚â§ ùî† := by
    exact Cardinal.mk_le_of_injective F.injective
  have hF''' : ùî† ‚â§ #(F '' s) := by
    rw [Cardinal.le_mk_iff_exists_set]
    refine ‚ü®s, rfl, ?_‚ü©
    exact hs hx
  exact le_trans hn (le_trans hF''' (le_trans hF'' hF'))

===== Proof 366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  apply le_of_surjective _
  exact fun x => x +·µ• x
  intro x
  use x -·µ• x
  simp [vadd_vsub]

===== Proof 367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have : #ùïú ‚â§ #s := by
    rw [show #ùïú = ùî† from Cardinal.eq.symm (by simpa using ùïú : Cardinal.aleph0_le_continuum)]
    apply Cardinal.continuum_le_cardinal_of_isOpen hs ‚ü®x, hx‚ü©
  simpa using this

===== Proof 368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  have : ‚àÉ c : Cardinal, c ‚â§ #s := by
    use #s
    rfl
  apply le_of_le_of_eq _ (Cardinal.mk_ordConnectedComponent hs h's)
  simpa using
    Cardinal.ordConnectedComponent_le_of_isOpen hs h's

===== Proof 369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  refine' le_of_le_of_eq (mk_le_of_subset_of_forall (fun _ _ => mem_univ _) fun _ _ => hs.mem_nhds) _
  obtain ‚ü®x, hx‚ü© := h's
  exact ((mk_denumerable ùïú).symm.trans (mk_denumerable E).symm).le.trans (mk_le_of_injective <| addLeftEmbedding x)

===== Proof 370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have : ùî† ‚â§ #ùïú := by
    rw [Cardinal.le_aleph0_iff_set_countable]
    exact ‚ü®fun _ => x, fun _ _ h =>
      (continuous_id (ùïú := ùïú) (E := ùïú)).1.injective h‚ü©
  have : #ùïú ‚â§ #s := by
    refine Cardinal.mk_le_of_injective ?_ (Continuous.continuousOn (fun _ => x))
  exact this.trans hs.cardinal_mk_le

===== Proof 371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have := hs.exists_isOpen_ball_subset hx
  obtain ‚ü®r, hr, hr'‚ü© := this
  have hball : #(Metric.ball x r) ‚â§ #s := by
    apply mk_le_of_subset
    apply hr'
  have hball' : #(Metric.ball x r) = ùî† := by
    apply mk_ball_eq_continuum
    assumption'
  assumption

===== Proof 372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  rw [show #ùî† = #(Set.univ : Set ùïú)] by rw [Set.univ_eq_univ_iff]; exact ‚ü®fun _ => ‚ü®‚ü©, fun _ => ‚ü®‚ü©‚ü©
  apply Cardinal.mk_le_of_injective _ hs.injective_on_injective; simpa using h's

===== Proof 373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  have : s.Nonempty := h's
  obtain ‚ü®x, hx‚ü© := this
  have := exists_mem_of_ne_zero (ne_zero_of_mem_of_unit x)
  obtain ‚ü®y, hy‚ü© := this
  have := exists_mem_of_ne_zero (ne_zero_of_mem_of_unit y)
  obtain ‚ü®z, hz‚ü© := this
  have := hs.exists_mem_open isOpen_univ ‚ü®0, by simp‚ü©
  obtain ‚ü®w, hw‚ü© := this
  norm_num [hx, hy, hz, hw]
  aesop

===== Proof 374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  exact (mk_le_of_subset_of_ae_mem hs.exists_mem_nhds_within_subset h's).trans_eq
    (by rw [Cardinal.mk_nhdsWithin_of_mem h's]; simp)

===== Proof 375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®c, hc‚ü© := h's
  haveI := Classical.decEq s
  have := hs.exists_isOpen_ball c
  rcases this with ‚ü®r, hr‚ü©
  apply le_trans _ (Cardinal.mk_ordConnectedComponent_le (mem_univ s))
  suffices (‚ãÉ p : s, ball p r) = s by
    have H := Cardinal.mk_iUnion_le_sum
    apply le_trans H
    apply Cardinal.sum_le_sum _
    intro p
    apply mk_ordConnectedComponent_le
  simp
  exact Eq.symm (iUnion_eq_self_of_mem_subset hs.mem_nhdsSet (fun _ hp => hr ‚ñ∏ hp))

===== Proof 376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have : ùî† ‚â§ #(Set.univ : Set E) := by
    rw [Cardinal.eq_of_mk_eq (Cardinal.mk_univ E)]
    exact le_rfl
  apply this.trans
  rw [Cardinal.le_mk_iff_exists_set]
  exact ‚ü®s, ‚ü®Set.subset_univ _, hs.openEmbedding_subtype_val.injOn‚ü©‚ü©

===== Proof 377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  rw [show #s = ùî† from hs.cardinal_eq_continuum h's]
  simp

===== Proof 378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  apply le_of_forall_pos_le_add
  intro _
  exact (mk_le_of_subset (hs.exists_subset_nhds'.choose_spec.1.trans (subset_of_mem_nhds' h's
    hs.exists_subset_nhds'.choose_spec.2)))

===== Proof 379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have h' : ùî† ‚â§ #ùïú := by
    exact le_trans aleph0_le_aleph0 (by norm_num)
  have h : #ùïú ‚â§ #s := by
    apply Cardinal.mk_le_of_injective
    exact fun x y hxy => by
      apply eq_of_dist_eq_zero
      have hxy' : dist x y = 0 := by
        rw [dist_eq_norm]
        simp [hxy]
      simpa using hxy'
  apply le_trans h' h

===== Proof 380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have h := le_of_lt (Cardinal.lt_aleph0_of_finite (Set.finite_singleton x))
  have h := Cardinal.mk_le_of_injective (Function.injective_id :
    Function.Injective (id : ({x} : Set E) ‚Üí E))
  have h := Cardinal.add_eq_right.{u, u} h
  have h := Cardinal.add_le_aleph0.{u, u} h
  have h := Cardinal.aleph0_le_continuum.{u, u}
  have h := Cardinal.add_le_aleph0.{u, u} h
  have h := Cardinal.add_le_aleph0.{u, u} h
  exact Cardinal.le_of_lt (Cardinal.continuum_lt_continuum.2 h)

===== Proof 381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  have : ‚àÉ y ‚àà s, y ‚â† x := by
    simpa [exists_and_left, exists_eq_left] using hs.exists_ne x
  apply le_of_le_of_eq _ (Cardinal.mk_fintype (Fin 2))
  exact Cardinal.continuum_le_mk _

===== Proof 382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  refine' le_of_not_lt fun h => _
  have h' : Set.Infinite s := by
    rw [‚Üê Set.infinite_coe_iff]
    refine' @Set.infinite_of_finite_compl _ _ _ hs.isClosed_compl (lt_of_le_of_lt _ h)
    simpa using Cardinal.mk_univ.symm.trans_le (Cardinal.mk_le_mk_of_subset (compl_subset_univ _))
  exact h'.false

===== Proof 383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  have : ùî† ‚â§ #(‚àë·∂† i : ‚Ñù, ùïú) := by
    refine le_trans _ (Cardinal.cantor _)
    exact one_lt_aleph0.trans_le (by simpa using le_sum_of_one_le fun _ => one_le_aleph0)
  refine this.trans ?_
  suffices #(‚àë·∂† i : ‚Ñù, ùïú) ‚â§ #(s ‚à© Set.range fun x : ùïú => x) by
    exact this.trans (Cardinal.mk_le_of_injective fun x => x.1)
  exact mk_sum_le.trans (Cardinal.mk_le_of_injective <|
    (add_injective _).comp (smul_injective _ (injective_id (ùïú := ùïú))))

===== Proof 384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (ùïú : Type*) [NontriviallyNormedField ùïú] [CompleteSpace ùïú] [AddCommGroup E]
    [Module ùïú E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ùïú E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : ùî† ‚â§ #s := by
  obtain ‚ü®x, hx‚ü© := h's
  exact le_of_le_of_eq (mt (fun h ‚Ü¶ h ‚ñ∏ s.finite_of_isOpen hs) h's.infinite_iff.2)
    (Cardinal.mk_ord_out <| @OutParam.instNonempty _ (‚ü®x, hx‚ü© : s))

===== Proof 385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp [HasCompactMulSupport, hg, Function.comp_apply]

===== Proof 386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [HasCompactMulSupport, mulSupport_comp]
  simp_rw [Set.disjoint_left, Set.mem_preimage, hg, Set.disjoint_singleton_left, imp_false,
    mulSupport_eq_empty_iff, not_forall]
  aesop

===== Proof 387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [hasCompactMulSupport_def]
  simp_rw [Function.comp_apply]
  rw [mulSupport_comp_eq_preimage]
  have : g ‚Åª¬π' {1} = {1} := by
    ext x
    simp [hg]
  rw [this]
  simp

===== Proof 388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [mulSupport_comp_eq_preimage, Set.preimage_eq_empty_iff, mulSupport_eq_empty_iff,
    hg, forall_eq']
  aesop

===== Proof 389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [HasCompactMulSupport, hg]
  simp (config := { contextual := true }) only [mulSupport_comp_eq_preimage, Set.preimage_def,
    Set.mem_preimage, Set.mem_singleton_iff, hg]
  apply hasBasis_compact.tendsto_iff hasBasis_compact
  aesop

===== Proof 390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [hasCompactMulSupport_def, mulSupport_comp, preimage_setOf_eq, hg]
  simp [hasCompactSupport_def]

===== Proof 391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [HasCompactMulSupport, Function.comp_apply, hg]
  simp

===== Proof 392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [HasCompactMulSupport, hg]
  simp only [mulSupport_comp, Set.preimage_one]
  simp only [isCompact_closure_iff_of_isCompact_sep (hg.trans one_ne_zero), Set.preimage_one]

===== Proof 393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [has_compact_mul_support_def, mul_one, hg]
  exact ‚ü®fun h => by simpa applying h, fun h => by simpa applying h‚ü©

===== Proof 394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [HasCompactMulSupport, Function.comp, hg]
  simp_rw [mulSupport_comp_eq_preimage f g]
  rw [isCompact_preimage]
  simp [hg]

===== Proof 395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [HasCompactMulSupport, mulSupport_comp_eq_preimage, Set.preimage_one hg]

===== Proof 396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [mulSupport_comp_eq_preimage, Set.preimage_one, hg]
  exact hasCompactSupport_comp_left (Œ± := Œ±)

===== Proof 397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [hasCompactMulSupport_def]
  simp_rw [mulSupport_comp g f]
  simp [hg]

===== Proof 398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [hasCompactMulSupport_def]
  simp [hg]

===== Proof 399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  delta HasCompactMulSupport
  simp_rw [mulSupport_comp]
  simp [hg]

===== Proof 400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [hasCompactMulSupport_def, mulSupport_comp_eq g]
  simp [hg]

===== Proof 401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [mulSupport_comp_eq_preimage, Set.preimage_preimage, hg]
  exact ‚ü®fun h => h.of_preimage_one, fun h => h.of_preimage_one‚ü©

===== Proof 402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [hasCompactMulSupport_def, Function.comp_apply]; aesop

===== Proof 403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [HasCompactMulSupport, mulSupport_comp_eq_preimage]
  simp_rw [Set.preimage_def]
  simp [hg]

===== Proof 404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [HasCompactMulSupport, hg, forall_eq, mem_imp_iff, function.comp_apply]
  simp

===== Proof 405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [mulSupport_comp_eq_preimage, Set.preimage_one g, mulSupport_one]
  exact (hasCompact_preimage_1 hg).symm

===== Proof 406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [HasCompactMulSupport, hg, Function.comp, Set.preimage_one]
  simp

===== Proof 407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [HasCompactMulSupport, mulSupport_comp]
  simp only [Set.image_1_eq_singleton_iff, hg, and_true]

===== Proof 408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [HasCompactMulSupport, mulSupport_comp_eq_preimage, hg]
  simp [preimage_const_of_mem (hg.2 (f 1))]

===== Proof 409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp [HasCompactMulSupport, isCompact_iff_compactSpace, ‚Üê exists_and_left,
    - exists_prop, - exists_eq_left, - exists_eq_right, - exists_eq_right']
  aesop

===== Proof 410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [hasCompactMulSupport_def, mulSupport_comp_eq_preimage]
  aesop

===== Proof 411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [HasCompactMulSupport, Function.comp_apply, hg, exists_eq_or_imp, mulSupport_comp_eq_preimage]
  constructor <;> intro h <;> [continuity; exact h]

===== Proof 412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [HasCompactMulSupport, f.mulSupport_comp_eq hg]

===== Proof 413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  constructor <;> intro <;>
    simp_all only [mulTSupport_comp_subset, mulTSupport_comp_eq_tsupport_of_mulSupport]
  all_goals aesop

===== Proof 414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp_rw [HasCompactMulSupport, Function.comp_apply, hg]
  simp [isCompact_singleton]

===== Proof 415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp only [HasCompactMulSupport, hg]
  simp (config := { contextual := true }) [not_imp_not]

===== Proof 416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ‚àÄ {x}, g x = 1 ‚Üî x = 1) :
    HasCompactMulSupport (g ‚àò f) ‚Üî HasCompactMulSupport f := by
  simp [HasCompactMulSupport, hg]

===== Proof 417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  unfold mk
  simp

===== Proof 418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk]

===== Proof 419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [DifferentialObject.d_mk]

===== Proof 420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk]

===== Proof 421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk, d]

===== Proof 422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  unfold mk
  simp

===== Proof 423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk, d‚ÇÄ]

===== Proof 424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk, d]

===== Proof 425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [ChainComplex]

===== Proof 426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  aesop

===== Proof 427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk, d]

===== Proof 428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [dif_neg (by decide : ¬¨(1 : ‚Ñï) = 0)]

===== Proof 429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [DifferentialObject.d]

===== Proof 430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [ChainComplex.mk]

===== Proof 431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simpa using
    (inferInstanceAs (d‚ÇÄ = 0 ‚Üí (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ)).2 rfl

===== Proof 432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [succ]

===== Proof 433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk_succ, d_next]

===== Proof 434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [diff_i]

===== Proof 435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk]

===== Proof 436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk, d]

===== Proof 437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  rw [mk_d_0_is_composable]
  rfl

===== Proof 438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk, d_0_1]

===== Proof 439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [succ]

===== Proof 440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [diff_i]

===== Proof 441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by aesop

===== Proof 442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [diff_i]

===== Proof 443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk_f_1_0, X‚ÇÅ]

===== Proof 444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk, d‚ÇÄ]

===== Proof 445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk, d]

===== Proof 446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [diff]

===== Proof 447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  rfl

===== Proof 448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by
  simp [mk, d‚ÇÄ]

===== Proof 449 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, assoc]

===== Proof 450 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, whiskerLeft_id_assoc]

===== Proof 451 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, rightUnitor_inv_naturality]

===== Proof 452 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp only [comp_whiskerRight, id_whiskerRight, whisker_right_id, comp_id, id_comp]
  simp [whisker_exchange]

===== Proof 453 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, Œ∑.naturality]

===== Proof 454 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [WhiskerRight, id_whiskerRight]

===== Proof 455 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  rw [‚Üê id_whiskerRight Œ∑, ‚Üê comp_whiskerRight (œÅ_ f).hom, ‚Üê comp_whiskerRight (œÅ_ g).inv]
  simp

===== Proof 456 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, whisker_exchange]

===== Proof 457 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, rightUnitor_inv]

===== Proof 458 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, assoc]

===== Proof 459 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [rightUnitor_inv_naturality]

===== Proof 460 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight, rightUnitor, rightUnitor_conjugation]

===== Proof 461 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [bicategory_comp, whiskerRight_comp, whisker_exchange]
  rw [‚Üê cancel_epi (œÅ_ f).inv]
  simp

===== Proof 462 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, ‚Üê cancel_epi (f ‚â´ Œ∑)]

===== Proof 463 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, ‚Üê cancel_epi (f ‚â´ Œ∑)]

===== Proof 464 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, assoc]

===== Proof 465 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  rw [‚Üê comp_whiskerRight, comp_id, whiskerRight_id]

===== Proof 466 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [rightUnitor_inv_naturality]

===== Proof 467 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id_symm, rightUnitor_inv]

===== Proof 468 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id]

===== Proof 469 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id]

===== Proof 470 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [‚Üê cancel_epi (f ‚â´ Œ∑)]

===== Proof 471 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [assoc]

===== Proof 472 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id_assoc]

===== Proof 473 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [rightUnitor_inv_naturality]

===== Proof 474 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, triangle]

===== Proof 475 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp

===== Proof 476 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp only [whiskerRight_id, rightUnitor_inv_naturality]
  simp

===== Proof 477 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, rightUnitor_inv_naturality]

===== Proof 478 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  rw [whisker_exchange, Iso.inv_hom_id, whisker_left_id, whisker_right_id]

===== Proof 479 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskerRight_id, whiskerLeft_id, ‚Üê cancel_epi (f ‚â´ Œ∑)]

===== Proof 480 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : Œ∑ = (œÅ_ f).inv ‚â´ Œ∑ ‚ñ∑ ùüô b ‚â´ (œÅ_ g).hom := by
  simp [whiskeringRight, id_whiskerRight]

===== Proof 481 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  have := Module.ext' S
  simp_all

===== Proof 482 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp

===== Proof 483 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  apply LaurentSeries.ext
  intro n
  simp [smul_coeff]

===== Proof 484 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext; simp [coeff_smul, ofPowerSeries_apply]

===== Proof 485 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext; simp

===== Proof 486 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp

===== Proof 487 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [smul_coeff]

===== Proof 488 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  rw [‚Üê PowerSeries.of_eq_Coe, RingHom.map_smul, of_eq_Coe, map_smul]

===== Proof 489 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp

===== Proof 490 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  rfl

===== Proof 491 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [smul_coeff]

===== Proof 492 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  apply Module.ext
  ext n
  simp [smul_apply, PowerSeries.coeff, LaurentSeries.coeff]
  rfl

===== Proof 493 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  apply PowerSeries.ext
  intro n
  rw [coeff_coe, coeff_smul, coeff_ofPowerSeries, coeff_smul]
  rfl

===== Proof 494 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [smul_coeff]

===== Proof 495 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [ofPowerSeries, coeff_of_int, smul_coeff]

===== Proof 496 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  congr 1
  rfl

===== Proof 497 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [smul_coeff]

===== Proof 498 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext n
  simp only [Module.algebraMap_end_apply, coe_mul_ofPowerSeries, coe_ofPowerSeries_mul]
  simp only [smul_eq_mul, ofPowerSeries, smul_one_eq_cast, mul_comm, Function.comp_apply,
    smul_apply, coe_def, mul_assoc, mul_left_comm, mul_comm, RingHom.id_apply]
  ring

===== Proof 499 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  rw [‚Üê ofPowerSeries_smul, ofPowerSeries_coe]

===== Proof 500 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [coeff_smul, smul_coeff]

===== Proof 501 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [mul_comm]

===== Proof 502 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  apply ext
  intro n
  simp [smul_coeff]

===== Proof 503 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp

===== Proof 504 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  simp [smul_eq_C_mul, mul_comm]

===== Proof 505 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [ofPowerSeries, smul_coeff, coeff_coe, smul_ite]

===== Proof 506 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [LaurentSeries.smul_coeff, PowerSeries.coeff_smul, mul_assoc]

===== Proof 507 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [coeff_smul, ofPowerSeries, coeff_ext]

===== Proof 508 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  simp [coeff_smul, ‚Üê smul_assoc, smul_eq_mul]

===== Proof 509 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  simp [smul_eq_C_mul, mul_comm]

===== Proof 510 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext; simp [smul_coeff]

===== Proof 511 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext
  rfl

===== Proof 512 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r ‚Ä¢ x : PowerSeries S) : LaurentSeries S) = r ‚Ä¢ (ofPowerSeries ‚Ñ§ S x) := by
  ext; simp [smul_coeff]

===== Proof 513 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases' p with p_coeff p_order
  rfl

===== Proof 514 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  simp only [integerNormalization, coeffIntegerNormalization]

===== Proof 515 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases p
  rfl

===== Proof 516 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rw [coeff, coeff_integerNormalization]

===== Proof 517 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  simp only [coeff, integerNormalization, coeffIntegerNormalization, Function.comp]

===== Proof 518 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases p
  rfl

===== Proof 519 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  simp only [integerNormalization, coeffIntegerNormalization]

===== Proof 520 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases p
  rfl

===== Proof 521 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rfl

===== Proof 522 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases' p with p
  rfl

===== Proof 523 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rcases p with ‚ü®‚ü©
  simp only [integerNormalization, coeff_monomial]
  rcases i with _ | _ | i
  all_goals simp [coeffIntegerNormalization]

===== Proof 524 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases p
  rfl

===== Proof 525 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rcases p with ‚ü®p‚ü©
  simp only [integerNormalization, coeffIntegerNormalization, coeff]

===== Proof 526 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases p
  rfl

===== Proof 527 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rcases p with ‚ü®‚ü©
  rfl

===== Proof 528 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases p
  rfl

===== Proof 529 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rfl

===== Proof 530 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rw [integerNormalization, coeffIntegerNormalization]

===== Proof 531 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  simp only [integerNormalization, coeffIntegerNormalization]
  by_cases hi : i < p.natDegree
  ¬∑ exact if_pos hi
  ¬∑ exact if_neg hi

===== Proof 532 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  induction p using Polynomial.induction_on'
  case hp hq => simp [*, coeffIntegerNormalization]
  case hq hp hq => simp [*, coeffIntegerNormalization]

===== Proof 533 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases p
  rfl

===== Proof 534 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rw [integerNormalization, coeffIntegerNormalization]

===== Proof 535 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  induction p using Polynomial.induction_on' with
  | h_add p q hp hq =>
    simp only [coeff_add, coeffIntegerNormalization, hp, hq, coeff_monomial,
      Finset.sum_ite_eq, Finset.mem_univ, ite_true]
  | h_monomial n z =>
    simp [integerNormalization]
    split_ifs with h1 h2 h3
    simp only [if_true, eq_self_iff_true] at h1
    simp only [if_true, eq_self_iff_true] at h2
    simp only [if_true, eq_self_iff_true] at h3
    contradiction

===== Proof 536 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  induction p using Polynomial.induction_on' <;> simp_all [coeff_monomial]

===== Proof 537 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  induction p using Polynomial.induction_on'
  simp [integerNormalization, coeffIntegerNormalization, *]
  rfl

===== Proof 538 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rcases p with ‚ü®p‚ü©
  simp only [integerNormalization, coeffIntegerNormalization, coeff]
  dsimp only
  congr

===== Proof 539 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rcases p with ‚ü®p‚ü©
  simp only [integerNormalization, coeffIntegerNormalization]
  rfl

===== Proof 540 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases p; rfl

===== Proof 541 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  simp [integerNormalization, coeffIntegerNormalization]

===== Proof 542 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  cases i <;> simp [integerNormalization, coeff_monomial]

===== Proof 543 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rw [integerNormalization, coeffIntegerNormalization]
  aesop

===== Proof 544 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ‚Ñï) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by
  rw [integerNormalization, coeffIntegerNormalization]

===== Proof 545 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  have hs : FiniteDimensional ‚Ñù (affineSpan ‚Ñù (Set.range s.points)) := by
    apply FiniteDimensional.finiteDimensional_of_finite
    exact (Set.finite_range s.points).to_subtype
  rw [dist_comm] at hp1
  rw [dist_comm]
  apply dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq_aux
  exacts [hp1, hs]

===== Proof 546 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm p1 p2]
  let a := s.orthogonalProjectionSpan p2
  rw [sq, sq, dist_eq_norm_vsub V p2 a, dist_eq_norm_vsub V p1 a,
    ‚Üê vsub_add_vsub_cancel p1 p2 a]
  simp only [map_add, norm_add_sq_real, add_assoc, add_left_comm, add_right_comm]
  ring_nf
  rw [add_comm]
  simp [add_comm]

===== Proof 547 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p2 (s.orthogonalProjectionSpan p2),
    dist_eq_norm_vsub V p1 (s.orthogonalProjectionSpan p2), ‚Üê vsub_add_vsub_cancel p1 p2 (s.orthogonalProjectionSpan p2),
    norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]
  exact s.inner_orthogonalProjection_vsub_eq_zero p2 hp1

===== Proof 548 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq, ‚Üê
    s.orthogonalProjection_eq_self_iff, s.orthogonalProjection_eq_self_iff]
  exacts [hp1, self_mem_affineSpan_of_mem_set]

===== Proof 549 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm] at *
  rw [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq]
  rw [dist_comm]
  rw [dist_comm]

===== Proof 550 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V]
  rw [dist_eq_norm_orthogonalProjection_vsub V, dist_eq_norm_orthogonalProjection_vsub V]
  rw [‚Üê vsub_add_vsub_cancel p1 p2 (s.orthogonalProjectionSpan p2)]
  apply norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero
  exact s.inner_orthogonalProjection_vsub_eq_zero p2

===== Proof 551 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  have hp1' : p1 ‚àà affineSpan ‚Ñù (Set.range s.points) := hp1
  rw [sq, dist_comm p1, dist_comm p1]
  $TFAE_have 1 2 (dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq_aux s p2 hp1')
  <;> simp [*]

===== Proof 552 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  have h := dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq ‚Ñù s.points p1 p2 hp1
  rw [dist_comm, dist_comm p2] at h
  exact h

===== Proof 553 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm p1 p2]
  rw [dist_comm p1 (s.orthogonalProjectionSpan p2)]
  rw [dist_comm p2 (s.orthogonalProjectionSpan p2)]
  rw [dist_eq_norm_vsub V p1 p2]
  rw [dist_eq_norm_vsub V p1 (s.orthogonalProjectionSpan p2)]
  rw [dist_eq_norm_vsub V p2 (s.orthogonalProjectionSpan p2)]
  rw [‚Üê vsub_add_vsub_cancel p1 (s.orthogonalProjectionSpan p2) p2]
  apply norm_add_sq_eq_norm_sq_add_norm_sq

===== Proof 554 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [‚Üê mul_self_inj_of_nonneg dist_nonneg dist_nonneg]
  repeat' rw [dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_eq_zero_of_mem_affine_span]
  ring_nf
  rw [‚Üê mul_self_inj_of_nonneg dist_nonneg dist_nonneg]
  repeat' rw [dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_eq_zero_of_mem_affine_span]
  ring_nf
  rw [s.orthogonalProjection_mem_affineSpan]
  ring_nf

===== Proof 555 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq_add_two_mul_add_two_mul
    s.orthogonalProjection_orthogonalProjection (Set.mem_range_self _)]
  simp [add_assoc, add_comm, add_left_comm]

===== Proof 556 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm p1 p2]
  apply dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq
  exact hp1

===== Proof 557 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_eq_norm_vsub, dist_eq_norm_vsub, dist_eq_norm_vsub, dist_eq_norm_vsub]
  rw [‚Üê @comp_apply_eq ‚Ñù, ‚Üê @comp_apply_eq ‚Ñù]
  norm_num
  rw [@InnerProductSpace.toNormedAddCommGroup.norm_eq_sqrt_inner ‚Ñù,
    @InnerProductSpace.toNormedAddCommGroup.norm_eq_sqrt_inner ‚Ñù,
    @InnerProductSpace.toNormedAddCommGroup.norm_eq_sqrt_inner ‚Ñù,
    @InnerProductSpace.toNormedAddCommGroup.norm_eq_sqrt_inner ‚Ñù]
  simp [@InnerProductSpace.toNormedAddCommGroup.inner_add_add_self ‚Ñù]

===== Proof 558 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_eq_norm_vsub V p1 p2]
  rw [dist_eq_norm_vsub V p1 (s.orthogonalProjectionSpan p2)]
  rw [dist_eq_norm_vsub V p2 (s.orthogonalProjectionSpan p2)]
  rw [‚Üê vsub_add_vsub_cancel p1 (s.orthogonalProjectionSpan p2) p2]
  apply norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero
  exact s.orthogonalProjection_inner_eq_zero p2

===== Proof 559 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  have h := s.dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq p2 hp1
  simp_all only [dist_comm, dist_eq_norm_vsub, ‚Üê sq, add_comm]

===== Proof 560 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p1 (s.orthogonalProjectionSpan p2),
     dist_eq_norm_vsub V p2 (s.orthogonalProjectionSpan p2)]
  congr
  apply LinearMap.map_add

===== Proof 561 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_le_iff_dist_sq_le]
  rw [dist_le_iff_dist_sq_le]
  rw [dist_le_iff_dist_sq_le]
  ring_nf
  nlinarith [s.orthogonalProjection_mem p2, s.orthogonalProjection_mem p1,
    s.orthogonalProjection_orthogonal p1, s.orthogonalProjection_mem p2]

===== Proof 562 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm]
  nlinarith [dist_comm (s.orthogonalProjectionSpan p2) p1,
    dist_comm (s.orthogonalProjectionSpan p2) p2]

===== Proof 563 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm p1 p2]
  apply dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq
  apply hp1

===== Proof 564 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_eq_norm_vsub V _ _, dist_eq_norm_vsub V _ _, dist_eq_norm_vsub V _ _]
  rw [add_comm]
  rw [and_comm ((_ : _) ‚àß _)]
  rw [Real.norm_of_nonneg (norm_nonneg _)]
  rw [Real.norm_of_nonneg (norm_nonneg _)]
  rw [Real.norm_of_nonneg (norm_nonneg _)]
  rw [‚Üê @dist_eq_norm_vsub _ _ _ _ _ _]
  rw [‚Üê @dist_eq_norm_vsub _ _ _ _ _ _]
  rw [‚Üê @dist_eq_norm_vsub _ _ _ _ _ _]
  rw [OrthogonalProjection.dist_add_dist_orthogonalProjection_eq_dist p1 p2 s.affineSpan_eq_top]

===== Proof 565 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm p1]
  rw [dist_comm p2]
  rw [‚Üê dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq s p2 hp1]
  simp [dist_eq_norm_vsub V _ _]
  rw [‚Üê add_comm]
  apply Eq.symm
  simp [add_comm]

===== Proof 566 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_eq_norm_vsub V p1 p2]
  rw [dist_eq_norm_vsub V p1 (s.orthogonalProjectionSpan p2)]
  rw [dist_eq_norm_vsub V p2 (s.orthogonalProjectionSpan p2)]
  rw [‚Üê vsub_add_vsub_cancel p1 (s.orthogonalProjectionSpan p2) p2]
  rw [norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]
  apply s.orthogonalProjection_inner_eq_zero

===== Proof 567 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  ¬∑ rw [dist_comm p1 p2]
    apply norm_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero
    apply s.orthogonalProjection_inner_eq_zero
    assumption

===== Proof 568 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  have hs : FiniteDimensional.finrank ‚Ñù (affineSpan ‚Ñù (Set.range s.points)) = n + 1 := by
    simpa using s.independent.finrank_affineSpan
  rw [dist_comm p1 p2]
  apply dist_eq_add_of_mem_orthogonal (s.orthogonalProjectionSpan_mem_ker p2) hp1

===== Proof 569 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm p1 p2]
  nlinarith [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq s.orthogonalProjection p2
    (mem_affineSpan ‚Ñù (Set.mem_range_self _))]

===== Proof 570 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  have h1 : dist p1 p2 * dist p1 p2 = dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
    simp_all only [sq, dist_eq_norm_vsub, ‚Üê mul_self_inj_of_nonneg dist_nonneg dist_nonneg,
      dist_vsub_cancel_right, dist_eq_norm_vsub, vadd_vsub, vadd_vsub,
      dist_vsub_cancel_left, add_right_eq_self, mul_self_eq_mul_self_iff]
    ring_nf
    tauto
  apply h1

===== Proof 571 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p1 (s.orthogonalProjectionSpan p2),
    dist_eq_norm_vsub V p2 (s.orthogonalProjectionSpan p2)]
  nlinarith [s.point_mem_orthogonalProjectionSpan p2 p1 hp1]

===== Proof 572 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm] at hp1; rw [dist_comm]
  rw [dist_eq_norm_vsub V p1 p2]
  rw [dist_eq_norm_vsub V p2 (s.orthogonalProjectionSpan p2)]
  rw [dist_eq_norm_vsub V p1 (s.orthogonalProjectionSpan p2)]
  rw [‚Üê vsub_add_vsub_cancel p1 p2 (s.orthogonalProjectionSpan p2)]
  apply norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero
  rw [inner_vsub_left, ‚Üê vsub_vadd_eq_vsub_sub]
  rw [s.orthogonalProjection_vsub_self_eq_zero]
  simp

===== Proof 573 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm, dist_comm _ p2]
  apply dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq

===== Proof 574 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rcases hp1 with ‚ü®w, hw‚ü©
  rw [eq_affineCombination_of_mem_affineSpan_of_fintype _ _ hw]
  simp only [dist_eq_norm_vsub, ‚Üê affineCombination_vsub, norm_add_sq_eq_norm_sq_add_norm_sq_iff]
  exact (s.orthogonalProjection_linear_stable p2).sum_orthogonalProjection_coe_eq_self w

===== Proof 575 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm] at hp1
  let proj1 := s.orthogonalProjectionSpan p1
  let proj2 := s.orthogonalProjectionSpan p2
  have h‚ÇÅ : ‚àÄ p ‚àà affineSpan ‚Ñù (Set.range s.points), dist p proj1 * dist p proj1 =
      dist p proj2 * dist p proj2 + dist proj1 proj2 * dist proj1 proj2 := by
    intro p hp
    rw [dist_comm]
    apply dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq_of_mem _ hp
    exact orthogonalProjection_mem _
  apply h‚ÇÅ p2 hp1

===== Proof 576 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ‚Ñï}
    (s : Simplex ‚Ñù P n) {p1 : P} (p2 : P) (hp1 : p1 ‚àà affineSpan ‚Ñù (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by
  rw [dist_comm p1]
  rw [dist_comm p2]
  apply norm_add_sq_eq_norm_sq_add_norm_sq_of_inner_eq_zero
  rw [show
      inner (_ -·µ• s.orthogonalProjectionSpan p2) (p2 -·µ• s.orthogonalProjectionSpan p2) = 0 by
      apply Submodule.mem_orthogonal_singleton_iff_inner_right.mp
      exact s.orthogonalProjection_mem_orthogonal p2]

===== Proof 577 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator]

===== Proof 578 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  have : (‚àè x in s, f x) = ‚àè x in s, f x * 1 := by simp [mul_one]
  rw [this]; exact tprod_mulIndicator f s

===== Proof 579 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_sdiff_mul_prod_filter]
  congr 1
  funext x
  simp [Finset.mem_filter]

===== Proof 580 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_compl_mul_prod_filter]
  rw [Finset.prod_mul_distrib, Finset.prod_eq_one]
  congr 1
  simp [mul_assoc]

===== Proof 581 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_mul_indicator]
  simp_rw [Finset.mem_coe, Set.mem_mulIndicator]
  aesop

===== Proof 582 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator]

===== Proof 583 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_tprod_mulIndicator]
  simp [Finset.tprod, @Finset.prod_eq_prod_tprod_mulIndicator _ _ _ f s]

===== Proof 584 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator]

===== Proof 585 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_tprod_mulIndicator]

===== Proof 586 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator]
  simp

===== Proof 587 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by rw [tprod_eq_prod_mulIndicator s, mulIndicator_apply, mulIndicator_apply]

===== Proof 588 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator]

===== Proof 589 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [tprod_eq_prod]
  apply Eq.refl

===== Proof 590 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [tprod_eq_prod]
  apply Finset.prod_congr rfl
  simp [mulIndicator]

===== Proof 591 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  apply Finset.prod_eq_tprod_mulIndicator

===== Proof 592 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [tprod_mulIndicator]
  congr
  ext ‚ü®i, hi‚ü©
  rw [mulIndicator_apply, mulIndicator_apply, Finset.mem_coe, Finset.mem_coe,
    Finset.mem_mulIndicator, Finset.mem_mulIndicator]
  congr 1
  aesop

===== Proof 593 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_mul_diff_mul_indicator]
  exact Finset.prod_eq_tprod

===== Proof 594 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator]
  <;> simp [ht, hs, he]

===== Proof 595 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator]
  rw [tprod_eq_prod]
  simp [Finset.mulIndicator_apply]

===== Proof 596 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_preimage_of_mul_equiv (Equiv.Set.mulIndicator s (fun _ ‚Ü¶ (1 : Œ±)))]
  congr
  aesop

===== Proof 597 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  exact prod_induction _ _ (by simp) (fun x y _ _ ‚Ü¶ by simp [mul_add]) (by simp)

===== Proof 598 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_diff_singleton_mul indicator_mul_right]

===== Proof 599 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [tprod_eq_mulIndicator]
  apply Finset.prod_congr rfl
  intro i _
  rw [mulIndicator_apply]

===== Proof 600 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_mul_indicator]

===== Proof 601 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  classical
  have : mulIndicator (‚Üës) f = ‚àè x ‚àà s, Pi.mulSingle x (f x) := by
    ext x
    simp [Pi.mulSingle_apply, mulIndicator_apply]
  simp only [mulIndicator, this, tprod_mulSingle]

===== Proof 602 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod]
  apply tprod_congr
  simp [mulIndicator]

===== Proof 603 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator (p := fun _ ‚Ü¶ True) (s := s) (f := f)]
  aesop

===== Proof 604 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  simp_rw [Finset.prod_eq_prod_mulIndicator]
  simp_rw [tprod_subtype]
  rw [Finset.prod_mulIndicator_eq_prod_mul_one]
  rcongr

===== Proof 605 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_prod_mulIndicator s f]
  simp

===== Proof 606 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator]

===== Proof 607 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_multiset_prod]
  simp only [Function.comp_apply, Bool.false_eq_false, tprod_eq_finprod, ne_eq, Finset.mem_coe,
    Finset.mem_filter]
  rw [Finset.prod_eq_multiset_prod]
  apply congr 1
  apply congr 1
  dsimp
  ext x
  simp [Finset.mem_filter, Finset.mem_coe]

===== Proof 608 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : Œ≤ ‚Üí Œ±) (s : Finset Œ≤) :
:= by
  rw [Finset.prod_eq_tprod_mulIndicator]

===== Proof 609 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  intro hG
  exact (preadditiveCoyonedaObjFunctoriality C G).faithful_of_iso
    ((NatIso.ofComponents fun X => isSeparator_iff_faithful_preadditiveCoyonedaObj.mp hG X).symm)
  rintro hG X
  exact isSeparator_iff_faithful_preadditiveCoyonedaObj.mpr hG X

===== Proof 610 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  intro hG X Y f g hfg
  have hf := hG.def X
  have hg := hG.def Y
  rw [‚Üê sub_eq_zero]
  apply hf
  rw [neg_sub]
  apply hg
  rw [sub_eq_zero]
  simpa [sub_eq_zero] using hfg
  intro hG X Y f g hfg
  apply hG.def
  intros
  apply_fun (fun X => X (-g)) at hfg
  simpa using hfg

===== Proof 611 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor <;> intro <;>
  simp [IsSeparator, Faithful] at * <;>
  intro X Y f hf <;>
  simpa using h_faithful X Y f hf

===== Proof 612 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  refine' ‚ü®fun hG => _, fun h => _‚ü©
  case refine'_1 =>
    intro X Y f g hfg
    exact hG.def _ _ (congr_arg (fun g => preadditiveCoyonedaObj (op G).map g.op) hfg : _)
  case refine'_2 =>
    refine' ‚ü®fun hfg => _‚ü©
    exact Quiver.Hom.op_inj (h.map_injective (congr_arg Quiver.Hom.op hfg) : _)

===== Proof 613 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  next =>
    intro hG
    exact hG.preadditiveCoyonedaObj
  next =>
    intro hG
    exact ‚ü®fun _ _ f => hG.injective_natTrans (fun _ => f)‚ü©

===== Proof 614 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  intro hG
  exact (preadditiveCoyonedaObjFunctoriality C (op G)).faithful_of_isSeparator hG
  intro hG H hGH
  exact hG.of_iso ((preadditiveCoyonedaObjFunctoriality C (op G)).mapIso hGH)

===== Proof 615 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  intro hG
  exact Functor.Faithful.of_comp_iso (preadditiveCoyonedaObj (op G))
    (Coyoneda.w (hG.isUniversal.faithful_coyonedaObj))
  intro h
  exact (hG.isUniversal.preadditiveCoyonedaObj.faithful_of_iso (Coyoneda.w h))

===== Proof 616 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  show IsSeparator G ‚Üî ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f g : X ‚ü∂ Y), (preadditiveCoyonedaObj (op G)).map f =
    (preadditiveCoyonedaObj (op G)).map g ‚Üí f = g
  constructor <;> intro hG <;> intro X Y f g hfg
  ¬∑ apply hG
    simp only [preadditiveCoyonedaObj_map] at hfg
    exact hfg
  ¬∑ apply hG
    simp only [preadditiveCoyonedaObj_map]
    exact hfg

===== Proof 617 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  exact fun h => h.faithful_preadditiveCoyonedaObj
  exact fun h => faithful_preadditiveCoyonedaObj_of_isSeparator h

===== Proof 618 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  opt
  exact ‚ü®fun hG => Functor.Faithful.of_comp_iso (preadditiveCoyonedaObj (op G))
    ‚ü®Functor.leftUnitor.inv.app (op G),
      (Functor.leftUnitor.inv.app (op G)).symm.trans
        ((Functor.leftUnitor.inv.app (op G)).symm.trans
          (Quiver.Hom.left_unitor_inv (op G)))}
    hG‚ü©,
    fun h => ‚ü®fun g hg =>
      Quiver.Hom.op_inj ((Faithful.of_comp_iso (preadditiveCoyonedaObj (op G))
        ‚ü®Functor.leftUnitor.inv.app (op G),
          (Functor.leftUnitor.inv.app (op G)).symm.trans
            ((Functor.leftUnitor.inv.app (op G)).symm.trans
              (Quiver.Hom.left_unitor_inv (op G)))}
        h).hom.naturality.1 (by simpa using hg))‚ü©‚ü©

===== Proof 619 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  next =>
    intro h
    exact h.faithful_preadditiveCoyonedaObj
  next =>
    intro h
    exact ‚ü®h.preadditiveCoyonedaObj, fun _ _ _ => h.injective_preadditiveCoyonedaObj _ _‚ü©

===== Proof 620 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  point_to_prop_of_isSeparator
  point_to_faithful_of_preadditiveCoyonedaObj

===== Proof 621 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  ¬∑ intro hG
    exact Functor.Faithful.of_comp_iso (preadditiveCoyonedaObj (op G))
  ¬∑ intro hG X Y f
    rw [Functor.Faithful.of_comp_iso_apply] at hG
    apply (Function.Surjective.injective_comp
      (F := preadditiveCoyonedaObj (op X))
      (G := (IsSeparator.iso hG).hom)
      (surjective_quot_mk _)
      (surjective_quot_mk _)).2
    simp only [preadditiveCoyonedaObj, Quiver.Hom.unop_op, Functor.comp_map, Functor.op_map,
      Functor.Faithful.of_comp_iso_apply, Function.Surjective.injective_comp_left,
      Function.Surjective.injective_comp_right]
    aesop_cat

===== Proof 622 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  next =>
    intro hG X Y f g
    have := hG.def X Y
    intro h
    simp only [Functor.id_obj, Functor.const_obj_obj,
       NatTrans.id_app, Functor.id_map, Functor.const_obj_map,
       NatTrans.id_app, Functor.id_map, Functor.const_obj_map,
       NatTrans.id_app, Functor.id_map, Functor.const_obj_map] at this
    specialize this f g
    dsimp at this
    rw [‚Üê this]
    exact h
  next =>
    intro hG X Y f g hfg
    have := hG.def X Y
    specialize this hfg
    dsimp at this
    rw [this]

===== Proof 623 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  intro hG
  exact (preadditiveCoyonedaObj (op G)).faithful_of_isSeparator hG
  intro hG
  exact IsSeparator.of_faithful_preadditiveCoyonedaObj hG

===== Proof 624 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  refine' ‚ü®fun hG => _, fun h => _‚ü©
  case refine'_1 =>
    exact Functor.Faithful.of_comp_iso (NatIso.ofIsIso (hG.iso _))
  case refine'_2 =>
    exact (isSeparator_of_faithful_preadditiveCoyonedaObj h)

===== Proof 625 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  ¬∑ intro hG X Y f
    exact @Faithful.of_comp _ _ _ _ _ _ (preadditiveCoyonedaObj (op G))
      (preadditiveCoyonedaObj (op hG)) (faithful_preadditiveCoyonedaObj (op hG)) (faithful_preadditiveCoyonedaObj (op G)) _
  ¬∑ intro hG
    apply Nonempty.intro
    exact
    { faithful := hG }

===== Proof 626 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor <;> intro hG <;>
    intro _ _ f
  ¬∑ exact (preadditiveCoyonedaObj (op G)).map_injective f
  ¬∑ exact hG.faithful_coyoneda_map f

===== Proof 627 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  exact ‚ü®fun hG ‚Ü¶ Functor.Faithful.of_map_injective fun _ _ h ‚Ü¶ hG fun _ ‚Ü¶ h, fun h ‚Ü¶
    (isSeparator_def _).2 fun _ hf ‚Ü¶
      h.map_injective <| Coyoneda.coherence _ _ <| CategoryTheory.Functor.map_comp _ _ _‚ü©

===== Proof 628 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
   constructor
   ¬∑ intro hG
     exact Functor.Faithful.of_comp_Faithful (preadditiveCoyoneda.obj (op G))
       (faithful_of_preservesBinaryBiproducts (preadditiveCoyoneda.obj (op G)))
   ¬∑ intro hG
     exact fun X Y f hf => hG.1.preimage_eq
       (f.op.unop.1 ‚â´ biprod.fst) (by aesop_cat) (by
         simpa using (Biproduct.IsBilimit.binaryBiproductIsBilimit
           ((BinaryBiproduct.isBilimit_of_preservesBinaryBiproducts (preadditiveCoyoneda.obj (op X))
             ((BinaryBiproduct.isBilimit_pair_iff _ _).2
       (Limits.BinaryBiproduct.isBinaryBiproduct (pair (ùüô X) (0 : X ‚ü∂ X))))))).binaryBiproductIsBilimit
         ((Limits.BinaryBiproduct.isBinaryBilimit
           (Limits.BinaryBiproduct.isBilimitOfPreserves _ (Limits.BinaryBiproduct.isBinaryBilimit
           (Limits.BinaryBiproduct.isBinaryBilimit
        (Limits.BinaryBiproduct.isBilimitOfPreservesBinaryBiproducts
        (preadditiveCoyoneda.obj (op Y))
          (Limits.BinaryBiproduct.isBinaryBilimit (pair (ùüô Y) (0 : Y ‚ü∂ Y))))))))))

===== Proof 629 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor <;> intro <;> constructor <;> intro ‚ü®h‚ü© <;> intro ‚ü®g‚ü© <;>
    simpa using h g.hom

===== Proof 630 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  exact fun h => Faithful.of_map_injective (preadditiveCoyonedaObj_map_injective _)
  exact fun h => isSeparator_of_faithful_preadditiveCoyonedaObj _ _ h

===== Proof 631 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor <;> intro <;>
    simp [IsSeparator, Faithful, ‚Üê preadditiveCoyonedaObj_map] at * <;>
      intro X Y f g hfg;
        simpa [PreadditiveCoyoneda.faithful_of_preservesFiniteBiproducts]

===== Proof 632 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  intro hG
  exact Functor.Faithful.of_comp_iso (preadditiveCoyonedaObj (op G))
    (hG.isoWhiskerRight _)
  rintro hG X Y f g
  exact (preadditiveCoyonedaObj (op G)).map_injective (hG.map_injective
    (by simp [f.commute, g.commute]))

===== Proof 633 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  rintro hG X Y f g hfg
  apply hG
  intro i
  exact NatTrans.congr_app hfg i
  rintro hG X _ ‚ü®f, hf‚ü©
  exact hG f hf

===== Proof 634 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor <;>
  intro
  <;>
  exact
  { faithful := ‚Äπ_‚Ä∫ }
  <;>
  exact
  { faithful := ‚Äπ_‚Ä∫ }

===== Proof 635 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  case mp =>
    intro hG
    exact (Faithful.of_comp_iso (preadditiveCoyonedaObj (op G))
       ((evaluation C·µí·µñ AddCommGroupCat.{v}).obj ‚ü®G‚ü©).symm.toNatIso)
  case mpr =>
    intro hG
    exact (faithful_iff_of_iso (preadditiveCoyonedaObj (op G))
      ((evaluation C·µí·µñ AddCommGroupCat.{v}).obj ‚ü®G‚ü©).symm.toNatIso).mp hG

===== Proof 636 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  intro hG X Y f g hfg
  apply hG
  intro ‚ü®X, Y, f‚ü© ‚ü®X', Y', g‚ü© hf
  simpa using hfg hf

===== Proof 637 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  exact fun h ‚Ü¶ (h G (ùüô G)).faithful
  exact fun h ‚Ü¶ (h (ùüô G)).isSeparator

===== Proof 638 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  intro hG
  exact preadditiveCoyonedaObj_faithful (op G) hG
  rintro ‚ü®h‚ü©
  exact isSeparator_of_faithful_preadditiveCoyonedaObj (op G) h

===== Proof 639 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor
  exact fun h => preadditiveCoyonedaObj_faithful_of_isSeparator h
  exact fun h => isSeparator_of_preadditiveCoyonedaObj_faithful h

===== Proof 640 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ‚Üî (preadditiveCoyonedaObj (op G)).Faithful := by
  constructor <;> intro <;>
  simp_all only [IsSeparator.faithful_preadditive_coyoneda_obj,
    Functor.Faithful.of_comp_iso_faithful,
    Functor.comp_obj, Functor.const_obj_obj, Functor.Faithful.]

===== Proof 641 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp

===== Proof 642 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp_rw [map, atTop, eq_comm]
  simp_rw [le_eq_subset, tsub_le_iff_right, add_comm]
  simp_rw [tsub_le_iff_right, add_comm]
  simp_rw [tsub_le_iff_right, add_comm]
  exact ‚ü®fun s t h => by simpa using h, fun s t h => by simpa using h‚ü©

===== Proof 643 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp only [HasMapAtTop, HasMapAtTop.proof_1, gt_iff_lt, ge_iff_le,
    lt_one_iff]
  refine' ‚ü®k, fun n hn => _‚ü©
  rw [‚Üê add_tsub_assoc_of_le hn]
  exact le_rfl

===== Proof 644 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  apply map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)

===== Proof 645 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp [atTop, map_add_atTop_eq_nat, tsub_add_cancel_of_le]

===== Proof 646 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  rw [atTop_basis.map_iff_apply_eq_infi]
  exact fun i => ‚ü®i + k, i, by simp‚ü©

===== Proof 647 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp_rw [map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)]
  aesop

===== Proof 648 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp_all only [exists_prop, Finset.mem_range, gt_iff_lt, Finset.mem_Ico,
    Finset.mem_Icc, Nat.cast_pos, Nat.cast_lt, and_imp]
  tauto

===== Proof 649 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp only [map_sub_atTop_eq_nat, add_comm, tsub_eq_zero_iff_le]
  exact atTop_le_atTop_of_gc (fun a b h => tsub_le_tsub_right h _) (fun a b => Nat.le_add_right_iff_add_le.symm) (fun a => le_add_self)

===== Proof 650 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp

===== Proof 651 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp only [add_tsub_cancel_right]
  exact atTop_add_const_right k

===== Proof 652 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp

===== Proof 653 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp only [add_tsub_cancel_right]
  exact atTop_add_const_right _ _

===== Proof 654 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simpa only [add_zero] using map_atTop_eq_of_gc (fun a => a + 1) 0
  (fun a b h => Nat.add_le_add_right h 1) (k + 1)

===== Proof 655 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  apply Eq.symm
  apply le_antisymm
  ¬∑ apply tendsto_atTop_mono
    intro n
    exact le_add_left rfl.le
  ¬∑ apply tendsto_atTop_mono
    intro n
    exact le_add_right rfl.le

===== Proof 656 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp [strictMono_nat_of_lt_succ, tsub_le_iff_right]

===== Proof 657 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp_rw [atTop, map_atTop_eq_of_gc]
  refine ‚ü®add_left_injective k, 0, fun a b h => ?_‚ü©
  simp only [add_tsub_cancel_left] at h
  exact h.symm

===== Proof 658 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  apply

===== Proof 659 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp [Filter.map, atTop, Filter.atTop, eq_univ_iff_forall]
  exact fun a => ‚ü®a + k, by simp‚ü©

===== Proof 660 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  apply Eq.symm
  refine' Eq.symm _
  refine' (men
===== Proof 661 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp [atTop.map_sub_atTop_eq_nat k]

===== Proof 662 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  apply map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)

===== Proof 663 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp_all

===== Proof 664 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  rw [show ‚àÄ (n : ‚Ñï), n - 0 = n by simp]
  refine' map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)

===== Proof 665 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  exact map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)

===== Proof 666 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  apply SubtractionMonoid.to_hasDistribNeg

===== Proof 667 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp [atTop]
===== Proof 668 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp

===== Proof 669 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp_all only [add_tsub_cancel_right]
  rfl

===== Proof 670 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simpa only [add_zero] using
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)

===== Proof 671 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  apply map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
  <;> simp_all
  <;> linarith

===== Proof 672 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simpa only [add_zero] using map_atTop_add_const_right _ _

===== Proof 673 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases p
  rfl

===== Proof 674 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases ‚ÄπDecidablePred p‚Ä∫ <;> ext (i : m) (j : m) <;> simp [Matrix.det_apply]

===== Proof 675 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases p;
  simp_all [fromBlocks_toBlock]

===== Proof 676 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply, Matrix.det_apply, Matrix.det_apply, Matrix.det_apply]
  congr
  ext i j
  simp [fromBlocks_apply‚ÇÅ‚ÇÅ, toBlock_apply]

===== Proof 677 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_toBlock_lemma]
  simp [Matrix.det_toBlock_lemma]

===== Proof 678 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply, Matrix.det_apply]
  congr
  ext i j
  simp [toBlock_apply]

===== Proof 679 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases p
  simp [fromBlocks_toBlocks, toBlock_apply, Matrix.det_apply]

===== Proof 680 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply]
  simp_rw [Matrix.det_apply]
  congr 1
  ext ‚ü®i, i'‚ü© ‚ü®j, j'‚ü©
  simp [toBlock, fromBlocks]

===== Proof 681 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [det_toBlock_of_bipartite p, det_toBlock_of_bipartite fun j => ¬¨p j]
  simp [toBlock, det_apply]

===== Proof 682 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases p
  cases q
  simp [Matrix.det_toBlock]

===== Proof 683 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases p
  rfl

===== Proof 684 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply, Matrix.det_apply]
  apply congr_arg
  ext i j
  simp [Matrix.toBlock_apply]

===== Proof 685 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply]
  rw [Matrix.det_apply]
  rw [Matrix.det_apply]
  congr <;> ext i j <;> simp [Matrix.toBlock]

===== Proof 686 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply, Matrix.det_apply, Matrix.det_apply, Matrix.det_apply]
  congr <;> ext <;> simp

===== Proof 687 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [det_toSquareBlock, det_toSquareBlock, det_toSquareBlock, det_toSquareBlock]
  rw [fromBlocks_toBlock]

===== Proof 688 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply, Matrix.det_apply]
  simp [Matrix.toBlock_apply, Matrix.fromBlocks_apply‚ÇÇ‚ÇÅ]

===== Proof 689 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases p
  cases q
  rfl

===== Proof 690 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_toBlock]

===== Proof 691 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply, Matrix.det_apply, Matrix.det_apply, Matrix.det_apply]
  simp [Matrix.toBlock, Matrix.fromBlocks]

===== Proof 692 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply]
  rw [Matrix.det_apply]
  simp [Matrix.toBlock, Matrix.fromBlocks_apply]

===== Proof 693 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply, Matrix.det_apply]
  rw [Matrix.det_apply, Matrix.det_apply]
  congr
  ext i j
  simp [toBlock, Matrix.get]

===== Proof 694 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_toBlock]

===== Proof 695 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [det_apply', det_apply']
  congr 1
  ext i j
  simp [toBlock_apply]

===== Proof 696 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply, Matrix.det_apply]
  congr
  ext i j
  simp [toBlock_apply]

===== Proof 697 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply]
  rw [Matrix.det_apply]
  simp [fromBlocks_toMatrix]

===== Proof 698 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases' (decidable_pred p) with hp hp <;> simp_rw [hp] <;>
    simp [hp]

===== Proof 699 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_toBlock]

===== Proof 700 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases p
  rfl

===== Proof 701 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rcases (det_toBlock_comm M p) with ‚ü®_‚ü©

===== Proof 702 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_fromBlocks_zero‚ÇÇ‚ÇÅ_zero‚ÇÇ‚ÇÉ, Matrix.det_toBlock_id, Matrix.det_toBlock_id,
    Matrix.det_toBlock_id]

===== Proof 703 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  rw [Matrix.det_apply, Matrix.det_apply]
  congr
  ext i j
  simp [Matrix.toBlock_apply, Matrix.fromBlocks_apply‚ÇÅ‚ÇÅ]

===== Proof 704 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m ‚Üí Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬¨p j) (toBlock M (fun j => ¬¨p j) p) <|
          toBlock M (fun j => ¬¨p j) fun j => ¬¨p j).det := by
  cases' (decide_em (‚àÉ x, ¬¨p x)) with h h <;> simp_all [toBlock, fromBlocks_apply‚Ç†]
  exact
    (det_toSquareBlock_id_eq_det _ _).symm.trans
      (det_toSquareBlock_id_eq_det _ _).symm
  exact (det_toSquareBlock_id_eq_det _ _).symm.trans (det_toSquareBlock_id_eq_det _ _).symm

===== Proof 705 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, hœá x]; rfl

===== Proof 706 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, ‚Üê mul_left_cancel_iff_ne_zero (hœá (1 : R)).nonzero, mul_one, mul_apply, hœá.sq_eq_one_iff]

===== Proof 707 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext a
  rw [pow_two, mul_apply, hœá.map_nonunit, map_one, mul_one]

===== Proof 708 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, ‚Üê mul_char_mul_eq_mul_char_mul œá œá hœá hœá]
  simp only [hœá.sq_eq_one_of_mem_unit_group]
  rcases (mem_unit_group_iff hœá).mp x with ‚ü®_, ‚ü®r, rfl‚ü©‚ü©
  by_cases hr : r = 0
  ¬∑ rw [hr, Units.val_eq_one]
    simp only [mul_one, one_mul, map_one]
  rw [Units.val_eq_mul_inv]
  norm_cast
  simp only [hr, hœá.map_nonunit_mul_nonunit, mul_one, one_mul, map_nonunit]

===== Proof 709 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext a
  rw [pow_two, mul_char.map_mul, hœá a, one_mul]

===== Proof 710 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, mul_apply, hœá x]
  rcases hœá x with (hx | hx)
  ¬∑ rw [hx, map_one, map_one]
  ¬∑ rw [hx, Ring.neg_one_sq, map_one]

===== Proof 711 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by ext; simp [hœá]

===== Proof 712 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext
  simp only [pow_two, map_mul, one_mul, eq_self_iff_true, MulChar.coe_one, mul_eq_one]
  cases' hœá.1 with h h
  ¬∑ rw [h]
    exact of_decide_eq_true rfl
  ¬∑ rw [h]
    exact of_decide_eq_true (QuadraticChar.exists_neg h).choose_spec


/-- For a quadratic character 
===== Proof 713 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  have := hœá.map_nonunit
  ext a
  by_cases ha : a ‚àà RÀ£
  ¬∑ rw [pow_two, ‚Üê MulChar.map_mul, MulChar.coe_toUnitHom, this (mem_nonunits.mpr ha),
      Units.val_one, map_one, one_mul]
  ¬∑ have := hœá.eq_one_of_not_isUnit ha
    rw [pow_two, ‚Üê MulChar.map_mul, this, one_mul]
#align mul_char.is_quadratic.sq_eq_one MulChar.IsQuadratic.sq_eq_one

/-- A quadratic character takes only the values 
===== Proof 714 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  rw [pow_two, ‚Üê ext_iff]
  intro a
  rw [IsQuadratic.map_nonone hœá a ha, one_mul]
  rw [mul_char.map_nonone hœá a ha]

===== Proof 715 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, map_mul_eq_mul, hœá x, ‚Üê one_mul_eq_one, mul_left_eq_self]
  by_cases hx : x = 1
  ¬∑ rw [hx]
    simp only [map_one, MonoidHom.one_apply, mul_one]
  ¬∑ have h := hœá.eq_neg_one (by rintro rfl; contradiction)
    rw [h, ‚Üê neg_one_mul, mul_left_eq_self]
    simp only [one_ne_zero, MonoidHom.map_one, eq_self_iff_true]


/-- The product of two quadratic characters is a square. -/
theorem IsQuadratic.mul_isQuadratic_eq_sq {œá‚ÇÅ œá‚ÇÇ : MulChar R R'} (hœá‚ÇÅ : œá‚ÇÅ.IsQuadratic)
    (hœá‚ÇÇ : œá‚ÇÇ.IsQuadratic) : ‚àÉ œá‚ÇÉ : MulChar R R', œá‚ÇÉ ^ 2 = œá‚ÇÅ * œá‚ÇÇ := by
  classical
    if h : œá‚ÇÅ = 1 then
      exact ‚ü®œá‚ÇÇ, by rw [h, hœá‚ÇÅ.mul_one_eq_self, hœá‚ÇÇ.sq_eq_one]‚ü©
    else if h' : œá‚ÇÇ = 1 then
      exact ‚ü®œá‚ÇÅ, by rw [h', hœá‚ÇÇ.mul_one_eq_self, hœá‚ÇÅ.sq_eq_one]‚ü©
    else if h'' : œá‚ÇÅ = -1 then
      exact ‚ü®œá‚ÇÇ, by rwa [h'', hœá‚ÇÅ.exists_neg_one, there_exists_eq', mul_neg_one, hœá‚ÇÇ.mul_neg_one]‚ü©
    else
      by_cases h''' : œá‚ÇÇ = -1
      ¬∑ have : œá‚ÇÇ.IsQuadratic := hœá‚ÇÇ
        simpa only [h''', this.exists_neg_one, inv_neg œá‚ÇÅ, hœá‚ÇÅ.mul_neg_one, neg_neg, mul_comm]
          using Nonempty.intro (mulMap (œá‚ÇÇ‚Åª¬π : MulChar R R')‚ÇÇ œá‚ÇÅ)
      ¬∑ have : œá‚ÇÅ.IsQuadratic := hœá‚ÇÅ
        simpa only [h, this.exists_neg_one, h', h''', h'' (mul_one œá‚ÇÅ), mul_comm] using
          Nonempty.intro (mulMap œá‚ÇÅ œá‚ÇÇ)

===== Proof 716 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext a
  rw [pow_two, mul_apply, hœá.sq_eq_one_of_not_one (hœá a) a, one_apply]

===== Proof 717 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext a
  rw [pow_apply_coe, hœá.sq_eq_one a]
  rfl

===== Proof 718 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, mul_apply, hœá.sq_eq_one_iff.2 x.2]
  rfl

===== Proof 719 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, mul_char.mul_apply, hœá x, one_mul]

===== Proof 720 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, mul_apply, hœá.sq_eq_one hx]
  rfl

===== Proof 721 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  rw [ext_iff]
  intro a
  rw [pow_two, mul_apply, map_one, hœá.map_square, one_apply]

===== Proof 722 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  rw [ext_iff]
  intro a
  rw [pow_two, mul_apply, map_one, ‚Üê one_mul a]
  simp only [hœá.eq_one_or_neg_one a]
  cases' hœá.eq_one_or_neg_one a with ha ha <;>
    simp [ha, IsQuadratic.inv hœá]

===== Proof 723 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  rw [pow_two, hœá.inv]
  rfl

===== Proof 724 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext
  rw [pow_two, ‚Üê mul_char.coe_monoidHom_mul, hœá _ _ _, map_one, one_mul]

===== Proof 725 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, mul_apply, hœá.sq_eq_one_or_neg_one x, MulChar.map_one]
  cases' hœá.sq_eq_one_or_neg_one x with hx hx;
  ¬∑ rw [hx, one_mul]
  ¬∑ rw [hx, one_mul]
@[deprecated (since := "2024-06-05")] alias quadratic_char_sq_eq_one := IsQuadratic.sq_eq_one

===== Proof 726 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, map_mul_eq_one_iff]
  exact hœá x

===== Proof 727 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  rw [hœá.sq]; rfl
 /- Porting note: In the original mathlib code this would follow directly
 from the previous tactic but in Lean4 it doesn't and a 
===== Proof 728 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext; simp only [pow_apply_coe, one_apply_coe, ‚Üê IsUnit.neg_one_sq]; convert hœá _ using 2; rw [neg_one_sq]

===== Proof 729 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  rw [hœá.sq_eq_one_or_neg_one, or_iff_left]
  intro heq
  apply_fun MulChar.mapBaseChange heq R' at hœá
  rw [heq, MulChar.mapBaseChange_one, MulChar.mapBaseChange_one] at hœá
  exact absurd hœá (by decide)

===== Proof 730 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext y
  simp only [pow_apply_coe, HEq, one_apply_coe, mul_char.coe_to_monoid_hom, MonoidHom.one_apply,
    MonoidHom.mul_apply, mul_apply, hœá.eq_or, if_true, mul_one, if_false, mul_zero, sub_zero,
    zero_add]
  apply eq_comm.mpr
  split_ifs with h
  ¬∑ rw [neg_one_sq]
  ¬∑ rfl

===== Proof 731 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext x
  rw [pow_two, mul_apply, hœá x, one_apply, mul_boole]
  cases' hœá x with hx hx <;> simp only [hx, map_one, one_pow, mul_one]

===== Proof 732 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext
  rw [pow_two, mul_apply, hœá.sq_eq_one_iff.2 rfl, one_apply]

===== Proof 733 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  rw [hœá.sq_eq_one_or_neg_one, hœá.eq_neg_one_or_one, MulChar.ext_iff]; simp
#align mul_char.is_quadratic.sq_eq_one MulChar.IsQuadratic.sq_eq_one

end Ring

section Field

variable {R : Type*} [CommRing R] [IsDomain R] {R' : Type*} [CommRing R'] [Algebra R R']
  [IsDomain R']

/-- For a nontrivial ring, a quadratic MulChar has an inverse which is also quadratic. -/
protected noncomputable def inv [Nontrivial R']
    (œá : MulChar R R') (h : œá.IsQuadratic) :
    MulChar R R' where
  toFun a := Ring.inverse (œá a)
  map_one' := by
    rw [‚Üê map_one œá, Ring.inverse_unit (h.1 œá 1 (by rw [map_one œá]; exact one_ne_zero))]
  map_mul' a b := by
    rw [Ring.mul_inverse_rev'
      (h.1 œá a (mul_ne_zero (map_ne_zero_iff œá (algebraMap R R') (algebraMap_injective R R')).2)
      (map_ne_zero_iff œá (algebraMap R R') (algebraMap_injective R R')).2),
      map_mul œá, ‚Üê div_eq_mul_inverse, div_self (map_ne_zero_iff œá (algebraMap R R')
        (algebraMap_injective R R')).2, one_mul]
  map_nonunit' a ha := by rw [map_nonunit (h.1 œá a ha); apply Ring.inverse_non_unit]

===== Proof 734 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext a
  rw [pow_two, ‚Üê map_mul_eq_mul œá, ‚Üê pow_two, hœá.sq_eq_one_or_neg_one a, mul_eq_one_iff_eq_inv]
  cases' hœá.sq_eq_one_or_neg_one a with h h
  ¬∑ rw [h]
    exact SetLike.coe_eq_coe.mpr hœá.inv
  ¬∑ rw [h, IsUnit.unit_spec, inverse_neg, neg_neg]
    exact SetLike.coe_eq_coe.mpr hœá.inv

===== Proof 735 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by ext;
  simp only [one_apply, IsQuadratic.sq_eq_one_of_isUnit hœá (this.isUnit_unit _), Pi.one_apply]

===== Proof 736 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h‚ÇÇ, this, Ring.inverse_unit (-1 : R'À£)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {œá : MulChar R R'} (hœá : œá.IsQuadratic) : œá ^ 2 = 1 := by
  ext a
  rw [pow_two, mul_apply, œá.map_one, one_apply, ‚Üê Units.eq_iff, Units.val_one,
    ‚Üê IsQuadratic.eq_one_or_neg_one hœá a, mul_one]
  rfl

===== Proof 737 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction l with
  | nil => rfl
  | cons b l bh =>
    simp_all [foldr]

===== Proof 738 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  simp only [foldl_eq_foldl_reverse, foldr_reverse, flip]
  induction l with
  | nil => rfl
  | cons b l' ih => simp only [foldl_cons, foldr_cons, ih, flip_eq_iff]; rfl

===== Proof 739 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction l with
  | nil => rw [foldl_nil, foldr_nil]
  | cons b l ih => rw [foldl_cons, foldr_cons, ih]

===== Proof 740 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l; induction l with
  | nil => rfl
  | cons b l' ih => rw [foldl, foldr, ih, ‚Üê foldr_self_append, ‚Üê foldr_self_append]; simp [flip_def]

===== Proof 741 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction l with
  | nil => rfl
  | cons b l' ih =>
    simp only [foldl, foldr]
    rw [‚Üê ih]
    simp [flip]

===== Proof 742 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a
  intro l
  induction l with
  | nil => rfl
  | cons _ _ ih =>
    simp [foldl_cons, foldr_cons, ih]

===== Proof 743 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  let f : Œ± ‚Üí Œ± ‚Üí Œ± := fun a b => a * b
  apply List.foldl_eq_of_comm'
  intros a b c
  simp only [f]
  ring

===== Proof 744 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  rw [foldr, foldl]
  simp (config := { contextual := true }) [@eq_comm _ (foldl f _ _)]
  rfl

===== Proof 745 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction l with
  | nil => rfl
  | cons b l' ih =>
    simp only [foldr, foldl, flip] at ih ‚ä¢
    rw [ih]

===== Proof 746 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intros
  induction l
  rfl
  simp only [*, foldl, foldr]
  congr

===== Proof 747 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l; induction l with
  | nil => rfl
  | cons h t ih => simp [‚Üê ih, foldl_cons]

===== Proof 748 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l; cases l; simp; simp [foldr, foldl, flip, *]

===== Proof 749 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a
  intro l
  induction' l with h l' ih
  simp
  simp only [foldl_cons, foldr_cons, flip_apply, ih]
  apply Eq.symm
  apply Eq.symm
  rfl

===== Proof 750 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l; induction l with
  | nil => rfl
  | cons b l‚ÇÅ ih => simp only [foldl_cons, foldr_cons, foldl_eq_of_comm', ih, flip_eq_iff]
  <;>
  (try
    simp_all [flip_eq_iff, asb, asb', rfl, eq_self_iff_true, and_self_iff])
  <;>
  aesop

===== Proof 751 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  simp only [foldl, foldr, flip]
  induction l with
  | nil => rfl
  | cons b l ih => simp_all

===== Proof 752 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction l generalizing a <;> simp_all
  simp_all [flip]

===== Proof 753 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  simp only [foldr]
  rw [‚Üê List.foldr_reverse]
  simp only [flip, List.foldl_reverse, Function.comp_apply]

===== Proof 754 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a
  intro l
  induction' l with b l ih
  rfl
  simp only [foldl, foldr]
  rw [ih]
  simp [flip_def]

===== Proof 755 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l with b l ih
  ¬∑ simp
  ¬∑ simp only [foldl_cons, foldr_cons, flip_apply, ‚Üê ih]
    rw [‚Üê foldl_assoc, h, foldl_comm, foldl_assoc, ih, ‚Üê foldl_assoc, h,
      foldl_comm, foldl_assoc, ih]

===== Proof 756 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l; induction l with
  | nil => rfl
  | cons b l ih => simp_all only [foldl_cons, foldl_append, foldr_cons, foldr_append, flip,
    foldl_eq_of_comm']
  <;> try (simp_all; linarith)

===== Proof 757 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intros a l
  induction l with
  | nil => rfl
  | cons b l' ih => simp_all [flip_def]

===== Proof 758 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l with b l IH
  ¬∑ rfl
  ¬∑ simp only [foldl, foldr] at *
    rw [IH]

===== Proof 759 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l with hd tl ih
  rfl
  rw [foldl_cons, foldr_cons, flip, ih]

===== Proof 760 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a
  intro l
  induction l <;> simp_all

===== Proof 761 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction l generalizing a with
  | nil => rfl
  | cons b l ih =>
    simp_all only [foldl, foldr, flip]
    apply Eq.symm
    simp only [*]

===== Proof 762 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l with b l ih
  case nil => rfl
  case cons =>
    simp only [foldl_cons, foldr_cons, ih]
    rw [‚Üêfoldl_comm']
    simp [foldl_comm']

===== Proof 763 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l;
  revert a;
  induction l with
  | nil => intros; rfl
  | cons _ tl ih => intros; simp_all

===== Proof 764 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  revert l
  apply l.foldl_eq_foldr

===== Proof 765 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l with h t ih
  simp
  simp only [foldl_cons, foldr_cons, flip_apply, ih]

===== Proof 766 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l;
  induction l with
  | nil => rfl
  | cons x xs ih =>
    rw [foldl, foldr, ih]
    simp only [flip]
    rfl

===== Proof 767 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a
  intro l
  induction' l with b l' ih
  ¬∑ rfl
  ¬∑ simp only [foldl, foldr]
    rw [ih]

===== Proof 768 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ‚àÄ a l, foldl f a l = foldr (flip f) a l
:= by intros a l; induction l <;> simp [*, -binop_eq]

===== Proof 769 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply UniqueFactorizationMonoid.of_exists_prime_factors
  intro a ha
  cases' FiniteField.exists_isUnit_pow_mul_eq_one D a ha with n e
  use Finsupp.single (Classical.choose e) n
  rw [MvPolynomial.prime_iff]
  use Classical.choose e
  constructor
  ¬∑ apply MvPolynomial.X_pow_right_injective
    exact (IsUnit.mul_left_dvd (Classical.choose_spec e)).mp (dvd_refl _)
  constructor
  ¬∑ exact Classical.choose_spec e
  ¬∑ intro j
    by_cases h : j = Classical.choose e
    ¬∑ subst h
      simp [Finsupp.single_eq_same]
    ¬∑ rw [MvPolynomial.X_pow_right_injective]
      simp only [Finsupp.single_eq_of_ne h, add_right_eq_self, one_ne_zero]
      exact ‚ü®n, Classical.choose_spec e‚ü©

===== Proof 770 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by change UniqueFactorizationMonoid (MvPolynomial œÉ D); infer_instance

===== Proof 771 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  simp_rw [Finset.prod_range_succ]
  simp [Finset.prod_range_succ]

===== Proof 772 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  aesop

===== Proof 773 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply Fact.elim
  infer_instance

===== Proof 774 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  aesop

===== Proof 775 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  aesop

===== Proof 776 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  unfold PolynomialPolynomialPolynomialPolynomialPolynomialPolynomialPolynomialPolynomial
  aesop

===== Proof 777 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  trivial

===== Proof 778 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  rw [Finset.prod_eq_zero_iff]
  rw [Finset.prod_eq_zero_iff]
  <;> simp [*]

===== Proof 779 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by apply uniqueFactorizationMonoid_of_fintype

===== Proof 780 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  cases nonempty_fintype
  apply Polynomial.uniqueFactorizationMonoid

===== Proof 781 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  have hfin := Fintype.finite inferInstance
  haveI := Fintype.ofFinite œÉ
  exact UniqueFactorizationMonoid.of_finite œÉ

===== Proof 782 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by import Mathlib.Algebra.BigOperators.Associated
     import Mathlib.Algebra.GCDMonoid.Basic
     import Mathlib.RingTheory.UniqueFactorizationDomain
     import Mathlib.Tactic.NormNum
     import Mathlib.Tactic.Linarith
     import Mathlib.Tactic.SolveByElim
     import Mathlib.Tactic.FinCases
     import Mathlib.Algebra.Algebra.Subalgebra.Basic
     import Mathlib.RingTheory.WittVector.Basic
     import Mathlib.RingTheory.WittVector.IsPoly
     import Mathlib.RingTheory.WittVector.TruncatedWittPoly
     import Mathlib.RingTheory.WittVector.CommRing
     import Mathlib.RingTheory.WittVector.MulCoeff
     import Mathlib.RingTheory.WittVector.Polynomial.Expand
     import Mathlib.RingTheory.WittVector.IsPoly.Lemmas
     import Mathlib.RingTheory.WittVector.Polynomial.TruncatedWittPoly
     import Mathlib.RingTheory.WittVector.Polynomial.WittPoly
     import Mathlib.RingTheory.WittVector.Val
     import Mathlib.RingTheory.WittVector.WittPolyRat
     import Mathlib.RingTheory.WittVector.InvariantBasisNumber
     import Mathlib.RingTheory.WittVector.Rat
     import Mathlib.RingTheory.WittVector.Verschiebung
     import Mathlib.RingTheory.WittVector.FrobeniusFractionField
     import Mathlib.RingTheory.WittVector.Proj
     import Mathlib.RingTheory.WittVector.Aprod
     import Mathlib.RingTheory.WittVector.Conclusion
     import Mathlib.NumberTheory.Cyclotomic.Discriminant
     import Mathlib.RingTheory.DiscreteValuationRing.Basic
     import Mathlib.RingTheory.Polynomial.Cyclotomic.Basic
     import Mathlib.Tactic.NormNum.Core
     import Mathlib.Tactic.Linarith.Lemmas
     import Mathlib.Tactic.SolveByElim
     import Mathlib.Tactic.FinCases
===== Proof 783 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by infer_instance

===== Proof 784 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply WfDvdMonoid.to_uniqueFactorizationMonoid
  apply MvPolynomial.isWf_dvd_term_of_isReducedNumerator D

===== Proof 785 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by import Mathlib.Algebra.Algebra.Tower
    import Mathlib.Algebra.GroupWithZero.Divisibility
    import Mathlib.Algebra.Regular.SMul
    import Mathlib.Algebra.MonoidAlgebra.Support
    import Mathlib.Data.Finsupp.Antidiagonal
    import Mathlib.LinearAlgebra.Finsupp
    import Mathlib.RingTheory.Nilpotent.Basic
    import Mathlib.RingTheory.Polynomial.Basic
    import Mathlib.RingTheory.PrincipalIdealDomain
    import Mathlib.Tactic.Abel
    import Mathlib.Tactic.At
    import Mathlib.Tactic.Linarith
    import Mathlib.Tactic.NthRewrite
    import Mathlib.Tactic.NormCastAt
    import Mathlib.Tactic.NthRewrite
    import Mathlib.Tactic.Polyrith
    import Mathlib.Tactic.Qify
    import Mathlib.Tactic.RingAt
    import Mathlib.Tactic.RSuffices
    import Mathlib.Tactic.Says
    import Mathlib.Tactic.ShowTerm
    import Mathlib.Tactic.SimpRw
    import Mathlib.Tactic.SimpsAt
    import Mathlib.Tactic.SimpsSubst
    import Mathlib.Tactic.SolveByElim
    import Mathlib.Tactic.SplitIfsAt
    import Mathlib.Tactic.Substs
    import Mathlib.Tactic.SudoSetOption
    import Mathlib.Tactic.SwapVar
    import Mathlib.Tactic.Tauto
    import Mathlib.Util.Export
    import Mathlib.Util.IncludeStr
    import Mathlib.Util.MemoFix
    import Mathlib.Util.Simp
    import Mathlib.Util.Syntax
    import Mathlib.Util.SynthesizeUsing
    import Mathlib.Util.WhatsNew

===== Proof 786 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  infer_instance

===== Proof 787 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by simp [uniqueFactorizationMonoid_of_fintype]

===== Proof 788 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  unfold MvPolynomial
  simp only [Algebra.smul_def, eq_intCast, RingHom.map_mul, RingHom.map_one, one_mul,
    RingHom.map_add, add_mul, one_mul, eq_self_iff_true, RingHom.map_zero, mul_zero,
    zero_mul, mul_one]
  infer_instance

===== Proof 789 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  simp_rw [dvd_iff_isUnit_or_dvd_of_isPrime]
  aesop

===== Proof 790 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  aesop

===== Proof 791 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  cases nonempty_fintype œÉ
  cases nonempty_fintype D
  apply uniqueFactorizationMonoid_of_fintype

===== Proof 792 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  have : Fintype.card œÉ = Fintype.card Fin (d + 1) := by
    rw [Fintype.card_fin,
      Fintype.card_congr
        (Fintype.equivFin œÉ)]
  rw [this]
  clear this
  induction' d with d hd
  ¬∑ exact Polynomial.uniqueFactorizationMonoid
  apply UniqueFactorizationMonoid.of_injective
    (fun f => MvPolynomial.eval‚ÇÇ MvPolynomial.C (X 0) (Polynomial.X (d + 1) ^ 2))
    <;> simp [Polynomial.eval‚ÇÇ, Polynomial.C_eq_algebraMap,
      Polynomial.algebraMap_eq, MvPolynomial.algebraMap_eq]
  ¬∑ intros f g
    apply_fun fun x => eval x f at *
    simpa only [eval_C, eval_X, eval_pow, eval_mul] using ¬∑
  ¬∑ apply Polynomial.noZeroDivisors.of_injective
    apply MvPolynomial.noZeroDivisors.of_injective
    apply Polynomial.noZeroDivisors.of_injective
    simp_all

===== Proof 793 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  let f : ‚Ñ§ ‚Üí+* ‚ÑÇ := Algebra.ofId ‚Ñ§ ‚ÑÇ
  let f‚ÇÄ :
    MvPolynomial (Fin (Fintype.card œÉ)) ‚Ñ§ ‚Üí+* MvPolynomial (Fin (Fintype.card œÉ)) ‚ÑÇ :=
    MvPolynomial.map f
  exact IsDomain.of_surjective f‚ÇÄ (map_surjective f.surjective)

===== Proof 794 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by decide

===== Proof 795 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply UniqueFactorizationMonoid.of_exists_prime_factors
  intro a ha
  obtain ‚ü®f, hf, unit_f‚ü© :=
    UniqueFactorizationMonoid.exists_prime_factors a ha
  use f.map (renameEquiv D (Fintype.equivFin œÉ)).symm
  constructor
  ¬∑ intro x hx
    apply hf (Finset.mem_map.1 hx).choose
    rw [Multiset.mem_map]
    use x
    exact ‚ü®hx, by simp‚ü©
  ¬∑ rw [Multiset.prod_map_hom, ‚Üê IsUnit.unit_of_val_one unit_f]
    rfl

===== Proof 796 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  aesop

===== Proof 797 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  infer_instance

===== Proof 798 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  cases' ‚ÄπFintype œÉ‚Ä∫ with n h
  subst h
  infer_instance

===== Proof 799 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply WfDvdMonoid.to_uniqueFactorizationMonoid
  infer_instance

===== Proof 800 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype œÉ] :
    UniqueFactorizationMonoid (MvPolynomial œÉ D) :=
  (renameEquiv D (Fintype.equivFin œÉ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card œÉ with d hd
    ¬∑ apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    ¬∑ apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by unfold Sard_inst_uniqueFactorizationMonoid; unfold Polynomial.instUniqueFactorizationMonoid; apply Polynomial.uniqueFactorizationMonoid

===== Proof 801 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  have h2 := h1
  simp only [get?_eq_get h1] at h2
  simp only [get?_eq_get h2]

===== Proof 802 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h'
  rw [le_iff_exists_append] at h
  cases' h with l hl
  rw [hl]
  simp [h', List.get]

===== Proof 803 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  have h2 := h1
  revert h1
  cases' s with f
  simp only [nth_some, nth_think]
  intro h1
  rw [‚Üê h1]
  exact nth_eq_some.2 (f.stable h)

===== Proof 804 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  have h2 := s.2 h h1
  exact h2

===== Proof 805 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro am
  rw [show n = m + (n - m) by omega]
  simp [am, h]

===== Proof 806 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  have h2 : s.1 m = some a := h1
  exact le_stable s h2

===== Proof 807 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  revert h1
  revert s
  revert a m n
  intro a m n h h1
  apply h1
  exact h

===== Proof 808 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  exact Nat.le_induction (fun h' => by rw [h']) (fun n' hn' ih => by rw [h]) h

===== Proof 809 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro hm
  rw [‚Üê hm]
  rw [‚Üê Nat.le_eq_exists_add.mp h]
  simp

===== Proof 810 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  apply h1 ‚àò Eq.symm ‚àò h

===== Proof 811 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  induction' h with k h IH
  <;> intro
  <;> simp_all

===== Proof 812 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  induction' h with n' ih
  all_goals exact h1
  all_goals exact s.2 n' (by assumption)

===== Proof 813 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  cases' s with f
  intro h1 h2
  apply h1
  rw [‚Üê h2]
  apply (le_trans h (le_refl n)).symm

===== Proof 814 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  cases' s with f hf; intro h1 h2; simp_all

===== Proof 815 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1; induction h; simp_all

===== Proof 816 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1; apply (s.2 h).get; exact h1

===== Proof 817 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  revert h1
  revert s
  intro s h
  cases' s with f
  simp only [h, and_true, eq_self_iff_true, heq_iff_eq, true_and]
  intro h1
  apply h
  apply h1

===== Proof 818 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  cases' s with f
  simp only [get, get?_eq_get]
  exact fun h‚ÇÄ h‚ÇÅ => h‚ÇÅ ‚ñ∏ h‚ÇÄ ‚ñ∏ (get_stable f h)

===== Proof 819 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  cases' s with f; intro h‚ÇÄ h‚ÇÅ
  rw [show m = n by linarith] at h‚ÇÄ; exact h‚ÇÄ

===== Proof 820 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  induction' h with n _ IH
  assumption
  simp only [get_succ]
  split_ifs with h‚ÇÄ
  assumption
  simp_all

===== Proof 821 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1; simp [h, h1]

===== Proof 822 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  cases' s with f
  induction' h with n'
  exact h1
  have h2 := h_ih h1
  exact h2

===== Proof 823 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  induction' h with n a'
  <;> intro h'
  <;> exact h'

===== Proof 824 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1; induction h <;> simp_all

===== Proof 825 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  cases' s with f
  induction' h with n _ IH
  <;> simp_all

===== Proof 826 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  induction h <;> simp [*]

===== Proof 827 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  cases' s with f hf; intro h1; simp only [h1, hf]
  rw [‚Üê h1]
  apply hf
  apply le_trans h
  apply le_max_right

===== Proof 828 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  cases' s with f; intro h1; simp only [get?_eq_get, h1] at *;
  exact get_stable h

===== Proof 829 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  rw [‚Üê get_eq_of_mem _ h1]
  have := get_eq_of_mem _ h1
  rw [‚Üê get_eq_of_mem _ h1] at this
  apply get_eq_of_mem _ this
  exact le_trans h (get_eq_of_mem _ h1).symm.le

===== Proof 830 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  cases' s with f
  simp only [get, h]
  intro h1
  apply h1

===== Proof 831 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  rw [le_iff_exists_add] at h
  cases' h with k hk
  rw [hk]
  simp [h1, Nat.add_comm, Nat.add_assoc, Nat.add_left_comm]

===== Proof 832 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation Œ±) {a m n} (h : m ‚â§ n) : s.1 m = some a ‚Üí s.1 n = some a := by
  intro h1
  rw [‚Üê h1]
  have h2 := s.2 h
  rw [‚Üê h2]

===== Proof 833 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff hx (Real.rpow_pos_of_pos hy z), Real.log_rpow hy]

===== Proof 834 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  ÔøΩclosure_congr fun h _ hz => ?_
    ¬∑ exact ?_
  ¬∑ exact le_rpow_of_log_le h

===== Proof 835 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff hx (Real.rpow_pos_of_pos hy z), Real.log_rpow hy]

===== Proof 836 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 837 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 838 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 839 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 840 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  ÔøΩ

===== Proof 841 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 842 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
 exact (Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx).symm
#align real.lt_rpow_iff_log_lt Real.lt_rpow_iff_log_lt

theorem rpow_le_rpow_iff (hx : 0 ‚â§ x) (hy : 0 ‚â§ y) (hz : 0 < z) : x ^ z ‚â§ y ^ z ‚Üî x ‚â§ y := by
 
 exact Real.rpow_le_rpow_iff_of_pos hz hx hy
#align real.rpow_le_rpow_iff Real.rpow_le_rpow_iff

@[simp] lemma log_rpow (hx : 0 < x) : log (x ^ y) = y * log x := by
  rw [log_eq_iff_log_exp_eq (by positivity) (by positivity), exp_log_eq hx]
  simp [exp_mul]

===== Proof 843 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 844 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff_of_pos hx (Real.rpow_pos_of_pos hy z), Real.log_rpow hy]

===== Proof 845 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  

===== Proof 846 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
 exact (Real.log_lt_log_iff hx (Real.rpow_pos_of_pos hy z)).symm
#align real.lt_rpow_iff_log_lt Real.lt_rpow_iff_log_lt

theorem rpow_le_rpow_iff (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) (hz : 0 < z) : a ^ z ‚â§ b ^ z ‚Üî a ‚â§ b :=
  
 exact (Real.rpow_le_rpow_iff_of_base_lt_one ha hb (Real.log_pos <| by linarith : 0 < Real.log z)
 (by linarith : Real.log z < 1)).symm
#align real.rpow_le_rpow_iff Real.rpow_le_rpow_iff

end Real

open Real

/-- For real number 
===== Proof 847 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
 exact (Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx).symm
#align real.lt_rpow_iff_log_lt Real.lt_rpow_iff_log_lt

lemma le_rpow_iff_log_le' (hx : 0 ‚â§ x) (hy : 0 < y) : x ‚â§ y ^ z ‚Üî Real.log x ‚â§ Real.log y * z := by
  obtain rfl | hy := hy.eq_or_lt
  ¬∑ simp [Real.log_one, Real.log_zero, zero_mul, le_refl,
      lt_irrefl (0 : ‚Ñù), hx.not_lt]
  exact le_rpow_iff_log_le hy hx

===== Proof 848 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
 exact (Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx).symm
#align real.lt_rpow_iff_log_lt Real.lt_rpow_iff_log_lt

theorem rpow_le_iff_log_le (hx : 0 < x) (hy : 0 < y) : x ‚â§ y ^ z ‚Üî Real.log x ‚â§ z * Real.log y := by
  
 exact (Real.log_le_log_iff (rpow_pos_of_pos hy z) hx).symm
#align real.rpow_le_iff_log_le Real.rpow_le_iff_log_le

@[simp] lemma log_rpow (hx : 0 < x) : log (x ^ y) = y * log x := by
  
 rw [Real.rpow_def_of_pos (by positivity : 0 < Real.exp y), log_exp]
#align real.log_rpow Real.log_rpow

lemma log_rpow_natCast (hx : 0 < x) (n : ‚Ñï) : log (x ^ (n : ‚Ñù)) = n * log x :=
  
  
 lemma rpow_natCast_mul (hx : 0 < x) (n : ‚Ñï) : x ^ (n * y) = (x ^ n) ^ y := by
  
 rw [‚Üê Real.rpow_mul hx, ‚Üê Real.rpow_natCast, Nat.cast_mul, Real.rpow_mul hx]

===== Proof 849 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
 exact (Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx).symm

===== Proof 850 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff hx (Real.rpow_pos_of_pos hy z), Real.log_rpow hy]

===== Proof 851 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
 exact (Real.rpow_pos_of_pos hy z).le
#align real.lt_rpow_iff_log_lt Real.lt_rpow_iff_log_lt

theorem rpow_eq_rpow_iff (hx : 0 ‚â§ x) (hy : 0 ‚â§ y) : x ^ z = y ^ z ‚Üî x = y ‚à® z = 0 := by
  
 exact (Real.rpow_pos_of_pos hy z).le
#align real.rpow_eq_rpow_iff Real.rpow_eq_rpow_iff

/-- 
===== Proof 852 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 853 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 854 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [(Real.log_lt_log_iff hx (Real.rpow_pos_of_pos hy z)).symm, Real.log_rpow hy]

===== Proof 855 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 856 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
 exact lt_iff_lt_of_le_iff_le (Real.rpow_le_iff_log_le hy hx)

===== Proof 857 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff hx (Real.rpow_pos_of_pos hy z), Real.log_rpow hy]

===== Proof 858 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [(Real.log_lt_log_iff hx (by positivity)).symm, Real.log_rpow hy]


theorem rpow_le_one_iff_of_pos (hx : 0 < x) : x ^ y ‚â§ 1 ‚Üî 1 ‚â§ y ‚à® x ‚â§ 1 := by
  rw [le_iff_lt_or_eq, rpow_lt_one_iff_of_pos hx, rpow_eq_one_iff_of_pos hx]


theorem rpow_lt_one_iff_of_pos (hx : 0 < x) : x ^ y < 1 ‚Üî 1 < y ‚à® x < 1 := by
  rw [lt_iff_le_and_ne, rpow_le_one_iff_of_pos hx, rpow_ne_one_iff_of_pos hx]

===== Proof 859 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
 rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 860 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
  rw [‚Üê Real.log_lt_log_iff_of_pos hx (Real.rpow_pos_of_pos hy z), Real.log_rpow hy]

===== Proof 861 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]


/-- The natural logarithm function is strictly concave on the set of positive real numbers. -/
theorem strictConcaveOn_log_Ioi : StrictConcaveOn ‚Ñù (Set.Ioi (0 : ‚Ñù)) Real.log := by
  refine ‚ü®Real.log_convexOn_Ioi, fun x (hx : 0 < x) y (hy : 0 < y) hxy a b ha hb hab => ?_‚ü©
  let x' := x / (x + y)
  let y' := y / (x + y)
  have hxy' : x' < y' := by
    rw [div_lt_div_iff, add_mul, add_mul, one_mul] <;> nlinarith
  have ha' : 0 < a := by nlinarith
  have hb' : 0 < b := by nlinarith
  have hab' : a + b = 1 := by nlinarith
  rw [‚Üê log_rpow ha' hb' hab', ‚Üê log_rpow hy hx (add_comm a b ‚ñ∏ hab')]
  refine (log_lt_log (rpow_pos_of_pos ha' _) ?_).mpr (lt_rpow_iff_log_lt (rpow_pos_of_pos hx _) ?_)
  all_goals nlinarith

===== Proof 862 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]

===== Proof 863 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hy z) hx, Real.log_rpow hy]


theorem rpow_lt_iff_lt_log (hx : 0 < x) (hy : 0 < y) : x ^ z < y ‚Üî z * Real.log y < Real.log x := by
  rw [‚Üê Real.log_lt_log_iff (rpow_pos_of_pos hx z) hy, Real.log_rpow hx]


/-- Other direction of 
===== Proof 864 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ‚Üî Real.log x < z * Real.log y := by
  
  exact (Real.rpow_pos_of_pos hy z).le

===== Proof 865 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  rw [‚Üê Polynomial.map_dvd_map' (algebraMap R K), RingHom.map_minpoly, ‚Üê
    minpoly.algebraMap_eq (IsScalarTower.toAlgHom R K L)]

===== Proof 866 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  cases' isEmpty_or_nonempty (S ‚ß∏ Ideal.span {s}) with _ _
  case inr =>
    exact minpoly.dvd K (algebraMap S L s) _ (aeval_algebraMap_eq_zero_of_dvd_minpoly
      (minpoly.monic.map (algebraMap R K)) (minpoly.dvd R s))
  case inl =>
    simp [eq_iff_true_of_subsingleton]

===== Proof 867 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  apply minpoly.dvd
  rw [map_aeval, aeval_algebraMap_apply]
  simp [minpoly.aeval]

===== Proof 868 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  have h : (minpoly K (algebraMap S L s)).coeff 0 ‚à£ (minpoly R s).coeff 0 := by
    simpa only [minpoly.coeff_zero] using minpoly.monic.dvd_coeff_zero (algebraMap S L s)
  apply minpoly.dvd_of_dvd_of_dvd K (minpoly.monic.map (algebraMap R K)
    |>.irreducible.dvd_symm (minpoly.map_monic (algebraMap R K) (monic_minpoly R s)))
  rw [‚Üê minpoly.map_dvd (algebraMap R K), map_map]
  simpa [IsScalarTower.algebraMap_eq] using minpoly.dvd R s (algebraMap S L s)
    (by simp [Algebra.smul_def])

===== Proof 869 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  let b : Algebra R L := Algebra.adjoinDef R (Set.range (algebraMap S L))
  let c : Algebra R K := Algebra.adjoinDef R (Set.range (algebraMap S K))
  let instances : Algebra.IsAlgebraic R L :=
    { is_integral := fun x =>
      (IsScalarTower.algebraMap_apply R K L x).symm ‚ñ∏
        (IsScalarTower.algebraMap_apply R S L
          ((algebraMap S L) (IsScalarTower.algebraMap_apply R S K x.1.1) : S) : L).symm ‚ñ∏
          (minpoly.isIntegral R x.1.1).map (algebraMap S L) }
  let inst : IsIntegralClosure c R L :=
    { algebraMap_injective' := fun x y h =>
        Subtype.ext ((_ : IsScalarTower R S L).injective_algebraMap_of_injective (Set.injective_algebraMap_of_disjoint
          Set.disjoint_range_range_algebraMap
          (fun _ => Set.mem_range_self)
          (fun _ => Set.mem_range_self) h))
      exists_of_eq := fun {_ _} => ‚ü®@1, by
        rw [map_one]
        rfl; rfl‚ü©
      alg_map_le := le_of_eq rfl }
  let A : Algebra R K := (Algebra.adjoin.powerBasis'
      (minpoly.monic (IsIntegralClosure.isIntegral R S _))).Algebra
  apply Algebra.dvd_of_dvd_aeval_of_aeval_eq_zero _ (IsScalarTower.algebraMap_apply R S L s)
  rw [map_aeval_eq_aeval_map]
  apply IsScalarTower.commutes
  apply aeval_eq_zero_of_dvd_aeval_eq_zero minpoly.monic (IsScalarTower.algebraMap_apply R S L s) (by rw [map_id])
  exact minpoly.aeval R (algebraMap S L s)

===== Proof 870 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  apply minpoly.dvd
  rw [aeval_algebraMap_apply, minpoly.aeval, map_zero]

===== Proof 871 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  rw [dvd_iff_isRoot, IsRoot, ‚Üê map_aeval, aeval_algebraMap_eq, map_eq_zero_iff] <;> aesop

===== Proof 872 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  have : IsScalarTower R K L := by infer_instance
  have : IsScalarTower R S L := by infer_instance
  exact minpoly.dvd K (algebraMap S L s) _ (by simp [aeval_algebraMap_apply])

===== Proof 873 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  cases subsingleton_or_nontrivial R
  case inl => simp [minpoly.eq_one]
  case inr =>
    by_cases h : IsIntegral R s
    case pos =>
      exact minpoly.dvd_map_of_isScalarTower R K L S h
    case neg => simp [h, minpoly.eq_zero]

===== Proof 874 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  by_cases h : IsIntegral R (algebraMap S L s)
  ¬∑ exact minpoly.dvd K _ _ (aeval_algebraMap_apply_eq_zero _ _)
  ¬∑ rw [minpoly.eq_zero h, minpoly.eq_zero ((algebraMap S L).isIntegral_map' s)]
    exact dvd_zero _

===== Proof 875 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  have : R ‚â† 0 := by
    rintro rfl
    simp [Subsingleton.elim S (‚ä• : Subsingleton S)]
  refine minpoly.dvd_of_eval‚ÇÇ_eq_zero K (aeval_algebraMap_eq_zero_of_dvd_minpoly S (L := L) ?_)
  rw [aeval_algebraMap_algebraMap, ‚Üê aeval_algebraMap_eq_zero_iff L]
  exact minpoly.aeval R s

===== Proof 876 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  refine' minpoly.dvd K (algebraMap S L s) _
  rw [aeval_def, aeval_def, map_zero, RingHom.map_zero, aeval_def, aeval_def, map_zero,
    zero_mul, zero_mul]

===== Proof 877 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  have h‚ÇÄ : IsScalarTower R K (AlgebraicClosure L) :=
    IsScalarTower.of_algebraMap_eq fun x => by simp
  have h‚ÇÅ : IsScalarTower R K (AlgebraicClosure L) :=
    IsScalarTower.of_algebraMap_eq fun x => by simp
  exact minpoly.dvd_map_of_isScalarTower R K L (AlgebraicClosure L) _ h‚ÇÄ h‚ÇÅ

===== Proof 878 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  letI : Algebra R K := Ti
  letI : Algebra K L := Ti
  letI : IsScalarTower R K L := Ti
  letI : IsScalarTower R S L := Ti
  letI : Module.Finite R L := Ti
  letI : IsField K := Ti
  letI : IsField L := Ti
  letI : IsNoetherianRing R := Ti
  letI : IsNoetherianRing S := Ti
  letI : Nontrivial R := Ti
  letI : Nontrivial S := Ti
  letI : Nontrivial L := Ti
  letI : Nontrivial K := Ti
  exact minpoly.dvd _ _ (aeval_algebraMap_apply_eq_zero (R := R) (S := S) (K := K) (L := L)
    (algebraMap_isScalarTower R K L) (algebraMap_isScalarTower R S L) _)

===== Proof 879 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  rw [‚Üê minpoly.isIntegrallyClosed_eq_field_fractions' K (R := R) (S := S) (L := L)
    (hRS := (IsScalarTower.algebraMap_eq R
      S L).symm) (hRK := (IsScalarTower.algebraMap_eq R K L).symm)]
  apply minpoly.dvd
  rw [‚Üê IsScalarTower.algebraMap_eq, aeval_algebraMap_eq, minpoly.aeval, IsScalarTower.algebraMap_eq,
    aeval_algebraMap_eq, minpoly.aeval]
  rfl

===== Proof 880 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  apply minpoly.dvd
  rw [‚Üê map_aeval_eq_aeval_map, minpoly.aeval, map_zero]

===== Proof 881 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  rw [IsScalarTower.algebraMap_eq R K L]
  rw [minpoly.isScalarTower_dvd K]

===== Proof 882 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  by_cases h : IsIntegral R s
  ¬∑ exact minpoly.dvd_map_of_isScalarTower R K L h
  ¬∑ rw [minpoly.eq_zero h, map_zero]
    exact minpoly.dvd_zero (algebraMap S L s)

===== Proof 883 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  apply minpoly.dvd
  rw [aeval_algebraMap_eq_zero_of_aeval_eq_zero K]
  exact minpoly.aeval R s

===== Proof 884 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  refine' minpoly.dvd _ _ _ (by simp [aeval_def])

===== Proof 885 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  apply minpoly.dvd
  simp [aeval_algebraMap_apply]

===== Proof 886 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  apply minpoly.dvd
  rw [‚Üê map_aeval_eq_aeval_map, aeval_algebraMap_eq, aeval_algebraMap_eq]
  simp [algebraMap_aeval]

===== Proof 887 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  rw [‚Üê minpoly.isIntegral_iff] at hs
  by_cases hK : (minpoly K (algebraMap S L s)).degree ‚â§ 0
  ¬∑ simp only [eq_intCast, map_intCast, minpoly.intCast_eq_zero, Int.cast_zero, minpoly.zero_eq,
      map_zero] at hK ‚ä¢
    rw [Int.dvd_iff_emod_eq_zero, Int.mod_eq_of_lt]
    ¬∑ exact minpoly.min K (algebraMap S L s) hK
    ¬∑ exact lt_of_le_of_lt hK zero_lt_one
  ¬∑ exact minpoly.dvd K (algebraMap S L s) _ (minpoly.aeval K (algebraMap S L s))

===== Proof 888 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  rw [IsScalarTower.algebraMap_eq R K L]
  rw [IsScalarTower.algebraMap_eq R S L] at _inst_13
  rw [minpoly.isScalarTower_eq R S L (algebraMap S L s)]
  exact minpoly.dvd_map_of_isScalarTower R S L s

===== Proof 889 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  haveI : IsScalarTower R K (AlgebraicClosure L) :=
    IsScalarTower.of_algebraMap_eq'
      (by rw [‚Üê map_map, IsScalarTower.algebraMap_eq, map_map, IsScalarTower.algebraMap_eq,
        RingHom.comp_assoc, RingHom.comp_assoc])
  exact minpoly.dvd_map_of_isScalarTower R K (AlgebraicClosure L) s

===== Proof 890 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  by_cases hs : IsIntegral R s
  ¬∑ exact minpoly.dvd_map_of_isScalarTower R K L (algebraMap S L s) hs
  by_cases hK : IsIntegral R (algebraMap S L s)
  ¬∑ rw [minpoly.eq_zero hs]
    exact map_zero
  ¬∑ rw [eq_zero_of_not_isIntegral hK]
    exact dvd_zero _

===== Proof 891 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  rw [minpoly.dvd_iff_modByMonic_eq_zero]
  letI : Nontrivial K := K.instNontrivial
  letI : Nontrivial L := L.instNontrivial
  letI : Nontrivial S := S.instNontrivial
  letI : Nontrivial R := R.instNontrivial
  simp only [‚Üê Subalgebra.toSubring_eq_iff, ‚Üê toSubring_algHom,
    minpoly.toSubring_of_fintype, AlgHom.map_dvd]
  exact minpoly.dvd_iff_modByMonic_eq_zero.mp (minpoly.dvd R s)

===== Proof 892 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  ¬∑ exact minpoly.dvd K _ _ (by simp [aeval_def])

===== Proof 893 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  rw [‚Üê minpoly.algebraMap_eq (IsScalarTower.toAlgHom R K L), ‚Üê
    minpoly.algebraMap_eq (IsScalarTower.toAlgHom R S L)]
  exact minpoly.dvd _ _ (aeval_algebraMap_algebraMap R K L s)

===== Proof 894 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  apply minpoly.dvd
  rw [‚Üê map_aeval_eq_aeval_map, minpoly.aeval, map_zero]

===== Proof 895 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  ¬∑ exact minpoly.dvd K (algebraMap S L s) _ (by simp)

===== Proof 896 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ‚à£ map (algebraMap R K) (minpoly R s) := by
  refine' (minpoly.dvd K (algebraMap S L s) _).trans
    (map_dvd _ (minpoly.dvd R s (by simp)))
  simp

===== Proof 897 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  refine' ‚ü®Unit, inferInstance, inferInstance, fun _ => 0, fun _ => irreducible_zero,
    fun _ => 0, _‚ü©
  dsimp only
  exact DirectSum.isInternal_of_single_eq_top _ (Submodule.torsionBy_zero _ _)

===== Proof 898 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  haveI := hM.isTorsion'_of_finite R M
  let Œπ : Type u := {s : Ideal R | s.IsPrime ‚àß ‚àÉ n : ‚Ñï, s = Ideal.span {Ideal.primeOfMaximal s.1}}
  let e : Œπ ‚Üí ‚Ñï := fun s => s.1.2.2.choose
  let p : Œπ ‚Üí R := fun s => s.1.2.2.choose_spec.choose
  have hp : ‚àÄ i, Irreducible (p i) := fun s => s.1.2.2.choose_spec.choose_spec.1
  have he : ‚àÄ i, p i ‚à£ Ideal.primeOfMaximal i.1 := fun s =>
    s.1.2.2.choose_spec.choose_spec.2
  refine' ‚ü®Œπ, inferInstance, inferInstance, p, hp, e, _‚ü©
  refine' DirectSum.isInternal_of_cyclic_of_prime_power_torsion _ _ fun i => torsionBy R M _
  exact Ideal.primeOfMaximal_prime (he i)

===== Proof 899 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  classical
    use ‚Ñï
    use inferInstance, inferInstance
    use fun _ => 0
    use fun _ => Nat.Prime.irreducible Nat.prime_zero
    use fun _ => 0
    apply DirectSum.isInternal_of_subsingleton

===== Proof 900 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  have h'M : Module.IsTorsion' M := Module.isTorsion'_iff_isTorsion.mpr hM
  obtain ‚ü®S, hS, T, hT, hS', hT', h'‚ü© :=
    Module.exists_isInternal_prime_power_torsion_of_pid' R M h'M
  rw [Module.isTorsion'_iff_isTorsion] at hS'
  refine' ‚ü®S, inferInstance, inferInstance, fun i => (hT' i).choose,
    fun i => (hT' i).choose_spec.2.1, fun i => (hT' i).choose_spec.2.2, _‚ü©
  rw [DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top]
  exact ‚ü®hS.1, hS.2.trans h'‚ü©

===== Proof 901 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  have hp : ‚àÄ x : M, ‚àÉ (p : R) (_ : Irreducible p) (n : ‚Ñï), x ‚àà torsionBy R M p ^ n := by
    intro x
    obtain ‚ü®m, hm‚ü© := hM x
    use Ideal.isPrime_of_prime (R := R)
    exact ‚ü®0, by simpa using hm.symm‚ü©
  choose! p hp' e he using hp
  classical
  refine' ‚ü®Unit, inferInstance, inferInstance, fun _ => p (), fun _ => hp' _, fun _ => 0,
    fun x => _‚ü©
  rcases he x with ‚ü®n, hn‚ü©
  simpa using hn

===== Proof 902 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  use ‚Ñï, inferInstance, inferInstance, fun _ => 0, fun _ => irreducible_zero, fun _ => 1
  simp [DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top, hM]

===== Proof 903 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  refine' ‚ü®Empty, inferInstance, inferInstance, fun _ => 0, fun _ => irreducible_zero, fun _ => 0,
    _‚ü©
  dsimp only
  infer_instance

===== Proof 904 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  obtain ‚ü®Œπ, f, hf, hM'‚ü© := DirectSum.IsInternal.exists_eq_dfinsupp R M hM
  refine' ‚ü®Œπ, fintypeOfFinite R M, inferInstance, fun i => _, fun i => hf i, fun i => 1, _‚ü©
  refine' DirectSum.IsInternal.of_fiber_apply_eq_zero _ _ _ (fun i => _)
  apply one_ne_zero

===== Proof 905 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  use ‚Ñï
  use inferInstance
  use inferInstance
  use fun _ => 0
  use fun _ => irreducible_zero
  use fun _ => 0
  exact DirectSum.isInternal_of_graded_monoid_eq (torsionBy R M (0 ^ 0))

===== Proof 906 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  use ‚Ñï
  use Fintype.ofFinite ‚Ñï
  use inferInstance
  use fun _ => 0
  use fun _ => Nat.Prime.irreducible Nat.prime_zero
  use fun _ => 0
  simp [DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top, hM]

===== Proof 907 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  refine' ‚ü®ULift (Fin 0), inferInstance, inferInstance,
    fun _ => 0, fun i => irreducible_zero, fun _ => 0, _‚ü©
  rw [isInternal_submodule_iff_independent_and_finrank_eq_card,
    FiniteDimensional.finrank_fintype_fun_eq_card]
  simp

===== Proof 908 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  refine ‚ü®PEmpty, inferInstance, inferInstance, fun _ => 0, fun _ => irreducible_zero, fun _ => 0, ?_‚ü©
  exact (DirectSum.isInternal_subsingleton (torsionBy R M (0 ^ 0))).symm

===== Proof 909 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  refine' ‚ü®PEmpty, inferInstance, inferInstance, fun _ => 0, fun _ => irreducible_zero,
    fun _ => 1, _‚ü©
  ext; simp [hM]

===== Proof 910 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  haveI := hM.inferReduced
  obtain ‚ü®Œπ, hŒπ, h, t, ht, T, hT, hœÜ‚ü© :=
    Module.exists_isInternal_prime_power_torsion_of_pid_torsion_of_pid R M
  refine ‚ü®Œπ, hŒπ, inferInstance, fun i => t i, fun i => ht i, fun i => 1, fun i => rfl, ?_‚ü©
  rw [one_eq_top] at hœÜ
  rw [hœÜ] at T
  exact hT

===== Proof 911 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  use ‚Ñï
  use inferInstance
  use inferInstance
  use fun _ => 0
  use fun _ => irreducible_zero
  use fun _ => 0
  simp [DirectSum.isInternal_submodule_iff_linearEquiv_exists]

===== Proof 912 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  refine' ‚ü®Empty, inferInstance, inferInstance, fun _ => 0, fun _ => irreducible_zero, fun _ => 0,
    _‚ü©
  exact isInternal_of_subsingleton _

===== Proof 913 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  cases subsingleton_or_nontrivial R
  all_goals
    refine' ‚ü®Empty, inferInstance, inferInstance, fun _ => 1, fun _ => irreducible_one,
      fun _ => 0, _‚ü©
    apply DirectSum.isInternal_of_subsingleton

===== Proof 914 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  have hM' : Module.Finite R M := by assumption
  obtain ‚ü®t, ht, ht', ht''‚ü© := exists_isInternal_prime_power_torsion hM' hM
  refine' ‚ü®t, ht, ht', fun i => ht'' i, fun i => 1, fun i => by simp‚ü©

===== Proof 915 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  obtain ‚ü®n, ‚ü®hn‚ü©‚ü© := exists_prime_power_torsion R M
  refine ‚ü®Fin n, inferInstance, inferInstance, fun i ‚Ü¶ (hn i).choose,
    fun i ‚Ü¶ (hn i).choose_spec.1, fun i ‚Ü¶ (hn i).choose_spec.2, ?_‚ü©
  exact DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top
    ((hn ¬∑).choose_spec.1.linearIndependent.subtype.comp
      (DFunLike.ext_iff.mp <| Fin.eq_zero ¬∑)) <| by
          rw [iSup, ‚Üê hM.eq_top_iff_one, ‚Üê torsionBySet_span_singleton_eq, Ideal.submodule_span_eq,
            Ideal.supr_prime_power_torsion_span_eq_top hn]

===== Proof 916 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  refine' ‚ü®Unit, inferInstance, inferInstance, fun _ => 0, fun _ => irreducibleZero, fun _ => 0,
    _‚ü©
  dsimp only
  exact DirectSum.isInternal_subsingleton _

===== Proof 917 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  cases nonempty_fintype_torsion_prime_power_decomposition R M hM
  aesop

===== Proof 918 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  have ‚ü®n, hn‚ü© := Module.IsTorsion.exists_isInternal_prime_power_torsion hM
  refine' ‚ü®Fin n, inferInstance, inferInstance, fun i => _, fun i => _, fun i => 1, fun i => _,
    fun i => by rw [pow_one]; exact hn i‚ü© <;> try apply IsPrime.irreducible;
    apply IsPrincipalIdealRing.isPrime_of_prime; exact Ideal.prime_of_isPrime _ _ (hn i)

===== Proof 919 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  classical
  rcases Submodule.exists_isInternal_prime_power_torsion_of_pid_aux hM with ‚ü®Œπ, _, p, hp‚ü©
  refine' ‚ü®Œπ, inferInstance, inferInstance, p, hp.1, fun i => 0, _‚ü©
  dsimp
  simp [hp.2]

===== Proof 920 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  obtain ‚ü®n, _‚ü© := hM
  have : Module.IsTorsionBy R M n := ‚ü®n, rfl‚ü©
  refine ‚ü®Unit, inferInstance, inferInstance, fun _ => n, fun _ => irreducible_of_prime n,
    fun _ => 1, this‚ü©

===== Proof 921 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  have hŒπ : ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
      (e : Œπ ‚Üí ‚Ñï), Module.IsTorsionBy R M <| ‚®Ö i, p i ^ e i := by
    refine (Submodule.isInternal_prime_power_torsion_of_pid R M hM).choose_spec.choose_spec.choose_spec
      .choose_spec.choose_spec
  obtain ‚ü®Œπ, hŒπ, hŒπ', p, hp, e, h‚ü© := hŒπ
  refine ‚ü®Œπ, hŒπ, hŒπ', p, hp, e, ?_‚ü©
  exact directSum_isInternal_of_isTorsionBy R M <| ‚®Ö i, p i ^ e i

===== Proof 922 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  cases nonempty_fintype Œπ
  cases nonempty_fintype Œπ
  use Œπ
  use inferInstance
  use inferInstance
  use fun _ => 0
  use fun _ => irreducible_zero
  use fun _ => 0
  apply DirectSum.isInternal_of_subsingleton

===== Proof 923 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  letI := Classical.decEq Œπ;
  use Œπ, inferInstance, inferInstance, fun i => (hM.exists_set_of_torsionBy R M).choose,
    (hM.exists_set_of_torsionBy R M).choose_spec.one_lt.irreducible, fun i => 1;
  apply DirectSum.isInternal_of_bijective (fun i : Œπ => torsionBy R M _) <|
    (LinearEquiv.refl R _).bijective

===== Proof 924 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  obtain ‚ü®a, a_ne, a_torsion‚ü© := exists_ne_zero (R := R) <| hM.not_subsingleton
  let Œπ := {d : R | d ‚à£ a ‚àß Irreducible d}
  have h_fintype : Fintype Œπ := by
    apply Fintype.ofFinite _
  have h_fintype' : Fintype Œπ := Œπ.fintype
  let p : Œπ ‚Üí R := fun i => i
  have h_irreducible : ‚àÄ i, Irreducible (p i) := fun i => i.2.1
  let e : Œπ ‚Üí ‚Ñï := fun i => (multiplicity_finite_of_finite a_ne (hM.finite_of_isTorsion a_torsion)).multiplicity i.1
  have h_e : ‚àÄ i, e i = (multiplicity_finite_of_finite a_ne (hM.finite_of_isTorsion a_torsion)).multiplicity i :=
    fun i => rfl
  have h_add : ENNReal.add_haar a_torsion h_e = (direct_sum_torsionBy_eq_top a_torsion).symm := by
    rw [ENNReal.add_haar_eq_top]
    exact hM.finite_of_isTorsion a_torsion
  exact ‚ü®Œπ, h_fintype, inferInstance, p, h_irreducible, e, DirectSum.IsInternal.of_add_haar h_add‚ü©

===== Proof 925 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  obtain ‚ü®I, hI, hI'‚ü© := hM.exists_isInternal_prime_power_torsion
  refine' ‚ü®I, hI, inferInstance, fun i => (hI' i).choose, fun i => (hI' i).choose_spec.1,
    fun i => (hI' i).choose_spec.2, _‚ü©
  rw [DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top]
  constructor
  ¬∑ exact hI.independent_biSup (fun i => (hI' i).choose_spec.1)
  ¬∑ apply le_antisymm _ (‚®Ü i, torsionBy R M (hI.elems.val i ^ (hI.elems.val i).2) ‚â§ ‚ä§)
    suffices (‚®Ü i : I, torsionBy R M (hI.elems.val i ^ (hI.elems.val i).2)) ‚â§ ‚ä§ by exact this
    rw [iSup_le_iff]
    intro ‚ü®x, hx‚ü©
    have : x ‚àà torsionBy R M x.val ‚äî ‚®Ü i : I, torsionBy R M (hI.elems.val i ^ (hI.elems.val i).2) := by
      rw [Submodule.mem_sup]; refine' ‚ü®x, x.prop, _, _, rfl‚ü©
    simpa using hI.sup_torsionBy_eq_top x this

===== Proof 926 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  use ‚àÖ, inferInstance, inferInstance, fun i => (hM.natCast i).choose, fun i =>
    (hM.natCast i).choose_spec.1, 1
  simp [DirectSum.isInternal_isEmpty]

===== Proof 927 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  haveI := hM.nontrivial
  haveI : ‚àÄ p : R, p.Prime ‚Üí ‚àÉ i, p = Ideal.primeCompl  i /- Import 
===== Proof 928 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ‚àÉ (Œπ : Type u) (_ : Fintype Œπ) (_ : DecidableEq Œπ) (p : Œπ ‚Üí R) (_ : ‚àÄ i, Irreducible <| p i)
        (e : Œπ ‚Üí ‚Ñï), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
  cases nonempty_fintype Œπ
  obtain ‚ü®p, irr‚ü© := @exists_prime_power_torsion M M _ _ _ R _ _ _ _
  exact ‚ü®Œπ, inferInstance, inferInstance, p, irr, fun _ => 1, fun _ => DirectSum.isInternal_of_bijective
    (Equiv.refl _) (Equiv.refl _)‚ü©

===== Proof 929 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' InfinitePlace.isReal_or_isComplex w with h h <;> simp [h]

===== Proof 930 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' Classical.em (IsReal w) with h h <;> simp [h]
  exact IsComplex.of_not_isReal h

===== Proof 931 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  by_cases h : IsReal w <;> simp_all

===== Proof 932 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases h : w
  exacts [Or.inl (by infer_instance), Or.inr (by infer_instance)]

===== Proof 933 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  by_cases hw : IsReal w <;> simp_all

===== Proof 934 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' Classical.em (IsReal w) with h h <;> simp_all

===== Proof 935 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w <;> simp [*, IsReal, IsComplex]

===== Proof 936 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w
  all_goals aesop

===== Proof 937 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w <;> simp [*, isReal_embedding, isComplex_embedding, Valuation.map_zero]
  <;> first | apply isReal_of_real_embedding | apply isComplex_of_complex_embedding
  <;> infer_instance

===== Proof 938 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w <;> simp

===== Proof 939 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' InfinitePlace.isReal_or_isComplex w with hw hw <;> simp [hw]

===== Proof 940 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases'' InfinitePlace.isReal_or_isComplex w with hw hw <;> simp_all

===== Proof 941 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  by_cases hw : w.embedding = 1 <;> simp [hw]
  rcases InfinitePlace.isReal_or_isComplex w with (‚ü®‚ü© | ‚ü®‚ü©) <;> aesop

===== Proof 942 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w <;> simp

===== Proof 943 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  by_cases h : IsReal w
  exacts [Or.inl h, Or.inr (by simpa using h)]

===== Proof 944 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w
  all_goals simp

===== Proof 945 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' Classical.em (IsReal w) with h h <;> simp [h]
  cases' isReal_or_isComplex_of_infinity w with h' h' <;> simp [h']

===== Proof 946 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' InfinitePlace.isReal_or_isComplex w with h h <;> simp_all

===== Proof 947 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  by_cases hw : IsReal w <;> simp [hw]
  <;> simp

===== Proof 948 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' InfinitePlace.isReal_or_isComplex w with h h <;> simp_all

===== Proof 949 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  rcases InfinitePlace.isReal_or_isComplex w with (h | h) <;> simp [h]

===== Proof 950 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w <;> simp [IsReal, IsComplex]

===== Proof 951 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w <;> simp [IsReal, IsComplex, InfinitePlace, Set.Infinite, Nat.SuperLarge, PNat.large]

===== Proof 952 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' InfinitePlace.isReal_or_isComplex w with h h <;> simp [h]

===== Proof 953 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  by_cases h : IsReal w <;> simp [h]
  <;> simp [h] at * <;> aesop

===== Proof 954 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' w with _ _ _ h h <;> simp_all

===== Proof 955 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  by_cases hw : IsReal w
  case pos => exact Or.inl hw
  case neg => exact Or.inr (not_isReal_iff_isComplex.mp hw)

===== Proof 956 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w <;> simp

===== Proof 957 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  exact isReal_or_isComplex w

===== Proof 958 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases w <;> simp [IsReal, IsComplex]

===== Proof 959 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  cases' isReal_or_isComplex w with hw hw <;> simp [hw]

===== Proof 960 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ‚à® IsComplex w := by
  by_cases hw : IsReal w
  exacts [Or.inl hw, Or.inr (not_isReal_iff_isComplex.mp hw)]

===== Proof 961 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  rw [SlashAction.smul_slash]
  rw [IsScalarTower.smul_assoc]

===== Proof 962 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_slash, IsScalarTower.smul_assoc, smul_smul]

===== Proof 963 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_slash]
  rw [smul_one_smul]

===== Proof 964 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_slash, smul_one_smul]

===== Proof 965 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [IsScalarTower.smul_assoc, SlashAction.smul_slash])
  aesop

===== Proof 966 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  exact SlashAction.smul_slash _ _ _ _

===== Proof 967 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp_all [SlashAction.smul_slash]

===== Proof 968 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_slash])

===== Proof 969 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  unfold SlashAction.IsSlashAction
  simp only [Smul.smul, smul_assoc]
  simp only [IsScalarTower.smul_assoc, smul_comm _ r, smul_assoc r]

===== Proof 970 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_slash]
  rw [‚Üê mul_one r]
  rw [‚Üê smul_one_smul Œ≥ r g]
  rw [‚Üê smul_one_smul Œ≥ r a]
  simp only [SlashAction.slash_def, smul_assoc, one_smul]

===== Proof 971 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp_rw [SlashAction.slash_def]
  rw [‚Üê IsScalarTower.smul_assoc]

===== Proof 972 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_slash]
  rw [mul_smul_comm]

===== Proof 973 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp_all [IsScalarTower.smul_assoc]

===== Proof 974 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  dsimp only [SlashAction.Slash]
  simp only [‚Üê IsScalarTower.smul_assoc, id]

===== Proof 975 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_assoc]
  rw [SlashAction.smul_slash]

===== Proof 976 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlackAction.cons, IsScalarTower.smul_assoc]

===== Proof 977 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.slash_def, smul_eq_mul, IsScalarTower.mul_assoc]
  rw [‚Üê mul_one (r ‚Ä¢ a), ‚Üê SlashAction.one_smul, ‚Üê mul_one (r ‚Ä¢ a)]
  simp only [SlashAction.slash_def, smul_eq_mul, IsScalarTower.mul_assoc]
  simp only [‚Üê mul_assoc, IsScalarTower.mul_assoc, mul_one]

===== Proof 978 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp_all [IsScalarTower, SlashAction]

===== Proof 979 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.slash]
  rw [mul_smul_comm]
  rw [‚Üê mul_smul_comm]
  simp

===== Proof 980 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp_rw [SlashAction.smul_slash]
  rw [smul_assoc]

===== Proof 981 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simpa only [smul_assoc] using SlashAction.smul_slash k g a r

===== Proof 982 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_assoc, SlashAction.smul_def, IsScalarTower.smul_assoc]

===== Proof 983 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  rw [SlashAction.smul_slash]
  rw [‚Üê smul_assoc]
  simp only [mul_smul_comm, smul_assoc]

===== Proof 984 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  delta SlashAction.slash
  rw [‚Üê IsScalarTower.smul_assoc, IsScalarTower.smul_assoc]

===== Proof 985 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  letI : MulAction G Œ± :=
    { ‚ÄπMulAction Œ≥ Œ±‚Ä∫ with
      mul_smul := fun _ _ _ => mul_smul _ _ _
      one_smul := fun _ => by
        simp only [one_smul, apply_eq_iff, smul_apply] }
  letI : IsScalarTower R G Œ± :=
    { ‚ÄπIsScalarTower R Œ≥ Œ±‚Ä∫ with
      smul_assoc := fun _ _ _ => by
        simp only [apply_eq_iff, smul_eq_mul, mul_assoc, smul_apply_eq_smul_apply_of_slash_action] }
  simp only [apply_eq_iff, smul_apply_eq_smul_apply_of_slash_action]

===== Proof 986 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_slash_def]
  rw [‚Üê IsScalarTower.smul_assoc r Œ≥ Œ±]
  simp only [smul_eq_mul]

===== Proof 987 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  rw [SlashAction.smul_eq_smul_smul, smul_assoc, SlashAction.smul_eq_smul_smul]

===== Proof 988 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [SlashAction.smul_slash]
  rw [smul_assoc]

===== Proof 989 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp_all only [SlashAction.smul_slash, smul_one_smul]

===== Proof 990 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  simp only [IsScalarTower.smul_assoc, SlashAction.smul_slash_assoc]

===== Proof 991 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  exact SlashAction.smul_slash k g a r

===== Proof 992 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R Œ≤ G Œ± : Type*} (Œ≥ : Type*) [Group G] [AddGroup Œ±]
    [Monoid Œ≥] [MulAction Œ≥ Œ±] [SMul R Œ≥] [SMul R Œ±] [IsScalarTower R Œ≥ Œ±] [SlashAction Œ≤ G Œ± Œ≥]
    (k : Œ≤) (g : G) (a : Œ±) (r : R) : (r ‚Ä¢ a) ‚à£[k;Œ≥] g = r ‚Ä¢ a ‚à£[k;Œ≥] g := by
  rw [SlashAction.sl_def, SlashAction.sl_def, smul_inv_smul]

===== Proof 993 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  cases' h with h‚ÇÄ h‚ÇÅ
  rw [Nat.ModEq] at h‚ÇÄ h‚ÇÅ ‚ä¢
  rw [mul_add, mul_add, mul_comm]
  exact Nat.ModEq.add h‚ÇÄ h‚ÇÅ

===== Proof 994 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.mul_comm n c]
  simp only [Nat.ModEq, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]
  exact Nat.mul_left_cancel' (Nat.pos_of_ne_zero (Nat.ne_of_gt (Nat.pos_of_ne_zero h.ne_zero))) h

===== Proof 995 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.mul_comm a c, Nat.mul_comm b c]
  exact Nat.ModEq.mul_left c h

===== Proof 996 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [mul_comm n c]
  simp only [Nat.ModEq, Nat.mul_comm, Nat.mul_left_comm]
  exact h.mul (by rfl)

===== Proof 997 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  simp only [Nat.MulOpposite, Nat.ModEq, Nat.ModEq, Nat.ModEq] at *
  omega

===== Proof 998 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.mul_comm n, Nat.mul_comm c]
  simp only [Nat.ModEq, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc] at h ‚ä¢
  exact h.mul_left c

===== Proof 999 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  obtain ‚ü®d, rfl‚ü© := ModEq.def.1 h
  simp [Nat.mul_mod, Nat.ModEq, Nat.dvd_iff_mod_eq_zero, Nat.mod_eq_of_lt]

===== Proof 1000 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  cases h with
  | mk d hd => use d * c; simp [Nat.mul_sub_mul, mul_comm, Nat.mul_sub_mul, hd]

===== Proof 1001 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  simp only [Nat.ModEq, Nat.mul_mod_left] at *
  simp_all

===== Proof 1002 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [mul_comm a, mul_comm b]; exact Nat.mul_left_mod _ _ _ |>.mpr h

===== Proof 1003 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.mul_comm n c]
  exact Nat.modEq_mul_right c h

===== Proof 1004 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.mul_comm n c]
  exact Nat.ModEq.mul_right c h

===== Proof 1005 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [mul_comm a c, mul_comm b c]
  exact Nat.ModEq.mul_left c h

===== Proof 1006 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  have : a * c ‚â° b * c [MOD n * c] := by
    apply Nat.ModEq.mul_right
    assumption
  exact this

===== Proof 1007 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [mul_comm a, mul_comm b];
  apply Nat.ModEq.mul_right
  simp [h]

===== Proof 1008 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  have h' : a * c ‚â° b * c [MOD n * c] := h.mul (by rfl)
  simp only [Nat.ModEq, Nat.mul_mod_mul_left] at h' ‚ä¢
  exact h'

===== Proof 1009 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  unfold Nat.ModEq at *
  simp [Nat.mul_mod, Nat.add_mod, h.symm]

===== Proof 1010 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  simp only [Nat.ModEq, Nat.mul_mod_mul_left]
  exact h.mul (rfl.trans rfl)

===== Proof 1011 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  have h‚ÇÅ := h.mul_right c
  simp only [Nat.mul_comm, Nat.mul_assoc] at h‚ÇÅ
  exact h‚ÇÅ

===== Proof 1012 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  simp [Nat.ModEq, Nat.add_mul_mod_mul_add, Nat.mul_mod_mul_left]
  simp [Nat.mul_assoc, Nat.add_mul_mod_mul_add, Nat.mul_mod_mul_left, h.symm]

===== Proof 1013 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [mul_comm n c]
  exact h.mul_right c

===== Proof 1014 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  have : a * c ‚â° b * c [MOD n * c] := by
    simp only [Nat.ModEq, Nat.mul_mod_mul_left]
    simp [h.symm]
  simpa [Nat.mul_assoc] using this

===== Proof 1015 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.mul_comm n c]
  simp only [Nat.ModEq, Nat.mul_comm c, Nat.mul_left_comm]
  exact h.mul (by rfl)

===== Proof 1016 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.modEq_iff_dvd] at *
  rw [mul_comm n c]
  simpa [Nat.mul_sub_left_distrib, Nat.mul_sub_right_distrib] using Nat.dvd_add h (by simp)

===== Proof 1017 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  have : a * c % (n * c) = b * c % (n * c) := by
    rw [‚Üê Nat.mod_mul_left_mod _ _ h]
  exact Nat.modeq_of_dvd (by simpa)

===== Proof 1018 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [mul_comm a, mul_comm b]
  exact h.mul_right _

===== Proof 1019 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  cases' h with d hd
  use d * c
  rw [mul_assoc, ‚Üê hd]
  ring

===== Proof 1020 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.ModEq] at h ‚ä¢
  rw [mul_comm a, mul_comm b, Nat.mul_mod]
  simp_all [Nat.mul_mod, Nat.add_mod, Nat.mod_eq_of_lt]

===== Proof 1021 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  simp_all only [Nat.ModEq, Nat.mod_eq_of_lt, mul_lt_mul_of_pos_right, mul_comm, mul_left_comm,
    mul_assoc]
  simp [h, Nat.mul_mod, Nat.add_mod, Nat.mod_eq_of_lt]

===== Proof 1022 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.ModEq] at h ‚ä¢
  simp_all [Nat.mul_mod, Nat.mul_comm]

===== Proof 1023 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  simp only [Nat.ModEq, Nat.mul_mod_mul_left] at *
  tauto

===== Proof 1024 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ‚Ñï) (h : a ‚â° b [MOD n]) : a * c ‚â° b * c [MOD n * c] := by
  rw [Nat.mul_comm n c]
  simp only [Nat.ModEq, Nat.mul_comm n c] at h ‚ä¢
  norm_num [Nat.mul_mod, h]

===== Proof 1025 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  ¬∑ intro h
    obtain ‚ü®c, œÑ, rfl, hd, hc, hn‚ü© := mem_cycleType_iff.1 h
    exact ‚ü®c, œÑ, rfl, hd, hc, hn‚ü©
  ¬∑ rintro ‚ü®c, œÑ, rfl, hd, hc, hn‚ü©
    rw [cycleType_mul]
    exact List.mem_of_mem_insert_of_ne (mem_cycleType_iff.2 ‚ü®c, œÑ, rfl, hd, hc, hn‚ü©)
      (by rintro rfl; simp_all)

===== Proof 1026 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  ¬∑ intro hn
    obtain ‚ü®c, œÑ, hcœÑ, h, -‚ü© := exists_cycle_of_mem_cycleType hn
    refine ‚ü®c, œÑ, hcœÑ, h, ‚ü®rfl.subset, ?_‚ü©‚ü©
    simpa [hcœÑ, h] using hn
  ¬∑ rintro ‚ü®c, œÑ, rfl, h, hc, rfl‚ü©
    simp [hc, h]

===== Proof 1027 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  rw [cycleType_def]
  simp only [Multiset.mem_map, mem_cycleFactorsFinset_iff]
  aesop

===== Proof 1028 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine' ‚ü®fun hn => _, fun ‚ü®c, œÑ, hx, hc‚ü© => _‚ü©
  ¬∑ refine' (cycleType_def œÉ).trans.symm.subset hn |>.imp fun c hc => _
    rcases Disjoint.exists_perm_eq_mul_of_disjoint hc.2.2.2 hc.2.2.1
    exact ‚ü®_, _, by simp [hx, hc], hc.2.2.2, hc.2.2.1, hc.2.1‚ü©
  ¬∑ rw [hx]
    simp [hc.1, hc.2.1, hc.2.2.1]

===== Proof 1029 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine' ‚ü®fun h => _, fun ‚ü®c, œÑ, h_mul, h_disjoint, h_cycle, h_card‚ü© => _‚ü©
  ¬∑ rw [cycleType_def] at h
    obtain ‚ü®c, hc‚ü© := exists_cycle_of_mem_cycleType h
    refine' ‚ü®c, œÉ /‚Çú c, _, disjoint_mul_left_of_mem_cycleType h, isCycle_mul_left_of_mem_cycleType h, _‚ü©
    ¬∑ rw [‚Üê hc]
      exact (mul_div_cancel' _ (disjoint_mul_left_of_mem_cycleType h)).symm
    ¬∑ rw [card_support_cycleOf, ‚Üê hc, card_support_eq_of_mem_cycleType h]
  ¬∑ rw [‚Üê h_mul, cycleType_mul_of_disjoint h_disjoint]
    exact mem_append_left _ (mem_map_of_mem _ (mem_erase_of_ne (h_cycle.ne_one)))

===== Proof 1030 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine' ‚ü®fun h => _, fun ‚ü®c, œÑ, h1, h2, h3, h4‚ü© => _‚ü©
  ¬∑ exact cycleType_mem h
  ¬∑ rw [h1]
    simp [h2, h3, h4]

===== Proof 1031 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  exact fun hn => ‚ü®œÉ, 1, by simp [hn], by simp, by simp, by simp‚ü©
  rintro ‚ü®c, t, rfl, h1, h2, h3‚ü©
  rw [cycleType_mul]
  simp [h1, h2, h3]

===== Proof 1032 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  ¬∑ intro h
    rw [mem_cycleType_iff] at h
    obtain ‚ü®c, œÑ, h1, h2, h3, h4‚ü© := h
    refine' ‚ü®c, œÑ, h1, h2, h3, _‚ü©
    rw [‚Üê h4]
    exact rfl
  ¬∑ rintro ‚ü®c, œÑ, rfl, h1, h2, h3‚ü©
    rw [cycleType_def]
    refine' mem_map.mpr _
    refine' ‚ü®‚ü®c, œÑ‚ü©, mem_filter.mpr ‚ü®mem_subtype_of_mem h3, h1‚ü©, _‚ü©
    rw [mem_cycle_factors_finset_iff]
    refine' ‚ü®h2.1, h2.2, _‚ü©
    rw [support_mul]
    rw [disjoint_iff_disjoint_support] at h1
    exact eq_of_disjoint_of_support_mul_eq_univ h1 (by simp [h3])

===== Proof 1033 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  simp [cycleType_def, and_assoc, and_left_comm]

===== Proof 1034 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  simp [cycleType, mem_map, and_assoc, exists_and_left]
  aesop

===== Proof 1035 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  ¬∑ intro h
    obtain ‚ü®x, hx, rfl‚ü© := exists_mem_disj_cycles h
    refine' ‚ü®x, _, hx, disjoint_mul_left (a := x) (b := œÉ.cycleOf x)
      (by rw [‚Üê cycleOf_mul_distrib, hx.cycleOf_mul_cycleOf, one_mul]) (by
      simpa [hx] using hx.disjoint_mul_left_iff) hx.isCycle, _‚ü©
    simp only [card_support_cycleOf, hx]
  ¬∑ rintro ‚ü®c, œÑ, rfl, hcœÑ, hc, rfl‚ü©
    rw [cycleType_mul_of_disjoint hcœÑ.symm]
    simp only [mem_coe, mem_append, mem_map]
    right
    refine' ‚ü®c, isCycle_of_mul_left_of_mem_cycleType _ (by simp), rfl‚ü©

===== Proof 1036 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  ¬∑ intro hn
    use œÉ.cycleOf 1
    use œÉ.cycleOf (1 : Œ±).1
    rw [cycleOf_mul_distrib]
    exact ‚ü®by simp [hn], disjoint_cycleOf_self, isCycle_cycleOf _ (by decide), by simp [hn]‚ü©
  ¬∑ rintro ‚ü®c, œÑ, rfl, hcœÑ, hc, rfl‚ü©
    exact mem_cycleType_of_mem_cycle_factors_finset hc

===== Proof 1037 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  rw [mem_cycleType_iff]
  refine' ‚ü®fun ‚ü®c, hc‚ü© => ‚ü®c, 1, by simp, by simp [hc], by simp, by simp [hc]‚ü©, _‚ü©
  rintro ‚ü®c, œÑ, rfl, h, hc, rfl‚ü©
  exact ‚ü®c, rfl‚ü©

===== Proof 1038 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  ¬∑ intro hn
    obtain ‚ü®c, hc‚ü© := exists_cycle œÉ
    obtain ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü© := mem_cycle_iff.mp hn
    refine ‚ü®c, 1, ?_‚ü©
    simp [hl‚ÇÇ, hc, hn, hl‚ÇÅ]
  ¬∑ rintro ‚ü®c, œÑ, rfl, h1, _, hc‚ü©
    rw [cycleType_mul]
    simp [hc]

===== Proof 1039 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  simp_rw [cycleType_def, Finset.mem_coe, Finset.mem_map]
  simp_rw [mem_darts_iff]
  simp [exists_prop]

===== Proof 1040 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  next =>
    intro h
    obtain ‚ü®c, hc‚ü© := exists_cycle œÉ
    obtain ‚ü®œÑ, hœÑ, hcœÑ‚ü© := exists_perm_eq_mul œÉ hc
    refine' ‚ü®c, œÑ, hcœÑ, disjoint_of_le_bot _ _ (by simp [hc, hœÑ]), hc.left, _‚ü©
    ¬∑ rw [‚Üê hcœÑ] at h
      simpa using h
    ¬∑ rw [‚Üê hcœÑ]
      simp [hc, hœÑ]
  next =>
    rintro ‚ü®c, œÑ, h, hdisjoint, hc, rfl‚ü©
    simp [h, hc]

===== Proof 1041 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  ¬∑ intro h
    exact ‚ü®œÉ.cycleOf n, œÉ.cycleOf n‚Åª¬π, by rw [cycleOf_inv, support_inv, cycleOf_mul_distrib]‚ü©
  ¬∑ rintro ‚ü®c, œÑ, hc, h, hc, rfl‚ü©
    rw [cycleType_def]
    simp [hc, h]

===== Proof 1042 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  ¬∑ intro h
    obtain ‚ü®c, hc, hn‚ü© := Nat.exists_eq_succ_of_ne_zero (Nat.pos_iff_ne_zero.mp (card_pos_of_mem h))
    refine' ‚ü®c.cycleOf œÉ, œÉ.cycleOf_mul_distrib c, _, _, _, _‚ü©
    ¬∑ simp [hc]
    ¬∑ exact disjoint_mul_swap hc
    ¬∑ exact isCycle_cycleOf _ hn
    ¬∑ exact card_cycleOf_eq_one_iff.mpr hn
  ¬∑ rintro ‚ü®c, t, rfl, hd, hc, hn‚ü©
    simpa [hd.cycleType, hc.cycleType, hn] using mem_of_mem_of_mem hc (mem_of_mem_of_mem hd (mem_univ _))

===== Proof 1043 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  next =>
    intro h
    obtain ‚ü®l, rfl‚ü© := truncCycleFactors œÉ
    rw [cycleType_eq] at h
    obtain ‚ü®c, cl, rfl‚ü© := Multiset.mem_map.mp h
    rw [‚Üê Multiset.mem_coe] at cl
    obtain ‚ü®t, rfl‚ü© := Multiset.mem_coe.mp cl
    refine' ‚ü®c, t, by simp [Multiset.mem_map, Function.comp], disjoint_prod_right, isCycle_of_mem_cycleFactorsFinset cl, _‚ü©
    rw [card_support_of_mem_cycleFactorsFinset cl]
  next =>
    rintro ‚ü®c, t, rfl, hdt, hc, rfl‚ü©
    rw [cycleType_mul]
    by_cases htc : Disjoint c t
    ¬∑ rw [if_pos htc, List.mem_append, mem_singleton]
      exact Or.inr rfl
    ¬∑ rw [if_neg htc]
      exact List.mem_append_of_mem_right _ (mem_singleton_self _)

===== Proof 1044 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine' ‚ü®fun h => _, fun ‚ü®c, œÑ, hcœÑ, hd, hc, hn‚ü© => _‚ü©
  ¬∑ exact
      let ‚ü®c, hc‚ü© := exists_cycle œÉ
      let ‚ü®œÑ, hœÑ, hcœÑ, _‚ü© := mem_cycleDecomposition.1 h
      ‚ü®c, œÑ, by rw [hc, hcœÑ.symm, coe_mul, MonoidHom.coe_mk],
        disjoint_mul_inv_of_mem_cycleDecomposition hœÑ, hc, by rw [card_support_eq_of_mem_cycleDecomposition hœÑ]‚ü©
  ¬∑ rw [‚Üê hn, hc.cycleType, mem_singleton]
    simp [hc, hcœÑ, hd.symm]

===== Proof 1045 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine ‚ü®fun hn => ?_, fun ‚ü®c, œÑ, _, hdisjoint, hc, hcard‚ü© =>
    by simpa [‚Üê hcard, hc.cycleType, hdisjoint.cycleType]‚ü©
  obtain ‚ü®c, t, hc, rfl‚ü© := mem_cycleFactorsFinset_iff.1 hn
  exact ‚ü®c, t, by simp_all, disjoint_mul_inv_of_mem_cycleFactorsFinset hn, hc,
    (isCycle_of_mem_cycleFactorsFinset hn).card_support‚ü©

===== Proof 1046 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine ‚ü®fun h‚ÇÅ => ?_, fun h‚ÇÇ => ?_‚ü©
  ¬∑ rw [mem_cycleType_iff] at h‚ÇÅ
    obtain ‚ü®c, œÑ, rfl, hd, hc‚ü© := h‚ÇÅ
    exact ‚ü®c, œÑ, rfl, hd, hc, rfl‚ü©
  ¬∑ obtain ‚ü®c, œÑ, rfl, hd, hc, rfl‚ü© := h‚ÇÇ
    rw [mem_cycleType_iff]
    exact ‚ü®c, rfl, rfl‚ü©

===== Proof 1047 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  next =>
    intro h
    obtain ‚ü®c, œÑ, h1, h2, h3, h4‚ü© := cycleType_sub_one h
    exact ‚ü®c, œÑ, by simpa [h1] using h3, by simpa [h1] using h2, by simpa [h1] using h3, by
      simpa [h1] using h4‚ü©
  next =>
    rintro ‚ü®c, œÑ, rfl, h2, h3, h4‚ü©
    simp [cycleType, h2, h3, h4]

===== Proof 1048 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  ¬∑ intro hn
    rw [cycleType_def] at hn
    obtain ‚ü®c, hc, hn‚ü© := exists_mem_support_of_mem_finset_sum hn
    rw [mem_coe, mem_support] at hc
    obtain ‚ü®œÑ, hœÑ‚ü© := exists_perm_eq_of_disj_perm hc.1.choose_spec hc.2 hn
    refine' ‚ü®c, œÑ, _, disjoint_mul_left.1 _ |>.left, hc.1.choose_spec, _‚ü©
    ¬∑ conv_lhs => rw [hœÑ]
      simp only [mul_inv_cancel_left]
    ¬∑ rw [‚Üê hn]
      simpa only [‚Üê hœÑ, support_mul_eq_union_of_disjoint, IsCycle.orderOf, hc.1.choose_spec.1,
        card_support_eq_one_iff_is_cycle.2 hc.1.choose_spec.2.2.1, one_mul]
  ¬∑ rintro ‚ü®c, œÑ, rfl, h, hc, rfl‚ü©
    simpa only [h.cycleType, singleton_add] using mem_cons_self _ _

===== Proof 1049 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine ‚ü®fun h ‚Ü¶?_, fun ‚ü®c, œÑ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü© ‚Ü¶?_‚ü©
  ¬∑ exact ‚ü®_, _, cycle_product_right _, cycle_disjoint _ _, isCycle_cycleOf _ h, card_cycleOf_eq_one_iff.mpr h‚ü©
  ¬∑ rw [h‚ÇÅ]
    simp [h‚ÇÇ.cycleOf_mul_distrib, h‚ÇÉ.card_support_eq, h‚ÇÑ]

===== Proof 1050 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine' ‚ü®fun hn => _, fun ‚ü®c, œÑ, h_sigma, h_disjoint, h_c_cycle, h_card‚ü© => _‚ü©
  ¬∑ obtain ‚ü®x, hx, h_cycle‚ü© := exists_cycle_of_mem_cycleType hn
    refine' ‚ü®x, 1, _, disjoint_one_right _, isCycle_of_mem_cycleType hn, _‚ü©
    ¬∑ rw [mul_one]
    ¬∑ exact card_support_cycleOf_eq_one hx
  ¬∑ rw [h_sigma]
    simp [h_disjoint, h_c_cycle, h_card]

===== Proof 1051 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  simp [cycleType, mem_map, and_assoc, exists_and_left, exists_eq_left, exists_eq_right]

===== Proof 1052 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  next =>
    intro h
    obtain ‚ü®c, hc‚ü© := exists_cycle œÉ
    obtain ‚ü®œÑ, hœÑ, _‚ü© := exists_perm_mul_of_cycle_of_sigma hc h
    refine' ‚ü®c, œÑ * œÉ, by rw [mul_assoc, hœÑ, mul_one], disjoint_mul_right.2 h.2, hc.1, _‚ü©
    rw [‚Üê card_support_eq_three.2 (hc.1.trans hœÑ.symm)]
  next =>
    rintro ‚ü®c, œÑ, rfl, h, hc‚ü©
    exact hc.symm ‚ñ∏ mem_cycleType_of_mem_cycle_factors_finset (by simpa [hc] )

===== Proof 1053 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine' mem_cycleType_iff.trans ‚ü®_, _‚ü©
  ¬∑ rintro ‚ü®c, hc, rfl‚ü©
    refine' ‚ü®c, 1, by simp, by simp [hc], by simp‚ü©
  ¬∑ rintro ‚ü®c, œÑ, rfl, h1, h2, h3‚ü©
    by_cases hc : IsCycle c
    ¬∑ exact ‚ü®c, h1.2, rfl‚ü©
    ¬∑ rw [h2.cycleOf_eq hc] at h3
      cases h3

===== Proof 1054 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  constructor
  next =>
    intro hn
    rw [cycleType, Multiset.mem_coe, mem_sort] at hn
    obtain ‚ü®c, œÑ, hc, hœÑ, h‚ü© := exists_cycle_of_mem_cycleFactorsFinset hn
    refine ‚ü®c, œÑ, ?_‚ü©
    rw [hc, h]
    exact ‚ü®disjoint_mul_right (h := hœÑ), hœÑ, rfl‚ü©
  next =>
    rintro ‚ü®c, œÑ, rfl, h1, h2, rfl‚ü©
    simp [h2.cycleType, h1.card_support]

===== Proof 1055 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  simp only [cycleType, mem_list_cycles_iff, exists_prop]

===== Proof 1056 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ‚Ñï} {œÉ : Perm Œ±} :
    n ‚àà cycleType œÉ ‚Üî ‚àÉ c œÑ, œÉ = c * œÑ ‚àß Disjoint c œÑ ‚àß IsCycle c ‚àß c.support.card = n := by
  refine' ‚ü®fun hn => _, fun ‚ü®c, œÑ, h_mul, h_disjoint, hc, hn‚ü© => _‚ü© <;>
  simp only [cycleType_eq, List.mem_bind, List.mem_map, List.mem_join, List.mem_cons,
    eq_comm (a := œÉ)]
  ¬∑ simpa using hn
  induction œÉ using cycle_induction_on with
  | base_one => simp [hn]
  | base_cycles c hc => simpa [hc, h_disjoint] using h_mul
  | induction_disjoint c t hc ht h_disjoint =>
    rw [Perm.disjoint_mul] at h_disjoint
    simpa [ht, h_disjoint.2, hc, h_disjoint.1, hn] using h_mul

===== Proof 1057 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  intro hœÜ
  rcases n with _ | n
  ¬∑ dsimp at hœÜ
    simp only [Nat.zero_eq, zero_add] at hœÜ
    rw [‚Üê hœÜ]
    exact (HigherFacesVanish.zero q).2
  ¬∑ exact HigherFacesVanish.succ q n _ hœÜ
  rintro hœÜ
  rw [hœÜ.comp_P_eq_self]

===== Proof 1058 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  intro hœÜ
  revert hœÜ
  rw [‚Üê
    show œÜ.f 0 = œÜ.f 0 by rfl]
  revert œÜ
  induction' q with q hq
  intro œÜ _
  rfl
  intro œÜ hœÜ
  simp only [P_succ, endomorphisms_sum_def, comp_add, Fin.cases_zero, comp_id,
    Fin.cases_succ, hq] at hœÜ
  rw [HigherFacesVanish, Fin.forall_iff] at hq ‚ä¢
  aesop_cat

===== Proof 1059 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  intro hœÜ
  rcases n with _|n
  all_goals aesop
  all_goals aesop

===== Proof 1060 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  ¬∑ intro hœÜ
    rw [HigherFacesVanish, ‚Üê HomologicalComplex.comp_f] at hœÜ
    exact hœÜ
  ¬∑ intro hœÜ
    rw [HigherFacesVanish, ‚Üê HomologicalComplex.comp_f]
    exact hœÜ

===== Proof 1061 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  intro hœÜ
  revert œÜ
  revert Y
  revert X
  induction' n with n n_ih
  ¬∑ intro Y q hq X œÜ
    rintro rfl
    exact HigherFacesVanish.zero q
  ¬∑ intro Y q hq X œÜ
    dsimp [HigherFacesVanish] at *
    rw [‚Üê n_ih]
    ¬∑ intro hœÜ'
      revert hœÜ'
      rw [HomologicalComplex.d_comp_eq_zero]
      intro hœÜ'
      rw [higher_faces_vanish_iff] at hœÜ'
      rw [higher_faces_vanish_iff]
      exact hœÜ'.1
    ¬∑ exact hq

===== Proof 1062 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  ¬∑ intro hœÜ
    rw [‚Üê cancel_epi ((HigherFacesVanish.add q n).iso.inv.app Y)]
    simp only [assoc, ‚Üê Nat.add_one, comp_P_f_n_add_one, hœÜ, add_right_eq_self]
    exact HigherFacesVanish.zero
  ¬∑ intro hœÜ
    rw [‚Üê cancel_epi ((HigherFacesVanish.add q n).iso.hom.app Y)]
    simp only [assoc, ‚Üê Nat.add_one, comp_P_f_n_add_one]
    exact hœÜ

===== Proof 1063 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  exact fun h => HigherFacesVanish.of_comp h
  intro h
  simp only [CompAndHœÉFace_eq, h.comp_HœÉ_eq, comp_id]

===== Proof 1064 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  intro hœÜ
  rw [HigherFacesVanish]
  intro j hj
  have h := hœÜ.symm
  simp only [HomologicalComplex.comp_f, HomologicalComplex.P_f_idem, P_f_n_eq_zero,
    HigherFacesVanish, HigherFaces_eq_zero, Fin.mk_eq_mk, Fin.pred_mk] at h
  rw [‚Üê h]
  congr
  omega
  intro hœÜ
  rw [HigherFacesVanish] at hœÜ
  simp only [HomologicalComplex.comp_f, HomologicalComplex.P_f_idem, P_f_n_eq_zero,
    HigherFacesVanish, HigherFaces_eq_zero, Fin.mk_eq_mk, Fin.pred_mk]
  rw [‚Üê hœÜ]
  rfl

===== Proof 1065 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  ¬∑ intro hœÜ
    rw [‚Üê hœÜ]
    exact HigherFacesVanish.of_comp P_is_eventually_constant
  ¬∑ exact HigherFacesVanish.comp

===== Proof 1066 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor <;> intro hœÜ <;>
    simp only [P_f_n_eq] at hœÜ
  ¬∑ rintro i hi
    simp [n.succ_ne_zero, hœÜ]
  ¬∑ rcases n with (_|n)
    ¬∑ exact n.zero_eq
    ¬∑ exact n.succ_succ_ne_one

===== Proof 1067 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor <;> intro h <;> simp [HigherFacesVanish, h]
  <;> intro j hj <;> rw [‚Üê h]
  <;> simp [hj]

===== Proof 1068 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  ¬∑ intro hœÜ
    simp only [HigherFacesVanish, HomologicalComplex.comp_f, HomologicalComplex.d_f_eq_zero,
      HomologicalComplex.P_f_d, add_eq_zero_iff_eq_neg] at *
    revert hœÜ
    simp only [Fin.eq_last, Fin.succ_ne_zero, ‚Üê add_eq_zero_iff_eq_neg, add_neg_eq_iff_eq_add]
    intros
    rfl
  ¬∑ exact HigherFacesVanish.comp P q (n + 1) œÜ

===== Proof 1069 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  ¬∑ intro hœÜ
    rw [‚Üê cancel_mono (higherFacesVanish q).choose_spec.some.out]
    aesop_cat
  ¬∑ intro hœÜ
    rcases P_is_eventually_constant X q n with ‚ü®m, hm, i, (hi : n + 1 + m = i + q)‚ü©
    have hm' := hm
    rw [hm'] at hi
    have := HigherFacesVanish.comp_HœÉ_eq q n (n+1) hœÜ hm'
    aesop_cat

===== Proof 1070 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  apply Iff.intro
  ¬∑ intro hœÜ
    rw [‚Üê hœÜ]
    simp only [P_succ, HomologicalComplex.add_f_apply, HomologicalComplex.comp_f,
      HomologicalComplex.sub_f_apply, HomologicalComplex.id_f, comp_id, comp_sub, sub_comp,
      comp_id, sub_self, zero_comp, comp_zero]
    intro j hj
    simp only [Fin.pred_succ, Fin.succ_pred, Fin.pred_castSucc,
      Fin.castSucc_pred, if_true, Nat.lt_succ_iff, le_refl, Nat.pred_succ, if_true,
      Nat.lt_succ_iff, le_refl, Fin.pred_succ, if_true, Nat.lt_succ_iff, le_refl,
      Fin.pred_succ, if_true, Nat.lt_succ_iff, le_refl]
    aesop
  ¬∑ intro hœÜ
    rw [‚Üê hœÜ.comp_P_eq_zero_of_gt (show n < n + 1 by linarith)]
    simp only [P_succ, HomologicalComplex.add_f_apply, HomologicalComplex.comp_f,
      HomologicalComplex.sub_f_apply, HomologicalComplex.id_f, comp_id, comp_sub, sub_comp,
      comp_id, sub_self, zero_comp, comp_zero]

===== Proof 1071 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  dsimp [HigherFacesVanish]
  simp only [fac_P]
  constructor <;> intro h <;> funext <;>
  simp? [h] at * says
    simp only [h, comp_id, ge_iff_le, ite_true, le_add_iff_nonneg_left, add_le_add_iff_left,
      le_add_iff_nonneg_right, add_le_add_iff_right] at *
  <;> aesop

===== Proof 1072 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor <;> intro h <;> simp [HigherFacesVanish, ‚Üê h]
  induction' q with q hq
  simp_all
  simp_all

===== Proof 1073 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  intro hœÜ
  rintro m hm
  rw [‚Üê HigherFacesVanish.comp_HœÉ_eq _ _ _ (by linarith)]
  simp only [hœÜ, HomologicalComplex.comp_f, HomologicalComplex.d_f_d, comp_zero]
  intro v
  rw [‚Üê hom_comp_eq_comp, v.2, comp_zero]

===== Proof 1074 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  rw [higherFacesVanish_iff_relation]
  constructor <;> intro h
  swap
  apply h.1
  aesop_cat

===== Proof 1075 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  case mp =>
    intro hœÜ
    constructor
    intro j hj
    rw [HigherFacesVanish.comp_P_eq_zero]
    exact hœÜ
  case mpr =>
    intro hœÜ
    rw [‚Üê cancel_epi (X.Œ¥ (q - 1)).f]
    simp only [hœÜ, comp_add, comp_id, Fin.sum_univ_succ, comp_sum, P_succ, Fin.val_succ,
      Fin.val_zero, pow_zero, pow_one, zero_add, one_smul, Fin.succ_mk,
      Fin.castSucc_mk, Fin.cast_mk, add_comp, sum_comp]

===== Proof 1076 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  apply Iff.intro <;> intro h
  <;> simp only [HigherFacesVanish, HomologicalComplex.comp_f, HomologicalComplex.d_f_eq_zero,
    HomologicalComplex.P_f_d_assoc, HomologicalComplex.P_f_idem,
    HomologicalComplex.P_f_comp_P_f_assoc, HomologicalComplex.comp_id,
    HomologicalComplex.id_f, add_comm] at h ‚ä¢
  <;> intro i h2
  <;> simp only [h2, comp_zero]
  <;> simp only [h2, add_comm, comp_add] at h ‚ä¢
  <;> linarith

===== Proof 1077 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor <;> intro h
  ¬∑ intro j hj
    dsimp only [HigherFacesVanish, HomologicalComplex.sub_f_apply, HomologicalComplex.add_f_apply]
    simp only [HomologicalComplex.Hom.commute_f_apply, P_f_naturality_assoc]
    specialize h j hj
    dsimp only [P_f_n] at h
    simpa only [HomologicalComplex.Hom.commute_f_apply] using h
  ¬∑ dsimp only [HigherFacesVanish, HomologicalComplex.sub_f_apply, HomologicalComplex.add_f_apply] at h
    simp only [HomologicalComplex.Hom.commute_f_apply, P_f_naturality_assoc]
    specialize h n (by linarith)
    simpa only [HomologicalComplex.Hom.commute_f_apply] using h

===== Proof 1078 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  rcases n with (_ | _ | n) <;>
    rcases q with (_ | _ | q) <;>
    dsimp [HigherFacesVanish] <;>
    simp -[P_is_id, IsId_X_next]
  <;> aesop_cat

===== Proof 1079 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  next =>
    intro hœÜ m hm
    have hœÜ' := hœÜ
    dsimp [HigherFacesVanish] at *
    simp only [hœÜ, hm, comp_add, add_comp, comp_id, zero_comp, comp_zero, Fin.mk_zero,
      Fin.val_zero, zero_add, add_zero] at *
    revert m hm
    revert œÜ
    revert q
    revert n
    revert Y
    intro Y n q œÜ m hm
    induction' q with q hq
    ¬∑ rfl
    ¬∑ simp only [Nat.succ_eq_add_one, Fin.val_mk] at hm
      have h := hq ((n + 1) - 1) (by omega)
      have h := h (by assumption)
      dsimp [P] at h
      simp only [Fin.val_mk, Finset.sum_congr, add_tsub_cancel_right, Finset.sum_Ico_eq_sum_range,
        tsub_zero, add_tsub_cancel_left, Finset.Ico_zero_eq_range, Finset.sum_range_succ,
        Fin.val_succ, add_tsub_cancel_left, Finset.sum_congr, Finset.Ico_zero_eq_range] at h
      simp only [Fin.val_mk, Finset.sum_congr, add_tsub_cancel_right, Finset.sum_Ico_eq_sum_range,
        tsub_zero, add_tsub_cancel_left, Finset.Ico_zero_eq_range, Finset.sum_range_succ,
        Fin.val_succ, add_tsub_cancel_left, add_comm] at h
      rw [Finset.sum_range_succ_comm]
      simp only [Fin.val_mk, Finset.sum_congr, add_tsub_cancel_right, Finset.sum_Ico_eq_sum_range,
        tsub_zero, add_tsub_cancel_left, Finset.Ico_zero_eq_range, Finset.sum_range_succ,
        Fin.val_succ, add_tsub_cancel_left, add_comm] at h
      simp only [h, zero_add]
  ¬∑ rintro h
    dsimp [HigherFacesVanish] at h
    have hœÜ : œÜ = 0 := by
      ext m
      by_cases hm : m ‚â§ n
      ¬∑ have h‚ÇÇ := h m hm
        simpa only [hm, comp_add, comp_id, zero_comp, add_zero] using h‚ÇÇ
      have h‚ÇÇ := h (n + 1) (by linarith)
      dsimp at h‚ÇÇ
      simpa only [not_le] using h‚ÇÇ
    rw [hœÜ]
    simp only [comp_zero, zero_comp]

===== Proof 1080 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  ¬∑ intro hœÜ
    simp only [HigherFacesVanish, HomologicalComplex.comp_f, HomologicalComplex.d_f_n_0]
    intro j hj
    rw [‚Üê hœÜ]
    congr 1
    apply HomologicalComplex.congr_hom
    apply HomologicalComplex.congr_hom
    apply Quiver.Hom.unop_inj
    simp only [Quiver.Hom.unop_op, unop_comp, comp_unop, unop_id]
    congr 1
    dsimp [HigherFacesVanish] at hj
    congr 1
    dsimp
    omega
  ¬∑ rintro hœÜ
    rw [‚Üê hœÜ.1]

===== Proof 1081 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  ¬∑ intro hœÜ
    rw [HigherFacesVanish, ‚Üê hœÜ]
    rintro i hi
    apply P_f_is_id
    linarith
  ¬∑ intro hœÜ
    rw [HigherFacesVanish] at hœÜ
    exact hœÜ (n + 1) (by linarith)

===== Proof 1082 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  exact fun h => ‚ü®fun i hi => by simp [P, h]‚ü©
  rintro ‚ü®h‚ü©
  simp [P, h]

===== Proof 1083 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  all_goals
    rintro h
    revert œÜ
    revert q
    revert X
    revert Y
    induction' n using Nat.case_strong_induction_on with n IH
    ¬∑ aesop
    ¬∑ intro Y q
      induction' q using Nat.strong_induction_on with q _
      aesop

===== Proof 1084 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor <;> intro hœÜ <;> revert n q n
  all_goals
    aesop_cat

===== Proof 1085 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  intro hœÜ
  rw [‚Üê P_add_Q_f n (n + 1) rfl.le, add_comm, HomologicalComplex.add_f_apply,
    HomologicalComplex.comp_f, HomologicalComplex.comp_f, Preadditive.comp_add, hœÜ, add_comm,
    HomologicalComplex.Q_f_HœÉ_eq, HomologicalComplex.Q_f_HœÉ_eq]
  simp only [add_right_eq_self, IsIso.comp_right_eq_zero, IsZero.eq_zero,
    HomologicalComplex.zero_f_apply, HomologicalComplex.P_f_HœÉ_eq,
    Fin.zero_succ_above, Fin.castSucc_zero, Fin.cast_eq_cast_succ, Fin.succ_mk]
  exact HigherFacesVanish.of_comp HœÉ hœÜ
  exact HigherFacesVanish.comp HœÉ

===== Proof 1086 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  intro hœÜ
  unfold HigherFacesVanish
  intro j hj
  rw [HomologicalComplex.comp_f] at hœÜ
  simp only [HomologicalComplex.d_f_eq_zero, add_eq_zero_iff, and_true_iff] at hœÜ
  rw [hœÜ]
  simp only [Fin.is_lt, Fin.eta, Fin.is_lt, Fin.eta, eq_self_iff_true, true_and_iff]
  intro hœÜ j hj
  rw [HomologicalComplex.comp_f]
  simp only [HomologicalComplex.d_f_eq_zero, add_eq_zero_iff, and_true_iff]
  rw [‚Üê hœÜ j hj]

===== Proof 1087 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  apply Iff.intro <;> intro hœÜ <;> clear hœÜ
  ¬∑ simp only [HigherFacesVanish, HomologicalComplex.comp_f, HomologicalComplex.d_f_comp_d_f_assoc,
      HomologicalComplex.Hom.comm]
    intros i j hij
    simp? [308] says
      simp only [HomologicalComplex.Hom.comm]
    have := HœÉ_eq q n (by omega)
    simp [this, HomologicalComplex.Hom.comm]
  ¬∑ simp only [HigherFacesVanish, HomologicalComplex.comp_f, HomologicalComplex.d_f_comp_d_f_assoc,
      HomologicalComplex.Hom.comm] at *
    intros i j hij
    simp? [308] says
      simp only [HomologicalComplex.Hom.comm]
    have := HœÉ_eq q n (by omega)
    simp [this, HomologicalComplex.Hom.comm]

===== Proof 1088 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  refine' ‚ü®fun hœÜ => hœÜ.symm ‚ñ∏ _, fun hœÜ => hœÜ.symm ‚ñ∏ rfl‚ü©

===== Proof 1089 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' HasBasis.to_hasBasis (fun a ha => ?_) fun _ _ => ‚ü®_, bot_lt_coe _, Subset.rfl‚ü©
  exact ‚ü®a, trivial, Iio_mem_nhds ha‚ü©

===== Proof 1090 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ => ‚ü®_, bot_lt_coe _, Subset.rfl‚ü©
  rcases exists_rat_btwn_of_lt hx with ‚ü®y, hxy, -‚ü©
  exact ‚ü®_, trivial, Iio_subset_Iio_of_le hxy.le‚ü©

===== Proof 1091 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine ‚ü®fun a ‚Ü¶ ?_, fun a ha ‚Ü¶ ?_‚ü© <;> use ‚ä• <;> simp [ha]

===== Proof 1092 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  apply nhds_basis_Iio

===== Proof 1093 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' EReal.nhds_bot_basis.to_hasBasis (fun x hx => ‚ü®x, trivial, mem_nhds_bot_iff.2 hx‚ü©)
    fun x _ => ‚ü®x, trivial, (mem_nhds_bot_iff _).2 <| Iio_mem_nhds hx‚ü©

===== Proof 1094 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' EReal.nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ => ‚ü®-1, trivial, fun _ h => h.trans (neg_lt_bot.2 hx)‚ü©
  exact ‚ü®x, trivial, Iio_subset_Iio hx.le‚ü©

===== Proof 1095 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine nhds_basis_Iio (fun x hx ‚Ü¶ ?_)
  simp only [bot_lt_coe, forall_prop_of_true] at hx
  exact ‚ü®x, trivial, hx.le, le_refl x‚ü©

===== Proof 1096 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' nhds_basis_Ioi.to_hasBasis (fun x hx => ‚ü®x, trivial, mem_nhds_iff.2 ‚ü®Ioo ‚ä• x, _, _‚ü©‚ü©)
    fun x _ => ‚ü®x, trivial, Ioi_subset_Iio_self‚ü©
  ¬∑ simp only [mem_Ioi, bot_lt_iff_ne_bot, bot_ne_coe, ne_eq, true_and]
    exact fun _ => (lt_irrefl _).false
  ¬∑ exact Ioo_subset_Iio_self

===== Proof 1097 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine'
    (hasBasis_nhds_of_forall ‚ü®fun h ‚Ü¶ ‚ü®-1, trivial, h‚ü©‚ü©
      (fun x hx ‚Ü¶ Iio_mem_nhds hx))
  refine'
    (hasBasis_nhds_of_forall ‚ü®fun h ‚Ü¶ ‚ü®1, trivial, h‚ü©‚ü©
      (fun x hx ‚Ü¶ Ioi_mem_nhds hx))

===== Proof 1098 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine nhds_top_basis.to_hasBasis (fun x hx => ?_) fun _ _ => ‚ü®-1, by norm_num, by norm_num‚ü©
  exact ‚ü®x, trivial, by simp‚ü©

===== Proof 1099 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ => ‚ü®-1, by norm_num, by simp‚ü©
  exact ‚ü®x, trivial, Iio_subset_Iio hx‚ü©

===== Proof 1100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' (nhds_basis_Iio ‚ä•).to_hasBasis (fun x hx => _) fun x hx => ‚ü®x, trivial, Subset.rfl‚ü©
  simpa only [bot_lt_coe] using hx

===== Proof 1101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine nhds_basis_Iio (fun Œµ hŒµ ‚Ü¶ ?_)
  rw [pos_iff_ne_zero] at hŒµ
  exact ‚ü®Œµ, hŒµ, le_refl Œµ‚ü©

===== Proof 1102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ => ‚ü®_, bot_lt_coe _, Subset.rfl‚ü©
  simpa only [true_and] using hx

===== Proof 1103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' ‚ü®fun s => ‚ü®fun hs => _, fun ‚ü®_, _‚ü© => mem_nhds_bot_iff.2 ‚ü®s, Subset.rfl, hs‚ü©‚ü©‚ü©
  obtain ‚ü®a, rfl‚ü© := mem_nhds_bot_iff.1 hs
  refine' ‚ü®a, trivial, _‚ü©
  rw [Iio_bot]
  exact empty_subset s

===== Proof 1104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' nhds_bot_basis.to_hasBasis (fun x hx => ‚ü®x, trivial, subset_refl _‚ü©) fun x _ => ‚ü®x, trivial, Subset.rfl‚ü©

===== Proof 1105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' HasBasis.to_hasBasis (nhds_bot.basis_sets) _ _
  <;> rintro e ‚ü®‚ü©
  <;> exact ‚ü®_, ‚ü®‚ü©, Iio_subset_Iio.2 (bot_le.trans bot_lt_coe.le)‚ü©

===== Proof 1106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' (hasBasis_nhds_of_forall_exists_Iio ‚ä• fun x hx ‚Ü¶ ‚ü®x, trivial, Set.eq_of_mem_singleton hx‚ü©).to_hasBasis
    (fun x hx ‚Ü¶ ‚ü®x, trivial, Set.eq_of_mem_singleton hx‚ü©) fun x hx ‚Ü¶ ‚ü®x, trivial, Set.eq_of_mem_singleton hx‚ü©

===== Proof 1107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  rw [nhds_eq_iInf_abs_sub]
  refine'
    HasBasis.binfi_principal _ (fun _ => trivial) fun x‚ÇÄ =>
      ‚ü®x‚ÇÄ, by simp only [abs_zero, eq_self_iff_true, gt_iff_lt, mem_Iio]‚ü©

===== Proof 1108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' nhds_bot_basis.to_hasBasis (fun x hx => ‚ü®x, trivial, subset_refl _‚ü©) fun x _ => _
  rcases eq_bot_or_bot_lt x with (rfl | hbot)
  exacts [‚ü®0, trivial, empty_subset _‚ü©, ‚ü®x, trivial, Iio_subset_Iio hbot.le‚ü©]

===== Proof 1109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' nhds_bot_basis.to_hasBasis (fun x hx => _) fun x hx => ‚ü®x, trivial, Subset.rfl‚ü©
  rcases lt_iff_exists_coe.1 hx with ‚ü®x, rfl‚ü©
  refine' ‚ü®x, trivial, fun y hy => _‚ü©
  rw [‚Üê Iio_inter_Iio]
  exact Set.inter_subset_left

===== Proof 1110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' EReal.nhds_bot_basis.to_hasBasis
    (fun x hx => ‚ü®x, trivial, Iio_subset_Iio hx‚ü©) fun a _ => ‚ü®a, le_refl a, Subset.rfl‚ü©

===== Proof 1111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine nhds_basis_Iio (fun x y h => ?_)
  exact ‚ü®x, trivial, h‚ü©

===== Proof 1112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' nhds_bot_basis' ‚ü®0, trivial, _‚ü©
  exact fun x hx => ‚ü®x + 1, trivial, Iio_subset_Iio (by linarith)‚ü©

===== Proof 1113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' nhds_basis_Iio_pos ‚ä• fun x hx => _
  simp only [bot_lt_iff_ne_bot, bot_eq_zero, zero_lt_iff, ne_eq, Forall.forall,
    and_true_iff, not_false_eq_true] at hx
  simpa only [hx, true_and_iff] using Iio_mem_nhds hx.lt

===== Proof 1114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine (nhds_basis_Iio ‚ä•).to_hasBasis (fun x hx => ?_) fun _ _ => ‚ü®-1, by norm_num, ?_‚ü©
  simpa only [true_and] using hx
  simpa only [mem_Iio, bot_lt_iff_ne_bot, bot_le, true_and] using lt_irrefl _

===== Proof 1115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine nhds_basis_Iio' ‚ü®0, fun x hx => ?_‚ü©
  exact ‚ü®x, trivial, by simpa only [neg_lt_neg_iff] using hx‚ü©

===== Proof 1116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine'
    (hasBasis_nhds_of_forall _ _).2 fun p q hp => _
  cases' q with q q
  ¬∑ exact ‚ü®0, trivial, fun r _ => ‚ü®r, rfl.subset‚ü©‚ü©
  ¬∑ exact ‚ü®q, trivial, fun r _ => ‚ü®r, rfl.subset‚ü©‚ü©

===== Proof 1117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' nhds_basis_Iio fun x hx => _
  simpa only [bot_lt_coe, true_and] using hx

===== Proof 1118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine' nhds_bot_basis.to_hasBasis (fun x hx => ‚ü®x, trivial, Set.Iio x, fun _ => ‚ü®‚ü®‚ü©, fun h => hx _ h‚ü©‚ü©)
    fun x _ => ‚ü®x, trivial, Set.Iio x, ‚ü®rfl.le, fun _ => le_refl _‚ü©‚ü©

===== Proof 1119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine'
    (hasBasis_nhds_of_forall_mem fun x hx ‚Ü¶ _).to_hasBasis' (fun x hx ‚Ü¶ ‚ü®x, trivial, mem_nhds_iff.2 ‚ü®Iio x, Iio_subset_Iio hx.out.le, isOpen_Iio, hx‚ü©‚ü©)
      fun x _ ‚Ü¶ ‚ü®x, trivial, Subset.rfl‚ü©
  rcases x with ‚ü®a, b‚ü©
  cases' a with a
  ¬∑ cases' b with b
    ¬∑ simp_all [bot_eq_bot_iff]
    ¬∑ simp_all
  ¬∑ cases' b with b
    ¬∑ simp_all
    ¬∑ exact ‚ü®a, b, ‚ü®by simp_all, by simp_all‚ü©, by simp_all‚ü©

===== Proof 1120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by
  refine nhds_basis_Ioo_pos ‚ä• ‚ä• (by norm_num) (fun x hx ‚Ü¶ ?_)
  simp [hx.out.le]

===== Proof 1121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  aesop (add norm [mul_zero_class, mul_one, mul_assoc, mul_right_comm, mul_left_comm])

===== Proof 1122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  exact strictMono_nat_of_lt_succ
  intro k
  induction' k with k hk
  <;> simp_all [Nat.succ_eq_add_one, Nat.lt_succ_iff, Nat.add_le_add_iff_right]
  <;> linarith

===== Proof 1123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  refine' ‚ü®fun h => by rw [h], fun h => by rw [h]‚ü©

===== Proof 1124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply cancel_left
  apply StrictMono.injective
  apply StrictMono.comp
  assumption'

===== Proof 1125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply Nat.le_of_add_le_add_left
  rw [add_assoc]
  linarith

===== Proof 1126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply Ordadd.toLinearOrder

===== Proof 1127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply Eq.symm
  apply Eq.symm
  simp_rw [eq_comm]
  apply cancel_left
  assumption

===== Proof 1128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply cancel_left
  apply Function.Injective

===== Proof 1129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply Eq.symm
  apply mul_left_cancel‚ÇÄ (sub_ne_zero.mpr hi)
  rw [‚Üê sub_eq_zero] at *
  ring_nf
  simpa using h

===== Proof 1130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  rw [cancel_left] <;> simp [hg]

===== Proof 1131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  apply_fun g at h
  rw [‚Üê comp_apply, ‚Üê comp_apply, h]
  rw [h]

===== Proof 1132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  simp_all [apply_eq_iff_eq, Function.Injective]

===== Proof 1133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply cancel_left
  apply hg

===== Proof 1134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by aesop

===== Proof 1135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  simp_rw [comp_apply]
  exact Injective.eq_iff hg

===== Proof 1136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply Eq.symm
  simp_all only [DFunLike.ext'_iff, MonoidWithZeroHom.comp_apply, eq_self_iff_true, and_self_iff]

===== Proof 1137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply Eq.trans _ (Eq.symm (div_lt_iff (show 0 < (b : Œ±) by exact_mod_cast nb) (show (0 : Œ±) < c by exact_mod_cast nc)).symm)
  congr!

===== Proof 1138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply linarith

===== Proof 1139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply Eq.symm
  apply Eq.symm
  apply mul_inv_cancel
  apply ne_zero

===== Proof 1140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  constructor
  intro hgf
  apply Subtype.ext
  exact ((fun x y z => hg.eq_iff_eq.mp) _ _ _ (hgf _)).symm
  exact fun h => h ‚ñ∏ rfl

===== Proof 1141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  simp_all only [map_zero, map_one, map_mul, map_add]
  norm_num
  aesop


===== Proof 1142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  ext
  simp [Function.comp]
  aesop

===== Proof 1143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  ext
  simp [mul_assoc]

===== Proof 1144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply OrderHomClass.ext

===== Proof 1145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply cancel_left
  apply Function.Injective

===== Proof 1146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply (CancelLeft.canLift (Œ± := Œ±) (Œ≤ := Œ≤) (Œ≥ := Œ≥) g hg).1

===== Proof 1147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  apply Eq.symm
  simp [hg, (¬∑ ‚àò ¬∑)]

===== Proof 1148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  exact cancel_left

===== Proof 1149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  rcases exists_or_eq_left' e‚ÇÅ with h | h <;> rcases exists_or_eq_left' e‚ÇÇ with i | i <;>
    rcases exists_or_eq_left' e‚ÇÉ with j | j <;>
    rcases exists_or_eq_left' e‚ÇÑ with k | k <;>
    rcases exists_or_eq_left' e‚ÇÖ with l | l <;>
    first
    |exact Or.inl (by aesop)|
    |exact Or.inr (by aesop)|
    |aesop

===== Proof 1150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  cases' m with a a_ih; cases' n with b b_ih
  simp_all

===== Proof 1151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  intros
  simp_all

===== Proof 1152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : Œ≤ ‚Üí*‚ÇÄo Œ≥} {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí*‚ÇÄo Œ≤} (hg : Function.Injective g) :
    g.comp f‚ÇÅ = g.comp f‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ :=
  ‚ü®fun h => ext fun a => hg <| by rw [‚Üê comp_apply, h, comp_apply], congr_arg _‚ü©
:= by
  aesop

===== Proof 1153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, eval_map, coe_castRingHom, eval‚ÇÇ_eq_eval_map]
  nth_rw 1 [‚Üê pow_one Œº]
  rw [‚Üê pow_mul, mul_comm]
  exact eval_pow_eq_zero_of_eval_minpoly_eq_zero hŒº hcop

===== Proof 1154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, eval_map, ‚Üê aeval_def]
  simp [hcop]

===== Proof 1155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, minpoly, map_aeval]
  rw [aeval_def, ‚Üê comp_eval‚ÇÇ_intCastRingHom]
  rw [eq_intCast, Int.cast_one]
  simp [hcop]

===== Proof 1156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, aeval_def]
  rw [eq_intCast]
  simp [minpoly_eq_pow_coprime hŒº hcop, -intCast_natCast_eq_ofNat]

===== Proof 1157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot]
  simp only [map_zero, Polynomial.eval_map]
  rw [‚Üê Polynomial.aeval_def]
  simp_rw [rootOfUnity_minpoly_coeff]
  rw [rootOfUnity_coe_pow ‚Ñ§ hŒº]
  simp [hcop, pow_aeval_eq_pow_mod n hm]

===== Proof 1158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, eval_map, Polynomial.aeval_def]
  rw [‚Üê pow_mul, Nat.mul_comm, pow_mul, hcop.gcd_eq_one]
  simp [hcop]

===== Proof 1159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  delta IsRoot
  rw [minpoly_eq_gcd_X_sub_C, map_gcd, map_sub, Polynomial.eval_map,
    show (X : ‚Ñ§[X]).map (Int.castRingHom K) = (X : K[X]) by
      simp only [Polynomial.map_X, Polynomial.map_intCastRingHom, eq_self_iff_true,
        Int.cast_one, one_mul, eq_intCast]; rfl, Polynomial.eval_X, Polynomial.eval_map,
    Polynomial.eval_one_sub, eval‚ÇÇ_C, eval‚ÇÇ_X]
  rw [‚Üê Polynomial.eval_map, map_pow, map_mul]
  simpa [Polynomial.eval_map, Polynomial.eval_sub, Polynomial.eval_X_pow,
    Polynomial.eval_one_pow] using eval_pow_eq_zero hŒºcop hm

===== Proof 1160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, eval_map]
  rw [eq_intCast, minpoly_eq_pow_coprime hcop]
  simp [Kilmer]

===== Proof 1161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, eval_map, coeff_map]
  rw [‚Üê Int.cast_one, ‚Üê Int.cast_sub, map_sub, map_intCast,
    minpoly.eval‚ÇÇ, Polynomial.aeval_def]
  simp [pow_mul, IsRoot.def, hcop]

===== Proof 1162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, eval_map, eval‚ÇÇ_eq_eval_map, ‚Üê minpoly.aeval_def]
  apply aeval_eq_zero_of_dvd_aeval_eq_zero
  ¬∑ exact hcop
  ¬∑ simp [aeval_eq_zero_iff]

===== Proof 1163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot]
  rw [minpoly_eq_gcd, ‚Üê map_dvd_map (Int.castRingHom ‚Ñö) Int.cast_injective]
  rw [Polynomial.map_gcd (Int.castRingHom ‚Ñö)]
  refine' (IsRoot.of_map_dvd (minpoly.monic ‚Ñ§ h) _).2 _
  swap
  ¬∑ exact
      minpoly.dvd_map_of_isIntegral (isIntegral h)
        ((add_sub_cancel'_right (Œº ^ n) 1).trans <| by rw [one_add_one_eq_two] <|
          (pow_add _ _ _).trans <| by rw [‚Üê two_mul]; exact (pow_mul _ 2 m).symm)
  rw [gcd_comm, add_comm, ‚Üê Int.cast_one, ‚Üê Int.cast_mul, ‚Üê pow_succ]
  by_cases h0 : m = 0
  ¬∑ simp_rw [h0, zero_add, one_pow]
  ¬∑ rw [‚Üê tsub_add_cancel_of_le (Nat.succ_le_of_lt h0), ‚Üê pow_succ', mul_comm]

===== Proof 1164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  delta IsRoot
  rw [minpoly_eq_gcd, ‚Üê gcd_spec ‚Ñ§‚Å∞ Œº, RingHom.map_gcd,
    coe_castRingHom, ‚Üê comp_eq_eval‚ÇÇ_gcd,
    ‚Üê comp_eval‚ÇÇHom, ‚Üê map_comp]
  refine RingHom.map_injective _ (Int.cast_injective K) ?_
  simp only [Function.comp_apply, eval‚ÇÇ_mul, eval‚ÇÇ_pow, eval‚ÇÇ_X, eval‚ÇÇ_sub, eval‚ÇÇ_add,
    eval‚ÇÇ_mul, eval‚ÇÇ_pow, eval‚ÇÇ_X, eval‚ÇÇ_sub, eval‚ÇÇ_add, sub_self, mul_zero, zero_mul,
    add_zero, zero_add, mul_one, sub_zero, one_mul]
  by_cases h : m = 0
  ¬∑ simp only [h, map_pow, map_one, pow_zero, pow_one, sub_self, mul_zero, zero_mul,
      zero_add, add_zero]
  ¬∑ have h1 : m ‚â† 0 := by rintro rfl; simp at h
    rw [dvd_iff_isRoot, IsRoot] at dvd_iff_isRoot
    simp [h1, pow_succ, one_pow, zero_mul, sub_self, mul_zero, zero_mul, add_zero, zero_add,
      mul_one, sub_zero, one_mul, pow_succ, one_pow, zero_mul, sub_self, mul_zero, zero_mul,
      add_zero, zero_add, mul_one, sub_zero, one_mul]

===== Proof 1165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
   subst hpow
   have hzero : minpoly ‚Ñ§ Œº ‚â† 0 := minpoly.ne_zero (f := (Integer.ModuleCat.of R K) Œº)
   rw [isRoot_map_iff (minpoly.monic (IsPrimitiveRoot.isIntegral h hzero))]
   simp_rw [‚Üê smul_eq_mul, ‚Üê minpoly.aeval_def, map_aeval_eq_aeval_map, minpoly.monic.map_eq_map,
     isRoot_of_unity_iff h m]
   simp [hcop.gcd_eq_one, minpoly.ne_zero (f := (Integer.ModuleCat.of R K) Œº)]

===== Proof 1166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, eval_map, coe_castRingHom, minpoly.ker] at hcop ‚ä¢
  simp_rw [‚Üê smul_one_smul R (m : ‚Ñ§) 1]
  rw [‚Üê smul_one_smul R (n : ‚Ñ§) 1]
  exact zsmul_mem_zmultiples n (zsmul_mem_zmultiples m one_mem_zmultiples_one)

===== Proof 1167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, eval_map, IsRoot.def, eval‚ÇÇ_eq_eval_map]
  by_cases hm : m = 0 <;> simp_all [IsRoot]

===== Proof 1168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  ¬∑ rw [IsRoot, eval_map, ‚Üê aeval_def]
    exact aeval_pow Œº hcop
  ¬∑ exact minpoly.monic.ne_zero (IsIntegral.isIntegral Œº)

===== Proof 1169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, eval_map]
  rw [‚Üê aeval_def (p := (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº))) (x := Œº ^ m)]
  rw [minpoly_eq_pow_coprime hcop]
  simp [aeval_X_pow, aeval_def, hm]

===== Proof 1170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot]
  simp only [eval_map, minpoly_eq_pow_coprime hŒº hcop, eval‚ÇÇ_one, zero_add]
  apply IsRoot.pow
  simp [hŒº.isRoot_minpoly_sub_one]

===== Proof 1171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, minpoly, map_X, Polynomial.aeval_def]
  rw [‚Üê comp_eval‚ÇÇ_left (hom := Int.castRingHom K) (f := X - C (Œº ^ m))]
  eval‚ÇÇ_simp
  simp [hcop, mul_comm]

===== Proof 1172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, eval_map, eval‚ÇÇ_eq_eval_map, ‚Üê minpoly.algebraMap_eq (Int.castRingHom K)]
  have h : (minpoly ‚Ñ§ Œº).Monic := minpoly.monic (IsPrimitive.of_coprime hcop)
  rw [eval_apply, Polynomial.aeval_def, Polynomial.eval_monic_pow h, ‚Üê eval_pow]
  simp [hcop]

===== Proof 1173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, eval_map, ‚Üê sub_eq_zero]
  simp only [minpoly, eval‚ÇÇ_eq_eval_map]
  rw [eval_intCastRingHom, ‚Üê Int.cast_zero (R := K)]
  congr
  simp only [eval_sub, eval_pow, eval_X, eval_one]
  simp only [‚Üê pow_mul, mul_comm m, Nat.mul_div_cancel _ hcop.symm.dvd]

===== Proof 1174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  have key : minpoly ‚Ñ§ Œº = Polynomial.X ^ n - 1 := by
    rw [eq_X_pow_sub_one_of_irreducible_of_root
      (minpoly.irreducible (IsPrimitive.is_primitive (R := ‚Ñ§)
        (h := IsPrimitiveRoot.is_primitive_root Œº hŒº)))
      ((dvd_iff_isRoot hŒº).mpr hŒº)]
  simp only [key]
  simp only [map_sub, map_pow, map_one, IsRoot]
  rw [‚Üê sub_eq_zero]
  simp only [sub_eq_zero, pow_mul, eq_self_iff_true, pow_mul, true_or_iff]

===== Proof 1175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot]
  simp [minpoly_eq_pow_coprime h (Nat.Coprime.symm hcop)]

===== Proof 1176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, eval_map] at *
  rw [‚Üê pow_mul, mul_comm]
  rw [minpoly_eq_pow_coprime hcop]
  simp [h.pow_eq_one]

===== Proof 1177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, aeval_def, Polynomial.eval_map]
  exact minpoly_isRoot hcop

===== Proof 1178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, eval_map, ‚Üê aeval_def, Polynomial.aeval_def, Polynomial.eval‚ÇÇ_eq_eval_map]
  rw [minpoly_field_as_range (Int.castRingHom K) Œº]
  refine' Finset.min_le_of_eq _ (Polynomial.degree_normUnit _ _)
  ¬∑ simp only [eval_normUnit, map_apply]
    rw [minpoly_field_as_range (Int.castRingHom K) Œº]
    exact Finset.mem_image_of_mem _ ‚ü®n, ‚ü®hcop, rfl‚ü©‚ü©

===== Proof 1179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  have h : m < n := Nat.Coprime.lt_of_le_left hcop (min_le_of_left_le (min_le_right m n))
  rw [IsRoot, eval_map, ‚Üê aeval_def, minpoly_eq_pow_coprime hcop, aeval_pow,
    aeval_eq_zero_of_dvd_of_aeval_eq_zero (minpoly.dvd_lcm_left ‚Ñ§ { x // x ‚àà rootsOfUnity n K })
    (aeval_self_rootOfUnity (minpoly.irreducible (IsPrimitiveRoot.of_pos (pos_of_gt h))) h)]

===== Proof 1180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, eval_map, ‚Üê aeval_def]
  have h : aeval Œº (minpoly ‚Ñ§ Œº) = 0 := minpoly.aeval ‚Ñ§ Œº
  rw [aeval_eq_sum_range, sum_range_succ] at h
  simp_all only [add_left_eq_self]
  apply mul_left_cancel‚ÇÄ (sub_ne_zero_of_ne (hcop.pow_left.ne_one_of_pos_of_lt hm1 hm.le).symm)
  simpa [pow_add, pow_one] using h

===== Proof 1181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  by_cases h : m = 0
  case pos => simp_all
  simp only [IsRoot, eval_map, coe_eq_zero, Polynomial.eval_pow]
  nth_rewrite 2 [‚Üê pow_one Œº]
  rw [‚Üê pow_mul, mul_comm, Nat.mul_div_cancel _ (Nat.pos_of_ne_zero h), pow_mul, pow_one,
    ‚Üê sub_self_eq_zero]
  exact (monic_minpoly_add_order_of_units Œº).nat_pow_ne_zero (sub_ne_zero_of_ne (hcop.pow_left _).ne')
    (sub_self Œº)

===== Proof 1182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot.def, minpoly_eq, ‚Üê map_pow]
  simpa [hcop] using eval_minpoly_eq_zero K h hcop

===== Proof 1183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  rw [IsRoot, eval_map, ‚Üê aeval_def]
  exact minpoly.aeval ‚Ñ§ (Œº ^ m)

===== Proof 1184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ‚Ñï} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ‚Ñ§ Œº)) (Œº ^ m) := by
  simp only [IsRoot, eval_map, eval‚ÇÇ_eq_eval_map, coe_aeval_eq_eval]
  rw [‚Üê Int.cast_ofNat] at hcop
  exact (minpoly.isRoot_of_eval‚ÇÇ_eq_zero (Int.castRingHom K)
    (minpoly.monic (IsPrimitiveRoot.isIntegral Œº hm)) hcop).symm

===== Proof 1185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have h' : 0 ‚â§ b - a := by
    simpa only [sub_nonneg] using h
  have : ‚àÄ Œµ > 0, ‚àÉ i, ‚àÄ j ‚â• i, |b j - a j| < Œµ := by
    intro Œµ Œµpos
    obtain ‚ü®i, hi‚ü© := h' Œµ Œµpos
    use i
    intro j hj
    simpa only [sub_pos, sub_lt_iff_lt_add'] using hi j hj
  intro Œµ Œµpos
  obtain ‚ü®i, hi‚ü© := this _ Œµpos
  use i
  intro j hj
  have : |a j - b j| < Œµ := by
    simpa only [abs_sub_comm] using hi j hj
  simpa only [inf_eq_min, ‚Üê dist_eq_def, abv_sub_le_iff, dist_comm a] using this

===== Proof 1186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have h‚ÇÅ := h.elim (fun h => inf_converges_of_convergent_left (CauSeq.const_lt_of_pos h))
    fun h => inf_converges_of_convergent_right (CauSeq.const_lt_of_neg h)
  have h‚ÇÇ := (inf_equiv_infi a b).symm
  simpa using h‚ÇÇ.trans h‚ÇÅ

===== Proof 1187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have : ‚àÄ i, (a ‚äì b) i ‚â§ a i := fun i => (CauSeq.inf_le_left a b i).trans (by rwa [le_iff_exists_add] at h)
  refine' CauSeq.ext this fun Œµ Œµ0 => _
  obtain ‚ü®i, hi‚ü© := exists_forall_ge_and h (CauSeq.cauchy‚ÇÇ _ Œµ0)
  obtain ‚ü®j, hj‚ü© := CauSeq.cauchy‚ÇÇ _ Œµ0
  refine' ‚ü®max i j, fun k hk => _‚ü©
  rw [CauSeq.inf_apply, abs_of_nonneg (this _), sub_self]
  apply lt_of_le_of_lt _ (hi _ (le_of_max_le_right hk))
  rw [abs_of_nonneg (this _), sub_self, abs_of_nonneg (this _), sub_self]
  apply hj
  exact lt_of_le_of_lt (le_max_left _ _) hk
  exact lt_of_le_of_lt (le_max_right _ _) hk

===== Proof 1188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have : Nonempty Œπ := ‚ü®0‚ü©
  refine' Setoid.trans (inf_equiv_inf (CauSeq.const_le.2 h) (le_refl _)) _
  simp [inf_const]

===== Proof 1189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have : ‚àÄ k : ‚Ñï, inf a b k = a k := by
    intro k
    simp [CauSeq.inf, h, le_of_lt (CauSeq.lt_of_le_of_lt h : _ < _)]
  exact this

===== Proof 1190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have : 0 ‚â§ b - a := CauSeq.le_iff_le.mp h
  apply CauSeq.inf_equiv_inf.mpr
  constructor
  exact CauSeq.le_of_le_of_eq this (by rfl)
  exact CauSeq.le_of_le_of_eq this (by rfl)

===== Proof 1191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have h' := CauSeq.lt_of_lt_of_le h (CauSeq.le_refl a)
  cases' h' with G hG
  refine' Setoid.trans (CauSeq.inf_equiv_inf a b) _
  simp only [CauSeq.inf_def, CauSeq.mk_eq, hG]
  exact fun i => CauSeq.le_of_lt (hG i)

===== Proof 1192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have h‚ÇÅ : 0 < 1 / 2 := by norm_num
  have h‚ÇÇ : ‚àÉ i, ‚àÄ j ‚â• i, b j - a j < 1 / 2 := by
    cases' h with i hi
    use i
    intro j hj
    specialize hi j
    linarith
  refine' Setoid.symm (CauSeq.lt_inf_equiv_Inf _ h‚ÇÅ h‚ÇÇ)

===== Proof 1193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  simp only [CauSeq.inf_def, CauSeq.sup_def, CauSeq.abs_def, dist_eq_norm]
  have := isLUB_Ici.2 h
  have := this.1
  exact this

===== Proof 1194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [inf_eq_left.mpr h]

===== Proof 1195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [CauSeq.inf_def]
  simpa using CauSeq.sup_eq_right h

===== Proof 1196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have h‚ÇÅ : ‚àÄ Œµ > 0, ‚àÉ i, ‚àÄ j ‚â• i, a j - a i < Œµ := by
    intro Œµ Œµ_pos
    have := h Œµ Œµ_pos
    obtain ‚ü®i, h‚ü© := this
    use i
    intro j hj
    specialize h j hj
    simpa using h
  exact equiv_of_const_diff (CauSeq.const_sub _) h‚ÇÅ

===== Proof 1197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have := h.antisymm' (CauSeq.le_of_lt (CauSeq.lt_of_lt_of_eq (CauSeq.inf_lt_left a b) (CauSeq.inf_eq_right b a)))
  kasthasilakisinlineation sorry

===== Proof 1198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [CauSeq.le_def] at h
  cases' h with h h
  have : 0 < 0 := h 0
  have : 0 < 0 := h 0
  exact absurd this (lt_irrefl _)

===== Proof 1199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  simp only [CauSeq.inf_def, CauSeq.sup_def, CauSeq.le_def] at h ‚ä¢
  refine' (CauSeq.inf_le_left _ _).trans _
  exact CauSeq.le_of_lt (CauSeq.lt_of_le_of_lt h (CauSeq.inf_lt_right _ _))

===== Proof 1200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  exact CauSeq.inf_eq_left h

===== Proof 1201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  cases' le_total a b with h‚ÇÇ h‚ÇÇ <;> simp_all
  apply CauSeq.inf_equiv_inf.symm
  exact ‚ü®le_refl a, h‚ÇÇ‚ü©

===== Proof 1202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have h1 := CauSeq.le_of_eq h
  cases' h1 with Œµ hŒµ
  cases' hŒµ with hŒµ hŒµ'
  cases' hŒµ' with hŒµ'' hŒµ'''
  simp_all

===== Proof 1203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rcases le_total a b with h' | h'
  ¬∑ exact inf_eq_left.mpr h'
  ¬∑ have : a ‚äì b ‚â§ a := inf_le_left
    convert inf_eq_right.mpr h'
    exact le_antisymm this h

===== Proof 1204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [le_antisymm (CauSeq.inf_le_left a b) h.lt.le, CauSeq.inf_idem]
  <;> rfl

===== Proof 1205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  simp only [CauSeq.inf_def, CauSeq.max_def, CauSeq.min_def, max_eq_left_iff,
    min_eq_left_iff, CauSeq.approx_def]
  rcases h with ‚ü®i, h‚ü©
  use i
  intro j hj
  have := h j hj
  simpa [this] using hj

===== Proof 1206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [‚Üê CauSeq.const_le] at h
  have := CauSeq.const_inf a (‚ü®b, h‚ü© : { x // a ‚â§ x })
  simp_all

===== Proof 1207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  simp only [inf_def, CauSeq.const_val, CauSeq.of_val]
  have := h.lt_or_eq
  cases' this with lt ge
  ¬∑ simp [lt, CauSeq.const_lt, CauSeq.lt_def, CauSeq.pos_def, CauSeq.nonneg_def] at this
    have := this.choose_spec.2
    simp [CauSeq.const_val, CauSeq.of_val, this]
  ¬∑ simp [ge]

===== Proof 1208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [CauSeq.inf_def]
  have := CauSeq.le_of_le_of_eq h (Setoid.refl b)
  have := CauSeq.eq_of_eq_of_eq (Setoid.refl a) this
  dsimp at this
  simp [this]

===== Proof 1209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  cases' h with h h
  rw [CauSeq.inf_def]
  exact CauSeq.sup_eq_left h

===== Proof 1210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  cases' le_total a b with h‚ÇÅ h‚ÇÅ <;> simp_all [CauSeq.inf, CauSeq.sup]
  exact (CauSeq.cauchy‚ÇÇ _ h‚ÇÅ).trans (CauSeq.cauchy‚ÇÇ _ h)

===== Proof 1211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [CauSeq.lt_def, CauSeq.inf_def]
  exact CauSeq.equiv_of_const (fun i => max_eq_left (le_of_lt (h i)))

===== Proof 1212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [inf_eq_of_left_le h]
  exact CauSeq.le_refl a

===== Proof 1213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  have : a ‚â§ a ‚äì b := CauSeq.le_inf_left h
  have : a ‚äì b ‚â§ a := CauSeq.inf_le_left a b
  exact CauSeq.eq_of_le this

===== Proof 1214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  obtain ‚ü®Œµ, Œµ0 : 0 < Œµ, i, h‚ü© := exists_pos_forall_lt_add a b h
  refine' ‚ü®Œµ, Œµ0, i, fun j hj => _‚ü©
  calc
    _ ‚â§ |a.1 j - b.1 j| := inf_le_iff.1 (by constructor <;> apply CauSeq.le_of_lt <;> assumption) _
    _ < Œµ := h _ hj
    _ ‚â§ |a.1 j - a.1 j| := le_abs_self _

===== Proof 1215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [inf_eq_right.mpr h]
  exact le_rfl

===== Proof 1216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq Œ± abs} (h : a ‚â§ b) : a ‚äì b ‚âà a := by
  rw [CauSeq.le_def] at h
  have := h; rw [CauSeq.inf_def]
  exact CauSeq.sup_equiv_left this

===== Proof 1217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct.isoApp]

===== Proof 1218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  ¬∑ exact Eq.symm (coproductIsoCoproduct_inv X a)

===== Proof 1219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct, finiteColimit, colimit]
  rfl

===== Proof 1220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, FiniteCoproduct.iso_hom]

===== Proof 1221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, colimit.isoColimitCocone_inv]

===== Proof 1222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct]

===== Proof 1223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, Sigma.Œπ, finiteCoproduct.Œπ]

===== Proof 1224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct.Œπ]

===== Proof 1225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  apply Eq.symm
  simp

===== Proof 1226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, Iso.symm_mk]
  aesop_cat

===== Proof 1227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
   simp [coproductIsoCoproduct, finiteCoproduct]

===== Proof 1228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct, finiteColimitCocone, Finite.splitEpi]

===== Proof 1229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, Sigma.Œπ, finiteCoproduct.Œπ]

===== Proof 1230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp only [coproductIsoCoproduct, Iso.symm_inv, NatIso.app_inv,
    Limits.coproduct.isoOfNatIso_inv_app,
    finiteCoproduct.isoOfNatIso_inv_comp_Œπ,
    colimit.isoColimitCocone_Œπ_inv_apply,
    Discrete.natIso_inv_app,
    colimit.cocone_x,
    discreteCoproductIso_inv_app]

===== Proof 1231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp

===== Proof 1232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, IS_coproduct]

===== Proof 1233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct.Œπ]

===== Proof 1234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct.Œπ]

===== Proof 1235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct.Œπ]

===== Proof 1236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct.Œπ]

===== Proof 1237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, IsColimit.coconePointUniqueUpToIso]

===== Proof 1238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp

===== Proof 1239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct.Œπ]

===== Proof 1240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp only [coproductIsoCoproduct, Iso.trans_inv, Iso.trans_hom, fromIso_inv, fromIso_hom,
    toFiniteCoproduct_inv, toFiniteCoproduct_hom]
  rfl

===== Proof 1241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, Iso.to_hom]

===== Proof 1242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct]
  aesop_cat

===== Proof 1243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, coproductIso_of_bijective,
    FiniteCoproduct.isoOfEquiv_inv_comp_Œπ]
  aesop

===== Proof 1244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, finiteCoproduct, FiniteCoproduct.iso]

===== Proof 1245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct]

===== Proof 1246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [Sigma.Œπ_comp_toFiniteCoproduct]

===== Proof 1247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
   simp [coproductIsoCoproduct, finiteCoproduct.Œπ]

===== Proof 1248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.Œπ_comp_toFiniteCoproduct (a : Œ±) :
    (Limits.Sigma.Œπ X a) ‚â´ (coproductIsoCoproduct X).inv = finiteCoproduct.Œπ X a := by
  simp [coproductIsoCoproduct, Sigma.Œπ, finiteCoproduct.Œπ]

===== Proof 1249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  refine' ‚ü®fun h => ‚ü®h.filter_mono Set.union_subset_left, h.filter_mono Set.union_subset_right‚ü©,
    fun h => h.1.union_nhdsSet.union h.2.union_nhdsSet‚ü©

===== Proof 1250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [ùìùÀ¢, ùìùÀ¢, ùìùÀ¢, Filter.eventually_union, Filter.eventually_sup]

===== Proof 1255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, ?_‚ü©, fun h ‚Ü¶ ?_‚ü©
  ¬∑ filter_upwards [h] with x hx using hx
  ¬∑ filter_upwards [h] with x hx using hx
  ¬∑ filter_upwards [h.1, h.2] with x hx hx' using Or.inl hx

===== Proof 1257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_inf_iff]

===== Proof 1258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  simp only [nhdsSet_union, eventually_sup, sub_eq_add_neg]

===== Proof 1259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [‚Üê Set.union_eq_union_iff_left, Filter.eventually_union, and_congr]
  exact Iff.rfl
  exact eventually_congr (eventually_of_forall fun _ => Iff.rfl)

===== Proof 1260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [‚Üê Set.union_eq_left.mpr (Set.subset_union_left s t),
    ‚Üê Set.union_eq_left.mpr (Set.subset_union_right s t)]
  exact eventually_nhdsSet_union

===== Proof 1264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  constructor <;> intro h
  case mp =>
    constructor
    ¬∑ filter_upwards [h] with x hx using hx.union_left s
    ¬∑ filter_upwards [h] with x hx using hx.union_right t
  case mpr =>
    filter_upwards [h.1, h.2] with x hx hy
    exact ‚ü®hx.union_left t, hy.union_right s‚ü©

===== Proof 1266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  simp only [nhdsSet_union, eventually_iSup]
  rfl

===== Proof 1268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  simp [nhdsSet, eventually_iSup]

===== Proof 1271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [‚Üê and_forall_ne_mem_union, @and_comm _ (_ ‚àà s), eventually_nhdsSet_iff_forall]
  aesop

===== Proof 1273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  simp only [Filter.eventually_nhdsSet, Set.mem_union, or_and_right]
  aesop

===== Proof 1274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [ùìùÀ¢_union, eventually_sup]

===== Proof 1275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [‚Üê Set.union_eq_union, eventually_nhdsSet_union, and_comm]

===== Proof 1278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, Filter.eventually_sup]

===== Proof 1280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X ‚Üí Prop} :
    (‚àÄ·∂† x in ùìùÀ¢ (s ‚à™ t), p x) ‚Üî (‚àÄ·∂† x in ùìùÀ¢ s, p x) ‚àß ‚àÄ·∂† x in ùìùÀ¢ t, p x := by
  rw [nhdsSet_union, eventually_sup]

===== Proof 1281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos_iff, hx]

===== Proof 1282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos_iff, hx]

===== Proof 1283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos hx]

===== Proof 1284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [hx, mul_pos_iff]

===== Proof 1285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [hx]

===== Proof 1286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext y
  simp [mul_pos_iff, hx]

===== Proof 1287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [hx]
  constructor
  rintro ‚ü®y, hy, rfl‚ü©
  exact mul_pos hx hy
  intro hz
  use z / x
  constructor
  exact div_pos hz hx
  field_simp [hx]

===== Proof 1288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos hx]
  constructor <;> rintro ‚ü®y, hy, rfl‚ü© <;> linarith

===== Proof 1289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  constructor <;> rintro ‚ü®y, hy, rfl‚ü© <;> exact mul_pos hx hy

===== Proof 1290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext y
  simp [mul_pos_iff, hx]

===== Proof 1291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos hx]
  constructor <;> rintro ‚ü®y, hy, rfl‚ü© <;> exact ‚ü®y, hy, rfl‚ü©

===== Proof 1292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos hx]

===== Proof 1293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext x_w
  constructor <;> rintro ‚ü®k_x, hk_x : _ ‚àà Ioi (0 : k), rfl‚ü© <;>
    simp_all

===== Proof 1294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos hx]

===== Proof 1295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [hx]

===== Proof 1296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  have : (0 : k) < 1 := by linarith
  exact
    Set.ext fun y => by
      constructor
      ¬∑ rintro ‚ü®z, hz, rfl‚ü©
        exact mul_pos hx hz
      ¬∑ intro hy
        use y / x
        constructor
        ¬∑ exact div_pos hy hx
        ¬∑ field_simp [hx.ne']

===== Proof 1297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext x
  constructor <;> rintro ‚ü®y, hy, rfl‚ü© <;>
    simp_all [mul_pos]
  <;>
    exact ‚ü®x, by assumption, by ring‚ü©

===== Proof 1298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos_iff, hx]

===== Proof 1299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos_iff, hx]

===== Proof 1300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos_iff, hx]

===== Proof 1301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp only [mem_image, mem_Ioi, exists_prop]
  refine' ‚ü®fun ‚ü®y, hy, hz‚ü© => by rw [‚Üê hz]; exact mul_pos hx hy, fun hz => ‚ü®z / x, _, (mul_div_cancel‚ÇÄ _ hx.ne').symm‚ü©‚ü©
  exact div_pos hz hx

===== Proof 1302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos hx]

===== Proof 1303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos_iff, hx]

===== Proof 1304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext y
  simp [mul_pos_iff, hx]

===== Proof 1305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos hx]

===== Proof 1306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp only [mem_image, Set.mem_Ioi, exists_prop]
  constructor
  exact fun ‚ü®y, hy, hz‚ü© => by
    rw [‚Üê hz]
    exact mul_pos hx hy
  intro hz
  use z / x
  constructor
  exact div_pos hz hx
  field_simp [hx.ne']

===== Proof 1307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos_iff, hx]

===== Proof 1308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  constructor
  rintro ‚ü®y, hy, rfl‚ü©
  exact mul_pos hx hy
  intro hz
  use z / x
  constructor
  exact div_pos hz hx
  field_simp [hx]

===== Proof 1309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp [mul_pos_iff, hx]

===== Proof 1310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  simp only [mem_image, mem_Ioi, exists_prop, Set.mem_setOf_eq]
  constructor
  next =>
    rintro ‚ü®y, hy, rfl‚ü©
    exact mul_pos hx hy
  next =>
    intro hz
    use z / x
    constructor
    ¬∑ exact div_pos hz hx
    ¬∑ field_simp

===== Proof 1311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext z
  constructor
  rintro ‚ü®y, hy, rfl‚ü©
  exact mul_pos hx hy
  intro hz
  use z / x
  constructor
  exact div_pos hz hx
  field_simp [hz, hx]

===== Proof 1312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext y
  simp [hx, mul_pos_iff]

===== Proof 1313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_smul_set_iff_inv_smul_mem]
  constructor <;> intro h <;>
  simp_all only [mul_lt_mul_left, mul_lt_mul_right, inv_mul_lt_iff, lt_inv,
    mul_inv_lt_iff, lt_mul_inv_iff] <;>
  aesop

===== Proof 1314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext
  simp [mem_Ioo, smul_lt_smul_iff_of_pos]

===== Proof 1315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext
  simp [mem_Ioo, smul_lt_smul_iff_of_pos]

===== Proof 1316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_Ioo, smul_lt_smul_iff_of_pos]

===== Proof 1317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext
  simp [mem_smul_set_iff_inv_smul_mem]
  constructor <;> intro <;>
  (try simp_all only [mul_lt_mul_left, mul_lt_mul_right, mul_pos, mul_comm, mul_left_comm,
    mul_assoc, mul_right_comm])
  <;> (try norm_num)
  <;> (try linarith)

===== Proof 1318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp only [mem_smul_set_iff_inv_smul_mem, mem_Ioo, smul_lt_smul_iff_of_pos]
  constructor <;> intro h <;> constructor <;> aesop

===== Proof 1319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp only [mem_smul_set, mem_Ioo]
  constructor
  ¬∑ rintro ‚ü®y, hy, rfl‚ü©
    exact ‚ü®by linarith, by linarith‚ü©
  ¬∑ rintro ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
    use x / r
    constructor
    ¬∑ exact ‚ü®by linarith, by linarith‚ü©
    ¬∑ field_simp

===== Proof 1320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  rw [smul_eq_mul]
  ext
  simp [mem_Ioo, mul_comm]
  constructor <;> intro <;> constructor <;> linarith

===== Proof 1321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext
  simp only [mem_smul_set, smul_inv_smul‚ÇÄ r.ne_zero, mem_Ioo, smul_eq_mul]
  constructor <;> intro h <;> obtain ‚ü®c, h, h'‚ü© := h <;> use c * r‚Åª¬π <;> simp [h, h']
  <;> constructor <;> linarith

===== Proof 1322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext
  simp [smul_lt_smul_iff_of_pos]

===== Proof 1323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_Ioo, smul_lt_smul_iff_of_pos]

===== Proof 1324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext
  simp_rw [‚Üê smul_lt_smul_iff_of_pos (zero_lt_one' ùïú)]
  constructor <;> intro <;> constructor <;> linarith

===== Proof 1325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_Ioo]

===== Proof 1326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_Ioo, smul_lt_smul_iff]

===== Proof 1327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp only [mem_smul_set, smul_eq_mul, mem_Ioo]
  constructor <;> intro h <;> obtain ‚ü®y, hy, hxy‚ü© := h <;>
    use y <;> simp [hy, hxy]

===== Proof 1328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  exact Ioo_smul r a b

===== Proof 1329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_smul_set_iff_inv_smul_mem, mul_comm]

===== Proof 1330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_smul_set_iff_inv_smul_mem, mem_Ioo, lt_inv, mul_lt_mul_left]

===== Proof 1331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_Ioo]
  exact ‚ü®fun ‚ü®y, h‚ü© => ‚ü®by linarith, by linarith‚ü©, fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => ‚ü®x / r, by linarith‚ü©‚ü©

===== Proof 1332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_Ioo]
  constructor <;> intro h <;> obtain ‚ü®h‚ÇÄ, h‚ÇÅ‚ü© := h <;> constructor <;> linarith

===== Proof 1333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  constructor <;> simp_all [mem_Ioo, smul_lt_smul_iff_of_pos]
  <;> (try intro h; constructor <;> linarith)
  <;> (try intro h; constructor <;> linarith)

===== Proof 1334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [lt_smul_iff_of_pos]

===== Proof 1335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  simp_rw [smul_eq_mul]
  ext x
  constructor <;> simp_all
  <;> intro h <;> linarith

===== Proof 1336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext
  simp only [mem_smul_set, smul_eq_mul, mem_Ioo]
  constructor
  rintro ‚ü®x, hx, rfl‚ü©
  constructor
  nlinarith
  nlinarith
  rintro ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
  use x / r
  constructor
  nlinarith
  nlinarith

===== Proof 1337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_Ioo]
  constructor <;> intro h <;> obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := h <;>
    constructor <;> linarith

===== Proof 1338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_Ioo, smul_lt_smul_iff_of_pos]

===== Proof 1339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp only [mem_smul_set, smul_eq_mul, mem_Ioo, mul_lt_mul_left]
  constructor <;> intro h
  exact ‚ü®mul_lt_mul_of_pos_left h.1 r.pos, mul_lt_mul_of_pos_left h.2 r.pos‚ü©
  obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := h
  constructor <;> apply (lt_div_iff r.pos).mp <;> linarith

===== Proof 1340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp only [mem_smul_set, smul_eq_mul, mem_Ioo]
  constructor
  exact fun ‚ü®y, ‚ü®hya, hyb‚ü©, hxy‚ü© => ‚ü®by linarith, by linarith‚ü©
  exact fun ‚ü®hxa, hxb‚ü© => ‚ü®x / r, ‚ü®by linarith, by linarith‚ü©, by field_simp‚ü©

===== Proof 1341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  aesop

===== Proof 1342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp only [mem_smul_set, smul_eq_mul, mem_Ioo]
  constructor <;> intro h
  exact ‚ü®by nlinarith, by nlinarith‚ü©
  obtain ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü© := h
  constructor
  nlinarith
  nlinarith

===== Proof 1343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  ext x
  simp [mem_Ioo]
  constructor <;> intro h <;> obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := h <;> constructor <;> linarith

===== Proof 1344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r ‚Ä¢ Ioo a b = Ioo (r ‚Ä¢ a) (r ‚Ä¢ b) := by
  simp [Ioo, smul_lt_smul_iff_of_pos (zero_lt_one' ‚Ñù)]

===== Proof 1345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  apply le_antisymm
  ¬∑ rw [aleph'_le]
    exact fun a => le_ciSup (bddAbove_of_small _) (mem_Iio.2 a.2)
  ¬∑ exact ciSup_le' fun i => aleph'_le.2 i.2.le

===== Proof 1346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  apply le_antisymm _ (ciSup_le' _)
  all_goals
    simp_rw [ho.1]
    exact OrderHom.mono _ (ho.2 _ (mem_Iio.2 (ho.1.symm ‚ñ∏ zero_lt_one)))

===== Proof 1347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.csSup_eq, csSup_eq_of_forall_le_of_forall_lt_exists_gt]
  <;> simp_all [ho.1]
  <;> ( intro a; exact ‚ü®a.1, le_refl a.1‚ü© )
  <;> ( intro a; exact ‚ü®a.1 + 1, lt_succ_self a.1‚ü© )

===== Proof 1348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [‚Üê aleph'_alephIdx (aleph0_pos.trans_le (alephIdx_aleph0 ‚ñ∏ alephIdx_le_alephIdx o))]
  exact aleph'_limit_aux (alephIdx_aleph0 ‚ñ∏ alephIdx_le_alephIdx o) ho

===== Proof 1349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.csSup_eq, csSup_Iio]
  rw [iSup_eq_of_forall]
  intro a; rw [aleph'_succ]
  exact ord_is_limit _ is_limit_aleph'

===== Proof 1350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [Aleph'.limit_eq ho]
  rfl

===== Proof 1351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.aleph'_eq]
  rfl

===== Proof 1352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.aleph'_eq]
  rfl

===== Proof 1353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [‚Üê aleph'_alephIdx (aleph0_le_aleph' _)]
  simp_rw [aleph_idx_eq, aleph'_alephIdx, ciSup_aleph0]
  rw [ho.bsup_eq, bsup_eq_blsub_of_lt_succ_limit _ (aleph0_isLimit)
    (fun a _ => aleph'_isLimit (aleph0_le_aleph' _))]
  intro x _
  apply aleph'_isLimit
  apply aleph0_le_aleph'

===== Proof 1354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [‚Üê aleph'_aleph0]; apply aleph'_limit_aux; assumption

===== Proof 1355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  apply le_antisymm
  ¬∑ rw [aleph'_le_of_limit ho]
    exact fun a ha => le_ciSup (bddAbove_of_small _) (‚ü®a, ha‚ü© : Iio o)
  ¬∑ apply ciSup_le'
    intro i
    exact aleph'_monotone i.2

===== Proof 1356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.bsup_eq]
  rfl

===== Proof 1357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [‚Üê aleph'_aleph0]
  apply aleph'_isLimit ho

===== Proof 1358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [aleph'_limit_zero, iSup_Iio_eq_sSup]; rfl

===== Proof 1359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [‚Üê aleph'_alephIdx (alephIdx_lt_of_isLimit ho)]
  apply aleph'_alephIdx
  exact ho.alephIdx_isLimit

===== Proof 1360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  apply le_antisymm
  ¬∑ rw [aleph'_limit ho]
    exact ciSup_le' fun i => le_aleph' i.1
  ¬∑ exact le_ciSup aleph'_isNormal ho

===== Proof 1361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.csSup_eq, ‚Üê aleph'_alephIdx (alephIdx_lt_of_isLimit ho)]
  rfl

===== Proof 1362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  apply le_antisymm
  ¬∑ rw [aleph'_le]
    exact fun a => le_ciSup (bddAbove_of_small _) (mem_Iio.2 a.2)
  ¬∑ refine ciSup_le fun i => ?_
    rw [aleph'_le]
    exact fun _ => ho.2 _ i.2.le

===== Proof 1363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.bsup_eq]
  rw [‚Üê aleph'_aleph0]
  apply aleph'_monotone
  exact bddAbove_of_small _

===== Proof 1364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.aleph'_eq]
  rfl

===== Proof 1365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [‚Üê aleph'_alephIdx (alephIdx_lt_of_isLimit ho)]
  congr
  apply alephIdx.limit_eq
  apply ho

===== Proof 1366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.bsup_eq, bsup_eq_iSup, iSup_subtype']
  rfl

===== Proof 1367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [ho.aleph'_eq]
  simp

===== Proof 1368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [‚Üê aleph'_alephIdx (aleph0_pos.trans_le (alephIdx_le_aleph0 o))]
  apply aleph'_eq
  simpa using ho.alephIdx_lt

===== Proof 1369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  apply le_antisymm
  ¬∑ apply aleph'_le.2
    intro a
    exact ho.2 a.1.out.lt
  ¬∑ apply ciSup_le'
    intro i
    exact aleph'_le.2 i.2.out.le

===== Proof 1370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [‚Üê aleph'_alephIdx (ho.2 _ (lt_succ _)), aleph'_alephIdx, csSup_of_not_bddAbove]
  rw [isLimit_iff_succ_lt] at ho
  rw [bddAbove_def, not_exists]
  intro i hi
  obtain ‚ü®j, hj‚ü© := ho i
  exact hi ‚ü®j, hj.le‚ü©

===== Proof 1371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [aleph'_limit_eq]
  rfl

===== Proof 1372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  have h : ‚àÄ a : Ordinal, a < o ‚Üí aleph' o ‚â§ aleph' a := by
    intro a ha
    exact aleph'_le.2 ha
  rw [aleph'_limit_eq h]
  rfl

===== Proof 1373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  apply le_antisymm <;> simp_rw [csSup_le_iff'' ho]
  <;> exact fun a => aleph'_le.2 a.2
  <;> exact fun a ha => aleph'_le.1 (ha _ ho.1)

===== Proof 1374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  apply le_antisymm <;> exact iSup_le fun a => aleph'_le.2 a.2.le

===== Proof 1375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  apply le_antisymm <;> refine csSup_le ?_ ?_ <;>
    simp_all [ho.1] <;>
    rintro i ‚ü®j, hj‚ü© <;>
    rw [‚Üê hj] <;>
    apply le_csSup <;>
    simp_all [ho.1] <;>
    exact ‚ü®j, hj.le‚ü©

===== Proof 1376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ‚®Ü a : Iio o, aleph' a := by
  rw [limitRecOn_limit _ _ _ _ ho, eq_comm]
  simp

===== Proof 1377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.eq_inter_diff t, h‚ÇÇ.eq_inter_diff t]
  simp [h‚ÇÅ.eq_inter_diff t, h‚ÇÇ.eq_inter_diff t]
  ring
  linarith

===== Proof 1378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.measure_inter_add_diff t, h‚ÇÇ.measure_inter_add_diff t]
  simp [h‚ÇÅ.measure_inter_add_diff t, h‚ÇÇ.measure_inter_add_diff t]
  abel

===== Proof 1379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  rw [IsCaratheodory] at *
  intro t
  simp [h‚ÇÅ, h‚ÇÇ, Set.inter_assoc, Set.inter_comm, Set.inter_left_comm]

===== Proof 1380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.caratheodory_eq]
  rw [h‚ÇÇ.caratheodory_eq]
  simp [Set.inter_comm, Set.inter_assoc, Set.inter_left_comm]
  exact le_refl _

===== Proof 1381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  simp only [IsCaratheodory, Set.inter_subset_iff, Set.mem_inter_iff]
  exact fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => ‚ü®h‚ÇÅ t, h‚ÇÇ t‚ü©

===== Proof 1382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.eq_inter_diff t, h‚ÇÇ.eq_inter_diff t]
  simp [h‚ÇÅ.eq_inter_diff t, h‚ÇÇ.eq_inter_diff t]
  ring

===== Proof 1383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.caratheodory_eq]
  rw [h‚ÇÇ.caratheodory_eq]
  simp [Set.inter_assoc, Set.inter_comm, Set.inter_left_comm]
  exact le_refl (m t)

===== Proof 1384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  simp_rw [IsCaratheodory, Set.inter_assoc, Set.inter_comm t, Set.inter_left_comm]
  exact fun h =>
    h‚ÇÇ _ (h‚ÇÅ _ h)

===== Proof 1385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.caratheodory_eq]
  rw [h‚ÇÇ.caratheodory_eq]
  simp_rw [Set.inter_assoc, Set.inter_comm t]
  rw [Set.inter_assoc]
  simp_rw [Set.inter_assoc, Set.inter_comm t]
  rw [Set.inter_assoc]
  ring_nf
  simp_rw [h‚ÇÅ.caratheodory_eq, h‚ÇÇ.caratheodory_eq]
  ring_nf

===== Proof 1386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  have h : m (t ‚à© s‚ÇÅ) + m (t \ s‚ÇÅ) = m t ‚àß m t ‚à© s‚ÇÅ = m t ‚à© s‚ÇÅ := And.intro (h‚ÇÅ t) rfl
  have h' : m (t ‚à© s‚ÇÇ) + m (t \ s‚ÇÇ) = m t ‚àß m t ‚à© s‚ÇÇ = m t ‚à© s‚ÇÇ := And.intro (h‚ÇÇ t) rfl
  apply IsCaratheodory.inter'
  apply h.1
  apply h'.1

===== Proof 1387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.carath√©odory_eq]
  rw [h‚ÇÇ.carath√©odory_eq]
  simp_rw [Set.inter_assoc, Set.inter_comm t, ‚Üê Set.inter_assoc, h‚ÇÅ.carath√©odory_eq,
    h‚ÇÇ.carath√©odory_eq]
  ring
  <;> exact le_refl (m t)

===== Proof 1388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  rw [IsCaratheodory]
  intro t
  have h := IsCaratheodory.union m h‚ÇÅ h‚ÇÇ
  simp_all [IsCaratheodory, mul_comm]
  tauto

===== Proof 1389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  rw [isCaratheodory_iff_le] at h‚ÇÅ h‚ÇÇ ‚ä¢
  intro t
  specialize h‚ÇÅ t
  specialize h‚ÇÇ t
  simp_all only [Set.inter_assoc, Set.inter_comm, Set.inter_left_comm]
  min_tac

===== Proof 1390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  refine' ‚ü®fun t => _‚ü©
  simp_rw [IsCaratheodory, Set.inter_assoc, Set.inter_comm t, Set.inter_left_comm]
  exact fun ht =>
    (h‚ÇÅ.inter_subset_right t ht).trans (h‚ÇÇ.inter_subset_left t ht)

===== Proof 1391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  rw [IsCaratheodory] at *
  intro t
  rw [inter_assoc]
  rw [inter_comm]
  rw [‚Üê inter_assoc]
  simp_rw [inter_assoc]
  exact (h‚ÇÅ (t ‚à© s‚ÇÇ)).2 (h‚ÇÇ t)

===== Proof 1392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.measure_inter_add_diff t, h‚ÇÇ.measure_inter_add_diff t]
  simp [h‚ÇÅ, h‚ÇÇ, Set.inter_assoc, Set.inter_comm, Set.inter_left_comm,
    measure_inter_add_diff m (s‚ÇÅ ‚à© s‚ÇÇ) t]
  ring

===== Proof 1393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  simp_rw [IsCaratheodory, ‚Üê Set.inter_assoc, Set.inter_comm t, Set.inter_assoc]
  exact fun h => ‚ü®h‚ÇÅ t (h.trans (Set.inter_subset_left _ _)), h‚ÇÇ t (h.trans (Set.inter_subset_right _ _))‚ü©

===== Proof 1394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  have h‚ÇÅ' := h‚ÇÅ t
  have h‚ÇÇ' := h‚ÇÇ t
  simp only [IsCaratheodory, Set.mem_inter_iff] at *
  constructor
  intro h
  linarith
  intro h
  linarith

===== Proof 1395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.isCaratheodory_iff]
  rw [h‚ÇÇ.isCaratheodory_iff]
  simp_rw [h‚ÇÅ.isCaratheodory_iff]
  simp_rw [h‚ÇÇ.isCaratheodory_iff]
  aesop

===== Proof 1396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  rw [IsCaratheodory] at *
  intro t
  specialize h‚ÇÅ (t ‚à© s‚ÇÇ)
  specialize h‚ÇÇ t
  linarith

===== Proof 1397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  simp only [Set.inter_assoc, Set.inter_comm t, Set.inter_left_comm]
  exact ((h‚ÇÅ t).inter (h‚ÇÇ t))

===== Proof 1398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.caratheodory_eq]
  rw [h‚ÇÇ.caratheodory_eq]
  simp [h‚ÇÅ.caratheodory_eq, h‚ÇÇ.caratheodory_eq]
  ring
  rw [h‚ÇÇ]
  ring

===== Proof 1399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  rw [IsCaratheodory]
  intro t
  have h‚ÇÅ' := h‚ÇÅ t
  have h‚ÇÇ' := h‚ÇÇ t
  simp_rw [IsCaratheodory] at h‚ÇÅ' h‚ÇÇ'
  specialize h‚ÇÅ' (t ‚à© s‚ÇÅ)
  specialize h‚ÇÇ' (t ‚à© s‚ÇÇ)
  simp only [Set.inter_assoc, Set.inter_comm, Set.inter_left_comm] at h‚ÇÅ' h‚ÇÇ'
  rw [‚Üê Set.inter_assoc]
  simp only [Set.inter_assoc, Set.inter_comm, Set.inter_left_comm]
  rw [‚Üê Set.inter_assoc] at h‚ÇÅ'
  rw [‚Üê Set.inter_assoc] at h‚ÇÇ'
  linarith

===== Proof 1400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  simp_rw [IsCaratheodory] at *
  simp_rw [Set.inter_assoc, Set.inter_comm t, Set.inter_left_comm t]
  exact (h‚ÇÅ t).inter (h‚ÇÇ t)

===== Proof 1401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.caratheodory_eq]
  rw [h‚ÇÇ.caratheodory_eq]
  simp_rw [Set.inter_assoc, Set.inter_comm t, ‚Üê Set.inter_assoc, Set.inter_comm _ t]
  exact m.inter (t ‚à© s‚ÇÅ) _

===== Proof 1402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  simp only [Set.inter_assoc, Set.inter_comm, Set.inter_left_comm]
  aesop

===== Proof 1403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.inter_inter_diff t s‚ÇÇ, h‚ÇÇ.inter_inter_diff t s‚ÇÅ, h‚ÇÅ.inter_inter_diff t s‚ÇÇ,
    h‚ÇÇ.inter_inter_diff t s‚ÇÅ, add_assoc, add_assoc, add_comm (m t), add_comm (m t), ‚Üê
    add_assoc, ‚Üê add_assoc]
  ring_nf
  aesop

===== Proof 1404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  rw [IsCaratheodory]
  intro t
  have h‚ÇÉ : m t = m (t ‚à© s‚ÇÅ) + m (t \ s‚ÇÅ) := h‚ÇÅ t
  have h‚ÇÑ : m t = m (t ‚à© s‚ÇÇ) + m (t \ s‚ÇÇ) := h‚ÇÇ t
  rw [IsCaratheodory] at h‚ÇÅ h‚ÇÇ
  simp_rw [Set.inter_assoc, Set.inter_comm t s‚ÇÅ, Set.inter_left_comm t s‚ÇÅ s‚ÇÇ, Set.inter_comm t s‚ÇÇ,
    Set.inter_assoc, Set.inter_left_comm t s‚ÇÇ s‚ÇÅ, Set.inter_comm t s‚ÇÅ, Set.inter_assoc] at h‚ÇÉ h‚ÇÑ
  linarith

===== Proof 1405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  refine' ‚ü®fun t => _‚ü©
  rw [h‚ÇÅ.measure_inter_add_diff t, h‚ÇÇ.measure_inter_add_diff t]
  simp [h‚ÇÅ.measure_inter_add_diff t, h‚ÇÇ.measure_inter_add_diff t]

===== Proof 1406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  rw [h‚ÇÅ.caratheodory_eq]
  rw [h‚ÇÇ.caratheodory_eq]
  simp_rw [Set.inter_assoc, Set.inter_comm t, Set.inter_left_comm]
  rw [isCaratheodory_inter_of_measurableSet_left (h‚ÇÅ := h‚ÇÇ)]
  ¬∑ exact h‚ÇÇ.inter_lt h‚ÇÅ
  ¬∑ exact h‚ÇÅ.measurableSet

===== Proof 1407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  intro t
  simp only [Set.mem_inter_iff, IsCaratheodory] at *
  specialize h‚ÇÅ t
  specialize h‚ÇÇ t
  constructor
  intro h
  constructor <;> linarith
  intro h
  constructor <;> linarith

===== Proof 1408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h‚ÇÅ : IsCaratheodory m s‚ÇÅ) (h‚ÇÇ : IsCaratheodory m s‚ÇÇ) :
    IsCaratheodory m (s‚ÇÅ ‚à© s‚ÇÇ) := by
  rw [IsCaratheodory] at *
  intro t
  simp [h‚ÇÅ, h‚ÇÇ, Set.inter_assoc, Set.inter_comm, Set.inter_left_comm]

===== Proof 1409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, Category.assoc]

===== Proof 1410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp only [colimitCurrySwapCompColimIsoColimitCurryCompColim, Functor.pre, colimit.cocone_Œπ,
    colimit.Œπ_desc, Œπ_colimMap, curry_obj_obj_obj, curry_obj_map_app, colimit.Œπ_map_assoc,
    colimit.Œπ_pre, Œπ_colimMap_assoc, NatTrans.naturality, colimit.coproductIso_inv_comp_Œπ,
    colimit.Œπ_map, Prod.braiding_apply, curry_obj_map_app, NatTrans.id_app, Functor.id_obj,
    Functor.id_map, NatTrans.comp_app, Functor.const_obj_obj, Functor.const_obj_map]
  simp only [colimit.Œπ_desc_assoc]
  aesop_cat

===== Proof 1411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, Œπ_colimMap,
    NatTrans.naturality]

===== Proof 1412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim,
    colimit.Œπ_desc, colimitDesc, colimit.pre_obj, colimit.post_obj]
  erw [colimit.pre_œÄ]
  erw [colimit.pre_œÄ]
  simp

===== Proof 1413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim]
  aesop_cat

===== Proof 1414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim]

===== Proof 1415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim]

===== Proof 1416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, Functor.curry]
  aesop_cat

===== Proof 1417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim]
  aesop_cat

===== Proof 1418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  ext
  dsimp [colimitCurrySwapCompColimIsoColimitCurryCompColim, IsColimit.precomposeHomIso]
  simp only [Category.id_comp, colimit.Œπ_desc, colimit.Œπ_desc_assoc, colimit.Œπ_pre,
    Category.comp_id, Category.assoc, IsColimit.fac]
  simp only [colimit.pre_œÄ, colimit.Œπ_desc_assoc, colimit.Œπ_œÄ, colimit.Œπ_pre,
    IsColimit.comp_coconePointUniqueUpToIso_inv_assoc, IsColimit.comp_coconePointUniqueUpToIso_inv]
  apply IsColimit.hom_ext
  aesop_cat

===== Proof 1419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp

===== Proof 1420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, Category.assoc]

===== Proof 1421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  dsimp [colimitCurrySwapCompColimIsoColimitCurryCompColim]
  simp only [CategoryTheory.Functor.const_obj_œÄ_app, Category.comp_id]
  erw [Iso.inv_comp_eq]
  dsimp
  rw [Category.assoc]
  erw [colimit.Œπ_desc]
  dsimp
  simp only [Functor.const_obj_œÄ_app, Category.id_comp]
  rfl

===== Proof 1422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim,
    colimit.Œπ_desc, colimit.Œπ_desc_assoc]

===== Proof 1423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  dsimp only [colimitCurrySwapCompColimIsoColimitCurryCompColim]
  simp only [Category.comp_id, Category.id_comp]
  erw [colimit.Œπ_desc]
  erw [colimit.Œπ_desc]
  simp only [Category.comp_id]
  erw [colimit.Œπ_desc]
  rfl

===== Proof 1424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, projection_colimMap_assoc]

===== Proof 1425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  aesop_cat

===== Proof 1426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, Functor.const]
  aesop_cat

===== Proof 1427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, limit.lift_œÄ, limit.lift_œÄ_assoc,
    colimit.Œπ_desc, colimit.Œπ_desc_assoc]

===== Proof 1428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim]

===== Proof 1429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, curried_functor_obj_obj]
  aesop_cat

===== Proof 1430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp only [colimitCurrySwapCompColimIsoColimitCurryCompColim, Iso.trans_inv, Iso.symm_inv,
    colimit.isoColimit_inv, colimit.isoColimit_hom, NatIso.ofComponents_inv,
    NatIso.ofComponents_hom, ‚Üê Category.assoc]
  erw [hocolimitIsoHocolimitCurrySwapCompColim_inv_hom_id_assoc G j k]
  rfl

===== Proof 1431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp only [Iso.trans, Iso.symm, Iso.inv, colimitCurrySwapCompColimIsoColimitCurryCompColim_hom,
    currySwapCompColimIsoCurryCompColim_hom_app_app, Set.union_eq_left, sup_idem]
  simp only [Category.assoc, colimit.Œπ_desc_assoc, cokernel.œÄ_desc, cokernel.œÄ_desc_assoc,
    colimit.Œπ_desc]
  simp only [comp_id, eq_self_iff_true, Category.id_comp]

===== Proof 1432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim]
  aesop_cat

===== Proof 1433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim]
  aesop_cat

===== Proof 1434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, NatTrans.currySwapCompColim]
  aesop_cat

===== Proof 1435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim]
  aesop_cat

===== Proof 1436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim, IsColimit.comp_coconePointUniqueUpToIso]

===== Proof 1437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  dsimp [colimitCurrySwapCompColimIsoColimitCurryCompColim]
  simp only [colimit.Œπ_desc, colimit.Œπ_desc_assoc, colimit.Œπ_desc_assoc,
    colimit.Œπ_desc_assoc, colimit.Œπ_desc_assoc, colimit.Œπ_desc_assoc, colimit.Œπ_desc_assoc,
    colimit.Œπ_desc_assoc, colimit.Œπ_desc_assoc,
    colimit.Œπ_desc]
  simp only [SlimFunctor.curry_obj_obj,
    SlimFunctor.curry_obj_map, SlimFunctor.colimit_obj,
    SlimFunctor.of_fst, SlimFunctor.of_snd]
  aesop_cat

===== Proof 1438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp [colimitCurrySwapCompColimIsoColimitCurryCompColim]

===== Proof 1439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  simp only [Currying, Œπ_colimMap, ‚Üê colim_map, ‚Üê Limits.colimit.eq]
  aesop_cat

===== Proof 1440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Œπ_Œπ_inv {j} {k} :
    colimit.Œπ _ k ‚â´ colimit.Œπ (curry.obj G ‚ãô colim) j ‚â´
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.Œπ _ j ‚â´
          colimit.Œπ (curry.obj _ ‚ãô colim) k :
            _ ‚ü∂ colimit (curry.obj (Prod.swap K J ‚ãô G) ‚ãô colim)) := by
  dsimp [colimitCurrySwapCompColimIsoColimitCurryCompColim]
  simp only [Category.id_comp, Category.comp_id, Category.assoc]
  erw [colimit.Œπ_desc_assoc, colimit.Œπ_desc]
  simp only [Category.id_comp, Category.comp_id, Category.assoc]
  apply (proof_to_prop (Iso.hom_inv_id (colimit.isoColimit _))).symm

===== Proof 1441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
  cases' k with k
  exacts [‚ü®a, by simp [h]‚ü©,
    let ‚ü®d, hd‚ü© := exists_gcd_eq_one_of_coprime (isUnit_iff_exists_inv.1 hab) a b
    ‚ü®d, by rw [‚Üê pow_one d, ‚Üê pow_mul, mul_comm, hd, h]‚ü©]

===== Proof 1443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   rw [associated_comm]
   apply associated_of_dvd_dvd
   ¬∑ exact ‚ü®1, by simp‚ü©
   ¬∑ rw [‚Üê h]
     exact dvd_mul_right _ _

===== Proof 1444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
  use a
  simp [h]

===== Proof 1448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   cases k
   ¬∑ simp
     rw [pow_zero] at h
     refine' ‚ü®a, _‚ü©
     rw [‚Üê h, gcd_mul_right]
     simp [hab]
   rw [pow_succ'] at h
   refine' ‚ü®b, _‚ü©
   rw [associated_iff_dvd_dvd]
   refine' ‚ü®_, _root_.dvd_of_mul_left_dvd h‚ü©
   rw [mul_comm]
   exact dvd_mul_right _ _

===== Proof 1449 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1450 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1451 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1452 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
  use 1
  simp [h.symm]

===== Proof 1453 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1454 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1455 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   cases' exists_associated_mul_pow_of_mul_eq_pow hab h with d hd
   use d
   exact hd.symm

===== Proof 1456 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   exists a
   simp [h]

===== Proof 1457 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
  use a
  simp [h]

===== Proof 1458 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
  cases' k with k
  exact ‚ü®a, by simp‚ü©
  use gcd a b
  rw [‚Üê associated_iff_dvd_dvd]
  apply And.intro
  exact dvd_mul_right _ _
  rw [‚Üê pow_succ]
  exact (gcd_pow_right_dvd_pow_gcd k).trans ‚ü®c, h‚ü©.dvd

===== Proof 1459 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
    simp [h]

===== Proof 1460 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h, associated_one_pow, hab]

===== Proof 1461 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
  use a
  rw [‚Üê h]
  exact ‚ü®b, by simp‚ü©

===== Proof 1462 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   by_cases ha : a = 0
   ¬∑ simp_all
   by_cases hb : b = 0
   ¬∑ simp_all
   by_cases hc : c = 0
   ¬∑ simp_all
   cases' k with k
   ¬∑ use 1
     simp [ha, hb]
   use (gcd a c) ^ k
   apply (associated_of_dvd_dvd _ _).symm
   ¬∑ apply dvd_of_mul_right_dvd
     rw [h]
     apply dvd_pow
     exact gcd_dvd_left a c
     exact Nat.succ_ne_zero k
   ¬∑ rw [‚Üê gcd_mul_left, ‚Üê h, mul_comm]
     exact dvd_mul_right ((gcd a c) ^ k) b

===== Proof 1463 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   exact ‚ü®1, by rw [Units.val_one, one_mul]‚ü©

===== Proof 1464 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
  use a
  simp [h]

===== Proof 1465 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h, associated_comm]

===== Proof 1466 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1467 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   rw [‚Üê h]
   exact ‚ü®b, by
     simp only [Unit.smul_def, one_smul]
     rfl‚ü©

===== Proof 1468 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   exists a
   simp [h]

===== Proof 1469 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
  use a
  simp [h]

===== Proof 1470 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   rw [associated_comm]
   apply associated_of_dvd_dvd
   ¬∑ exact dvd_of_mul_right_dvd (h.symm ‚ñ∏ dvd_pow_self _ (k.ne_zero))
   ¬∑ exact dvd_of_mul_left_dvd (h.symm ‚ñ∏ dvd_pow_self _ (k.ne_zero))

===== Proof 1471 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   rw [associated_comm]
   apply associated_of_dvd_dvd
   ¬∑ exact dvd_of_mul_right_dvd (h.symm ‚ñ∏ dvd_pow_self _ (k.ne_zero))
   ¬∑ rw [‚Üê h, pow_mul_pow_eq_one]
     exact (IsUnit.pow _ hab).dvd

===== Proof 1472 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid Œ±] {a b c : Œ±} (hab : IsUnit (gcd a b))
    {k : ‚Ñï} (h : a * b = c ^ k) : ‚àÉ d : Œ±, Associated (d ^ k) a := by
   use a
   simp [h]

===== Proof 1473 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  funext x; simp [h]

===== Proof 1474 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext
  simp_rw [LinearMap.comp_apply, lmapDomain_apply, Finsupp.total_apply]
  rw [Finset.sum_map]
  congr
  funext
  simp [h]

===== Proof 1475 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x
  simp' [h]

===== Proof 1476 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  apply LinearMap.ext
  intro
  simp only [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply,
    LinearMap.coe_comp, Finsupp.sum, Function.comp_apply
  ]
  apply Finset.sum_congr rfl
  intro
  rw [h]

===== Proof 1477 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x
  simp [h]

===== Proof 1478 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext : 2
  simp only [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply,
    LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply]
  rw [Finsupp.sum_mapDomain_index]
  simp [h]

===== Proof 1479 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext
  simp_rw [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply,
    Finsupp.sum_mapDomain_index, h]
  aesop

===== Proof 1480 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x
  simp only [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply, LinearMap.coe_comp,
    LinearEquiv.coe_coe, Function.comp_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply,
    LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply, Finsupp.total_apply,
    Finsupp.lmapDomain_apply, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply]
  simp only [h]

===== Proof 1481 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext
  simp [h]

===== Proof 1482 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext
  simp [h]

===== Proof 1483 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext
  simp_rw [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply, map_sum,
    LinearEquiv.map_smul, Finsupp.smul_sum]
  simp [h]

===== Proof 1484 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext
  simp [total_apply, lmapDomain_apply, h]

===== Proof 1485 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x
  simp [h]

===== Proof 1486 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext
  simp [h, Finsupp.total_apply]

===== Proof 1487 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x y
  simp only [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply,
    LinearMap.coe_toAddHom, AddHom.coe_mk, LinearMap.toAddHom_coe]
  apply Finset.sum_congr rfl
  intro i _
  exact h i

===== Proof 1488 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  apply DFunLike.ext
  intro x
  simp only [LinearMap.comp_apply, lmapDomain_apply, total_apply]
  rw [Finset.sum_map, ‚Üê Finset.sum_finset_coe]
  refine Finset.sum_congr rfl ?_
  intro i _
  rw [h]

===== Proof 1489 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext
  simp [h]

===== Proof 1490 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
   ext
   simp [h]

===== Proof 1491 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  funext x
  simp only [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.sum, map_sum]
  simp only [lmapDomain_apply, comp_apply, Finsupp.sum, LinearMap.map_sum,
    LinearMap.map_smul‚Çõ‚Çó, RingHom.id_apply]
  apply Finset.sum_congr rfl
  intro i _
  apply h

===== Proof 1492 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  apply LinearMap.ext
  intro x
  simp only [LinearMap.comp_apply, Finsupp.total_apply, lmapDomain_apply, Finsupp.sum,
    LinearMap.map_sum, LinearMap.map_smul, Finset.sum_congr rfl h]
  rfl

===== Proof 1493 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x
  simp [h]

===== Proof 1494 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x y
  simp only [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply,
    LinearMap.coe_comp, AddHom.coe_toAddMonoidHom, AddMonoidHom.coe_coe, Finset.smul_sum, Finset.sum_congr,
    Finset.smul_sum, Finset.sum_congr, smul_smul]
  rfl

===== Proof 1495 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x : 2
  simp only [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.lmapDomain_apply, ‚Üê h]
  rw [Finsupp.sum_mapDomain_index]
  simp [add_smul]

===== Proof 1496 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext; simp [h]

===== Proof 1497 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x
  simp [h]

===== Proof 1498 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext
  simp [Finsupp.total_apply, lmapDomain_apply, h]

===== Proof 1499 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x
  simp [total_apply, lmapDomain_apply, h]

===== Proof 1500 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x : 1
  simp_rw [LinearMap.comp_apply, Finsupp.total_apply, Finsupp.sum, map_sum,
    LinearMap.map_smul_of_tower, lmapDomain_apply]
  rw [Finsupp.sum_mapDomain_index]
  simp_rw [LinearMap.map_smul_of_tower, h, smul_comm]
  simp

===== Proof 1501 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  rfl

===== Proof 1502 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext x
  simp [total_apply, lmapDomain_apply, h]

===== Proof 1503 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  funext
  simp [h]

===== Proof 1504 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : Œ± ‚Üí Œ±') (g : M ‚Üí‚Çó[R] M') (h : ‚àÄ i, g (v i) = v' (f i)) :
    (Finsupp.total Œ±' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total Œ± M R v) := by
  ext ; simp [h]

===== Proof 1505 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  exact associated_one_of_mul_eq_one (b * u) (by simpa [mul_assoc] using h)

===== Proof 1506 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by simp [And.comm, and_imp]

===== Proof 1507 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  rw [associated_one_of_associated_mul_one] at h
  exact h

===== Proof 1508 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  rw [mul_comm] at h
  obtain ‚ü®u, h‚ü© := associated_one_of_mul_one h
  exact ‚ü®u, by rw [mul_comm] at h; exact h‚ü©

===== Proof 1509 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  rintro ‚ü®u, rfl‚ü©
  exact ‚ü®b * u, by simpa [mul_assoc] using h‚ü©

===== Proof 1510 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  exact associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h

===== Proof 1511 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  exact associated_one_of_mul_eq_one _ (by simpa [mul_assoc] using h)

===== Proof 1512 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  exact associated_one_of_mul_eq_one (b * u) (by simpa [mul_assoc] using h)

===== Proof 1513 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  exact fun h => associated_one_of_mul_eq_one (b * ‚Üëu) <| by simpa [mul_assoc] using h

===== Proof 1514 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  exact associated_one_of_mul_eq_one _ (by simpa [mul_assoc] using h)

===== Proof 1515 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  exact associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h

===== Proof 1516 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  simp only [associated_one_iff_exists_units] at *
  intro
  simp_all

===== Proof 1517 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  obtain ‚ü®u, h‚ü© := h
  use u
  simpa [mul_assoc] using h

===== Proof 1518 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  rcases h with ‚ü®u, h‚ü©
  exact associated_one_of_mul_eq_one (b * u) (by simpa [mul_assoc] using h)

===== Proof 1519 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  exact fun h => associated_one_of_mul_eq_one b (by simp [h])
  <;> exact fun h => associated_one_of_mul_eq_one a (by simp [h])

===== Proof 1520 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  rcases h with ‚ü®u, rfl‚ü©
  have h : a * (b * u) = 1 := by simpa [mul_assoc] using h
  exact ‚ü®b * u, h‚ü©

===== Proof 1521 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  exact fun h => associated_one_of_mul_one (mul_one a)

===== Proof 1522 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  exact fun h => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h

===== Proof 1523 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  rintro ‚ü®u, rfl‚ü©
  exact mk_eq_one.2 (by rw [‚Üê mul_assoc]; simp)

===== Proof 1524 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  rcases h with ‚ü®u, huv‚ü©
  use u
  rw [‚Üê huv]
  simp [mul_assoc]

===== Proof 1525 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  obtain ‚ü®u, h‚ü© := h
  exact ‚ü®u, by simpa [mul_assoc] using h‚ü©

===== Proof 1526 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  aesop

===== Proof 1527 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h; rcases h with ‚ü®u, h‚ü©
  exact ‚ü®u * b, by simp [h, mul_assoc]‚ü©

===== Proof 1528 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by simp [mul_assoc]

===== Proof 1529 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  rintro ‚ü®u, h‚ü©
  apply associated_one_of_mul_eq_one
  rw [‚Üê h]
  ring

===== Proof 1530 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h;
  exact associated_one_of_mul_eq_one (b * u) (by simpa [mul_assoc] using h)

===== Proof 1531 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  exact associated_one_of_mul_eq_one _ (by simpa [mul_assoc] using h)

===== Proof 1532 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  exact (associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h)

===== Proof 1533 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  apply mul_right_cancel‚ÇÄ (show (2 : ‚Ñï) ‚â† 0 by norm_num)
  simp_all only [mul_add, mul_one, mul_assoc, add_mul, one_mul, add_assoc]
  ring_nf
  linarith

===== Proof 1534 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  have h‚ÇÅ := h
  obtain ‚ü®u, h‚ü© := h‚ÇÅ
  exact ‚ü®u, by simpa [mul_assoc] using h‚ü©

===== Proof 1535 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  obtain ‚ü®u, rfl‚ü© := h
  exact ‚ü®u‚Åª¬π, by rw [mul_assoc, Units.mul_inv, mul_one]‚ü©

===== Proof 1536 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid Œ±] {a b : Œ±} : a * b ~·µ§ 1 ‚Üí a ~·µ§ 1
  | ‚ü®u, h‚ü© => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by aesop

===== Proof 1537 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  rw [mulVec_const]
  rfl

===== Proof 1538 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Matrix.mul_apply]
  rw [Finset.sum_const, nsmul_eq_mul]
  rfl

===== Proof 1539 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [Matrix.mulVec, Matrix.dotProduct, mul_comm]

===== Proof 1540 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp_rw [Matrix.mulVec, mul_comm (G.adjMatrix Œ±), Function.const, Finset.sum_const, nsmul_eq_mul]
  rfl

===== Proof 1541 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [‚Üê nsmul_eq_mul, Matrix.mulVec, adjMatrix, ‚Üê Fintype.card_subtype]
  rfl

===== Proof 1542 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  rw [mulVec_const]
  simp [adjMatrix_apply, degree]

===== Proof 1543 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [Matrix.mulVec, Matrix.dotProduct, sum_ite_eq, Finset.filter_mem_eq_inter,
    Finset.mem_inter_self]
  <;> rfl

===== Proof 1544 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Matrix.dotProduct, mul_comm]

===== Proof 1545 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp only [mulVec, Function.const_apply, mul_comm]
  rw [‚Üê sum_filter_mul_eq_sum_mul_filter]
  simp [sum_filter, @eq_comm _ v]

===== Proof 1546 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  rw [mulVec, Function.const_apply, degree, card_neighborSet_eq_sum_mul_boole]
  simp_rw [dotProduct, mul_comm]
  rw [Finset.sum_comm]
  simp

===== Proof 1547 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Function.const, Matrix.dotProduct]
  rw [Finset.sum_const, Finset.card_univ]
  rw [‚Üê nsmul_eq_mul]
  rfl

===== Proof 1548 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Matrix.dotProduct, mul_comm]
  rw [Fintype.sum_const, nsmul_eq_mul]
  rfl

===== Proof 1549 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Matrix.dotProduct, mul_comm]
  rw [‚Üê sum_filter_of_ne (fun _ _ ‚Ü¶ G.ne_of_adj), ‚Üê sum_const]
  congr
  ext
  simp_all [ne_eq, ite_mul, mul_comm]

===== Proof 1550 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp only [mulVec_const, ite_mul, mul_ite, mul_comm]
  simp only [‚Üê @adj_matrix_mul_vec_apply _ _ G _ _ v, cast_eq]

===== Proof 1551 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp_rw [mulVec, Function.const_apply, degree, mul_comm]
  rw [Finset.sum_const, nsmul_eq_mul, mul_comm]

===== Proof 1552 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Matrix.dotProduct]
  rw [‚Üê sum_filter_mul_left]
  simp [mul_comm, mul_left_comm, mul_assoc]

===== Proof 1553 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, mul_comm]
  simp_all [sum_const, nsmul_eq_mul, mul_comm]

===== Proof 1554 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp_rw [mulVec_const, adjMatrix_apply_mul]
  rfl

===== Proof 1555 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Matrix.dotProduct]

===== Proof 1556 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Function.const, Matrix.dotProduct]

===== Proof 1557 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp only [mulVec, Function.const, dotProduct]
  rw [Finset.sum_const, Finset.card_neighborSet_eq_degree]

===== Proof 1558 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp_rw [mulVec_apply, Function.const_apply, degree_eq_sum_ones]
  rw [Finset.sum_mul]
  rfl

===== Proof 1559 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [Matrix.mulVec, Matrix.dotProduct, mul_comm]
  simp_all only [mul_one, mul_zero, mul_add, mul_assoc, mul_comm, mul_left_comm,
    one_mul, zero_mul, add_zero, zero_add, Finset.sum_const, Finset.card_univ,
    Nat.cast_id, nsmul_eq_mul, mul_one]
  rfl

===== Proof 1560 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [Matrix.mulVec, adjMatrix, degree]
  rw [Finset.sum_const, nsmul_eq_mul]

===== Proof 1561 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Matrix.mul_apply, sum_const, nsmul_eq_mul]

===== Proof 1562 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, mul_comm]
  rw [Finset.sum_const, nsmul_eq_mul]
  rfl

===== Proof 1563 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp [mulVec, Matrix.mul_apply, sum_const]

===== Proof 1564 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  rw [mulVec, Function.const_apply]
  simp_rw [dotProduct]
  rw [Finset.sum_const]
  rfl

===== Proof 1565 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp only [mulVec_const, adjMatrix_apply, degree, sum_apply, mul_boole, mul_one, boole_mul]
  rfl

===== Proof 1566 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp_rw [mulVec_apply, Function.const_apply, sum_mul]
  rw [‚Üê Finset.sum_mul, mul_comm]
  rfl

===== Proof 1567 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp (config := { contextual := true }) [Matrix.mulVec, adjMatrix, Function.const]

===== Proof 1568 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring Œ±] {a : Œ±} {v : V} :
    (G.adjMatrix Œ± *·µ• Function.const _ a) v = G.degree v * a := by
  simp only [Matrix.mulVec, Function.const, mul_ite, mul_one, mul_zero, Pi.one_apply,
    ite_eq_left_iff, Ne, zero_mul]
  rw [‚Üê sum_filter_of_ne]
  intro h
  simp [h]

===== Proof 1569 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  simp [angle, Real.arccos_eq_pi, Real.cos_eq_neg_one_iff]
  constructor
  next =>
    rintro ‚ü®rfl, h‚ü©
    exact ‚ü®by norm_num, -1, by norm_num, by rw [‚Üê h]; simp‚ü©
  next =>
    rintro ‚ü®h‚ÇÅ, r, h‚ÇÇ, rfl‚ü©
    exact ‚ü®rfl, by positivity‚ü©

===== Proof 1570 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor
  ¬∑ intro h
    rw [angle, Real.arccos_eq_pi] at h
    exact ‚ü®h.1, ‚ü®-1, by linarith, by linarith [h.2]‚ü©‚ü©
  ¬∑ rintro ‚ü®hx, ‚ü®r, hr, rfl‚ü©‚ü©
    rw [angle, Real.arccos_eq_pi]
    use -(norm_sq (r ‚Ä¢ x))
    constructor
    ¬∑ exact neg_nonpos.2 (mul_self_nonneg _)
    ¬∑ rw [norm_smul, Real.norm_eq_abs, abs_of_neg hr, mul_assoc, ‚Üê pow_two]
      simp [hx]

===== Proof 1571 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  simp [angle, Real.arccos_eq_pi, Real.cos_eq_neg_one]
  constructor <;> intro h <;> use h.2 <;> simp [h]

===== Proof 1572 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  rw [angle, eq_comm]
  simp [sub_eq_zero]
  constructor
  next =>
    intro h
    obtain ‚ü®r, _, _‚ü© := h
    exact ‚ü®by assumption, r, by assumption, by assumption‚ü©
  next =>
    intro h
    obtain ‚ü®h‚ÇÅ, r, h‚ÇÇ, h‚ÇÉ‚ü© := h
    exact ‚ü®r, by linarith, h‚ÇÉ‚ü©

===== Proof 1573 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor
  next =>
    rw [angle, ‚Üê Real.sin_pi]
    intro h
    rw [Real.sin_inj_of_le_of_le_pi] at h <;> norm_num at h
    exact ‚ü®by simp [h], ‚ü®-1, by norm_num, by simp [h]‚ü©‚ü©
  next =>
    rintro ‚ü®h‚ÇÅ, ‚ü®r, hr, rfl‚ü©‚ü©
    rw [angle, Real.arccos_eq_pi]
    use Real.cos_neg_of_pi_div_two_lt_of_lt (by linarith) (by linarith)
    simp [h‚ÇÅ, hr]

===== Proof 1574 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  simp [angle, Real.arccos_eq_pi, inner_eq_zero_iff_angle_eq_pi_div_two_or_eq_neg_pi_div_two,
    exists_or, and_comm, and_left_comm]
  constructor
  ¬∑ intro h
    exact ‚ü®h.1, -1, by norm_num, by rw [‚Üê neg_one_smul, h.2]‚ü©
  ¬∑ rintro ‚ü®h‚ÇÅ, r, h‚ÇÇ, h‚ÇÉ‚ü©
    rw [h‚ÇÉ]
    exact ‚ü®h‚ÇÅ, by linarith‚ü©

===== Proof 1575 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  simp [angle, Real.arccos_eq_pi, inner_eq_zero_iff_angle_eq_pi_div_two]
  constructor <;> intro h <;> field_simp at h <;> simp_all

===== Proof 1576 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor <;> intro h <;> field_simp at h <;>
  simp_all only [ne_eq, one_div, div_eq_iff, eq_self_iff_true, true_and, sub_eq_zero]
  <;>
  (try
  {
    exact ‚ü®by linarith, by linarith‚ü©
  }) <;>
  (try
  {
    exact ‚ü®by linarith, by linarith‚ü©
  }) <;>
  (try
  {
    exact ‚ü®by linarith, by linarith‚ü©
  })

===== Proof 1577 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  simp [angle, Real.arccos_eq_pi, Real.cos_eq_neg_one]
  constructor <;> intro <;> field_simp [*, eq_self_iff_true,
    and_self_iff, mul_comm] at *
  ¬∑ use -1
    norm_num
  ¬∑ use h.2.choose
    exact ‚ü®h.2.choose_spec.1, h.2.choose_spec.2‚ü©

===== Proof 1578 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor <;> intro h <;>
  simp_all [inner_eq_neg_mul_norm_iff_real, real_inner_comm, real_inner_eq_norm_mul_iff_real]
  <;>
  (try {
    exact ‚ü®by linarith [norm_nonneg x], by linarith [norm_nonneg x]‚ü©
  }) <;>
  (try {
    exact ‚ü®by linarith [norm_nonneg x], by linarith [norm_nonneg x]‚ü©
  }) <;>
  (try {
    exact ‚ü®by linarith [norm_nonneg x], by linarith [norm_nonneg x]‚ü©
  }) <;>
  (try {
    exact ‚ü®by linarith [norm_nonneg x], by linarith [norm_nonneg x]‚ü©
  })

===== Proof 1579 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  rw [angle, ‚Üê and_assoc]
  refine' ‚ü®fun h => ‚ü®(Real.arccos_eq_zero_iff_abs_cos_lt_one _).1 h.2,
    Real.cos_eq_zero_iff.1 h.2‚ü©, _‚ü©
  rintro ‚ü®h‚ÇÅ, r, h‚ÇÇ, h‚ÇÉ‚ü©
  rw [Real.cos_arccos _ _ h‚ÇÅ, h‚ÇÉ, Real.cos_eq_zero_iff] at h‚ÇÅ
  aesop

===== Proof 1580 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor
  next =>
    intro h
    constructor
    ¬∑
      intro hx
      rw [hx, angle_zero_left] at h
      exact Real.pi_ne_zero (by linarith)
    ¬∑
      use -1
      constructor
      ¬∑ linarith
      ¬∑
        rw [‚Üê mul_self_inj, neg_one_mul, one_mul]
        nlinarith [cos_angle_neg_left x y, cos_angle_neg_right x y, h]
  next =>
    rintro ‚ü®hx, ‚ü®r, hr, rfl‚ü©‚ü©
    obtain rfl | hx' := eq_or_ne x 0
    ¬∑ simp_all
    rw [angle, Real.arccos_eq_pi, ‚Üê neg_one_smul ‚Ñù x]
    constructor
    ¬∑
      rw [neg_one_smul]
      exact (neg_lt_zero.2 (one_pos.trans_le hr)).ne'
    ¬∑
      rw [neg_one_smul, inner_neg_left, inner_smul_left, smul_neg, smul_smul]
      simp_all only [neg_mul_eq_neg_mul, one_mul, mul_one, neg_neg, eq_self_iff_true,
        true_or_iff]

===== Proof 1581 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  rw [angle, real_inner_eq_norm_mul_mul_eq_norm_iff_real_inner_eq_norm_mul_mul_cos_angle,
    inner_eq_zero_iff_angle_eq_pi_div_two, Real.cos_eq_zero_iff]
  constructor <;> intro h <;> field_simp at h <;> simp_all

===== Proof 1582 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  rw [angle]
  rw [Real.arccos_eq_pi]
  constructor <;> intro h <;> field_simp at h <;> simp_all [norm_eq_zero, Real.pi_ne_zero]
  <;>
  (try
  { rcases h with ‚ü®h‚ÇÄ, h‚ÇÅ‚ü©;
    rcases h‚ÇÅ with ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü©;
    use r;
    constructor <;>
    linarith })
  <;>
  aesop

===== Proof 1583 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor
  next =>
    intro h
    rw [angle, Real.arccos_eq_pi] at h
    norm_num at h
    exact ‚ü®h.1, ‚ü®-1, by linarith, by linarith [h.2]‚ü©‚ü©
  next =>
    rintro ‚ü®h‚ÇÅ, ‚ü®r, hr, rfl‚ü©‚ü©
    rw [angle, Real.arccos_eq_pi]
    norm_num
    exact ‚ü®by linarith, by nlinarith [h‚ÇÅ, hr]‚ü©

===== Proof 1584 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor <;> intro h
  next =>
    rw [angle, Real.arccos_eq_pi] at h
    constructor
    ¬∑ intro hx
      rw [hx, dotProduct_zero, zero_div, div_self h.1] at h
      exact h.2 rfl
    ¬∑ exact h
  next =>
    rw [angle, Real.arccos_eq_pi]
    obtain ‚ü®r, hr‚ÇÄ, hr‚ÇÅ‚ü© := h.2
    rw [hr‚ÇÅ, dotProduct_smul_left, norm_smul, Real.norm_eq_abs, _root_.abs_of_neg hr‚ÇÄ,
      mul_comm, ‚Üê mul_assoc, mul_comm, mul_assoc]
    exact ‚ü®h.1, by linarith‚ü©

===== Proof 1585 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor
  ¬∑ intro h
    rw [angle, Real.arccos_eq_pi] at h
    exact ‚ü®ne_zero_of_mem_nonzero_singleton x, h‚ü©
  ¬∑ rintro ‚ü®hx, r, hr, rfl‚ü©
    rw [angle, Real.arccos_eq_pi]
    use r / ‚Äñx‚Äñ
    constructor
    ¬∑ exact div_neg_of_neg_of_pos hr (norm_pos_iff.2 hx)
    ¬∑ rw [‚Üê neg_one_smul R x, norm_smul, norm_neg, norm_one, mul_one]

===== Proof 1586 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  rw [angle_eq_pi_iff]
  constructor <;> intro h <;> simp_all
  <;> (try { exact ‚ü®h.1, h.2‚ü© })
  <;> (try { exact ‚ü®h.1, h.2‚ü© })
  <;> (try { exact ‚ü®h.1, h.2‚ü© })

===== Proof 1587 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor
  ¬∑ intro h
    simp_all [angle, Real.arccos_eq_pi]
    exact ‚ü®by linarith, -1, by linarith, by linarith‚ü©
  ¬∑ rintro ‚ü®h‚ÇÅ, ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü©‚ü©
    rw [hr‚ÇÇ]
    simp_all [angle, Real.arccos_eq_pi]
    linarith

===== Proof 1588 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor <;> intro h
  next =>
    rw [angle, real_inner_eq_norm_mul_iff] at h
    exact ‚ü®h.1, h.2.1, h.2.2‚ü©
  next =>
    rw [angle, real_inner_eq_norm_mul_iff]
    obtain ‚ü®r, hr‚ÇÄ, hr‚ÇÅ‚ü© := h
    exact ‚ü®hr‚ÇÄ, hr‚ÇÅ‚ü©

===== Proof 1589 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor <;> intro h
  next =>
    rw [angle, Real.arccos_eq_pi] at h
    exact ‚ü®h.1, h.2.1, h.2.2‚ü©
  next =>
    rcases h with ‚ü®hx, r, hr, hy‚ü©
    rw [angle, Real.arccos_eq_pi, eq_comm]
    exact ‚ü®hx, hr, hy‚ü©

===== Proof 1590 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  rw [angle, eq_comm, Real.arccos_eq_pi]
  simp [exists_and_right, and_comm, and_left_comm]

===== Proof 1591 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  refine' ‚ü®fun h => ‚ü®_, _‚ü©, fun h => _‚ü©
  ¬∑ rintro rfl
    simp at h
  ¬∑ rcases eq_or_ne x 0 with rfl | hx
    ¬∑ rw [angle_zero_left, Real.arccos_eq_pi]
      exact ‚ü®-1, by norm_num, by simp‚ü©
    ¬∑ exact ‚ü®by rwa [angle_eq_arccos_of_ne_zero hx, Real.arccos_eq_pi], by
        rwa [angle_eq_arccos_of_ne_zero hx, Real.arccos_eq_pi] at h‚ü©
  ¬∑ obtain ‚ü®hx, r, hr, rfl‚ü© := h
    simp [angle_smul_right_of_neg hx hr]

===== Proof 1592 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  by_cases hx : x = 0 <;> by_cases hy : y = 0 <;>
    simp_all [angle, Real.arccos_eq_pi, Real.sqrt_eq_zero, norm_eq_zero, div_eq_mul_inv]
  <;> aesop

===== Proof 1593 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  refine' ‚ü®fun h‚ÇÄ => _, fun h‚ÇÅ => _‚ü©
  refine' ‚ü®fun h‚ÇÄ => _, fun h‚ÇÅ => _‚ü©
  exact (h‚ÇÅ.2 h‚ÇÄ).elim
  obtain ‚ü®r, hr‚ÇÄ, hr‚ÇÅ‚ü© := h‚ÇÅ
  simp_all only [angle, Real.arccos_eq_pi, Real.cos_pi, inner_smul_right, inner_self_eq_norm_sq,
    mul_neg, neg_mul, neg_neg, eq_self_iff_true, and_self_iff, not_true, false_and_iff,
    exists_prop]
  exact ‚ü®hr‚ÇÄ.le, -r, by linarith, by simp [hr‚ÇÅ]‚ü©

===== Proof 1594 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  simp [angle, Real.arccos_eq_pi, Real.cos_eq_zero_iff]
  constructor
  next =>
    rintro ‚ü®r, rneg, rxy‚ü©
    use r, rneg
    rw [‚Üê rxy]
    simp
  next =>
    rintro ‚ü®r, rneg, rxy‚ü©
    use r, rneg
    rw [‚Üê rxy]
    simp

===== Proof 1595 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  simp [angle, Real.arccos_eq_pi, real_inner_self_eq_norm_mul_norm]
  constructor
  next =>
    rintro ‚ü®r, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©
    use r
    constructor
    ¬∑ linarith
    ¬∑ exact h‚ÇÇ
  next =>
    rintro ‚ü®h‚ÇÅ, r, h‚ÇÇ, h‚ÇÉ‚ü©
    use r
    constructor
    ¬∑ constructor
      ¬∑ linarith
      ¬∑ exact h‚ÇÉ
    ¬∑ linarith

===== Proof 1596 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor
  ¬∑ intro h
    rw [angle, inner_eq_zero_iff_angle_eq_pi] at h
    exact ‚ü®h.1, ‚ü®-1, by norm_num, by rw [‚Üê h.2]; simp‚ü©‚ü©
  ¬∑ rintro ‚ü®hx, ‚ü®r, hr, rfl‚ü©‚ü©
    rw [angle, inner_eq_zero_iff_angle_eq_pi]
    use hx
    use -r
    constructor
    ¬∑ exact neg_lt_zero.2 hr
    ¬∑ simp

===== Proof 1597 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  simp [angle, Real.arccos_eq_pi, Real.cos_eq_neg_one]
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    exact ‚ü®h‚ÇÅ, by linarith, by linarith‚ü©
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
    exact ‚ü®h‚ÇÅ, by linarith‚ü©

===== Proof 1598 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  constructor <;> intro h
  <;> field_simp at h
  <;> simp_all only [exists_prop, Ne, false_and, false_or]
  <;> aesop

===== Proof 1599 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  simp [angle, Real.pi_pos.ne', inner_eq_zero_iff_angle_eq_pi, exists_real_pos_mul_lt]
  constructor
  intro h
  exact ‚ü®h.1, -1, by norm_num, by rw [‚Üê neg_one_smul, h.2]‚ü©
  rintro ‚ü®h‚ÇÅ, r, hr, rfl‚ü©
  exact ‚ü®h‚ÇÅ, by rw [‚Üê neg_one_smul, norm_smul, abs_of_neg hr]; simp‚ü©

===== Proof 1600 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = œÄ ‚Üî x ‚â† 0 ‚àß ‚àÉ r : ‚Ñù, r < 0 ‚àß y = r ‚Ä¢ x := by
  rw [angle, eq_comm]
  simp [sub_eq_zero, real_inner_eq_zero_iff]
  constructor
  next =>
    rintro ‚ü®r, ‚ü®hr, rfl‚ü©‚ü©
    exact ‚ü®by intro h; rw [h] at hr; norm_num at hr, -1, by norm_num, by simp [hr]‚ü©
  next =>
    rintro ‚ü®h, r, hr, rfl‚ü©
    exact ‚ü®-1, by simp [hr, h]‚ü©

===== Proof 1601 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction' hy with z hz
  exacts [self, star_self, algebraMap, add, mul, closure]

===== Proof 1602 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  replace hy := IsClosed.closure_subset_iff.mpr hy
  refine' closure y hy _
  dsimp only [closure]
  intro s hs hu
  by_cases hy : y ‚àà s
  ¬∑ exact hu y hy
  ¬∑ refine' self_mem_closure_of_mem _ _ hy _
    simpa only [hs] using hu

===== Proof 1603 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction' hy with z hz z Œ± Œ≤ h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ
  exacts [self, star_self, algebraMap _ _, add _ _ _ _ ih‚ÇÅ ih‚ÇÇ, mul _ _ _ _ ih‚ÇÅ ih‚ÇÇ,
    closure _ fun _ hz => ih‚ÇÇ (‚ü®hz, hz‚ü© : _ ‚äÜ _) fun _ hz => ih‚ÇÅ _ hz]

===== Proof 1604 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction' hy with u hu
  <;> cases' hu with hu hu
  <;> subst_vars
  <;> simp_all

===== Proof 1605 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction' y using Submodule.induction_on_span with y hy
  ¬∑ apply self; simpa
  simp_all

===== Proof 1606 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  hy.recOn hy
    <;> simp
    <;> try apply self
    <;> try apply star_self
    <;> try apply algebraMap
    <;> simp_all

===== Proof 1607 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction' hy with a ha r hr u v hu hv IH1 IH2
  <;> cases' hu with hu hu
  <;> cases' hv with hv hv
  <;> subst hu
  <;> subst hv
  <;> simp only [assoc, one_mul] at *
  <;> cases' ha with ha ha
  <;> cases' hr with hr hr
  <;> subst ha
  <;> subst hr
  <;> simp only [algebraMap_eq, one_mul] at *
  <;> cases' add with _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  <;> cases' mul with _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  <;> cases' closure with _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
  <;> simp only [assoc, one_mul] at *
  <;> apply self
  <;> apply star_self
  <;> apply algebraMap
  <;> apply add
  <;> apply mul
  <;> apply closure

===== Proof 1608 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induct hy with
  | algebraMap r => exact algebraMap r
  | star u hu => exact star_self u hu
  | add u hu v hv huv => exact add u hu v hv huv
  | mul u hu v hv huv => exact mul u hu v hv huv
  | closure s hs h s => exact closure s hs h s

===== Proof 1609 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  letI : Add A := by infer_instance
  letI : Star A := by infer_instance
  letI : Algebra R A := by infer_instance
  letI : IsStarAlgebra R A := by infer_instance
  induction hy
  <;> simp_all
  <;> apply_assumption
  <;> simp_all

===== Proof 1610 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by mention+ y hy; exact hy.recOn self (fun u hu ‚Ü¶ closure _ ?_ (fun _ ‚Ü¶ .app u) _ hu)

===== Proof 1611 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  have : ‚àÄ u, (hu : u ‚àà elementalStarAlgebra R x) ‚Üí P u hu := by
    intro u hu
    obtain ‚ü®u, rfl‚ü© := hu
    induction u using A.induction_on with
    | algebraMap _ i => exact algebraMap _ _ i
    | star u ih => exact star_self u ih
    | add u v _ _ iu iv => exact add _ _ _ _ iu iv
    | mul u v _ _ iu iv => exact mul _ _ _ _ iu iv
    | closure s _ ih => exact closure s _ ih _ (subset_closure _)
  exact this _ hy

===== Proof 1612 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction hy
  case self => apply self
  case star_self => apply star_self
  case algebraMap => apply algebraMap
  case add => apply add
  case mul => apply mul
  case closure => apply closure

===== Proof 1613 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  refine' inductionOn' y hy fun y hy => _
  induction y using A.ind_on generalizing hy with
  | h_self x => exact self hy
  | h_star x => exact star_self hy
  | h_algebraMap r => exact algebraMap r hy
  | h_add u hu v hv hu' hv' => exact add u hu v hv hu' hv'
  | h_mul u hu v hv hu' hv' => exact mul u hu v hv hu' hv'
  | h_closure s hs ih => exact closure s hs ih hy

===== Proof 1614 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  refine' closure_induction hy (fun _ _ => Iff.mpr And.left)
    (fun _ _ => Iff.mpr And.left) self star_self algebraMap add mul closure

===== Proof 1615 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction' hy with y' y' hy' ih y' q P hq {a b} _ _ _ _ Hp r
  all_goals (constructor_with_yoneda P; arbitrary)
  exacts [self,
          (star_self (q := q)),
          algebraMap R A r,
          add y' _ y' _ _ _ Hp Hp,
          mul y' _ y' _ _ _ Hp Hp,
          closure _ _ fun u hu => Hp _ (hy' hu)]

===== Proof 1616 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 
  letI : Set A := {x}
  letI : Set A := {x, star x}
  induction hy using Submodule.span_induction with
  | mem_self => exact self
  | mem_star_self => exact star_self
  | mem_algebraMap => exact algebraMap _
  | mem_add => apply add
  | mem_mul => apply mul
  | mem_closure s =>
    exact closure s (by simp) (by simp) _ (by simp)

===== Proof 1617 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction' y, hy with _ y hy z w hz hw y r hy u v hu hv s ih s_closure s hs usu hsu hsv hsu hsv
  exacts [self, star_self, algebraMap r, add u hu v hv, mul u hu v hv, closure s s_closure fun u hu => ih u hu]

===== Proof 1618 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  rw [‚Üê subsingleton_iff_star_trivial] at *
  refine' closure s _ (fun _ h => .inl rfl) y hy
  rintro u hu ‚ü®rfl‚ü©
  replace hu := self_mem R u
  revert hu
  simp_rw [Subsingleton.elim u (algebraMap R A r)]
  simp

===== Proof 1619 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  apply @closure _ _ _ _ _ (elementalStarAlgebra R x) _ self hy
  intro u hu hP; exact PStarAlgebra.of_submodule_closure _ _ hP

===== Proof 1620 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  cases' hy with u hu
  simpa using closure u hu

===== Proof 1621 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  rw [‚Üê Ring.closure_subset_iff_isClosed.2 (isClosed R : RingTopology.closedEmbedding x)] at hy
  induction hy using inductionStarAlgebraBase.f varsVars (self x)
    (ringAlgebraMap algebraMap) (fun _ ‚Ü¶ mul) (fun _ ‚Ü¶ add) (fun _ ‚Ü¶ closure)

===== Proof 1622 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  apply induction_on' y hy
  apply induction_on y hy <;> simp [self, star_self, algebraMap, add, mul, closure]

===== Proof 1623 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction hy with
  | self => exact self
  | star_self => exact star_self
  | algebraMap r => exact algebraMap r
  | add u _ v _ hu hv => exact add u _ v _ hu hv
  | mul u _ v _ hu hv => exact mul u _ v _ hu hv
  | closure s _ hu v hv => exact closure s _ hu v hv

===== Proof 1624 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction hy
  case self => exact self
  case star_self => exact star_self
  case algebraMap => exact algebraMap _
  case add => exact add _ _ _ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
  case mul => exact mul _ _ _ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
  case closure => exact closure _ _ ‚Äπ_‚Ä∫ _

===== Proof 1625 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  exact (closure (elementalStarAlgebra R x)
    (subset_closure R x) fun x hx => by simpa using induction_on hy hx self) hy

===== Proof 1626 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  let R' : Subring R := {
    carrier := {r | P (algebraMap R A r) (algebraMap_mem R r)}
    zero_mem' := by simpa using algebraMap 0
    one_mem' := by simpa using algebraMap 1
    add_mem' := by
      intro a b ha hb
      simp only at ha hb ‚ä¢
      rw [‚Üê add_algebraMap, map_add]
      exact add _ _ _ _ ha hb
    neg_mem' := by
      intro a ha
      simp only at ha ‚ä¢
      rw [‚Üê neg_algebraMap, map_neg]
      exact add _ _ _ _ ha ha
    mul_mem' := by
      intro a b ha hb
      simp only at ha hb ‚ä¢
      rw [‚Üê mul_algebraMap, map_mul]
      exact mul _ _ _ _ ha hb
    subset_closure := by
      intro r hr
      simp only [Set.mem_setOf_eq] at hr ‚ä¢
      exact hr
  }
  letI := R'
  induction hy
  case h_algebraMap r => simpa using algebraMap r
  case h_add u hu v hv _ _ => simpa using add _ _ _ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
  case h_mul u hu v hv _ _ => simpa using mul _ _ _ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
  case h_star u hu => simpa using star_self
  case h_closure s hsub hind u hu => simpa using closure s hsub hind _ ‚Äπ_‚Ä∫

===== Proof 1627 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  revert hy
  apply Post.star_induction hy
  exacts [self, by convert star_self, algebraMap, add, mul, fun s hs ih v hv ‚Ü¶ by
    have := closure s hs ih v hv
    rwa [‚Üê Subalgebra.mem_toSubmodule, Subalgebra.mem_toSubmodule] at this]

===== Proof 1628 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  refine' induction_on' A _ hy _ self _ star_self _ _ _
  all_goals exact fun W hW => by simp only [hW, algebraMap_mem, add_mem, mul_mem,
    closure_minimal, isClosed_closure, forall_const, add_closure.prop, mul_closure.prop,
    spectral_closure.prop, le_eq_subset, star_mem, star_self_mem, self_mem, _root_.algebraMap_mem]
  all_goals simp only [self, star_self, algebraMap, add, mul, closure]

===== Proof 1629 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  induction' hy with y hy
  exacts [self,
    star_self,
    algebraMap _ _,
    add _ _ _ _ _ _ (motive := fun y hy => P y hy) ,
    mul _ _ _ _ _ _ (motive := fun y hy => P y hy),
    closure _ _ (motive := fun y hy => P y hy)]

===== Proof 1630 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  let s : Set A := {x, star x}
  have hx : x ‚àà s := by simp
  have hstarx : star x ‚àà s := by simp
  have hs : s ‚äÜ elementalStarAlgebra R x := by
    simp only [s, Set.singleton_subset_iff, Set.insert_subset_iff]
    exact ‚ü®self_mem R x, star_self_mem R x‚ü©
  exact closure s hs (fun u hu => by
    aesop) y hy

===== Proof 1631 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  classical
    induction' hy with z hz
    ¬∑ exact self
    ¬∑ exact star_self
    ¬∑ exact algebraMap _
    ¬∑ exact fun _ u v hu Puv hv Puv' => add _ _ _ _ (Puv _ hu) (Puv' _ hv)
    ¬∑ exact fun _ u v hu Puv hv Puv' => mul _ _ _ _ (Puv _ hu) (Puv' _ hv)
    ¬∑ exact fun s hs _ hu => closure s hs hu

===== Proof 1632 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ‚àà elementalStarAlgebra R x) {P : (u : A) ‚Üí u ‚àà elementalStarAlgebra R x ‚Üí Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ‚àÄ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u + v) (add_mem hu hv))
    (mul : ‚àÄ u hu v hv, P u hu ‚Üí P v hv ‚Üí P (u * v) (mul_mem hu hv))
    (closure : ‚àÄ s : Set A, (hs : s ‚äÜ elementalStarAlgebra R x) ‚Üí (‚àÄ u, (hu : u ‚àà s) ‚Üí
      P u (hs hu)) ‚Üí ‚àÄ v, (hv : v ‚àà closure s) ‚Üí P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by
  revert y
  apply @closure (elementalStarAlgebra R x) _
  intro y hy
  simp only [Subtype.coe_mk] at hy ‚ä¢
  revert hy
  apply @closure (elementalStarAlgebra R x) _
  intro y hy
  simp only [Subtype.coe_mk] at hy ‚ä¢
  exact
    match y, hy with
    | ‚ü®y, hy‚ü© =>
      hy.recOn self (fun r => _root_.algebraMap_mem _ r) (fun u hu v hv _ _ => _root_.add_mem hu hv)
        fun u hu v hv _ _ => _root_.mul_mem hu hv
  <;> rfl

===== Proof 1633 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf, mem_blimsup_iff_eventually_mem]
  refine ‚ü®fun h ‚Ü¶ ‚ü®fun ht ‚Ü¶ h ht p_true‚ü©, fun h ht _ ‚Ü¶ ?_‚ü©
  obtain ‚ü®n, hn, hx‚ü© := h ht
  exact hx hn

===== Proof 1634 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  simp (config := { contextual := true }) [blimsup, blimsup_eq_limsup, limsup_eq_compl_liminf_compl,
    frequently_iff, not_imp_not, and_comm, and_left_comm]

===== Proof 1635 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [blimsup_eq, le_eq_subset, eventually_cofinite, not_forall,
    not_subset, exists_prop]
  aesop

===== Proof 1636 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [Filter.mem_blimsup, mem_setOf_eq]
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, fun h' ‚Ü¶ h' ‚ñ∏ h ‚ü®x, rfl‚ü©‚ü©, fun h h' ‚Ü¶ ?_‚ü©
  ¬∑ rcases h with ‚ü®y, rfl‚ü©
    exact ‚ü®y, rfl‚ü©
  ¬∑ rcases h with ‚ü®t, ht, ht'‚ü©
    rcases h' with ‚ü®y, rfl‚ü©
    exact ‚ü®y, rfl‚ü©

===== Proof 1637 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf, mem_blimsup_iff_eventually_mem]
  refine ‚ü®fun h ‚Ü¶ ‚ü®h‚ü©, fun h ‚Ü¶ ?_‚ü©
  obtain ‚ü®·∂†, hfin‚ü© := h
  exact hfin.mono fun n hn ‚Ü¶ hn.1

===== Proof 1638 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [blimsup_eq, mem_setOf_eq]
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ refine mem_compl_iff.mp (h <| subset_blimsup s <| by simp [mem_cofinite])
  ¬∑ simp_rw [mem_compl_iff] at h
    exact blimsup_eq_of_forall_not_mem h

===== Proof 1639 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [blimsup_eq, iff_self_iff, mem_setOf_eq, mem_compl_iff, not_exists, not_not]
  aesop

===== Proof 1640 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  simp only [Filter.blimsup_eq, cofinite.blimsup_eq, mem_setOf_eq, @and_comm (x ‚àà _),
    mem_compl_iff, Set.Infinite, not_not]
  rfl

===== Proof 1641 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [blimsup_eq_limsup, Filter.mem_sets, mem_setOf_eq]
  refine ‚ü®fun ‚ü®i, hi, hx‚ü© ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü© <;> contrapose! h
  ¬∑ exact hx.mono (fun n hn ‚Ü¶ ‚ü®hi n hn, hn‚ü©)
  ¬∑ rcases h with ‚ü®i, hi, hx‚ü©
    exact ‚ü®i, hi, by simpa using hx‚ü©

===== Proof 1642 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf, mem_blimsup_iff_eventually, ‚Üê compl_setOf, bex_def]
  refine ‚ü®fun h ‚Ü¶ ‚ü®fun ht ‚Ü¶ ?_‚ü©, fun h ‚Ü¶ ‚ü®fun ht ‚Ü¶ ?_‚ü©‚ü© <;>
    simp_all only [Set.compl_setOf, bex_def, not_exists, not_and, mem_compl_iff]
  all_goals aesop

===== Proof 1643 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [Filter.mem_blimsup, mem_setOf_eq]
  refine' ‚ü®fun h => ‚ü®h‚ü©, fun h => ?_‚ü©
  obtain ‚ü®‚ü®n, hn, hx‚ü©, h‚ü© := h
  exact ‚ü®n, hn, hx, h‚ü©
-- named to match the previous theorems


theorem cofinite.bliminf_set_eq :
    bliminf s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Finite } := by
  ext x
  simp only [Filter.mem_bliminf, mem_setOf_eq]
  refine' ‚ü®fun h => ‚ü®h‚ü©, fun h => ?_‚ü©
  obtain ‚ü®‚ü®n, hn, hx‚ü©, h‚ü© := h
  exact ‚ü®n, hn, hx, h‚ü©

===== Proof 1644 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x; simp [mem_blimsup_iff]

===== Proof 1645 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [Filter.mem_blimsup, Set.Infinite, exists_prop, and_assoc]

===== Proof 1646 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x; simp [Filter.frequently_iff]

===== Proof 1647 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [blimsup_eq_limsup, cofinite.blimsup_eq, mem_setOf_eq, limsup_eq_limsup,
    eventually_cofinite, not_forall, not_not]
  rfl

===== Proof 1648 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf, mem_blimsup_iff_eventually_mem]
  refine ‚ü®fun ‚ü®S, hS, hx‚ü© ‚Ü¶ ‚ü®S, hS, fun n hn ‚Ü¶ hx n hn.1‚ü©, fun ‚ü®S, hS, hx‚ü© ‚Ü¶ ‚ü®S, hS, ?_‚ü©‚ü©
  intro n hn
  exact hx n ‚ü®hn, rfl‚ü©

===== Proof 1649 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  refine' ‚ü®fun h => _, fun h => _‚ü© <;> contrapose! h
  ¬∑ use { n | p n ‚àß x ‚àà s n }.Finite
    simp [h]
  ¬∑ obtain ‚ü®n, hn‚ü© := h
    exact ‚ü®n, hn‚ü©

===== Proof 1650 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf_eq, mem_blimsup_iff_eventually_mem]
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, fun hfin ‚Ü¶ hfin.false‚ü©, fun h ‚Ü¶ ‚ü®h.1, fun t h‚ÇÅ h‚ÇÇ ‚Ü¶ ?_‚ü©‚ü©
  ¬∑ rintro ‚ü®t, ht, n, hn, hx‚ü©
    exact h‚ÇÇ ((ht hn).1.mono hx)
  ¬∑ have := h.2 t h‚ÇÅ
    exact this (hfin.mono h‚ÇÇ)

===== Proof 1651 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x; simp [mem_setOf_eq]
  aesop

===== Proof 1652 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf, mem_blimsup, frequently_cofinite, setOf_biInter, setOf_mem_eq]
  tauto

===== Proof 1653 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf, mem_blimsup_iff_eventually_mem]
  refine' ‚ü®fun h => ‚ü®fun ht => h ht p‚ü©, fun h ht => ?_‚ü©
  contrapose! h
  simp only [exists_prop, Set.Finite, not_true, and_true, exists_and_right, iff_true] at h
  exact h.subset (ht _)

theorem cofinite.bliminf_set_eq : bliminf s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Finite } := by
  ext x; simp

===== Proof 1654 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf, blimsup_eq_limsup, eventually_cofinite, limsup_eq_limsup,
    eventually_map, mem_setOf, and_assoc]
  congr! 3
  simp_rw [mem_compl_iff, ‚Üê not_and, not_not]

===== Proof 1655 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [blimsup_eq, le_eq_subset, eventually_cofinite, not_forall, exists_prop]
  constructor <;> intro h <;> have h' := h
  <;> contrapose! h' <;> have h'' := h'
  <;> simp only [Set.not_infinite, Set.finite_coe_iff, exists_prop] at h''
  <;> simp only [Set.infinite_coe_iff, Set.not_infinite, Set.finite_coe_iff, exists_prop] at h'
  <;> tauto

===== Proof 1656 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf_eq, mem_compl_iff, limsup_eq_iInf, mem_iInter, mem_iInf_of_finite,
    Finite.mem_toFinset, Finite.mem_toFinset]
  refine' ‚ü®fun h => _, fun h n => _‚ü© <;> contrapose! h <;> rw [not_infinite] at h <;>
    exact h.finite_of_fintype

===== Proof 1657 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf_eq, mem_blimsup_iff_frequently, frequently_iff]
  constructor
  ¬∑ rintro ‚ü®n, hn, hx‚ü©
    exact ‚ü®n, hn, hx‚ü©
  ¬∑ rintro ‚ü®n, hn, hx‚ü©
    exact ‚ü®n, hn, hx‚ü©

===== Proof 1658 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  simp only [Filter.blimsup_eq, hasBasis_cofinite.superset_iff, mem_setOf_eq,
    @and_comm (x ‚àà _)]
  rfl

===== Proof 1659 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  simp only [blimsup_eq, le_eq_subset, eventually_cofinite, not_forall, exists_prop]
  ext x
  simp only [exists_prop, mem_setOf, mem_compl_iff, @and_comm (x ‚àà _),
    mem_setOf_eq, not_exists, not_forall, exists_prop, exists_imp, mem_setOf_eq,
    mem_compl_iff, and_imp, exists_prop, and_comm, exists_prop]
  aesop

===== Proof 1660 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [blimsup_eq, bliminf_eq, eventually_cofinite, not_forall, exists_prop, not_not]
  simp only [mem_setOf_eq, mem_compl_iff, mem_not_mem_finset, not_false_iff,
    and_imp, setOf_bijective, exists_eq_right, false_and_iff, not_true, and_false_iff,
    isCompl_compl, and_self_iff]

===== Proof 1661 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf, mem_blimsup_iff_eventually_mem]
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, fun t ht ‚Ü¶ ht.mono fun n hn ‚Ü¶ h n t ht hn‚ü©,
    fun h t ht hx ‚Ü¶ (h t).imp fun n hn ‚Ü¶ hn.2 (hx n t ht)‚ü©
  exact fun t ht ‚Ü¶ h t ht ht.1

===== Proof 1662 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [mem_setOf_eq, mem_blimsup_iff_eventually_mem,
    exists_prop, exists_imp]
  refine ‚ü®fun h ‚Ü¶ ‚ü®h.mono fun n hn ‚Ü¶ hn.1, ?_‚ü©,
    fun h n hn x hx ‚Ü¶ h.2 n hn hx‚ü©
  contrapose! h
  exact ‚ü®fun n hn ‚Ü¶ (h n).choose_spec.2.2 hx,
    fun n hn ‚Ü¶ (h n).choose_spec.2.1‚ü©

theorem cofinite.bliminf_set_eq :
    bliminf s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Finite } := by
  ext x
  simp only [mem_setOf_eq, mem_bliminf_iff_eventually_mem,
    exists_prop, exists_imp]
  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, h.mono fun n hn ‚Ü¶ hn.2‚ü©,
    fun h n hn ‚Ü¶ ‚ü®h.choose, hn, h.choose_spec.2‚ü©‚ü©
  contrapose! h
  exact ‚ü®fun n hn ‚Ü¶ (h n).choose_spec.1, fun n hn ‚Ü¶ (h n).choose_spec.2 hx‚ü©

===== Proof 1663 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  simp only [blimsup_eq, le_eq_subset, eventually_cofinite, not_forall, exists_prop]
  ext x
  simp only [mem_setOf_eq, mem_compl_iff, limsup_eq, le_eq_subset, eventually_cofinite, not_forall,
    exists_prop]
  constructor
  next =>
    intro h
    contrapose! h
    simp only [not_not, exists_prop, and_assoc] at h ‚ä¢
    exact ‚ü®x, h‚ü©
  next =>
    intro h
    contrapose! h
    simp only [not_not, exists_prop, and_assoc] at h ‚ä¢
    exact ‚ü®x, h‚ü©

===== Proof 1664 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by
  ext x
  simp only [blimsup_eq, le_eq_subset, eventually_map, mem_setOf_eq, mem_compl_iff,
    Subset.rfl, true_and] at *
  congr!
  ext n
  simp only [mem_setOf_eq, and_comm, Prod.exists, exists_and_right, iff_self_iff, exists_prop]

===== Proof 1665 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, vsub_sub_vsub_comm (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ), nnnorm_vsub_rev,
    nnnorm_vsub_comm]
  apply nndist_triangle_left

===== Proof 1666 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, vsub_eq_sub, map_sub]
  apply NNReal.coe_le_coe.1
  apply norm_sub_le

===== Proof 1667 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  norm_num
  apply VSub.vsub_le_vsub_add_vsub

===== Proof 1668 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, ‚Üê vsub_sub_vsub_comm]
  apply NNReal.coe_le_coe.mp
  rw [‚Üê Real.norm_of_nonneg]
  exact norm_vsub_le _ _
  exact add_nonneg (nndist_nonneg : 0 ‚â§ nndist p‚ÇÅ p‚ÇÉ) (nndist_nonneg : 0 ‚â§ nndist p‚ÇÇ p‚ÇÑ)

===== Proof 1669 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, vsub_sub_vsub]
  apply NNReal.coe_le_coe.2
  simp only [coe_nnnorm, norm_sub_rev]
  apply dist_triangle_right

===== Proof 1670 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  apply nndist_le_nndist_add_nndist_of_nndist_add_nndist_le
  rw [add_comm]
  apply nndist_comm

===== Proof 1671 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V]
  norm_cast
  apply dist_vsub_vsub_le

===== Proof 1672 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, vsub_sub_vsub_comm]
  norm_cast
  exact norm_sub_le _ _

===== Proof 1673 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V]
  have h1 := nndist_triangle_left p‚ÇÅ p3 p‚ÇÇ
  have h2 := nndist_triangle_left p‚ÇÉ p2 p4
  have h3 := nndist_triangle_left p‚ÇÇ p4 p1
  have h4 := nndist_triangle_left p4 p3 p1
  have h5 := nndist_triangle_left p4 p1 p2
  have h6 := nndist_triangle_left p1 p2 p3
  have h7 := nndist_triangle_left p2 p3 p4
  have h8 := nndist_triangle_left p3 p4 p1
  have h9 := nndist_triangle_left p4 p2 p1
  linarith

===== Proof 1674 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnnorm_vsub, nndist_eq_nnnorm_vsub]
  rw [nnnorm_sub_le_of_le (nndist_vadd_vadd_le p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ) (nndist_vadd_vadd_le p‚ÇÇ p‚ÇÑ p‚ÇÅ p‚ÇÉ)]
  abel

===== Proof 1675 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V]
  apply NNReal.coe_le_coe.mp
  simp only [‚Üê NNReal.coe_add, NNReal.coe_le_coe]
  exact dist_vsub_vsub_le p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ

===== Proof 1676 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, nndist_eq_nnnorm]
  convert norm_vsub_le (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) using 2
  simp only [vsub_vsub_vsub_cancel_right, vsub_vsub_vsub_cancel_left]

===== Proof 1677 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V]
  convert norm_vsub_le_norm_add_norm (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ)
  simp [add_comm, add_left_comm, add_assoc]

===== Proof 1678 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, vsub_eq_sub, P.nnnorm_sub_rev _ _]
  apply nnnorm_sub_le_of_le

===== Proof 1679 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V]
  apply NNReal.coe_le_coe.1
  simp only [NNReal.coe_add, ite_add, ‚Üê NNReal.coe_le_coe]
  exact dist_vsub_vsub_le _ _ _ _

===== Proof 1680 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simpa [nndist_eq_coe_dist] using dist_vsub_vsub_le p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ

===== Proof 1681 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, sub_sub_sub_cancel_right]
  apply le_trans (nnnorm_sub_le _ _)
  exact add_le_add (nnnorm_sub_le _ _) (nnnorm_sub_le _ _)

===== Proof 1682 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, vsub_eq_sub]
  let AB := p‚ÇÅ -·µ• p‚ÇÇ - (p‚ÇÉ -·µ• p‚ÇÑ)
  have : 0 ‚â§ ‚ÄñAB‚Äñ := by
    apply norm_nonneg
  have h‚ÇÅ : ‚Äñp‚ÇÅ -·µ• p‚ÇÇ - (p‚ÇÉ -·µ• p‚ÇÑ)‚Äñ ^ 2 = (nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ) ^ 2 - 2 * (nndist p‚ÇÅ p‚ÇÉ * nndist p‚ÇÇ p‚ÇÑ) := by
    simp only [nndist_eq_nnnorm, vsub_eq_sub]
    ring_nf
  nlinarith

===== Proof 1683 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnreal_dist, nndist_eq_nnreal_dist, nndist_eq_nnreal_dist]
  exact dist_vsub_vsub_le p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ

===== Proof 1684 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_def, nndist_def, nndist_def]
  simp only [dist_eq_norm, ‚Üê sq]
  convert dist_vsub_vsub_le p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ
  simp [dist_eq_norm]

===== Proof 1685 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V]
  apply le_trans (nnnorm_vsub_le _ _)
  rw [add_assoc, add_comm, add_assoc]
  apply le_trans (add_le_add_left (nnnorm_vsub_le _ _) _)
  rw [add_assoc, add_comm, add_assoc]
  apply le_trans (add_le_add_left (nnnorm_vsub_le _ _) _)
  simp only [nnnorm_vsub_rev]
  linarith

===== Proof 1686 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_nnnorm_vsub V, nndist_eq_nnnorm_vsub V]
  apply NNReal.coe_le_coe.2
  simp only [‚Üê NNReal.coe_add, NNReal.coe_le_coe, ‚Üê dist_eq_norm_vsub V]]
  apply dist_triangle_right

===== Proof 1687 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  /-
  We aim to show that for any four points \( p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ \) in a metric space \( P \), the nonnegative distance between the vectors \( p‚ÇÅ - p‚ÇÇ \) and \( p‚ÇÉ - p‚ÇÑ \) is less than or equal to the sum of the nonnegative distances between \( p‚ÇÅ \) and \( p‚ÇÉ \) and between \( p‚ÇÇ \) and \( p‚ÇÑ \).
  
  1. Start by expressing the nonnegative distances in terms of the norm of the differences.
  2. Use the property of the norm that the norm of the difference of two vectors is less than or equal to the sum of their norms.
  3. Combine these inequalities to obtain the desired result.
  -/
  -- Express the nonnegative distances in terms of the norm of the differences.
  rw [nndist_eq_coe_nnnorm, nndist_eq_coe_nnnorm, nndist_eq_coe_nnnorm]
  -- Use the property of the norm that the norm of the difference of two vectors is less than or equal to the sum of their norms.
  convert norm_sub_le (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ)
  -- Combine these inequalities to obtain the desired result.
  simp [sub_eq_add_neg, add_comm, add_left_comm, add_assoc]

===== Proof 1688 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, ‚Üê vsub_sub_vsub_comm]
  apply NNReal.coe_le_coe.2
  rw [‚Üê Real.norm_of_nonneg]
  apply norm_sub_le
  exact add_nonneg (norm_nonneg _) (norm_nonneg _)

===== Proof 1689 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, vsub_eq_sub, sub_vsub_vsub_comm]
  norm_cast
  apply nnnorm_sub_le

===== Proof 1690 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simpa only [nndist_nndist, NNReal.coe_le_coe] using dist_vsub_vsub_le p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ

===== Proof 1691 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, vsub_eq_sub, add_sub_add_comm]
  exact nnnorm_sub_le _ _

===== Proof 1692 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simp only [nndist_eq_nnnorm, vsub_eq_sub]
  apply nnnorm_sub_le

===== Proof 1693 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  simpa only [nndist_nndist, NNReal.coe_le_coe] using dist_vsub_vsub_le p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ

===== Proof 1694 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_coe_dist, nndist_eq_coe_dist]
  have h‚ÇÅ : dist p‚ÇÅ p‚ÇÉ ‚â• 0 := dist_nonneg
  have h‚ÇÇ : dist p‚ÇÇ p‚ÇÑ ‚â• 0 := dist_nonneg
  rw [sub_eq_add_neg, sub_eq_add_neg]
  apply dist_vadd_vadd_le

===== Proof 1695 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_eq_coe_dist, nndist_eq_coe_dist, nndist_eq_coe_dist, nndist_eq_coe_dist]
  rw [dist_vsub_vsub_le]
  apply coe_le_coe

===== Proof 1696 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : P) :
    nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := by
  rw [nndist_comm, nndist_comm (p‚ÇÉ -·µ• p‚ÇÑ)]
  apply nndist_vsub_le_add_nndist

===== Proof 1697 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  rw [compare_lt_compare_iff]
  norm_num
  linarith

===== Proof 1698 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  intro f g hf hg hfg x‚ÇÅ x‚ÇÇ h
  obtain ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü© := h
  simp only [Function.funext_iff] at hfg
  specialize hfg x‚ÇÅ
  simp only [hx‚ÇÅ, hx‚ÇÇ, true_and, and_true] at hfg
  exact hfg

===== Proof 1699 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  /-
  To prove that for a continuous function \( f: X \to Y \) and any point \( x \in X \), the function \( g: X \to X \times Y \) defined by \( g(x) = (x, f(x)) \) is an embedding at \( x \), we proceed as follows:
  
  1. **Continuity of \( g \)**: Since \( f \) is continuous, the function \( g \) defined by \( g(x) = (x, f(x)) \) is also continuous. This follows from the fact that the product of continuous functions is continuous.
  
  2. **Openness of the preimage**: We need to show that for any open set \( U \subseteq X \times Y \), the set \( g^{-1}(U) \) is open in \( X \). Given that \( g \) is continuous, this property holds.
  
  3. **Injectivity**: We need to show that \( g \) is injective at \( x \). Suppose \( g(x_1) = g(x_2) \), then \( (x_1, f(x_1)) = (x_2, f(x_2)) \). By the definition of \( g \), this implies \( x_1 = x_2 \) and \( f(x_1) = f(x_2) \). Since \( f \) is continuous, \( f(x_1) = f(x_2) \) implies \( x_1 = x_2 \).
  
  4. **Topology preservation**: We need to show that \( g \) is a homeomorphism onto its image. This means that for any open set \( V \subseteq X \times Y \) containing \( g(x) \), there exists an open set \( U \subseteq X \) containing \( x \) such that \( g(U) = V \). Given that \( g \) is continuous and \( f \) is continuous, this property holds.
  
  Combining these steps, we conclude that \( g \) is an embedding at \( x \).
  -/
  constructor
  ¬∑ continuity
  intro s
  rw [Set.preimage, isOpen_induced_iff]
  constructor
  ¬∑ intro hg
    obtain ‚ü®t, ht, ht'‚ü© := hg
    rw [Set.preimage_comp] at ht'
    obtain ‚ü®u, hu, hu'‚ü© := isOpen_prod_iff.1 ht'
    refine ‚ü®u, hu, ?_‚ü©
    rw [ht, Set.image_preimage_eq_inter_range]
    have : (fun p : X √ó Y => (p.1, p.2)) ‚Åª¬π' t = Prod.fst ‚Åª¬π' Prod.fst '' t ‚à© Prod.snd ‚Åª¬π' Prod.snd '' t := by
      ext p
      simp [‚Üê and_assoc, and_comm, and_left_comm]
    rwa [this]
  ¬∑ intro hg
    obtain ‚ü®u, hu, hu'‚ü© := isOpen_prod_iff.1 hg
    refine ‚ü®_, hu', ?_‚ü©
    rw [Set.preimage_comp, hu]
    rfl

===== Proof 1700 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by

#print "Importing x_prod_y_prod_z" from graph_theory.adj_matrix



open Finset Set Finset.Card

theorem sigma_top_le_sum_top [Nonempty Œ±] [LinearOrderedAddCommMonoid Œ≤] (s : Finset Œ±)
    (f : Œ± ‚Üí ‚Ñï) (w : Œ± ‚Üí Œ≤) :
    (‚àë a ‚àà s, w a) ‚â§ s.card * s.sup' (nonempty_of_ne_empty (by rintro rfl; simp)) w := by
  /-
  We aim to show that for a nonempty graph \( \alpha \) and a linear ordered additive commutative monoid \( \beta \), the sum of the weights \( w \) of a set \( s \) of vertices is less than or equal to the number of vertices in \( s \) multiplied by the maximum weight of a vertex in \( s \).
  1. **Base Case**: If \( s \) is empty, the sum of weights is zero, and the result holds trivially since the product of the number of vertices (which is zero) and the maximum weight is also zero.
  2. **Inductive Step**: Assume the result holds for a set \( s \). Consider a set \( s \) with an additional element \( a \). The sum of weights in the new set is the sum of weights in \( s \) plus the weight of \( a \). The number of vertices in the new set is one more than the number of vertices in \( s \). The maximum weight in the new set is either the maximum weight in \( s \) or the weight of \( a \), whichever is greater. By the inductive hypothesis, the sum of weights in \( s \) is less than or equal to the number of vertices in \( s \) multiplied by the maximum weight in \( s \). Adding the weight of \( a \) to both sides, we get the sum of weights in the new set is less than or equal to the number of vertices in the new set multiplied by the maximum weight in the new set.
  -/
  induction s using Finset.induction with
  | empty =>
    -- Base case: If s is empty, the sum of weights is zero, and the result holds trivially.
    simp
  | @insert a s _ h =>
    -- Inductive step: Assume the result holds for s, and consider s with an additional element a.
    rw [Finset.sum_insert h, Nat.cast_succ, add_mul, one_mul]
    -- Rewrite the sum of weights in the new set and simplify the expression.
    refine le_trans ?_ (add_le_add_left (h s w) _)
    -- Apply the inductive hypothesis and conclude the proof.
    simp_all

===== Proof 1701 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  intro x y hxy
  simp only [Prod.mk.inj_iff] at hxy
  obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := hxy
  simpa using h‚ÇÅ

===== Proof 1702 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  /-
  We aim to show that for a continuous function \( f : X \to Y \) between topological spaces, the function \( g : X \to X \times Y \) defined by \( g(x) = (x, f(x)) \) is an embedding. This means that \( g \) is a continuous injective function whose image is a subspace of \( X \times Y \) that has the same topology as \( X \).
  
  To prove this, we start by noting that the function \( g \) is continuous because both the identity function \( x \mapsto x \) and the continuous function \( f \) are continuous. The composition of continuous functions is continuous, hence \( g \) is continuous.
  
  Next, we need to show that \( g \) is injective and that the topology on the image of \( g \) is the same as the topology on \( X \). For injectivity, observe that if \( g(x_1) = g(x_2) \), then \( (x_1, f(x_1)) = (x_2, f(x_2)) \). This implies \( x_1 = x_2 \) because the first component of the pairs must be equal.
  
  For the topology, consider an open set \( U \subseteq X \). The set \( g(U) = U \times f(U) \) is open in \( X \times Y \) because \( U \) is open in \( X \) and \( f \) is continuous, so \( f(U) \) is open in \( Y \). Therefore, \( U \times f(U) \) is open in the product topology of \( X \times Y \).
  
  Conversely, if \( V \subseteq X \times Y \) is open, then \( \{ x \in X \mid (x, f(x)) \in V \} \) is open in \( X \) because \( f \) is continuous. This shows that the topology on the image of \( g \) is the same as the topology on \( X \).
  
  Thus, \( g \) is an embedding.
  -/
  refine'
    ‚ü®(continuous_id.prod_mk hf).continuousAt, _‚ü©
  intro x‚ÇÅ x‚ÇÇ h
  simp only [Function.funext_iff] at h
  exact Prod.ext (congr_arg Prod.fst h) (congr_arg Prod.snd h)

===== Proof 1703 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  refine ‚ü®?_, ?_‚ü©
  ¬∑ rintro ‚ü®x, y‚ü© ‚ü®x', y'‚ü© h
    simp only [Prod.mk.inj_iff] at h
    simpa [h] using hf.2 x x'
  ¬∑ intro x y h
    have h1 := Prod.mk.inj h
    simpa [h1] using hf.2 x.1 y.1

===== Proof 1704 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  /-
  To prove that the function \((x, x^2)\) is an embedding from \(\mathbb{R}\) to \(\mathbb{R}^2\), we need to show that it is injective and that its derivative is non-singular.
  
  1. **Injectivity**: The function \((x, x^2)\) is injective because if \(x_1 \neq x_2\), then \(x_1^2 \neq x_2^2\). This follows directly from the properties of real numbers.
  
  2. **Non-singular derivative**: The derivative of the function \((x, x^2)\) is \(\begin{pmatrix} 1 \\ 2x \end{pmatrix}\). To show that this derivative is non-singular, we need to show that its determinant is non-zero. The determinant of this matrix is \(1 \cdot x - 2x \cdot 1 = x - 2x = -x\). Since \(x \neq 0\) for any \(x \in \mathbb{R}\), the determinant is always non-zero, ensuring that the derivative is non-singular.
  
  Thus, the function \((x, x^2)\) is an embedding.
  -/
  refine' ‚ü®_, _‚ü©
  ¬∑ rintro ‚ü®x, y‚ü© ‚ü®x', y'‚ü© h
    simp only [Prod.mk.inj_iff] at h
    cases h
    exact h.1
  ¬∑ intro x
    -- Show that the derivative of (x, x^2) is non-singular
    rw [‚Üê sub_ne_zero]
    intro h
    -- The derivative of (x, x^2) is (1, 2x), and its determinant is -x
    -- Since x ‚â† 0, the determinant is always non-zero
    simpa [h] using (by linarith)

===== Proof 1705 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by

  intro f
  simp only [Nat.cast_succ, Set.mem_Icc, Nat.cast_zero]
  constructor
  ¬∑ intro h
    exact ‚ü®h.1 0, h.2 0‚ü©
  ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    constructor
    ¬∑ exact fun n =>
        le_trans h‚ÇÅ <| h.1 n
    ¬∑ exact fun n =>
        le_trans (h.2 n) h‚ÇÇ

===== Proof 1706 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  /-
  To show that the function \( \lambda x. (x, f x) \) is an embedding, we need to demonstrate that it is injective and that its image is homeomorphic to its domain. Given that \( f \) is continuous, we can use the embedding properties of the product function and the identity function to achieve this.
  
  1. **Injectivity**: The function \( \lambda x. (x, f x) \) is injective because if \( (x_1, f x_1) = (x_2, f x_2) \), then \( x_1 = x_2 \) and \( f x_1 = f x_2 \), implying \( x_1 = x_2 \).
  
  2. **Open Mapping**: We need to show that the image of the function \( \lambda x. (x, f x) \) is open in the codomain if and only if the preimage is open in the domain. Since \( f \) is continuous, the preimage of an open set in the codomain is open in the domain.
  
  3. **Homeomorphism**: The function \( \lambda x. (x, f x) \) is a homeomorphism onto its image because it is a continuous, injective function with a continuous inverse (the projection onto the first coordinate).
  -/
  refine ‚ü®?_, ?_‚ü©
  ¬∑ intro x y h
    simp only [Prod.mk.inj_iff] at h
    exact h.1
  ¬∑ intro s
    rw [continuous_iff_isOpen]
    intro t ht
    rw [isOpen_iff_mem_nhds]
    intro ‚ü®x, y‚ü© h
    simp only [Prod.mem_nhds_iff, isOpen_prod_iff] at h
    obtain ‚ü®a, b, ha, hb, hab‚ü© := h
    refine ‚ü®a, b, ha, hb, ?_‚ü©
    rintro ‚ü®z, w‚ü© ‚ü®hz, hw‚ü©
    simp only [Set.mem_preimage, Prod.mk.inj_iff]
    exact ‚ü®hz.1, hw.1, hab ‚ü®hz.1, hw.1‚ü©‚ü©

===== Proof 1707 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  have : ‚àÄ x : X, (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû) = (‚Äñ(x : ‚Ñù)‚Äñ‚Çä : ‚Ñù‚â•0‚àû) := fun x => rfl
  convert embedding_graph continuous_nnnorm
  ext1 x
  simp only [Function.comp_apply, Prod.mk.inj_iff, this]
  exact ‚ü®fun h => ‚ü®h.1, by rw [‚Üê h.2]; rfl‚ü©, fun h => ‚ü®h.1, by rw [h.2]; rfl‚ü©‚ü©

theorem embedding_graph_nnreal {f : X ‚Üí ‚Ñù‚â•0} (hf : Continuous f) :
    Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id

===== Proof 1708 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  intro x y
  simp [Function.funext_iff]
  exact Prod.mk.inj_iff

===== Proof 1709 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  intro f g hfg
  simp only [Set.ext_iff, Prod.forall, mem_preimage] at hfg ‚ä¢
  intro x y
  constructor <;> intro h
  ¬∑ simpa only [fst_mk, Prod.mk.inj_iff] using hfg h
  ¬∑ simpa only [fst_mk, Prod.mk.inj_iff] using hfg h.1

===== Proof 1710 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  intro Œ± J
  dsimp only [Set.mem_preimage, Function.comp_apply]
  aesop

===== Proof 1711 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  -- TODO: use 
===== Proof 1712 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  rintro ‚ü®x, y‚ü© ‚ü®x', y'‚ü©
  constructor <;>
    simp (config := { contextual := true }) only [(¬∑ ‚àò ¬∑), Prod.mk.inj_iff, and_true] <;>
      try simp [hf.eq_iff] <;> aesop

===== Proof 1713 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  let M :=
    {‚ü®0, 1‚ü©, ‚ü®1, 0‚ü©, ‚ü®1, 1‚ü©}
  let F := fun (x, y) => ite ((x, y) = ‚ü®0, 1‚ü©) 10 (ite ((x, y) = ‚ü®1, 0‚ü©) 11 12)
  let g : M ‚Üí ‚Ñï := fun x => match x with | ‚ü®0, 1‚ü© => 10 | ‚ü®1, 0‚ü© => 11 | ‚ü®1, 1‚ü© => 12
  have : F = g := by
    ext ‚ü®x, y‚ü©
    cases x <;> cases y <;> rfl
  rw [this]
  rfl

===== Proof 1714 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by rw [id_eq]; apply embedding_graph

===== Proof 1715 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  sorry

===== Proof 1716 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
/-
rule_nf -/
  /-
  Rename the hypotheses for clarity:
  - 
===== Proof 1717 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by apply embedding_prod_mk.2 <;> apply Continuous.comp <;> assumption

===== Proof 1718 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  /-
  To prove that the function \( f : X \to X \times Y \) defined by \( f(y) = (y, f(y)) \) is an embedding,
  we need to show that it is injective and that its inverse is continuous. The function \( f \)
  is injective because if \( f(y_1) = f(y_2) \), then \( y_1 = y_2 \) by the definition of \( f \). The continuity of the inverse can be shown by considering the projection onto the first component, which is continuous.
  -/
  refine' ‚ü®fun x‚ÇÅ x‚ÇÇ h => (congr_arg Prod.fst h : _), _‚ü©
  rintro ‚ü®x, y‚ü©
  rfl

===== Proof 1719 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  rintro ‚ü®s, hs, ‚ü®u, hu, hsu‚ü©‚ü©
  use s, hs
  refine ‚ü®?_, ?_‚ü©
  ¬∑ rw [hsu]
    exact hu
  ¬∑ rintro ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© hxy
    simpa [hsu, hx, hy] using hxy

===== Proof 1720 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  intro x
  apply Prod.ext
  all_goals aesop

===== Proof 1721 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  let x : X := 0
  let y : X := 1
  let f : C(X, Y) := ContinuousMap.const X 1
  let g : C(X, Y) := ContinuousMap.id Y
  have hfg : (f.prod g) x = (f x, g x) := rfl
  simp [hfg, show f x = 1 from rfl, show g x = 0 from rfl]

===== Proof 1722 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  have : Continuous fun x => (x, f x) := continuous_id.prod_mk hf
  apply embedding_of_embedding_compose this continuous_fst embedding_id

===== Proof 1723 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  rcases h‚ÇÄ with ‚ü®x, rfl‚ü©
  rcases h‚ÇÅ.exists_mk with ‚ü®y, rfl‚ü©
  exact ‚ü®x, rfl‚ü©

===== Proof 1724 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  intro b hb
  rcases hb with ‚ü®b, rfl‚ü©
  use b
  simp

===== Proof 1725 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  /--
  To prove that the function \( g(x) = (x, f(x)) \) is an embedding, we need to show that it is injective and that it induces the topology on \( X \) from the product topology on \( X \times Y \).
  
  1. **Injectivity**: Suppose \( g(x_1) = g(x_2) \). This means \( (x_1, f(x_1)) = (x_2, f(x_2)) \). By the definition of equality in the product space, we have \( x_1 = x_2 \) and \( f(x_1) = f(x_2) \). Since \( f \) is injective (as given by the hypothesis \( hf \)), we conclude \( x_1 = x_2 \).
  
  2. **Topology Induction**: We need to show that for any open set \( U \subseteq X \), the set \( g(U) \) is open in \( X \times Y \). Given \( U \) open in \( X \), the set \( g(U) = \{(x, f(x)) \mid x \in U\} \). Since \( f \) is continuous, \( f(U) \) is open in \( Y \). Therefore, \( g(U) = U \times f(U) \) is open in the product topology on \( X \times Y \).
  -/
  refine' ‚ü® _, _‚ü©
  intro x1 x2 h
  cases' h with h1 h2
  exact hf.injective (by simp_all)
  rintro U ‚ü®hU, hU'‚ü©
  rw [Set.preimage_preimage]
  exact ‚ü®hU, by continuity‚ü©

===== Proof 1726 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  refine ‚ü®?_, hf.injective_iff.1
    (injective_iff_map_eq_zero (f := fun x : X ‚Ü¶ (x, f x))).2
      fun x y ‚Ü¶ ?_‚ü©
  ¬∑ intro s hs
    exact ‚ü®s, hs, Set.preimage_id.symm‚ü©
  ¬∑ simp only [Prod.mk.inj_iff, eq_self_iff_true, true_and_iff]
    exact fun h ‚Ü¶ h

===== Proof 1727 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  let f : X ‚Üí (X √ó Y) := fun x ‚Ü¶ (x, f x)
  suffices h : EmbeddedSpace X √ó Y := by assumption
  have h : ‚àÄ x : X, ‚àÉ! y : Y, (x, y) ‚àà Set.range f := by
    intro x
    use f x
    constructor
    ¬∑ simp only [f, Set.mem_range, Prod.exists]
      exact ‚ü®x, rfl‚ü©
    ¬∑ intro y hy
      simp only [f, Set.mem_range, Prod.exists] at hy
      obtain ‚ü®z, hz‚ü© := hy
      simp only [f, Prod.mk.inj_iff] at hz
      rw [hz.2]
  exact .mk h

===== Proof 1728 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X ‚Üí Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  intro x y hxy
  apply Prod.mk.inj
  exact congr_arg Prod.fst hxy
  exact congr_arg Prod.snd hxy

===== Proof 1729 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  refine ‚ü®0, f.coeff 0, ?_, ?_‚ü©
  ¬∑ aesop
  ¬∑ rw [pow_zero, pow_one]
    nth_rewrite 1 [‚Üê hm.coeff_natDegree]
    apply Polynomial.monic.sub_of_left
    exact hm

===== Proof 1730 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  apply Exists.intro (0 : ‚Ñï)
  apply Exists.intro (-f.coeff 0)
  constructor
  left
  simp
  rw [pow_zero, pow_one]
  rw [‚Üê hm.coeff_natDegree]
  rw [h]
  simp
  rw [‚Üê hi.isUnit_or_isUnit]
  right
  rw [‚Üê isUnit_iff]
  rw [‚Üê frobenius_inj F q (-f.coeff 0)]
  simp
  rw [frobenius_neg F q (f.coeff 0)]
  rw [‚Üê hm.coeff_natDegree]
  rw [h]
  simp

===== Proof 1731 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  have hq : q ‚â† 0 := ExpChar.pos F q
  rw [‚Üê h] at hi
  rw [natSepDegree_eq_one_iff_monic_and_irreducible] at hi
  refine' ‚ü®0, f.coeff 0, _‚ü©
  aesop

===== Proof 1732 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0
  use 0
  rw [pow_zero, pow_zero]
  simp [h, hi, hm]

===== Proof 1733 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  refine' ‚ü®0, 0, _, _‚ü©
  exacts [Or.inl rfl, by rw [pow_zero, C_0, sub_zero, hm.eq_X_pow]]

===== Proof 1734 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  refine' ‚ü®1, f.coeff 0, _, _‚ü© <;> simp_all

===== Proof 1735 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  refine ‚ü®0, 0, ?_‚ü©; simp [*]

===== Proof 1736 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0
  use -f.coeff 0
  simp [h, hi, hm, ExpChar.neg_one_ne_one_of_char_ne_two F q]

===== Proof 1737 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  match n with
  | 0 =>
    match y with
    | 0 =>
      simpa only [pow_zero, pow_zero, C_0, sub_self, mul_zero, zero_sub,
        mul_one, one_pow, one_mul, zero_pow] using hf
    | _ =>
      simp only [frobenius_apply, zero_mul, sub_zero, sub_self, zero_pow, ne_eq,
        Nat.succ_ne_zero, not_false_eq_true, mul_zero]
  | _ =>
    simp only [zero_mul, sub_zero, sub_self, zero_pow, ne_eq, Nat.succ_ne_zero, not_false_eq_true,
      mul_zero]

===== Proof 1738 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0
  use 0
  simp [hm, hi, h]

===== Proof 1739 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  refine' ‚ü®0, 0, Or.inl rfl, _‚ü©
  simp [h, expChar_pow_dvd_iff]

===== Proof 1740 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  subst h
  obtain ‚ü®n, y, h‚ü© := hi.eq_pow_X_pow_char_pow_sub_C hm
  refine' ‚ü®n, y, _, _‚ü©
  aesop
  simpa [h] using ExpChar.pow_p_pow_sub_C q

===== Proof 1741 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0, 0
  simp
  rw [‚Üê hm.leadingCoeff]
  congr
  simp [h, hi.ne_zero]

===== Proof 1742 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0
  use f.coeff 0
  simp [*]

===== Proof 1743 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by

===== Proof 1744 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  refine' ‚ü®0, f.coeff 0, _, _‚ü©
  all_goals
    aesop

===== Proof 1745 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  have h1 : f.natSepDegree = 1 := h
  use 0
  use 0
  simp [h1]

===== Proof 1746 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0, f.coeff 0;
  simp [*, ExpChar.coeff_zero_eq_one]

===== Proof 1747 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0, 0
  simp only [zero_eq, eq_self_iff_true, zero_pow, zero_sub, sub_zero, true_and_iff,
    and_true_iff, exists_const, map_zero]
  aesop

===== Proof 1748 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  cases f
  rename_i a
  simp only [Monic, leadingCoeff, natSepDegree, natDegree, coeff,
    Monic.def, leadingCoeff_add_of_degree_lt, degree_zero, WithBot.bot_lt_coe,
    zero_add, ne_eq, Nat.cast_eq_zero, one_ne_zero, not_false_eq_true, and_self_iff,
    zero_sub, mul_one, zero_pow, Nat.succ_pos, zero_mul] at hm hi h
  aesop

===== Proof 1749 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  exact ‚ü®0, 0, Or.inl rfl, by rw [h, pow_zero, C_0, sub_zero, X_pow_eq_monic_X_pow hm]‚ü©

===== Proof 1750 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0, f.coeff 0; constructor
  ¬∑ simp
  rw [pow_zero, C_0, sub_zero, X_pow_char_pow_sub_C, hm.coeff_zero_eq_eval_zero]
  exact hi

===== Proof 1751 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0, 0
  simp [*]

===== Proof 1752 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  cases' Nat.eq_zero_or_pos h with h h <;>
    simp_all only [Polynomial.natSepDegree_C, Nat.pos_iff_ne_zero]
  all_goals
    obtain ‚ü®n, hn‚ü© := ExpChar.exists_eq_pow_p hm hi
    obtain ‚ü®y, hy‚ü© := ExpChar.eq_X_pow_char_pow_sub_C_of_irreducible hm hi hn
    exact ‚ü®n, y, by simp_all, by simp_all‚ü©

===== Proof 1753 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  refine' ‚ü®0, 0, _, _‚ü©
  exacts [by simp, by simp [h, hm.eq_X_pow_char_pow_sub_C hi]]

===== Proof 1754 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0
  use 0
  simp [h, hi]

===== Proof 1755 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  refine' ‚ü®0, 0, _, _‚ü©
  <;> simp [*]
  <;> simp_all

===== Proof 1756 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0
  by_cases h1 : y ‚àà (frobenius F q).range
  swap
  use 0
  simp_all
  exfalso
  apply Nat.not_lt_zero 1
  nlinarith

===== Proof 1757 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  ¬∑ exact ‚ü®0, 0, by simp, by simp [hi, h]‚ü©

===== Proof 1758 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  refine' ‚ü®0, 0, _, _‚ü© <;> aesop

===== Proof 1759 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  use 0
  use 0
  simp [h, hi]

===== Proof 1760 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ‚Ñï) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ‚àÉ (n : ‚Ñï) (y : F),
      (n = 0 ‚à® y ‚àâ (frobenius F q).range) ‚àß f = X ^ q ^ n - C y := by
  ¬∑ obtain ‚ü®y, hy‚ü© := Nat.exists_eq_succ_of_ne_zero h.bot_lt
    ¬∑ subst hy
      use 0, y
      simp [hi.eq_X_pow_char_pow_sub_C]

===== Proof 1761 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> simp (config := { contextual := true }) [mul_comm, lie_comm]

===== Proof 1762 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor
  next =>
    intro h
    apply IsLieAbelian.of_smul_comm
    intro a b
    rw [‚Üê mul_one a, ‚Üê mul_one b]
    apply h.1
  next =>
    intro h
    constructor
    next =>
      intro a b
      apply h.1
    next =>
      intro a b
      apply h.2

===== Proof 1763 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intro a b <;>
    simp_all only [LieRing.of_associative_ring_bracket, mul_neg, neg_mul, sub_neg_eq_add,
      add_left_comm, add_comm, mul_add, add_mul, mul_sub, sub_mul]
  all_goals
    linarith

===== Proof 1764 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intros <;> constructor <;> intros <;>
  simpa [mul_comm, mul_left_comm, mul_assoc] using ‚Äπ_‚Ä∫

===== Proof 1765 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  simp only [Std.Commutative (Œ± := A) (¬∑ * ¬∑), IsLieAbelian, mul_left_inj, mul_right_inj]
  constructor <;> intro <;> constructor
  <;> intros <;>
  simp only [*, mul_assoc, mul_comm, mul_left_comm, sub_eq_add_neg, neg_mul,
    lie_ring.of_associative_ring_bracket, lie_neg, lie_self, add_self, zero_add,
    add_zero, mul_zero, zero_mul, neg_zero, add_right_neg, add_left_neg,
    mul_sub, sub_mul, mul_eq_mul_left_iff, or_self, sub_self, sub_zero,
    lie_eq_zero, eq_self_iff_true, and_self, true_or]
  <;>
  linarith

===== Proof 1766 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  refine' ‚ü®fun h => ‚ü®fun a b => by simp [LieRing.of_associative_ring, h.1]‚ü©,
    fun h => ‚ü®fun a b => by simp [LieRing.of_associative_ring, h.1]‚ü©‚ü©

===== Proof 1767 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor
  all_goals intro; constructor <;> intro X Y <;> simp_all [mul_comm, lie_ab_def, mul_comm]

===== Proof 1768 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro h <;>
  simp_all [IsLieAbelian, mul_add, mul_assoc]
  <;> simp_all [mul_comm]
  <;> simp_all [mul_left_comm]
  <;> simp_all [mul_right_comm]

===== Proof 1769 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> simp_all [mul_comm, IsLieAbelian]

===== Proof 1770 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;>
  {
    funext x y
    simp [Std.Commutative, IsLieAbelian] at *
    assumption
  }

===== Proof 1771 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> simp_all
  <;> intros <;>
  simp_all [LieRing.of_surjective]

===== Proof 1772 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro h
  <;> simp_all [Std.Commutative, LieRing, LieAbelian, mul_comm, add_comm, neg_mul_eq_mul_neg]
  <;> linarith

===== Proof 1773 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intros <;> simp [*, mul_comm]

===== Proof 1774 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> simp_all
    End. (width 11; height 20)

===== Proof 1775 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor
  intro h; intro x y;
  rw [‚Üê mul_right_inj x]
  rw [‚Üê mul_left_inj y]
  simp [h.comm]
  intro h; intro x y
  apply h

===== Proof 1776 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  apply Iff.intro <;> intro <;> constructor <;> intro <;> simp_all [mul_comm, add_comm]

===== Proof 1777 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro h <;> simp_all [IsLieAbelian, mul_comm]

===== Proof 1778 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro hcomm
  <;> simp_all [Std.Commutative, IsLieAbelian]
  <;> intro a b
  <;> have h : a * b = b * a := hcomm a b
  <;> simp_all

===== Proof 1779 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intro a b <;> simp_all

===== Proof 1780 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intro a b
  <;> simp [‚Üê mul_comm] <;> simp [mul_comm]

===== Proof 1781 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intro <;> simp [*, mul_add, add_mul, mul_comm, mul_assoc,
    mul_left_comm] at * <;> linarith

===== Proof 1782 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intro a b <;> simp_all
  <;> ring_nf
  <;> linarith

===== Proof 1783 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> aesop

===== Proof 1784 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intros e <;>
    simp_all [IsLieAbelian, ‚Üê LieRing.of_associative_ring_bracket,
      LieRing.of_associative_ring_comm]

===== Proof 1785 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intro a b <;> simp_all
  <;> ring_nf
  <;> linarith

===== Proof 1786 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intro a b <;> simp_all [mul_comm]

===== Proof 1787 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> simp [mul_comm] <;> intro
  <;>
    simp_all

===== Proof 1788 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intro  <;>
  ¬∑ 
    let a := Classical.choose ‚Äπ_‚Ä∫; let b := Classical.choose ‚Äπ_‚Ä∫
    have := Classical.choose_spec ‚Äπ_‚Ä∫
    simp_all only
    linarith

===== Proof 1789 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intro a b
  <;> simp [‚Üê LieRing.of_associative_ring_mul, IsLieAbelian] at * <;> simp [*]

===== Proof 1790 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro h
  ¬∑ exact { mul_comm := fun x y => by rw [‚Üê Std.Commutative.comm]; exact h.comm x y }
  ¬∑ exact { mul_comm := fun x y => by rw [h.mul_comm] }

===== Proof 1791 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro h <;>
  exact { __ := inferInstance,
          mul_comm := h }

===== Proof 1792 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (Œ± := A) (¬∑ * ¬∑) ‚Üî IsLieAbelian A := by
  constructor <;> intro <;> constructor <;> intros <;>
    simp [‚Üê comm] <;> linarith

===== Proof 1793 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [dist_eq_norm, dist_eq_norm, ‚Üê div_left_inj' (c - c)‚Åª¬π, _root_.div_eq_mul_inv,
    mul_right_comm, ‚Üê mul_assoc, mul_right_inv, one_mul]
  simp [dist_eq_norm]

===== Proof 1794 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv]
  rw [div_eq_mul_inv]
  rw [dist_mul_right]
  rw [dist_mul_right]
  rw [dist_comm]

===== Proof 1795 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  exact dist_mul_right_inv _ _ _

===== Proof 1796 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  exact Metric.dist_mul_right_cancel a b c.inv

===== Proof 1797 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv, dist_mul_right]

===== Proof 1798 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv, dist_mul_right, dist_mul_right, mul_comm a]

===== Proof 1799 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  exact MetricSpace.dist_mul_right a b c‚Åª¬π

===== Proof 1800 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  simp [dist_eq_norm, mul_right_comm, norm_mul]

===== Proof 1801 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv, dist_mul_right, dist_mul_left, inv_mul_cancel_right]

===== Proof 1802 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv, dist_mul_right, dist_mul_right, mul_comm b, dist_comm]

===== Proof 1803 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv, dist_mul_left, dist_mul_right, mul_comm b, dist_comm]

===== Proof 1804 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [dist_eq_norm, dist_eq_norm]
  simp [div_eq_mul_inv, ‚Üê dist_eq_norm]

===== Proof 1805 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  exact Metric.dist_mul_right_cancel a b c

===== Proof 1806 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  exact MetricSpace.dist_mul_right _ _ _

===== Proof 1807 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  simp [dist_eq_norm, ‚Üê mul_right_sub, ‚Üê mul_left_sub]

===== Proof 1808 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  simp only [div_eq_mul_inv, dist_eq_norm, mul_inv_rev, mul_right_comm, sub_eq_add_neg]
  rw [‚Üê dist_mul_right, ‚Üê dist_mul_left, mul_left_inv, dist_one_left]

===== Proof 1809 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  simp [dist_eq_norm, mul_sub, sub_mul, ‚Üê mul_assoc]

===== Proof 1810 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv]
  rw [div_eq_mul_inv]
  simp only [dist_eq_norm, mul_inv_rev, map_mul, mul_sub_left_distrib, sub_eq_add_neg, add_assoc]
  simp [dist_eq_norm, mul_inv_rev, map_mul, mul_sub_left_distrib, sub_eq_add_neg, add_assoc]

===== Proof 1811 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  exact dist_mul_right_inj c‚Åª¬π

===== Proof 1812 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  exact MetricSpace.dist_mul_right_inv a b c

===== Proof 1813 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  exact MetricSpace.isometry_of_dist_eq (fun x y => by simp [dist_eq_norm, ‚Üê mul_sub]) _ _

===== Proof 1814 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [dist_eq_norm, dist_eq_norm, ‚Üê Isometry.nnorm_map (show Isometry (op : M ‚Üí M·µê·µí·µñ) from isometry_op),
    ‚Üê Isometry.nnorm_map (show Isometry (op : M ‚Üí M·µê·µí·µñ) from isometry_op), ‚Üê map_div, ‚Üê map_div]

===== Proof 1815 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv]
  rw [div_eq_mul_inv]
  rw [dist_mul_right]
  rw [dist_mul_right]
  ring

===== Proof 1816 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv, dist_mul_right, dist_mul_left, mul_comm]

===== Proof 1817 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  simp only [div_eq_mul_inv, dist_eq_norm, ‚Üê MulOpposite.op_smul, ‚Üê IsometricSMul.isometry_of_mul_left
    (op (1 : M)) (by rw [op_one]), dist_eq_norm]
  ring

===== Proof 1818 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv]
  simp [dist_eq_norm, mul_right_comm]

===== Proof 1819 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  simp only [div_eq_mul_inv, dist_eq_norm, mul_inv_rev, norm_inv, eq_self_iff_true,
    ‚Üê dist_eq_norm_div, dist_comm]

===== Proof 1820 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv]
  rw [div_eq_mul_inv]
  simp [dist_eq_norm, mul_sub, ‚Üê dist_eq_norm_div]

===== Proof 1821 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  simp [div_eq_mul_inv, dist_eq_norm, ‚Üê mul_inv, norm_smul]

===== Proof 1822 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv, div_eq_mul_inv, dist_mul_right, dist_mul_right, mul_comm c, mul_comm c,
    dist_comm]

===== Proof 1823 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  rw [div_eq_mul_inv]
  rw [div_eq_mul_inv]
  rw [dist_mul_right]
  rw [dist_mul_right]
  rw [dist_comm]

===== Proof 1824 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M·µê·µí·µñ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  simp only [div_eq_mul_inv, dist_eq_norm_div, ‚Üê ring.inverse_mul_cancel_right a b c]
  simp [dist_eq_norm, norm_mul]

===== Proof 1825 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_succ_zero, ack_succ_succ]
  | succ n ih =>
    simp [ack_succ_succ, ih, ack_succ_zero, ack_succ_succ]
    omega

===== Proof 1826 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero, Nat.pow_succ, Nat.mul_succ]
  | succ n ih =>
    simp only [ack_succ, ih, Nat.pow_succ, Nat.mul_succ]
    omega

===== Proof 1827 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack]
  | succ n ih => simp [ack, ih, pow_succ, mul_comm]

===== Proof 1828 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n <;> simp_all [ack_succ_succ, ack_succ_zero]
  omega

===== Proof 1829 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero, ack_succ]
  | succ n ih => simp [ack_succ, ack_succ_succ, ih]

===== Proof 1830 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero]
  | succ n ih =>
    simp [ack_succ_succ, ih]
    ring

===== Proof 1831 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack]
  | succ n ih => simp [ack, ih, pow_succ, mul_succ]

===== Proof 1832 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero =>
    simp [ack_zero, ack_succ, ack_one, ack_two, Nat.pow_succ, Nat.pow_succ, Nat.pow_succ]
  | succ n ih =>
    simp [ack_succ, ih, Nat.pow_succ, Nat.mul_succ]
    linarith

===== Proof 1833 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  rw [ack_three]
  rfl
  <;>
  aesop

===== Proof 1834 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero, Nat.pow_succ, Nat.mul_succ]
  | succ n ih => simp [ack_succ, ih, Nat.pow_succ, Nat.mul_succ, Nat.add_assoc]

===== Proof 1835 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero, Nat.pow_succ]
  | succ n ih =>
    simp [ack_succ, ih, Nat.pow_succ, Nat.mul_succ]
    omega

===== Proof 1836 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack]
  | succ n ih =>
    simp [ack, ih, Nat.pow_succ, Nat.mul_succ]
    omega

===== Proof 1837 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero, Nat.pow_succ, Nat.mul_succ]
  | succ n ih =>
    simp [ack_succ_succ, ih, Nat.pow_succ, Nat.mul_succ]
    omega

===== Proof 1838 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack]
  | succ n ih => simp [ack, ih, pow_succ, mul_comm, mul_left_comm, mul_assoc]

===== Proof 1839 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero =>
    simp [ack_succ_zero, Nat.pow_succ]
  | succ n ih =>
    simp [ack_succ_succ, ih, Nat.pow_succ]
    omega

===== Proof 1840 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero =>
    simp only [ack_zero, ack_succ, ack_one, Nat.zero_eq, add_zero, pow_succ, pow_zero, one_mul,
      zero_add]
  | succ n ih =>
    simp only [ack_succ, ih, pow_succ, Nat.succ_add, Nat.add_succ]
    omega

===== Proof 1841 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero =>
    simp [ack_zero, ack_succ, Nat.pow_succ, Nat.mul_succ]
  | succ n ih =>
    simp [ack_succ, ih, Nat.pow_succ, Nat.mul_succ]
    omega

===== Proof 1842 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_succ_zero]
  | succ n ih => simp [ack_succ_succ, ih]
    omega

===== Proof 1843 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero, ack_succ]
  | succ n ihn => simp [ack_succ, ihn]
  <;> omega

===== Proof 1844 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero, Nat.pow_succ]
  | succ n ih => simp [ack_succ, ih, Nat.pow_succ, Nat.mul_succ, Nat.add_succ, Nat.succ_add]
    linarith

===== Proof 1845 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack]
  | succ n ih =>
    simp [ack, ack_succ_succ, ih]
    omega

===== Proof 1846 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n <;> simp [ack_succ_succ, ack_succ_zero, *]
  <;> norm_num <;> ring_nf
  <;> omega

===== Proof 1847 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero, Nat.pow_succ]
  | succ n ih =>
    simp [ack_succ, ih, Nat.pow_succ, Nat.mul_comm, Nat.add_comm, Nat.add_assoc]

===== Proof 1848 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n <;> simp [ack_succ, IH, pow_succ]
  ring

===== Proof 1849 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero =>
    simp [ack_zero, Nat.pow_succ]
  | succ n ih =>
    simp [ack_succ, ih, Nat.pow_succ, Nat.mul_succ]
    omega

===== Proof 1850 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => rfl
  | succ n ih =>
    rw [ack_succ_succ, ih]
    ring

===== Proof 1851 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack_zero]
  | succ n ihn => simp [ack_succ, ihn, pow_succ, mul_comm]

===== Proof 1852 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp
  | succ n ih =>
    simp [ack_succ_succ, ih]
    ring_nf
    omega

===== Proof 1853 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => rfl
  | succ n ih =>
    simp_all [ack_succ_succ, ack_succ_zero, Nat.mul_succ, Nat.pow_succ, Nat.mul_zero, Nat.zero_add]
    omega

===== Proof 1854 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n <;>
    simp [*, ack_succ_succ, pow_succ, mul_comm, mul_left_comm, mul_assoc]
  <;>
    omega

===== Proof 1855 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack]
  | succ n ih =>
    simp [ack, ack_succ_succ, ih]
    omega

===== Proof 1856 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero => simp [ack]
  | succ n ih =>
    simp [ack, ack_succ_succ, Nat.mul_succ, Nat.add_succ, ih]
    omega

===== Proof 1857 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [log_le_log_iff hx zero_lt_one]

===== Proof 1858 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  exact log_le_log_iff hx zero_lt_one

===== Proof 1859 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_le_log_iff hx zero_lt_one]
  simp [hx]

===== Proof 1860 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_le_log_iff hx zero_lt_one]
  simp

===== Proof 1861 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_rpow hx (1 / x)]
  rw [log_div (rpow_pos_of_pos hx _) (rpow_pos_of_pos hx _) (one_div_pos.mpr hx)]
  field_simp
  rw [log_rpow hx (1 / x)]
  constructor <;> intro <;> linarith

===== Proof 1862 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê @log_one Œ±, log_le_log_iff hx zero_lt_one]

===== Proof 1863 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  exact log_le_log_iff hx zero_lt_one

===== Proof 1864 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  exact log_le_log_iff hx zero_lt_one

===== Proof 1865 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  exact log_le_log_iff hx zero_lt_one

===== Proof 1866 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_le_log_iff hx zero_lt_one]
  simp

===== Proof 1867 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê @log_one ùïú, log_le_log_iff hx zero_lt_one]

===== Proof 1868 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  constructor <;> intro h <;>
  simp_all [log_le_iff_le_exp hx, exp_le_iff_le_log hx]

===== Proof 1869 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_le_log_iff hx zero_lt_one]
  simp

===== Proof 1870 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  exact log_le_log_iff hx zero_lt_one

===== Proof 1871 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê le_log_iff_exp_le (by norm_num : (0 : ‚Ñù) < 1) hx]
  simp

===== Proof 1872 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_rpow hx (1 / x)]
  simp [log_le_log_iff, hx, zero_lt_one]

===== Proof 1873 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê not_lt, log_neg_iff hx, not_lt]

===== Proof 1874 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  simp [hx, log_le_log_iff]

===== Proof 1875 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  constructor <;> intro h <;> simp_all [hx, Real.log_le_iff_le_exp]

===== Proof 1876 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_le_log_iff (by norm_num : (0 : ‚Ñù) < 1) hx]
  simp

===== Proof 1877 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê @log_one]
  rw [log_le_log_iff hx zero_lt_one]

===== Proof 1878 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê@log_one]
  rw [‚Üê@log_rpow hx (1 / x)]
  rw [log_le_log_iff (by positivity) (by positivity)]
  rw [‚Üêmul_le_mul_iff_left (by positivity : 0 < x)]
  field_simp
  rw [‚Üêle_div_iff (by positivity : 0 < x)]
  ring_nf

===== Proof 1879 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê @log_one]
  simp [log_le_log_iff, hx]

===== Proof 1880 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_rpow hx]
  simp [log_le_log_iff, hx]

===== Proof 1881 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê @log_one ‚Ñù]
  rw [log_le_log_iff hx zero_lt_one]

===== Proof 1882 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  exact log_le_log_iff hx zero_lt_one

===== Proof 1883 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_le_log_iff hx zero_lt_one]
  simp

===== Proof 1884 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  exact log_le_log_iff hx zero_lt_one

===== Proof 1885 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  simp [‚Üê @log_le_log_iff_exp_le_exp x 1, hx]

===== Proof 1886 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  exact log_le_log_iff hx zero_lt_one

===== Proof 1887 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê Real.log_one]
  rw [‚Üê Real.log_le_log_iff hx zero_lt_one]
  simp

===== Proof 1888 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by
  rw [‚Üê log_one]
  rw [‚Üê log_rpow hx]
  rw [log_le_log_iff (rpow_pos_of_pos hx _) hx]
  rw [le_iff_eq_or_lt]
  simp [le_iff_eq_or_lt]

===== Proof 1889 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp only [mem_neighborFinset, mem_compl, mem_sdiff, mem_singleton]
  tauto

===== Proof 1890 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext u
  simp [Finset.mem_compl, Finset.mem_sdiff, G.adj_comm]

===== Proof 1891 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext u
  simp [mem_neighborFinset, Set.mem_compl_iff, mem_edgeSet]

===== Proof 1892 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext x
  simp [mem_neighborFinset, mem_compl, ne_comm]

===== Proof 1893 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext
  constructor <;> simp (config := { contextual := true })
  <;> aesop

===== Proof 1894 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [and_assoc, and_comm, and_left_comm]

===== Proof 1895 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [and_comm]

===== Proof 1896 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext u
  simp [mem_neighborFinset, Set.mem_compl_iff]

===== Proof 1897 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [and_comm, eq_comm]

===== Proof 1898 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [and_comm, eq_comm]

===== Proof 1899 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp
  aesop

===== Proof 1900 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp only [Finset.mem_compl, Finset.mem_sdiff, Finset.mem_singleton, mem_neighborFinset,
    and_comm, not_and, not_imp_not, not_not]
  constructor
  next =>
    rintro h
    simp [h]
  next =>
    rintro h
    simp [h]

===== Proof 1901 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp only [mem_compl, mem_neighborFinset, Nat.cast_inj, Set.mem_diff, Finset.mem_compl,
    Finset.mem_singleton, mem_neighborFinset]
  tauto

===== Proof 1902 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [and_comm, Finset.mem_compl, G.mem_neighborFinset, Finset.mem_sdiff,
    Finset.mem_singleton]

===== Proof 1903 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext u
  simp [and_comm, eq_comm]

===== Proof 1904 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext
  simp [imp_false]
  aesop

===== Proof 1905 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp only [mem_neighborFinset, mem_compl, mem_sdiff, mem_singleton]
  constructor <;> tauto

===== Proof 1906 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [imp_false]
  aesop

===== Proof 1907 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp only [mem_neighborFinset, mem_compl, mem_sdiff, mem_singleton]
  constructor <;> tauto

===== Proof 1908 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext u
  simp [mem_neighborFinset, mem_edgeSet]
  constructor <;> intro h <;> simp_all [and_imp, not_and] <;> aesop

===== Proof 1909 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext
  simp [mem_neighborFinset, mem_edgeFinset]
  aesop

===== Proof 1910 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext
  simp [G.mem_neighborFinset, Set.mem_compl, eq_comm]

===== Proof 1911 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [and_comm, eq_comm]

===== Proof 1912 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [mem_neighborFinset, Set.mem_compl, eq_comm]

===== Proof 1913 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [and_comm, eq_comm]

===== Proof 1914 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp only [mem_neighborFinset, mem_compl, mem_sdiff, mem_singleton]
  aesop

===== Proof 1915 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  simp [Finset.ext_iff, mem_neighborFinset, Set.mem_compl, mem_sdiff]
  aesop

===== Proof 1916 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [mem_neighborFinset, G.adj_comm]

===== Proof 1917 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp [mem_neighborFinset, mem_compl]

===== Proof 1918 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext w
  simp only [mem_compl, mem_neighborFinset, Finset.mem_sdiff, mem_singleton]
  by_cases h : G.Adj v w <;> simp [h]

===== Proof 1919 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext
  simp only [Finset.mem_compl, Finset.mem_sdiff, Finset.mem_singleton, Nat.cast_id]
  aesop

===== Proof 1920 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    G·∂ú.neighborFinset v = (G.neighborFinset v)·∂ú \ {v} := by
  ext
  simp

===== Proof 1921 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  rw [MulAction.mem_orbit] at h
  rcases h with ‚ü®r, hr, rfl‚ü©
  exact SameRay.sameRay_pos_smul_left v‚ÇÇ hr

===== Proof 1922 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®r, ‚ü®hr, rfl‚ü©‚ü© := h
  exact SameRay.sameRay_pos_smul_left v‚ÇÇ (Units.posSubgroup.mem_coe.mp hr)

===== Proof 1923 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  rw [MulAction.mem_orbit] at h
  obtain ‚ü®u, rfl‚ü© := h
  exact SameRay.sameRay_pos_smul_left v‚ÇÇ u.ne_zero

===== Proof 1924 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  rw [MulAction.mem_orbit] at h
  obtain ‚ü®a, rfl‚ü© := h
  refine' SameRay.sameRay_pos_smul_right _ a.pos

===== Proof 1925 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®‚ü®r, hr‚ü©, rfl‚ü© := h
  exact SameRay.sameRay_pos_smul_left v‚ÇÇ hr.1

===== Proof 1926 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®Œº, rfl‚ü© := h
  apply SameRay.sameRay_pos_smul_right
  positivity

===== Proof 1927 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, rfl‚ü© := h
  obtain ‚ü®a, rfl‚ü© := Units.exists_iff_exists_val.mp ‚ü®a, rfl‚ü©
  refine' SameRay.sameRay_pos_smul_left _ (zero_lt_one.trans_le a.2)

===== Proof 1928 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, rfl‚ü© := h
  refine' SameRay.sameRay_pos_smul_left _ (Units.posSubgroup.mem a)

===== Proof 1929 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, rfl‚ü© := h
  rcases eq_or_ne a 0 with rfl | ha
  ¬∑ simp
  ¬∑ exact SameRay.sameRay_pos_smul_right v‚ÇÇ (Units.mk0 a ha).isUnit

===== Proof 1930 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, rfl‚ü© := h
  refine' SameRay.sameRay_pos_smul_left _ (Units.posSubgroup.mem_pos a)

===== Proof 1931 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a‚ÇÄ, rfl‚ü© := h
  refine' SameRay.sameRay_pos_smul_right _ Units.val_pos

===== Proof 1932 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, rfl‚ü© := h
  exact SameRay.sameRay_pos_smul_left v‚ÇÇ a.prop

===== Proof 1933 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  rw [MulAction.mem_orbit] at h
  rcases h with ‚ü®a, rfl‚ü©
  exact SameRay.sameRay_pos_smul_left v‚ÇÇ (Units.posSubgroup.mem_coe.1 a.prop)

===== Proof 1934 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®r, hr, rfl‚ü© := h
  exact SameRay.sameRay_pos_smul_right v‚ÇÇ hr

===== Proof 1935 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®r, hr, rfl‚ü© := h
  refine' SameRay.sameRay_pos_smul_right _ (by simp [hr])

===== Proof 1936 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, ha, rfl‚ü© := h
  apply SameRay.sameRay_pos_smul_left
  simp [ha]

===== Proof 1937 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®u, hu‚ü© := h
  rw [MulAction.mem_orbit] at hu
  obtain ‚ü®r, hr, rfl‚ü© := hu
  refine' SameRay.smul_right _ (Units.smul_def r v‚ÇÇ)
  simp [Units.posSubgroup]

===== Proof 1938 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  rcases h with ‚ü®r, hr, rfl‚ü©
  simpa only [Units.posSubgroup_mem_iff] using SameRay.sameRay_pos_smul_right (r : R) hr

===== Proof 1939 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, rfl‚ü© := h
  refine' sameRay_pos_smul_right _ a.prop

===== Proof 1940 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®r, _, rfl‚ü© := h
  exact SameRay.sameRay_pos_smul_right v‚ÇÇ (Units.posSubgroup.mem_posSubgroup.mp r.prop)

===== Proof 1941 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®r, hr, rfl‚ü© := h
  refine' SameRay.sameRay_pos_smul_right v‚ÇÇ (mem_posSubgroup.mp hr)

===== Proof 1942 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, rfl‚ü© := h
  refine' SameRay.sameRay_pos_smul_left _ a.prop

===== Proof 1943 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, ha, rfl‚ü© := h
  have H : 0 ‚â§ (a : R) := by
    norm_cast
  simpa only [SameRay.sameRay_pos_smul_right] using H

===== Proof 1944 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®c, hc‚ü© := h
  rw [‚Üê hc]
  apply SameRay.sameRay_pos_smul_right
  exact Units.posSubgroup_pos.mp hc.symm.isUnit

===== Proof 1945 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  rw [MulAction.mem_orbit] at h
  obtain ‚ü®a, rfl‚ü© := h
  apply SameRay.sameRay_pos_smul_right
  exact a.isUnit.pos

===== Proof 1946 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®r, hr, rfl‚ü© := h
  exact SameRay.sameRay_pos_smul_right v‚ÇÇ (Units.posSubgroup.mem_posSubgroup.mp hr)

===== Proof 1947 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, rfl‚ü© := h
  refine' SameRay.sameRay_pos_smul_right _ a.prop

===== Proof 1948 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  obtain ‚ü®a, rfl‚ü© := h
  exact SameRay.sameRay_pos_smul_right v‚ÇÇ a.prop

===== Proof 1949 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  rw [MulAction.orbit_eq_iff] at h
  obtain ‚ü®a, ha, rfl‚ü© := h
  exact SameRay.sameRay_pos_smul_left v‚ÇÇ ha.ne'

===== Proof 1950 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  rcases h with ‚ü®‚ü®r, hr : 0 < r.1‚ü©, rfl : v‚ÇÅ = r ‚Ä¢ v‚ÇÇ‚ü©
  exact SameRay.sameRay_pos_smul_left v‚ÇÇ hr

===== Proof 1951 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  rcases h with ‚ü®a, rfl‚ü©
  simpa using SameRay.sameRay_pos_smul_right (a : R) (a.2 : (0 : R) < _)

===== Proof 1952 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v‚ÇÅ v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit ‚Ü•(Units.posSubgroup R) v‚ÇÇ) :
    SameRay R v‚ÇÅ v‚ÇÇ := by
  let s : Set M := {v | 0 ‚â§ v}
  exact h.of_fintype_of_sum_eq_two <| Set.ext fun v ‚Ü¶ by simp [s]

===== Proof 1953 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
  intro h
  simp_all
 have B : y ‚â† ‚àû := by
  intro h
  simp_all
  norm_cast at h
  have C : y.toNNReal = 0 := by
    apply le_antisymm
    ¬∑ have temp : (y.toNNReal : ‚Ñù‚â•0‚àû) ‚â§ 0 := by
        simp_all
      norm_cast at temp
      simp_all
    ¬∑ have temp : (y.toNNReal : ‚Ñù‚â•0‚àû) ‚â• 0 := by
        simp_all
      norm_cast at temp
      simp_all
  have D : y = 0 := by
    apply le_antisymm
    ¬∑ have temp : y ‚â§ 0 := by
        simp_all
      linarith
    ¬∑ have temp : y ‚â• 0 := by
        simp_all
      linarith
  simp_all

===== Proof 1954 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro h
    have h' : (0 : ‚Ñù‚â•0‚àû) ‚â§ y := by simp [h]
    rw [h, ‚Üê hi] at h'
    exact not_lt_of_le h' h'y
  have B : y = (y : ‚Ñù‚â•0) := rfl
  simp_rw [B] at hi
  norm_cast at hi
  linarith

===== Proof 1955 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro H
    rw [H] at h'y
    norm_num at h'y
  have B : (0 : ‚Ñù‚â•0) < y := Ne.bot_lt A
  have C : (0 : ‚Ñù‚â•0) < Real.sqrt y := NNReal.sqrt_pos.mpr B
  have D : (0 : ‚Ñù‚â•0) < Real.sqrt (x / y) := by
    apply Real.sqrt_pos.mpr
    exact div_pos h'x h'y
  have E : (0 : ‚Ñù‚â•0) < Real.sqrt x := by
    apply Real.sqrt_pos.mpr
    exact h'x
  have F : Real.sqrt (x / y) * Real.sqrt y = Real.sqrt x := by
    rw [‚Üê Real.sqrt_mul]
    ¬∑ field_simp
    ¬∑ exact mul_nonneg h'x.le h'y.le
  have G : Real.sqrt y ‚â§ Real.sqrt (x / y) := by
    apply Real.sqrt_le_sqrt
    rw [‚Üê div_le_iff h'y]
    rw [F]
    exact le_sqrt_of_sq_le (by nlinarith)
  linarith

===== Proof 1956 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro A
    simp_all only [Ne, ofReal_eq_zero, one_ne_zero, not_false_iff, mul_eq_mul_left_iff]
  have B : y ‚â† 1 := by
    intro A
    simp_all only [Ne, ofReal_eq_one, one_ne_zero, not_false_iff, mul_eq_mul_left_iff]
  have C : y ‚â† 0 := by
    intro A
    simp_all only [Ne, ofReal_eq_zero, one_ne_zero, not_false_iff, mul_eq_mul_left_iff]
  have D : y ‚â† 1 := by
    intro A
    simp_all only [Ne, ofReal_eq_one, one_ne_zero, not_false_iff, mul_eq_mul_left_iff]
  have E : y ‚â† 0 := by
    intro A
    simp_all only [Ne, ofReal_eq_zero, one_ne_zero, not_false_iff, mul_eq_mul_left_iff]
  have F : y ‚â† 1 := by
    intro A
    simp_all only [Ne, ofReal_eq_one, one_ne_zero, not_false_iff, mul_eq_mul_left_iff]
  simp_all only [Ne, ofReal_eq_zero, one_ne_zero, not_false_iff, mul_eq_mul_left_iff]

===== Proof 1957 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by simp [y]
  have : (‚àë i ‚àà Finset.univ.erase k, 1 / y i) = (‚àë i ‚àà Finset.univ.erase k, 1 / y i) := rfl
  have B : (‚àë i ‚àà Finset.univ.erase k, 1 / y i) < (‚àë i ‚àà Finset.univ.erase k, 1 / x i) := by
    apply Finset.sum_lt_sum_of_nonempty
    . apply Finset.erase_nonempty.2 (Finset.mem_univ k)
    intro i hi
    have : i ‚â† k := by simpa using hi
    exact div_lt_div_of_lt hy (h'x i this)
  have C : (‚àë i ‚àà Finset.univ, 1 / y i) ‚â§ (‚àë i ‚àà Finset.univ.erase k, 1 / x i) + 1 / x k := by
    rw [Finset.sum_erase_eq_sub (Finset.mem_univ k)]
    linarith
  linarith

===== Proof 1958 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    simp only [ne_eq, y.prop, and_true, not_false_eq_true]
  have B : z ‚â† 0 := by
    simp only [ne_eq, z.prop, and_true, not_false_eq_true]
  have C : 0 < y := by
    simp only [NNReal.pos_iff, ne_eq, y.prop, and_true, true_and]
    linarith
  have D : 0 < z := by
    simp only [NNReal.pos_iff, ne_eq, z.prop, and_true, true_and]
    linarith
  have E : 0 < K := by positivity
  have F : (œÅ : ‚Ñù) = 1 / x := by
    have : (œÅ : ‚Ñù) = y / z := by
      rw [‚Üê div_eq_div_iff _ _ A B, ‚Üê div_eq_div_iff _ _ B A] <;>
      simp only [‚Üê NNReal.coe_div, NNReal.coe_eq_zero, ne_eq, y.prop, z.prop, and_true, true_and,
        y.ne_zero, z.ne_zero]
      linarith
    rw [this]
    field_simp [C.ne', D.ne']
  rw [F] at hœÅ
  simp only [E, Ne, one_div, inv_eq_zero, Nat.cast_eq_zero, Nat.cast_ne_zero, not_false_eq_true,
    mul_eq_mul_left_iff] at hœÅ
  rcases hœÅ with (hœÅ | hœÅ)
  ¬∑ norm_num at hœÅ
  ¬∑ exact hœÅ

===== Proof 1959 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro h
    rw [h] at h'y
    simp at h'y
  have B : (y : ‚Ñù) ‚â† 0 := by
    exact_mod_cast A
  have C : (y : ‚Ñù‚â•0) ‚â† 0 := by
    simpa only [Ne, coe_eq_zero] using A
  have E : IsGreatest { r : ‚Ñù | 0 ‚â§ r ‚àß ‚Üëy ‚â§ r ^ 2 ‚àß x < r } (y : ‚Ñù) := by
    refine' ‚ü®by simp [h'y], fun r h => _‚ü©
    simp only [mem_setOf_eq, and_imp, zero_le', le_max_iff, zero_le_one,
      and_true_iff, le_max_left, and_true_iff, le_max_right] at h
    obtain ‚ü®_, h, h'‚ü© := h
    have : r ^ 2 ‚â§ y := by
      calc
        r ^ 2 ‚â§ (y : ‚Ñù) ^ 2 := by
          exact_mod_cast h'y.2.1
        _ ‚â§ y := by
          have : (1 : ‚Ñù) ‚â§ y := by
            have : 1 ‚â§ y := by
              have : 0 < y := by
                exact_mod_cast h'y.1
              linarith
            linarith
          exact_mod_cast (le_of_lt this)
    linarith
  use E.1
  simpa only [sq, max_le_iff, and_imp, zero_le', le_max_iff, zero_le_one,
    and_true_iff, le_max_left, and_true_iff, le_max_right] using E.2

===== Proof 1960 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro H
    simp_all
  have B : (0 : ‚Ñù‚â•0) < y := lt_of_le_of_ne (zero_le _) A.symm
  have C : (y : ‚Ñù‚â•0‚àû) ‚â§ 2 * y := by
    rw [‚Üê one_mul y]
    exact mul_le_mul (by norm_num) (le_refl _) (zero_le _) (zero_le_one.trans B.le)
  have D : 2 * y ‚â§ 2 * ‚Äñh'y‚Äñ‚Çä := mul_le_mul (by norm_num) (le_max_left _ _) (zero_le _) (zero_le_one.trans B.le)
  have E : 2 * ‚Äñh'y‚Äñ‚Çä ‚â§ ‚Äñh'y‚Äñ‚Çä := by
    rw [‚Üê nnnorm_add_self]
    exact (norm_add_le _ _).trans (le_of_eq (max_add_add_right _ _ _))
  linarith

===== Proof 1961 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro A
    have B : y = 0 := A
    contradiction
  have B : ‚àÄ A : y = 0, False := by
    intro A
    have B : y ‚â† 0 := by simpa using h'y
    contradiction
  simpa

===== Proof 1962 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro h
    rw [h] at h'y
    simp at h'y
  have B : y ‚â† ‚àû := by
    intro h
    rw [h] at h'y
    simp at h'y
  norm_cast at h'y
  have C : y ‚â§ 1 := by
    apply le_of_not_lt
    intro h'
    have D : (1 : ‚Ñù‚â•0‚àû) = ‚àû := by
      apply le_antisymm
      ¬∑ apply le_of_lt h'
      ¬∑ apply ENNReal.top_le_iff.2
        apply le_of_eq
        simp
    rw [D] at h'y
    simp at h'y
  have D : y < 1 := by
    apply lt_of_le_of_ne
    ¬∑ apply C
    ¬∑ apply A
  rcases D with ‚ü®E, F, G‚ü©
  rw [‚Üê E, ‚Üê F] at h'y
  norm_num at h'y
  linarith

===== Proof 1963 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro contra
    have H : (0 : ‚Ñù‚â•0) = y * (y + ‚Üë(n - 1))‚Åª¬π * (A : ‚Ñù‚â•0) := by simp [contra]
    simp only [NNReal.coe_zero, zero_mul, mul_zero, contra] at H
    simp at H

===== Proof 1964 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro H
    have H' := congr_arg Real.sqrt H
    rw [Real.sqrt_eq_zero_of_nonpos (le_of_lt hy)] at H'
    exact NNReal.coe_ne_zero.19 H'.symm
  have B : ‚àÄ z : ‚Ñù‚â•0, Real.sqrt ‚Üëz = ‚Üë(NNReal.sqrt z) := fun z ‚Ü¶ by
    have : 0 ‚â§ (z : ‚Ñù) := by norm_cast
    rw [Real.sqrt_eq_rpow, Real.rpow_nat_cast, NNReal.sqrt_eq_rpow]
    norm_cast
  have C : ‚àÄ y : ‚Ñù‚â•0, y ^ (1 / 2 : ‚Ñù) = ‚Üë(NNReal.sqrt y) := fun y ‚Ü¶ by
    have : (0 : ‚Ñù) ‚â§ (1 / 2 : ‚Ñù) := by norm_num
    rw [‚Üê Real.sqrt_eq_rpow_of_nonneg this, Real.sqrt_eq_rpow, Real.rpow_nat_cast]
    norm_cast
  apply_fun (fun x ‚Ü¶ x ^ (1 / 2 : ‚Ñù)) at hxy
  simpa [A, B, C, NNReal.sqrt_eq_zero_of_le_zero (le_of_lt hy)] using hxy

===== Proof 1965 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by simp
  have B : 0 < y := by positivity
  calc
    (a : ‚Ñù) = a * y * y‚Åª¬π := by simp
    _ = a * y * (1 / y) := by simp
    _ = a * (y * (1 / y)) := by ring
    _ = a * 1 := by simp [h']
    _ = a := by simp

===== Proof 1966 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
     intro A
     have A' : y ‚â† 0 := by
        intro A'
        rw [A, A'] at A'
        simp at A'
     exact A' A
  field_simp [A, h'y]
  ring

===== Proof 1967 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by simp_all
  have B : y ‚â† 1 := by simp_all
  have C : y ‚â† 0 := by simp_all
  have D : y ‚â† 1 := by simp_all
  exact absurd h'y C

===== Proof 1968 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro H
    have H' := congr_arg Real.sqrt H
    rw [Real.sqrt_eq_zero] at H'
    swap
    ¬∑ exact h'y
    have H'' := h'y
    simp_all
  field_simp [A, y]
  ring
  have B : Nr ‚â† 0 := by
    intro H
    have H' := congr_arg Real.sqrt H
    rw [Real.sqrt_eq_zero] at H'
    swap
    ¬∑ exact h'Nr
    have H'' := h'Nr
    simp_all
  field_simp [B, Nr]
  ring

===== Proof 1969 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro
    <;> linarith
  have B : (a : ‚Ñù) = (a : ‚Ñù‚â•0) := by norm_cast
  simp_all
  have C : (a : ‚Ñù) = (a : ‚Ñù‚â•0) := by norm_cast
  linarith

===== Proof 1970 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by simpa using ((Classical.choose_spec h'y).1)
  have B : y ‚â† ‚àû := by simpa using ((Classical.choose_spec h'y).2.1)
  have C : y ‚â† 1 := by simpa using ((Classical.choose_spec h'y).2.2.1)
  have D : y ‚â† 0.5 := by simpa using ((Classical.choose_spec h'y).2.2.2)
  have E : (1 : ‚Ñù) < y := by
    have : 1 < y := by
      have := h'y.choose_spec.2.2.2
      simp_all
    linarith
  have F : (y : ‚Ñù) < 2 := by
    have : (y : ‚Ñù) < 2 := by
      have := h'y.choose_spec.2.2.2
      simp_all
    linarith
  have G : (y : ‚Ñù) ‚â† 0 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have H : (y : ‚Ñù) ‚â† 1 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have I : (y : ‚Ñù) ‚â† 0.5 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have J : y ‚â† 0 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have K : y ‚â† ‚àû := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have L : y ‚â† 1 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have M : y ‚â† 0.5 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have N : y ‚â† 0 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have O : y ‚â† ‚àû := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have P : y ‚â† 1 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have Q : y ‚â† 0.5 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have R : y ‚â† 0 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have S : y ‚â† ‚àû := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have T : y ‚â† 1 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have U : y ‚â† 0.5 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have V : y ‚â† 0 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have W : y ‚â† ‚àû := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have X : y ‚â† 1 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have Y : y ‚â† 0.5 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have Z : y ‚â† 0 := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have AA : y ‚â† ‚àû := by
    have := h'y.choose_spec.2.2.2
    simp_all
  have BB : y ‚â† 
===== Proof 1971 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro A
    rw [A] at h'y
    norm_num at h'y
  have B : 0 < y := by
    exact NNReal.pos_iff.mpr (by simpa using A)
  have C : y * x > 0 := by
    exact mul_pos (by simpa using A) (by simpa using B)
  have D : y * x ‚â† 0 := by
    exact (pos_iff_ne_zero.mp C).1
  have E : y * x ‚â† 1 := by
    exact (pos_iff_ne_zero.mp C).2
  exact E

===== Proof 1972 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    contrapose! h'y
    simp_all
  have B : (0 : ‚Ñù‚â•0) < 1 := by norm_num
  have C : (0 : ‚Ñù‚â•0) < y := by
    contrapose! h'y
    simp_all
  have D : (0 : ‚Ñù‚â•0) < y + 1 := by linarith
  have E : (0 : ‚Ñù‚â•0) < (y + 1) ^ 2 := by positivity
  have F : (0 : ‚Ñù‚â•0) < 2 * y + 1 := by linarith
  linarith

===== Proof 1973 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by simp_all
  have B : x ‚â† 0 := by simp_all
  have C : z ‚â† 0 := by simp_all
  have D : w ‚â† 0 := by simp_all
  calc
    dist x y = norm (x - y) := by simp [dist_eq_norm]
    _ = norm (x - z + (z - y)) := by rw [‚Üê dist_eq_norm]
    _ = norm (x - y) := by congr 1; ring
    _ = dist x y := by simp [dist_eq_norm]

===== Proof 1974 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro h
    rw [h] at h'y
    norm_num at h'y
  have B : y ‚â† ‚àû := by
    intro h
    rw [h] at h'y
    norm_num at h'y
  have C : (y : ‚Ñù‚â•0‚àû) = (y : ‚Ñù‚â•0) := by simp [A, B]
  have D : (y : ‚Ñù‚â•0‚àû) = (y : ‚Ñù‚â•0) := by simp [A, B]
  have E : (y : ‚Ñù‚â•0‚àû) = (y : ‚Ñù‚â•0) := by simp [A, B]
  have F : (y : ‚Ñù‚â•0‚àû) = (y : ‚Ñù‚â•0) := by simp [A, B]
  simp_all only [add_right_inj]
  convert hh
  simp_all

===== Proof 1975 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
  intro h
  have h' := h'y
  rw [h] at h'
  simp at h'

===== Proof 1976 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro H

===== Proof 1977 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro h
    apply h'y
    simp only [h, _root_.zero_eq, zero_add, zero_sub, sub_zero, zero_mul,
      mul_zero, zero_le_one, one_le_iff_ne_zero]
    norm_num
  have B : y + ((1 - y) * coeff C 0) ‚â† 0 := by
    intro h
    apply A
    have : coeff C 0 = 0 := by
      apply eq_of_sub_eq_zero
      linarith
    simp only [this, _root_.zero_eq, zero_add, zero_sub, sub_zero, zero_mul,
      mul_zero, zero_le_one, one_le_iff_ne_zero]
    norm_num
  have C : coeff C 0 ‚â† 0 := by
    apply ne_zero_of_lt
    exact (coeff_lt_one_of_lt h'y).2
  have : y * coeff C 0 < 1 := by
    apply (mul_lt_mul_left A).2
    exact coeff_lt_one_of_lt h'y
  linarith

===== Proof 1978 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by intro h; rw [h] at h'y; simp at h'y
  have I : (Real.toNNReal (1 / y) : ‚Ñù‚â•0) = 1 / y := by
    refine' Real.toNNReal_div 1 y A _
    simp
  rw [‚Üê I]
  norm_num
  linarith

===== Proof 1979 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro h
    rw [h] at h'y
    simp at h'y
  have B : 0 ‚â§ realToNNReal (fun _ => 0) y := by
    apply Real.nonneg_of_mul_nonneg_left _ (by norm_num : (0 : ‚Ñù) < 2)
    have : y * (realToNNReal (fun _ => 0) y) = 0 := by
      simp [y.property, A]
    simpa [y.property, A] using this
  linarith

===== Proof 1980 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    simp only [ne_eq, one_div, y.ne_iff, not_false_eq_true]
    have : 0 < (2 : ‚Ñù‚â•0) := by norm_num
    have : 0 < (5 : ‚Ñù‚â•0) := by norm_num
    have : 0 < (1 : ‚Ñù‚â•0) := by norm_num
    simp only [ne_eq, one_div, y.ne_iff, not_false_eq_true, ne_eq, one_div, y.ne_iff,
      not_false_eq_true, ne_eq, one_div, y.ne_iff, not_false_eq_true]
    aesop
  simp only [one_div, ne_eq, A, not_false_eq_true]
  norm_num
  aesop

===== Proof 1981 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro A
    have B : y = 0 := by
      apply eq_of_le_of_not_lt
      exact le_of_eq A
      intro B
      linarith
    linarith
  have B : y ‚â† 1 := by
    intro B
    have C : y = 1 := by
      apply eq_of_le_of_not_lt
      exact le_of_eq B
      intro C
      linarith
    linarith
  have C : y ‚â† 0 ‚àß y ‚â† 1 := by
    constructor
    exact A
    exact B
  exact C

===== Proof 1982 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by simp [h']
  have : (0 : ‚Ñù‚â•0) ‚â§ y := by positivity
  have B : (y : ‚Ñù‚â•0‚àû) ‚â† 0 := by simpa using A
  have : (y : ‚Ñù‚â•0‚àû) * (y : ‚Ñù‚â•0‚àû)‚Åª¬π = 1 := by prec_glued this B
  have : (y : ‚Ñù‚â•0‚àû)‚Åª¬π = (y : ‚Ñù‚â•0‚àû)‚Åª¬π := rfl
  have : NoZPowersInBranch E (y : ‚Ñù‚â•0‚àû)‚Åª¬π := by apply NoZPowersInBranch.inv; assumption
  have : NoZPowersInBranch E (y : ‚Ñù‚â•0‚àû) := by assumption
  have : NoZPowersInBranch E x := by apply NoZPowersInBranch.of_isGood_is_unit; assumption
  tauto

===== Proof 1983 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro h
    have : z ‚â† 0 := by
      intro hz
      simp only [hz, zero_mul, one_ne_zero, h, mul_eq_one] at h'y
    apply this
    simpa [h] using hy
  have B : (y : ‚Ñù) ‚â† 0 := by
    intro h
    have : (y : ‚Ñù‚â•0) = 0 := by
      simpa [h] using hy
    apply A
    simpa [this] using hy
  field_simp [A, B] at hy ‚ä¢
  ring_nf at hy ‚ä¢
  simpa [hy] using hy

===== Proof 1984 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ‚Ñù‚â•0 using h'y
  have A : y ‚â† 0 := by
    intro h

    rw [h] at h'y
    norm_num at h'y
  have B : 0 < y :=
    Ne.bot_lt A
  have C : y * z < y * 1 := by
    apply mul_lt_mul_of_pos_left _ B
    exact h'z
  simp only [mul_one] at C
  linarith

===== Proof 1985 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply RespectsIso.of_respects_arrow_iso
  intro X Y f hf
  have : IsIso (ùüô X) := inferInstance
  have : IsIso (ùüô Y) := inferInstance
  exact hf

===== Proof 1986 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  rw [respectsIso_iff_is_lawful_delete_flip]
  exact unrestricted_respectsIso

===== Proof 1987 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectIso_of_mem _ fun _ _ => Set.toFinite _

===== Proof 1988 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply Types.finite_respectsIso

===== Proof 1989 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectIso_imp_of_agree
  aesop_cat

===== Proof 1990 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  exact
    -- We show that 
===== Proof 1991 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectfulFunctorReflectsIso

===== Proof 1992 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectIso_of_is_lawful_lattice
  case restrict_comp => intro X Y Z f g; rw [‚Üê Functor.map_comp]; rfl
  case forget_comp => intro X Y Z f g; rw [‚Üê NatTrans.comp_app]; rfl

===== Proof 1993 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectEsymm_of_is_isomorphic_to_ring

===== Proof 1994 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectIso_of_isIso_to_equiv _ _ Equiv.plift.isEquiv_lift
  aesop_cat

===== Proof 1995 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectCoherence
  intro X Y Z e f
  cases f
  simp

===== Proof 1996 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  constructor <;> intro C D D_iso f <;> induction D_iso <;> assumption

===== Proof 1997 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  exact ‚ü®fun _ _ _ => inferInstance, fun _ _ _ => inferInstance‚ü©

===== Proof 1998 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  constructor <;> intro X Y Z e X Y Z e <;>
    aesop_cat

===== Proof 1999 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectsIso_of_isStableUnderIso _
  intro X Y Z e f
  simp only [comp_obj, comp_map]
  intro
  assumption

===== Proof 2000 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectfulSubsingleton_iff.mpr
  constructor <;>
  simp (config := { contextual := true }) [Finite, Finite.of_iso]
  <;>
  aesop

===== Proof 2001 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply RespectsIso.of_respects_arrow_iso
  intro X Y f hf
  have : IsIso f := hf
  infer_instance

===== Proof 2002 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  rw [respectsIso_iff_is_lawful_Ext]
  apply is_lawful_Ext.mk
  intro A B
  simp only [Finite]
  constructor
  intro h‚ÇÅ h‚ÇÇ
  apply h‚ÇÅ.of_iso h‚ÇÇ
  intro h‚ÇÅ h‚ÇÇ
  apply h‚ÇÅ.of_iso h‚ÇÇ.symm

===== Proof 2003 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply RespectsIso.of_respects_arrow_iso
  intro X Y f hf
  cases' hf with hf
  exact ‚ü®Finite.of_iso hf‚ü©

===== Proof 2004 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respecteds
  intro X Y Z eX Z eY Z
  simp_all

===== Proof 2005 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  constructor <;> intro X Y Z eX eY <;> simp_all

===== Proof 2006 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respect_iso
  intro X Y Z e X' Y' Z' e'
  rw [‚Üê e.isIso_hom, ‚Üê e'.isIso_hom]
  rfl

===== Proof 2007 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  refine' ‚ü®fun _ _ _ => inferInstance, fun _ _ _ => inferInstance‚ü©

===== Proof 2008 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  exact ‚ü®fun _ _ _ => id, fun _ _ _ => id‚ü©

===== Proof 2009 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply RespectsIso.of_respects_arrow_iso
  intro X Y f hf
  have hf' : Finite f.hom := hf
  rw [Finite.iff_of_arrow_iso (Arrow.isoMk f.hom.symm)] at hf'
  exact hf'

===== Proof 2010 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectfulIso
  simp_all

===== Proof 2011 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectful
  simp only [Finite.of_iso, Equiv.Perm.finite_of_finite_inverse, and_true]
  simp only [Finite.of_iso, Equiv.Perm.finite_of_finite_inverse, and_true]

===== Proof 2012 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply respectIso_of_covers
  intro X Y Z e f hf
  infer_instance

===== Proof 2013 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  refine' ‚ü®fun _ _ _ => inferInstance, fun _ _ _ => inferInstance‚ü©

===== Proof 2014 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply RespectsIso.of_respects_arrow_iso
  intro X Y f
  intro ‚ü®_‚ü©
  exact ‚ü®inferInstance‚ü©

===== Proof 2015 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply @respectsIso_of_isStableUnderComposition _ _ _ id _ _ _;
  intro X Y Z f; simp
  intro X Y Z f; simp

===== Proof 2016 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  rw [respectsIso_iff_arrow_mk_iso_iff]
  intro X Y f g e
  have : f ‚â´ e.hom = g := by rw [e.comp_hom]
  infer_instance

===== Proof 2017 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  exact (lt_top_iff_ne_top.2) hs.einfsep_ne_top

===== Proof 2018 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top, ‚Üê pos_iff_ne_zero]
  exact (Nat.cast_pos.2 (Nat.pos_of_ne_zero (hs.einfsep_pos))).trans_le
    (le_of_eq (Nat.cast_zero.symm))

===== Proof 2019 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  intro h
  obtain ‚ü®x, hx‚ü© := hs
  obtain ‚ü®y, hy‚ü© := hs
  exact (hx.2 hy.1).symm (hx.1.trans hy.2)

===== Proof 2020 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  simpa [einfsep] using hs

===== Proof 2021 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  simpa using hs.einfsep_ne_top

===== Proof 2022 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [einfsep_lt_top_iff]
  exact hs.finite_of_edist_ne_top

===== Proof 2023 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [ENat.lt_top_iff_dom]
  exact hs.einfsep_dom

===== Proof 2024 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  simpa [einfsep] using hs

===== Proof 2025 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  apply lt_top_iff_ne_top.mpr
  exact (einfsep_pos_iff_nontrivial.mpr hs).ne

===== Proof 2026 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  have h‚ÇÄ := hs
  rw [Set.Nontrivial] at h‚ÇÄ
  obtain ‚ü®x, hx, y, hy, hxy‚ü© := h‚ÇÄ
  exact (edist_lt_top x y).trans_le (le_einfsep_iff.mpr fun _ _ _ _ => edist_le_einfsep)

===== Proof 2027 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  by_contra h
  rw [Set.einfsep_top] at h
  apply Set.not_nontrivial_empty
  exact (eq_empty_of_forall_not_mem fun f hf => h f hf).symm

===== Proof 2028 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [ENNReal.lt_top_iff_ne_top]
  exact hs.einfsep_ne_top

===== Proof 2029 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  intro h
  have h' : s.einfsep = 0 := by simpa using h
  have h‚ÇÅ := hs
  rw [‚Üê Set.nonempty_iff_ne_empty] at h‚ÇÅ
  obtain ‚ü®x, hx‚ü© := h‚ÇÅ
  rw [einfsep_zero] at h'
  have h‚ÇÇ : x ‚àâ s := by simpa [h'] using hx
  exact h‚ÇÇ hx

===== Proof 2030 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [Set.einfsep]
  apply lt_top_iff_ne_top.mpr
  exact fun h ‚Ü¶ hs (einfsep_eq_top.mp h)

===== Proof 2031 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  have : s.einfsep ‚â† 0 := einfsep_ne_zero_of_nontrivial hs
  exact WithTop.coe_lt_top _

===== Proof 2032 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  simpa [einfsep, hs] using (pos_iff_ne_zero.mpr einfsep_pos_of_finite).ne'

===== Proof 2033 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  refine' lt_top_iff_ne_top.mpr _
  simpa [lt_top_iff_ne_top] using hs

===== Proof 2034 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [ENNReal.lt_top_iff_ne_top]
  simp_rw [einfsep_eq_top]
  push_neg
  intro h
  obtain ‚ü®x, hx‚ü© := hs
  exact h x hx.1 x hx.1 hx.2 rfl

===== Proof 2035 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  have h := hs.einfsep_ne_top
  exact WithTop.lt_top_iff_ne_top.mpr h

===== Proof 2036 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  exact hs.einfsep_ne_top

===== Proof 2037 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [ENNReal.lt_top_iff_ne_top]
  simp [hs]

===== Proof 2038 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  have h := hs.einfsep_ne_top
  exact h.lt_top

===== Proof 2039 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [einfsep_lt_top_iff]
  exact hs.mono (by aesop)

===== Proof 2040 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  exact (hs.einfsep_ne_top).ne

===== Proof 2041 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  simp_rw [Set.Nontrivial, not_exists, not_lt] at hs
  refine' ne_of_lt _
  obtain ‚ü®x, hx‚ü© := hs
  obtain ‚ü®y, hy‚ü© := hs
  obtain ‚ü®z, rfl, hz‚ü© := hy
  exact einfsep_lt_top_of_distinct x z hx.symm

===== Proof 2042 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [Set.Nontrivial] at hs
  obtain ‚ü®x, hx‚ü© := hs
  obtain ‚ü®y, hy‚ü© := hs
  by_cases hxy : x = y
  ¬∑ simp [hxy]
  ¬∑ exact einfsep_lt_top_of_ne hxy

===== Proof 2043 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  exact hs.einfsep_ne_top

===== Proof 2044 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  simpa using hs.einfsep_ne_top

===== Proof 2045 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  exact hs.einfsep_ne_top

===== Proof 2046 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  simpa [nontrivial_iff_exists_ne] using hs

===== Proof 2047 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rcases hs with ‚ü®x, hx, y, hy, hxy‚ü©
  exact ((edist_lt_top x y).trans_le hxy.le).ne

===== Proof 2048 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ‚àû := by
  rw [lt_top_iff_ne_top]
  exact hs.einfsep_ne_top

===== Proof 2049 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z, ?_, ?_‚ü©
  ¬∑ simp
  ¬∑ intro p hp
    rw [Set.mem_insert_iff, Set.mem_insert_iff, Set.mem_singleton_iff] at hp
    rcases hp with (rfl | rfl | rfl) <;>
      simpa only [vsub_self, eq_self_iff_true, true_or_iff, or_true_iff, vadd_zero] using h
#align wbtw.collinear Wbtw.collinear

theorem collinear_iff_exists_forall_eq_smul_vadd {s : Set P} :
    Collinear R s ‚Üî
      ‚àÉ (p : P) (v : V),
        p ‚àà s ‚àß (‚àÄ q ‚àà s, ‚àÉ r : R, r ‚Ä¢ v = q -·µ• p) ‚àß
      (s ‚äÜ affineSpan R ({p} : Set P) ‚à® s ‚äÜ 0) := by
  refine ‚ü®fun h => ?_, fun ‚ü®p, v, hp, hv, hs‚ü© => ?_‚ü©
  ¬∑ by_cases h : ‚àÉ p, p ‚àà s ‚àß s ‚äÜ 0
    ¬∑ rcases h with ‚ü®p, hp, h0‚ü©
      refine ‚ü®p, 0, hp, ?_‚ü©
      rintro q rfl
      obtain ‚ü®v, hv‚ü© :=
        h ((zero_smul R v : P) : Set P) (Set.mem_zero _) (vsub_mem_zero p q) hl
      refine ‚ü®v, ?_‚ü©
      rw [zero_smul, hv] at hv
      rw [‚Üê hv, zero_vsub]
    push_neg at h
    obtain ‚ü®p, hp‚ü© := h
    refine ‚ü®p, (‚ü®0, -p‚ü© : V), hp, ?_‚ü©
    rintro q (rfl | rfl) <;>
      ¬∑ refine ‚ü®0, ?_‚ü©
        simp
  ¬∑ by_cases h0 : v = 0
    ¬∑ cases hs.resolve_right fun h => h rfl
      rw [h0, Set.subset_singleton_iff, Set.mem_zero, eq_comm] at hs
      rcases hs with (rfl | req)
      ¬∑ rw [eq_self_iff_true, true_or_iff, affineSpan_zero]
        exact collinear_singleton _ _ _
      ¬∑ rw [affineSpan_zero] at req
        change q ‚àà ‚àÖ at req
        exact absurd req Set.not_mem_empty q
    ¬∑ rw [collinear_iff_of_nontrivial]
      refine ‚ü®p, hp, fun q hq => ?_‚ü©
      ¬∑ obtain ‚ü®r, hr‚ü© := hv q hq
        refine ‚ü®r, ?_‚ü©
        by_cases h1 : q = p
        ¬∑ use r - 1
          simp [h1]
        ¬∑ have h2 : (r ‚Ä¢ v) =·µ• q -·µ• p :=
            vsub_vadd_eq_vsub_sub (q -·µ• p) v ‚ñ∏ hr
          refine ‚ü®r, ?_‚ü©
          simp [h2]
      apply (vsub_right_injective p).surjective_iff
      rintro ‚ü®v, rfl‚ü©
      obtain ‚ü®r, hr‚ü© := hv p hp
      refine ‚ü®(r‚Åª¬π : R) ‚Ä¢ v, ?_‚ü©
      simp [hr]

===== Proof 2050 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  refine' collinear_pair.insert_left _
  refine' collinear_pair.insert_right _
  exact h.wbtw.collinear

theorem Wbtw.collinear_subset {x y z : P} (h : Wbtw R x y z) :
    Set.Collinear R ({x, y, z} : Set P) := by
  rw [‚Üê Set.image_id ({x, y, z} : Set P)]
  exact (Collinear.image_id _).subset h.collinear

===== Proof 2051 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine' ‚ü®x, 1, _‚ü©
  intro w hw
  rw [Set.mem_insert_iff, Set.mem_insert_iff] at hw
  rcases hw with (rfl | rfl | rfl)
  ¬∑ refine' ‚ü®0, _‚ü©
    have he : z = x + (z -·µ• x) := by simp [vsub_vadd_eq_vsub_sub]
    simp_all
  ¬∑ refine' ‚ü®1, _‚ü©
    simp
  ¬∑ refine' ‚ü®2, _‚ü©
    have he : z = x + (z -·µ• x) := by simp [vsub_vadd_eq_vsub_sub]
    simp_all

===== Proof 2052 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  simp_rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, ?_‚ü©
  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff]
  intros
  refine ‚ü®1, ?_‚ü©
  simp [h]

theorem collinear_pair (p‚ÇÅ p‚ÇÇ : P) : Collinear R ({p‚ÇÅ, p‚ÇÇ} : Set P) := by
  refine collinear_iff_exists_forall_eq_smul_vadd.2 ‚ü®p‚ÇÅ, ?_‚ü©
  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff, forall_eq_or_imp, and_true_iff]
  simp

theorem collinear_pair' (p‚ÇÅ p‚ÇÇ : P) : Collinear R ({p‚ÇÇ, p‚ÇÅ} : Set P) := by
  rw [Set.pair_comm]
  exact collinear_pair _ _

===== Proof 2053 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x -·µ• y, Set.Pairwise.forall_mem_insert
    ?_ (Set.Pairwise.forall_mem_insert (Set.Pairwise.forall_mem_singleton ?_) ?_)‚ü©
  ¬∑ intro _ hz
    rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hz
    rw [hz]
    abel
  ¬∑ intro _ hy _ hz
    rw [Set.mem_insert_iff] at hy
    cases hy with
    | inl hy =>
      rw [hy, ‚Üê @vsub_eq_zero_iff_eq R _ z x, ‚Üê @smul_eq_zero_iff_eq R _ (?_ : R) (z -·µ• x)] at h
    ¬∑ rw [hz]
      abel
    | inr hy =>
      rw [hy, ‚Üê @vsub_eq_zero_iff_eq R _ z y, ‚Üê @smul_eq_zero_iff_eq R _ (?_ : R) (z -·µ• y)] at h
      ¬∑ rw [hz]
        abel
      ¬∑ exact h
  ¬∑ intro _ hx _ hy
    rw [Set.mem_insert_iff] at hx hy
    cases' hx with hx hx <;> cases' hy with hy hy
    ¬∑ rw [hx, hy]
      abel
    ¬∑ rw [hx, hy]
      abel
    ¬∑ rw [hx, hy]
      abel
    ¬∑ rw [hx, hy]
      abel

===== Proof 2054 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z, ?_‚ü©
  rw [Set.Pairwise, pairwise_insert_of_symmetric (@collinear_pair _ _ _ _ _ h)]
  exact ‚ü®Or.inr (Or.inr rfl), fun _ => Or.inl rfl,
    fun _ h => Or.inr (Or.inr (vsub_eq_zero_iff_eq.mp (eq_of_heq h))), fun _ _ => Or.inr rfl,
    fun _ _ => Or.inl rfl‚ü©
#align wbtw.collinear Wbtw.collinear

/-- 
===== Proof 2055 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vsub_vadd]
  refine ‚ü®x, z, ?_‚ü©
  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff, or_imp, forall_eq_or_imp, and_imp]
  exact fun _ hy ‚Ü¶ ‚ü®1, zero_smul _ _, by simpa using h.right_mem‚ü©
#align wbtw.collinear Wbtw.collinear

theorem Collinear.wbtw_or_wbtw_or_wbtw {x y z : P} (h : Collinear R ({x, y, z} : Set P)) :
    Wbtw R x y z ‚à® Wbtw R y z x ‚à® Wbtw R z x y := by
  refine h.exists_forall_eq_smul_vsub_vadd.imp fun a ha ‚Ü¶ ?_
  rcases Set.pairwise_insert_of_symmetric (@collinear_symmetric R _ _ _ _ _) ha.1 with
    ‚ü®‚ü®t, ht‚ü©, ‚ü®u, hu‚ü©‚ü©
  replace ha := ha.2.2.2; rw [ht, hu, sub_add_eq_sub_sub_swap, sub_self, zero_sub, neg_eq_zero]
    at ha
  rcases eq_or_ne x z with (rfl | hxz)
  ¬∑ rw [ht, zero_smul] at hu; rcases eq_or_ne x y with (rfl | hxy) <;> simp [*]
  rcases eq_or_ne x y with (rfl | hxy); ¬∑ simp [*]
  rcases eq_or_ne z y with (rfl | hyz); swap; ¬∑ simp [*]
  rw [add_comm t u] at hu
  rcases t.lt_or_eq_of_le (add_right_injective _ hu.symm).le with (ht2 | rfl); swap
  ¬∑ simp_rw [ht2, ht, hu] at ha; exact ha.irrefl
  rcases u.lt_or_eq_of_le (add_left_injective _ hu).le with (hu2 | rfl); swap
  ¬∑ simp_rw [hu2, ht, hu] at ha; exact ha.irrefl
  simp_rw [ht, hu, add_assoc] at ha; norm_num at ha
  rw [(by congr <;> linarith :
      u + t ‚Ä¢ (z -·µ• x) +·µ• x = t.pred ‚Ä¢ (u.succ ‚Ä¢ (z -·µ• x)) +·µ• x),
    ‚Üê neg_smul, ‚Üê sub_eq_neg_add] at hu
  by_cases htz : t = 0 <;> simp_all [smul_smul, mul_neg, neg_smul, sub_smul, add_smul, add_comm,
    add_left_comm]
  by_cases huz : u = 0
  ¬∑ simp_all
  have hu_pos : 0 < u := huz.lt_or_lt.resolve_left fun h ‚Ü¶ ha <| by simp [h.symm, ht, hu, htz]
  have ht_pos : 0 < t := htz.lt_or_lt.resolve_left fun h ‚Ü¶ ha <| by simp [h.symm, ht, hu, huz]
  exact Or.inr <| Or.inr <| ‚ü®rfl, rfl, by field_simp [ht_pos, hu_pos, ht, hu, htz, huz]
    at ha; linarith‚ü©
#align collinear.wbtw_or_wbtw_or_wbtw Collinear.wbtw_or_wbtw_or_wbtw

===== Proof 2056 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro w hw
  rw [Set.mem_insert_iff, Set.mem_insert_iff, Set.mem_singleton_iff] at hw
  rcases hw with (rfl | rfl | rfl)
  ¬∑ refine ‚ü®0, ?_‚ü©
    rw [zero_smul, zero_vadd]
    exact h.wbtw.left_mem
  ¬∑ rcases h with ‚ü®t, ht‚ü©
    refine ‚ü®t, ?_‚ü©
    rw [ht, smul_add, one_smul, vadd_vadd]
  ¬∑ refine ‚ü®1, ?_‚ü©
    rw [one_smul, vadd_vsub]
    exact h.wbtw.right_mem

===== Proof 2057 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  simp_all only [Set.insert_nonempty, Set.finite_singleton, and_self, forall_true_left,
    Finset.coe_insert]
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  rintro a (rfl | rfl | rfl)
  ¬∑ refine ‚ü®0, ?_‚ü©
    simp [h.wbtw.left_mem]
  ¬∑ rcases h with ‚ü®t, ht, rfl‚ü©
    refine ‚ü®t, ?_‚ü©
    simp
  ¬∑ refine ‚ü®1, ?_‚ü©
    simp [h.wbtw.right_mem]

===== Proof 2058 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro p hp
  rw [Set.mem_insert_iff, Set.mem_insert_iff, Set.mem_singleton_iff] at hp
  rcases hp with (rfl | rfl | rfl)
  ¬∑ refine ‚ü®0, ?_‚ü©
    simp [vsub_eq_zero_iff_eq] at h
    simp [h]
  ¬∑ rcases h with ‚ü®t, h‚ü©
    use t
    simp [h]
  ¬∑ refine ‚ü®1, ?_‚ü©
    simp [vsub_eq_zero_iff_eq] at h
    simp [h]

===== Proof 2059 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro p hp
  rw [Set.mem_insert_iff, Set.mem_insert_iff, Set.mem_singleton_iff] at hp
  rcases hp with (rfl | rfl | rfl) <;> (try simp)
  ¬∑ exact ‚ü®1, by simp [h.wbtw.sameRay]‚ü©
  ¬∑ exact ‚ü®0, by simp‚ü©
  ¬∑ exact ‚ü®-1, by simp [h.wbtw.sameRay.neg_right]‚ü©

===== Proof 2060 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro w hw
  rw [Set.mem_insert_iff, Set.mem_insert_iff, Set.mem_singleton_iff] at hw
  rw [hw]
  refine ‚ü®1, ?_‚ü©
  simp_all only [one_smul, vadd_vsub]
#align wbtw.collinear Wbtw.collinear

theorem Sbtw.collinear {x y z : P} (h : Sbtw R x y z) : Collinear R ({x, y, z} : Set P) :=
  h.wbtw.collinear

===== Proof 2061 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®1, -1, 0, ?_‚ü©
  bintro p (rfl | rfl | rfl) <;>
  simp_all [lineMap_apply]

===== Proof 2062 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro p hp
  rw [Set.mem_insert_iff, Set.mem_insert_iff] at hp
  rcases hp with (rfl | rfl | rfl)
  ¬∑ refine ‚ü®0, ?_‚ü©
    rw [zero_smul, zero_vadd]
    simp only [vsub_self, add_zero, Submodule.mem_span_singleton]
  ¬∑ rcases h with ‚ü®t, h‚ü©
    use t
    rw [‚Üê h, vsub_vadd_eq_vsub_sub, smul_sub, sub_smul, one_smul, smul_smul]
  ¬∑ refine ‚ü®1, ?_‚ü©
    rw [one_smul, vsub_vadd]

===== Proof 2063 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  use 0, x, by simpa using h

===== Proof 2064 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z, ?_‚ü©
  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff, forall_eq_or_imp, forall_eq]
  refine ‚ü®fun r => ‚ü®r, ?_‚ü©, fun r => ‚ü®r + 1, ?_‚ü©‚ü© <;> simp_rw [smul_vadd] <;> simp [h.wbtw]
#align wbtw.collinear Wbtw.collinear

theorem Sbtw.collinear {x y z : P} (h : Sbtw R x y z) : Collinear R ({x, y, z} : Set P) :=
  (wbtw_insert_iff R x).mp h.wbtw

===== Proof 2065 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  obtain ‚ü®a, ‚ü®rfl, rfl‚ü©‚ü© := h
  exact .inl 0 1 (add_pos (by norm_num) (by norm_num)) (by norm_num)
#align wbtw.collinear Wbtw.collinear

theorem Sbtw.collinear {x y z : P} (h : Sbtw R x y z) : Collinear R ({x, y, z} : Set P) :=
  h.wbtw.collinear

===== Proof 2066 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  induction' h with x y z
  exacts [collinear_pair _ _,
    collinear_triple _]
#align wbtw.collinear Wbtw.collinear

theorem Sbtw.collinear {x y z : P} (h : Sbtw R x y z) : Collinear R ({x, y, z} : Set P) :=
  h.wbtw.collinear
#align sbtw.collinear Sbtw.collinear

theorem Wbtw.exists_eq_smul_vadd_mem_affineSpan {x y z : P}
    (h : Wbtw R x y z) : ‚àÉ (a : R) (_ : 0 ‚â§ a) (_ : a ‚â§ 1), y = a ‚Ä¢ (z -·µ• x) +·µ• x +·µ• x := by
  rcases h with ‚ü®h, rfl‚ü©
  rcases h with ‚ü®a, ha, rfl‚ü©
  refine ‚ü®a, ha.1, ha.2, ?_‚ü©
  rw [vadd_vadd, smul_vsub, vsub_vadd]

===== Proof 2067 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro p hp
  fin_cases hp
  ¬∑ rw [‚Üê @vsub_eq_zero_iff_eq R _ P _ _ x]
    simp [h.left_mem]
  ¬∑ cases' h with h h
    ¬∑ rw [‚Üê eq_vadd_iff_vsub_eq] at h
      rw [h]
      simp
    ¬∑ rw [‚Üê @vsub_eq_zero_iff_eq R _ P _ _ z] at h
      simp [h]

===== Proof 2068 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  rw [eq_comm] at h; rcases h with ‚ü®r, rfl‚ü©
  refine
    ‚ü®1, -r, r + 1, Set.pair_comm _ x, Set.insert_comm _ _ _,
      Set.insert_pair _ _ (Set.mem_insert _ _), ?_‚ü©
  intro p hp
  simp_all only [add_smul, neg_smul, one_smul, Set.mem_insert_iff, Set.mem_singleton_iff]
  rcases hp with (rfl | rfl | rfl) <;>
  simp (config := { contextual := true }) only [true_or, eq_self_iff_true, or_true]

===== Proof 2069 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd, Set.pairwise_insert_of_symmetric (symmetric_vsub R)]
  refine
    ‚ü®x, Set.insert_subset_iff.2 ‚ü®h.wbtw.left_ne, fun _ hy => ?_‚ü©, fun t =>
      ‚ü®(1 : R) - t, 0, ?_, ?_‚ü©‚ü©
  ¬∑ rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hy
    rw [hy]
    exact (vsub_vadd_eq_vsub_sub x z x).symm
  ¬∑ simp_rw [add_smul, sub_smul, one_smul, ‚Üê smul_add, vsub_add_vsub_cancel, sub_add_cancel]
  ¬∑ rw [Set.insert_subset_iff]
    exact ‚ü®h.wbtw.insert_endpoints_subset_affineSpan, Set.singleton_subset_iff.2 h.wbtw.left_mem‚ü©
#align wbtw.collinear Wbtw.collinear

theorem Sbtw.collinear {x y z : P} : Sbtw R x y z ‚Üí Collinear R ({x, y, z} : Set P) := fun h =>
  h.wbtw.collinear.subset (Set.insert_subset_insert <| Set.insert_subset_insert <| Set.singleton_subset_iff.2
    h.mem_affineSpan)

===== Proof 2070 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, by simp, fun p hp => ?_‚ü©
  simp_all only [Set.mem_insert_iff, Set.mem_singleton_iff]
  rcases hp with (rfl | rfl) <;> tauto

===== Proof 2071 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro p hp
  simp_all only [Set.mem_insert_iff, Set.mem_singleton_iff]
  rcases hp with (rfl | rfl)
  ¬∑ refine ‚ü®0, ?_‚ü©
    simp
  ¬∑ rcases h with ‚ü®t, h‚ü©
    refine ‚ü®t, ?_‚ü©
    rw [h]
    simp [vadd_vsub]

theorem Wbtw.collinear' {x y z : P} (h : Wbtw R x y z) :
    Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®z, x -·µ• z, ?_‚ü©
  intro p hp
  simp_all only [Set.mem_insert_iff, Set.mem_singleton_iff]
  rcases hp with (rfl | rfl)
  ¬∑ refine ‚ü®0, ?_‚ü©
    simp
  ¬∑ rcases h with ‚ü®t, h‚ü©
    refine ‚ü®t, ?_‚ü©
    rw [h]
    simp [vadd_vsub]

===== Proof 2072 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro w hw
  cases' mem_insert_iff.mp hw with hw hw
  ¬∑ use 0
    simp [hw]
  ¬∑ cases' mem_singleton_iff.mp hw with hw hw
    ¬∑ use 1
      simp [hw]
    ¬∑ have hx : x = w := by simp_all
      have hy : y = (1 / 2 : R) ‚Ä¢ (w +·µ• z) := by simp_all
      have hz : z = w := by simp_all
      use 2
      simp [hx, hy, hz, smul_smul, mul_add, add_mul, mul_comm]

theorem collinear_pair' (p‚ÇÅ p‚ÇÇ : P) : Collinear R ({p‚ÇÅ, p‚ÇÇ} : Set P) := by
  rw [collinear_iff_of_mem (mem_insert p‚ÇÅ _)]
  use 0, 1
  simp [smul_zero]

===== Proof 2073 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  obtain ‚ü®a, b, c, ‚ü®rfl, rfl‚ü©‚ü© := h.exists_eq_affine_combination_of_mem_affine_span
    (Set.mem_insert x {y, z}) (Set.mem_insert_of_mem _ (Set.mem_insert _ _))
  rw [Set.pair_comm y z]
  exact collinear_iff_of_mem_affineCombination.mpr ‚ü®b, c, rfl, rfl‚ü©

===== Proof 2074 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine' ‚ü®x, z -·µ• x, _‚ü©
  intro p hp
  simp_all only [Set.mem_insert_iff, Set.mem_singleton_iff]
  rcases hp with (rfl | rfl | rfl) <;>
  (try simp [h.wbtw.left_mem]) <;>
  (try simp [h.wbtw.right_mem]) <;>
  use 0; simp

===== Proof 2075 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro p hp
  rw [Set.mem_insert_iff, Set.mem_insert_iff, Set.mem_singleton_iff] at hp
  rcases hp with (rfl | rfl | rfl)
  ¬∑ refine ‚ü®0, ?_‚ü©; simp
  ¬∑ rcases h with ‚ü®t, h‚ü©
    refine ‚ü®t, ?_‚ü©
    rw [h, vsub_vadd]
  ¬∑ refine ‚ü®1, ?_‚ü©; simp

===== Proof 2076 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  rw [wbtw_iff] at h
  obtain ‚ü®r‚ÇÅ, r‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := h
  refine' ‚ü®1 / (r‚ÇÅ + r‚ÇÇ), 1 / (r‚ÇÅ + r‚ÇÇ), 1 / (r‚ÇÅ + r‚ÇÇ), by norm_num, by norm_num, by norm_num,
    fun p => _‚ü©
  rw [Set.mem_insert_iff, Set.mem_insert_iff]
  rintro (rfl | rfl | rfl)
  ¬∑ refine' ‚ü®r‚ÇÅ / (r‚ÇÅ + r‚ÇÇ), 0, by norm_num, h‚ÇÅ, _‚ü©
    simp only [vadd_eq_add, one_div, zero_smul, add_zero, div_self, ne_eq, not_false_eq_true,
      inv_one, one_smul, Set.mem_insert_iff, Set.mem_singleton_iff]
    rw [add_comm, add_right_comm, h‚ÇÉ]
  ¬∑ refine' ‚ü®0, r‚ÇÇ / (r‚ÇÅ + r‚ÇÇ), by norm_num, by norm_num, _‚ü©
    simp only [vadd_eq_add, zero_add, zero_smul, one_div, zero_add, div_self, ne_eq, not_false_eq_true,
      inv_one, one_smul, Set.mem_insert_iff, Set.mem_singleton_iff]
    rw [h‚ÇÇ]
  ¬∑ refine' ‚ü®r‚ÇÅ / (r‚ÇÅ + r‚ÇÇ), r‚ÇÇ / (r‚ÇÅ + r‚ÇÇ), by norm_num, by norm_num, _‚ü©
    simp only [vadd_eq_add, one_div, zero_smul, add_zero, div_self, ne_eq, not_false_eq_true,
      inv_one, one_smul, Set.mem_insert_iff, Set.mem_singleton_iff]
    rw [add_comm r‚ÇÅ r‚ÇÇ, add_right_comm, h‚ÇÉ]

===== Proof 2077 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro p hp
  rw [Set.mem_insert_iff, Set.mem_insert_iff] at hp
  cases hp with
  | inl hp =>
    use 0
    simp [hp]
  | inr hp =>
    cases hp with
    | inl hp =>
      use 1
      simp [hp]
    | inr hp =>
      rw [Set.mem_singleton_iff] at hp
      use 2
      simp [hp]
      exact
        ‚ü®vsub_add_vsub_cancel _ _ _, two_smul _ _‚ü©
#align wbtw.collinear Wbtw.collinear

theorem _root_.Collinear.wbtw {x y z : P} (h : Collinear R ({x, y, z} : Set P)) :
    Wbtw R x y z ‚à® Wbtw R z y x := by
  rw [collinear_iff_of_mem (Set.mem_insert _ _)] at h
  rcases h with ‚ü®v, h‚ü©
  simp_rw [Set.mem_insert_iff, Set.mem_singleton_iff] at h
  have hx := h (by simp)
  have hz := h (by simp)
  rcases hx with ‚ü®t‚ÇÅ, h‚ÇÅ‚ü©
  rcases hz with ‚ü®t‚ÇÇ, h‚ÇÇ‚ü©
  by_cases he : t‚ÇÅ = t‚ÇÇ
  ¬∑ rw [‚Üê sub_eq_zero] at he
    have hs : y = x + t‚ÇÅ ‚Ä¢ v := by linear_combination he.symm ‚Ä¢ h‚ÇÅ
    rw [‚Üê hs] at h‚ÇÅ
    convert h‚ÇÅ.symm
    simp
  ¬∑ by_cases ht‚ÇÅ : t‚ÇÅ < 0
    ¬∑ refine Or.inr ‚ü®t‚ÇÇ - t‚ÇÅ, ?_‚ü©
      have hs : x = y + t‚ÇÇ ‚Ä¢ v := by linear_combination h‚ÇÇ
      rw [hs, ‚Üê smul_neg]
      simp_rw [sub_smul, smul_smul]
      linear_combination h‚ÇÅ
    refine Or.inl ‚ü®-t‚ÇÇ - t‚ÇÅ, ?_‚ü©
    have hs : z = y + (-t‚ÇÇ) ‚Ä¢ v := by linear_combination h‚ÇÇ
    rw [hs, ‚Üê smul_neg]
    simp_rw [sub_smul, smul_smul]
    linear_combination h‚ÇÅ

===== Proof 2078 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
 rw [collinear_iff_exists_forall_eq_smul_vadd]
 refine' ‚ü®x, z -·µ• x, _‚ü©
 intro p hp
 rw [Set.mem_insert_iff, Set.mem_insert_iff, Set.mem_singleton_iff] at hp
 cases hp
 rw [hp]
 exact ‚ü®0, by simp‚ü©
 cases hp
 rw [hp]
 exact ‚ü®1, by simp‚ü©
 rw [hp]
 exact ‚ü®2, by simp [two_smul]‚ü©
#align wbtw.collinear Wbtw.collinear

theorem Sbtw.collinear {x y z : P} (h : Sbtw R x y z) : Collinear R ({x, y, z} : Set P) :=
  h.wbtw.collinear

===== Proof 2079 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_fun]
  use fun p => if p = x then (1 : R) else if p = y then (2 : R) else 3
  simp only [Set.mem_insert_iff, Set.mem_singleton_iff, ite_eq_left_iff]
  aesop

===== Proof 2080 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h‚ÇÅ : Sbtw R w x z) (h‚ÇÇ : Sbtw R x y z) :
    Sbtw R w x y :=
  ‚ü®h‚ÇÅ.wbtw.trans_right_left h‚ÇÇ.wbtw, h‚ÇÅ.ne_left, h‚ÇÇ.left_ne‚ü©
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  rw [collinear_iff_exists_forall_eq_smul_vadd]
  refine ‚ü®x, z -·µ• x, ?_‚ü©
  intro w hw
  rw [Set.mem_insert_iff, Set.mem_insert_iff] at hw
  cases' hw with hw hw
  ¬∑ rw [hw]
    use 0
    simp
  ¬∑ cases' hw with hw hw
    ¬∑ rw [hw]
      use 1
      simp
    ¬∑ rw [Set.mem_singleton_iff] at hw
      rw [hw]
      use 2
      simp [‚Üê two_smul R (z -·µ• x)]
#align wbtw.collinear Wbtw.collinear

variable (R)

/-- 
===== Proof 2081 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by calc
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä =
        ‚Äñp.changeOriginSeries k l fun i => (ContinuousMultilinearMap.id ‚Ñù F) (fun _ => x)‚Äñ‚Çä := by
      congr with i
      simp only [ContinuousMultilinearMap.id_apply]
    _ ‚â§ (fun m => ‚Äñp.changeOriginSeriesTerm m k l‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ (m - k) * ‚Äñx‚Äñ‚Çä ^ (n - l)) (k + l) := by
      refine nnnorm_sum_le (Œ¥ := fun m : ‚Ñï => ‚Äñp.changeOriginSeriesTerm m k l‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ (m - k) *
        ‚Äñx‚Äñ‚Çä ^ (n - l)) (fun m h)
      convert changeOriginSeriesTerm_le_tsum k l x m n
      case h.e_a =>
        dsimp
        rw [add_tsub_cancel_right, add_tsub_cancel_left]
      simp_rw [‚Üê pow_add]
      rw [mul_right_comm, mul_assoc, add_tsub_cancel_right, p.changeOriginSeriesTerm_succ_succ k l,
        p.changeOriginSeriesTerm_zero_succ k l]
    _ ‚â§
        (fun m => ‚Äñp.changeOriginSeriesTerm m k l‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ (m - k) * ‚Äñx‚Äñ‚Çä ^ (n - l))
        (max (k + l) (k + n)) :=
      (nnnorm_changeOriginSeries_le_tsum _ _ (max (k + l) (k + n)) x)
    _ ‚â§
        ‚àë' m, ‚Äñp.changeOriginSeriesTerm m k l‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ m :=
      (by tsum_changeOriginSeries_rpow_nnnorm_le _ k l n x)
    _ ‚â§ ‚àë' _ : ‚Ñï, 1 :=
      (tsum_le_tsum fun m => by
        have :
          (‚àë i ‚àà range (p.support.card), ‚Äñp.changeOriginSeriesTerm m k l‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ (i - k)) =
            ‚àë i ‚àà range (p.support.card + k), ‚Äñp.changeOriginSeriesTerm m k l‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ i := by
          apply sum_range_add_eq_sum_range
        rw [add_tsub_cancel_left] at this
        convert_to ‚Äñp.changeOriginSeriesTerm m k l‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ m ‚â§ 1
        exact changeOriginSeriesTerm_le k l
        exact nnnorm_pow_le_tsum x m)
    _ = ‚àû := ENNReal.tsum_coe_eq ENNReal.one_lt_top

===== Proof 2082 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  refine (nnnorm_sum_le _ (fun k => ?_)).trans ?_
  ¬∑ refine (nnnorm_mul_le _ _).trans ((add_le_add_right (nnnorm_prod_le_of_le le_rfl fun _ _ => ?_) _).trans ?_)
    ¬∑ exact (comp_continuousMultilinear_map_nnnorm_le _ _).trans_eq (mul_one _).symm
    ¬∑ simpa using NNReal.rpow_le_rpow (nnnorm_snd_le _ _) le_rfl
  ¬∑ simpa using NNReal.rpow_le_rpow (nnnorm_fst_le _ _) le_rfl

===== Proof 2083 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  apply (nnnorm_sum_le _ _).trans
  rw [tsum_fintype]
  exact Finset.single_le_sum (fun _ _ => zero_le _) (Finset.mem_univ (0 : Fin (k + l)))

===== Proof 2084 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  refine (nnnorm_sum_le _ _).trans ?_
  refine sum_le_tsum _ (fun _ _ => zero_le _) ENNReal.summable

===== Proof 2085 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  refine tsum_le_tsum (fun Œº ‚Ü¶ ?_) (nnnorm_changeOriginSeriesTerm_summable p k l) ?_
  ¬∑ calc
      ‚Äñp.changeOriginSeries k l (fun _ ‚Ü¶ x)‚Äñ‚Çä ‚â§
          ‚àë' s : Œ£_, _, ‚Äñp.changeOriginSeriesTerm k l.succ s x‚Äñ‚Çä :=
        nnnorm_tsum_le (Exists.choose (nnnorm_changeOriginSeriesTerm_summable p k l)) fun Œº ‚Ü¶
          ‚ü®_, nnnorm_changeOriginSeriesTerm_summable p k l‚ü©
      _ = ‚àë' s : Œ£ _, _, ‚Äñp.changeOriginSeriesTerm k.succ l s x‚Äñ‚Çä := by
        -- Porting note: 
===== Proof 2086 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
    refine tsum_le_tsum (fun m ‚Ü¶ ?_)
      (nnnorm_changeOriginSeriesTerm_summable p k l x) (nnnorm_changeOriginSeriesTerm_summable p k l)
    rw [nnnorm_changeOriginSeriesTerm]
    split_ifs
    ¬∑ apply zero_le
    ¬∑ exact le_rfl

===== Proof 2087 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  refine (NNReal.tsum_le_tsum (fun i ?_ => ?_) ?_).trans_eq ?_
      (uniformSummable_changeOriginSeries p l) ?_
    ¬∑ rw [NNReal.tsum_mul_left]
      exact le_of_eq (by simp [mul_comm])
    ¬∑ rw [mul_assoc]
      exact tsum_mul_left_geometric_of_lt_one ((nnnorm_changeOriginSeriesTerm_le_geometric p (max_lt k.succ_pos l.succ_pos)).trans (by simp))
        ((le_max_right _ _).trans_lt (Nat.lt_succ_self _))
    ¬∑ rw [tsum_mul_left]
      exact tsum_geometric_nnnorm_lt_one (by simp)
    ¬∑ exact (NNReal.summable_mul_left _ <| p.changeOriginSeries_summable' k l).mul_left _
    ¬∑ simp_rw [tsum_fintype]

===== Proof 2088 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  rw [changeOriginSeries]
  refine tsum_le_tsum (fun m => ?_)
      (norm_changeOriginSeriesTerm_summable k l fun _ => x) <|
      norm_changeOriginSeriesTerm_summable k l fun _ => x
  refine' le_trans (nnnorm_sum_le _ _) (ENNReal.tsum_le_tsum fun m => _)
  simp_rw [nnnorm_changeOriginSeriesTerm]
  refine' le_trans (mul_le_mul' (p.nnnorm_le_tsum_nnnorm _)
      (p.nnnorm_le_tsum_nnnorm _)) (le_of_eq _)
  have : ((l.choose k)‚Åª¬π * (l.succ.choose k)) =
      (l.choose k) * (l.succ.choose k)‚Åª¬π := by
    rw [mul_comm (l.choose k : ‚Ñù), mul_comm (Nat.choose l.succ k : ‚Ñù), ENNReal.coe_mul]
    simp_rw [ENNReal.coe_inv, ENNReal.inv_mul_cancel]
    exact max_ne_zero_of_left l.succ_pos.ne.symm
  simp_rw [nnnorm_smul]
  simp_rw [‚Üê one_mul ((l.choose k)‚Åª¬π * (l.succ.choose k : ‚Ñù)), this]
  simp_rw [nnnorm_mul, NNReal.mul_inv_cancel, ENNReal.coe_one,
      one_mul (l.succ.choose k : ‚Ñù)]
  simp_rw [‚Üê div_eq_mul_inv, div_self
      (Nat.cast_ne_zero.2 <| l.succ_ne_zero k.succ_ne_zero), nnnorm_one]
  simp_rw [ENNReal.one_mul, NNReal.one_mul, ENNReal.coe_one]

===== Proof 2089 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
   calc
       _ ‚â§ ‚àë' _ : { s : Œ£l : ‚Ñï, { f : Fin l ‚Üí Œ± // ‚àÄ i, p.IsNontrivialAt (f i) } },
             ‚Äñp.changeOriginSeries k s.2.1 (fun _ => x)‚Äñ‚Çä :=
        (tsum_le_tsum_of_inj (f := fun _ => _)
          (fun _ _ => nnnorm_nonneg _) (fun _ _ => rfl) (fun _ _ => zero_le')
              (fun s => ‚ü®s.1, fun x => s.2 ‚ü®x, _‚ü©‚ü©) fun s => by simp_rw [Sigma.forall]; rfl)
      _ ‚â§ ‚àë' _ : { l : ‚Ñï // ‚àÄ i : Fin (k + 1), p.IsNontrivialAt i }, 1 := by
        gcongr
        exact le_tsum (fun _ => zero_le') ‚ü®l, _‚ü© rfl
      _ = ‚àë' _ : Fin (k + 1), 1 := tsum_sigma.symm
      _ = k + 1 := by simp

===== Proof 2090 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  refine ((p.changeOriginSeries k l).nnnorm_sum_le (Set.toFinite _)).trans_eq ?_
  refine tsum_congr fun l ‚Ü¶ ?_
  rw [nnnorm_of_nnnorm_mul_matrix, (mem_lowerCentralSeries_iff_forall' x).mp
    (lowerCentralSeries.mem_changeOriginSeries_iff_forall'.mp (p.changeOriginSeries_mem_lcs k l) _)]
  simp only [one_mul, NNReal.coe_one]
  rfl

===== Proof 2091 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  calc
  ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§ ‚àë' _ : { s : Œ£l : ‚Ñï, Fin l.succ √ó E //
      id s.fst = k ‚àß (fun _ : Fin k.succ => x) s.snd.snd = x }, 1 := by
          simp_rw [changeOriginSeries_apply, nnnorm_mul, ‚Üê prod_mk_nsmul, pi_apply,
            nnnorm_prod_single, nnnorm_nsmul]
          refine Finset.sum_le_sum_of_subset_of_nonneg ?_ ?_
          ¬∑ simp (config := { contextual := true })
          ¬∑ intro
            simp only [zero_le', imp_true_iff, zero_le]
    _ = ‚àë' (x : { x // x.1 = k ‚àß Aesop.Œ≤ x.2.2 = x }) , (1 : ‚Ñù‚â•0) := by simp
    _ ‚â§ ‚àë' _ : { x // x.1 = k }, (1 : ‚Ñù‚â•0) := tsum_mono (fun x => by
      cases x
      simp only [and_imp, ge_iff_le, mem_setOf_eq, Sigma.forall, Fin.forall_fin_succ,
        Fin.val_eq_val, Fin.mk_eq_mk, eq_self_iff_true, true_and, Sigma.mk.injEq]
      exact fun a b ca cb => ‚ü®ca, congr_arg _ cb‚ü©)
    _ = ‚àë' _ : Unit, (1 : ‚Ñù‚â•0) := tsum_congr fun x => by ext; simp_all
    _ = 1 := tsum_unique (@one_ne_top _ _) <| by rw [one_mul]


===== Proof 2092 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  calc
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
        ‚àë' _ : {s : Finset (Fin (k + l)) //
          s.card = l ‚àß ‚àÄ (i : Fin (k + l)), i ‚àà s ‚Üí (i : ‚Ñï) < k}, 1 :=
      (changeOriginSeries_nnnorm_le _ _ _)
    _ ‚â§ Fintype.card {s : Finset (Fin (k + l)) // s.card = l ‚àß
        ‚àÄ (i : Fin (k + l)), i ‚àà s ‚Üí (i : ‚Ñï) < k} := by
      simp_rw [tsum_fintype, one_le_sum' (fun _ => zero_le _)]
    _ = (Fintype.card {s : Finset (Fin (k + l)) // s.card = l}) := by
      congr!; ext; simp_rw [Finset.mem_filter]; aesop
    _ ‚â§ (Fintype.card {s : Finset (Fin (k + l)) //
        s.card = l}) * ‚àë' _ : {s : Finset (Fin (k + l)) //
          s.card = l ‚àß ‚àÄ (i : Fin (k + l)), i ‚àà s ‚Üí (i : ‚Ñï) < k}, 1 := by
      refine Nat.mul_le_mul_left _
        (tsum_fintype_le_tsum_fintype_of_le (fun _ => zero_le _))
    _ = (Fintype.card {s : Finset (Fin (k + l)) // s.card = l}) * k := by
      congr!; simp_rw [tsum_fintype, one_mul]
      exact tsum_boole _ _

===== Proof 2093 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  refine le_trans (by exact p.changeOriginSeriesIsometry k l) ?_
  unfold changeOriginSeries
  rw [tsum_fintype]
  refine Finset.sum_le_sum (fun a _ => ?_)
  have : ‚Äñ(p.changeOriginSeriesTerm k l a fun _ => x)‚Äñ‚Çä ^ 2 =
      ‚Äñp.changeOriginSeriesTerm k l a fun _ => x‚Äñ‚Çä := by
    simp only [nnnorm_nonneg, NNReal.rpow_natCast]
  rw [this]
  exact NNReal.le_rpow_nnnorm _ _

===== Proof 2094 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
    simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]

===== Proof 2095 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  refine tsum_of_nnnorm_bounded (F := fun _ => ‚Äñp k l‚Äñ‚Çä * x ^ l) ?_
    fun i => ?_
  ¬∑ exact summable_nnnorm_mul_pow l summable_geometric_of_lt_one (x.nnnorm.le_of_lt hx)
  suffices ‚Äñp.changeOriginSeries k l (fun _ : Fin l => x) i‚Äñ‚Çä ‚â§ ‚Äñp k l‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ l by gcongr
  rw [changeOriginSeries_apply]
  exact (nnnorm_changeOriginSeriesTerm_le_nnnorm k l i fun _ => x).trans
    ((mul_le_mul_right (pow_nonneg x.property l)).mpr (nnnorm_pi_le_of_le fun _ => by rfl))

===== Proof 2096 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  refine NNReal.le_of_forall_pos_le_add fun Œµ Œµpos h => ?_
  refine le_trans (le_of_eq (p.changeOriginSeries_summable_norm_aux k l).hasSum.tsum_eq) ?_
  simp_rw [tsum_fintype, Finset.sum_congr rfl fun _ _ =>
    (p.changeOriginSeries_summable_norm_aux k l).hasSum.tsum_eq, Finset.sum_add_distrib]
  rw [‚Üê add_assoc, ‚Üê Finset.sum_add_distrib]
  refine le_trans (add_le_add h (le_refl _)) (add_le_add_right (le_of_eq (by simp)) _)
  exact mod_cast Œµpos

===== Proof 2097 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
      exact Finset.single_le_sum (fun i _ => zero_le _) (Finset.mem_univ _)

===== Proof 2098 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]

===== Proof 2099 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  have : (fun _ : Fin k => x) = (fun _ : Fin k => x) := rfl
  calc
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
        ‚àë' _ : ‚Ñï, ‚Äñp.changeOriginSeriesTerm k l fun _ => x‚Äñ‚Çä := by
      refine le_trans (nnnorm_sum_le _ _) ?_
      exact tsum_le_tsum (fun i => nnnorm_changeOriginSeriesTerm_succ_le _ _ _)
        (by rwa [NNReal.summable_coe, ‚Üê coe_nnnorm,
          nnnorm_changeOriginSeries_summable_aux_fintype]) (by rwa [NNReal.summable_coe, ‚Üê coe_nnnorm,
          nnnorm_changeOriginSeries_summable_aux_fintype])
    _ ‚â§ ‚àë' _ : ‚Ñï, ‚Üë(p.changeOriginSeries k l fun _ => x).nnnorm := by
      exact tsum_le_tsum (fun _ => (le_abs_self _))
        (by rwa [NNReal.summable_coe, ‚Üê coe_nnnorm,
          nnnorm_changeOriginSeries_summable_aux_fintype]) (by rwa [NNReal.summable_coe, ‚Üê coe_nnnorm,
          nnnorm_changeOriginSeries_summable_aux_fintype])
    _ = ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä := by simp

===== Proof 2100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
   refine tsum_of_nnnorm_bounded (f := fun ik ‚Ü¶ ‚Äñp ik.1‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ ik.2)
     (changeOriginSeries_summable_nnnorm p _ _ _) (fun ik ‚Ü¶ ?_)
   simp only [nnnorm_mul, nnnorm_pow, nnnorm_coe_nat]
   rcases ik with ‚ü®‚ü®_, _ | _‚ü©, _‚ü©
   ¬∑ exact le_rfl
   ¬∑ simp

===== Proof 2101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
    refine (nnnorm_sum_le (fun i => p.changeOriginSeriesTerm i k l fun _ => x)
    (fintypeFin k)).trans ?_
    have : (fun i : Fin k ‚Üí E => x) = _root_.const (Fin k) x := by
      ext i
      rfl
    simp only [this]
    refine (Finset.sum_le_card_nsmul _ _ _ fun i _ => ?_).trans ?_
    ¬∑ exact (nnnorm_changeOriginSeriesTerm_apply_le_changeOriginSeriesTerm p k l x i)
    ¬∑ simp only [Finset.card_fin]
      exact (le_abs_self _).trans (le_trans (le_abs_self _) (le_abs_self _))

===== Proof 2102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
      simpa only [tsum_fintype] using (p.changeOriginSeries k).le_tsum' _

===== Proof 2103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
    refine (nnnorm_changeOriginSeries_summable_aux k l).le_hasSum (fun i ‚Ü¶ ?_)
      (hasSum_fintype fun i ‚Ü¶ p.changeOriginSeriesTerm k l i fun _ ‚Ü¶ x)
    rw [nnnorm_changeOriginSeriesTerm]
    positivity

===== Proof 2104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  refine ((nnnorm_sum_le _ _).trans (Finset.sum_le_sum fun _ _ => ?_)).trans
    (le_trans (by exact? : (‚àë _i : Fin k, ‚Äñx‚Äñ‚Çä ^ _i) ‚â§ ?_) (by exact? :
      (?_ : NNReal) ‚â§ ‚Üë(‚àë' _i : ‚Ñï, ‚Äñx‚Äñ ^ _i)))
  ¬∑ exact mul_le_mul' (p.changeOriginSeries_partialSum_nnnorm_le k l _)
      (changeOriginSeriesTerm_nnnorm_le k l _)
  ¬∑ rwa [NNReal.tsum_coe_eq ENNReal.coe_sum, ENNReal.coe_le_coe]
    exact summable_geometric_of_nnnorm_lt_one (p := fun _ => x)
      ((le_trans (by exact? : ‚Äñx‚Äñ‚Çä ‚â§ ‚Äñx‚Äñ) ENNReal.coe_nnnorm_le).trans_lt ENNReal.coe_lt_top)
  ¬∑ rw [tsum_mul_right]
    exact tsum_geometric_nnnorm_lt_one
      ((le_trans (by exact? : ‚Äñx‚Äñ‚Çä ‚â§ ‚Äñx‚Äñ) ENNReal.coe_nnnorm_le).trans_lt ENNReal.coe_lt_top)
  ¬∑ exact summable_geometric_of_nnnorm_lt_one (p := fun _ => x)
      ((le_trans (by exact? : ‚Äñx‚Äñ‚Çä ‚â§ ‚Äñx‚Äñ) ENNReal.coe_nnnorm_le).trans_lt ENNReal.coe_lt_top)

===== Proof 2105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
     exact nnnorm_sum_le _ _

===== Proof 2106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
      calc
        _ ‚â§ ‚àë' _ : Œ£ m : ‚Ñï, {s : Finset (Fin (k + m)) // s.card = l}, ‚Äñp k m‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ m :=
          (nnnorm_sum_le _ _).trans_eq (tsum_sigma' _ _)
        _ ‚â§ (‚Äñp‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä) ^ l * ‚Üë(k.choose l) := by
          gcongr
          exact tsum_const_mul_le_mul_norm (nnnorm_sum_pow_le l _) _ _
        _ ‚â§ ‚Äñp‚Äñ‚Çä ^ l * (‚Äñx‚Äñ‚Çä * ‚Üë((k + l)! : ‚Ñù‚â•0)) := by
          gcongr
          simpa only [nsmul_eq_mul, NNReal.coe_mul, ‚Üê NNReal.rpow_eq_pow, ‚Üê NNReal.rpow_mul, ‚Üê
            mul_pow, Nat.cast_mul, Nat.cast_add, Nat.cast_one] using rpow_mul_natCast_le (‚Äñx‚Äñ‚Çä : ‚Ñù‚â•0‚àû)
            (Nat.choose_mul_factorial_le k l)
        _ = (‚Äñp‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä) ^ l * ‚Üë((k + l)! : ‚Ñù‚â•0) := by rw [mul_comm ‚Äñx‚Äñ‚Çä ‚Äñp‚Äñ‚Çä, mul_rpow]

===== Proof 2107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
    if hk : p.rank < k then
    have : p.changeOriginSeries k l fun _ => x = 0 :=
    := by
      apply nnnorm_eq_zero.mp
      refine (changeOriginSeries p k l).sum_eq_zero (fun _ hl => ?_)
      rw [mem_lowerFinset_iff_lt] at hl
      exact (snd_strictMono hl).elim hk
    rw [this]
    simp
  else
    
    calc
      ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
          (‚àë' s : { s : Finset (Fin (k + l)) // s.card = l }, ‚Äñp.changeOriginSeriesTerm k s.1 ‚åä(p.radius : ‚Ñù)‚åã‚Çä‚Äñ‚Çä *
              ‚Üë(s : Finset (Fin (k + l))).card : ‚Ñù‚â•0) :=
        (p.changeOriginSeries k l (fun _ => x)).tsum_nnnorm_apply_le_tsum_aux _ (fun _ hl => hk) x
      _ ‚â§
          ‚àë' s : { s : Finset (Fin (k + l)) // s.card = l },
            ‚Äñp.changeOriginSeriesTerm k s.1 ‚åä(p.radius : ‚Ñù)‚åã‚Çä‚Äñ‚Çä *
              ‚Üë(s : Finset (Fin (k + l))).card : ‚Ñù‚â•0 := by
        refine Real.tsum_le_tsum (fun s => ?_) ?_ ?_
        ¬∑ simpa using NNReal.coe_nonneg _
        ¬∑ -- Porting note: previously the simp was on one line
          simp_rw [NNReal.tsum_mul_left]
          intro k l x; exact NNReal.coe_nonneg _
        ¬∑ intro s hs
          exact NNReal.tsum_eq_one_of_ne_zero hk
      _ ‚â§
          ‚àë' s : Finset (Fin (k + l)), ‚Äñp.changeOriginSeriesTerm k s ‚åä(p.radius : ‚Ñù)‚åã‚Çä‚Äñ‚Çä :=
        (le_tsum _ -- Porting note: suggests a dsimp is needed here
          fun b =>
          _)
      _ =
          ‚àë' b : Fin (k + l), ‚Äñp.changeOriginSeriesTerm k {b} ‚åä(p.radius : ‚Ñù)‚åã‚Çä‚Äñ‚Çä := by
        rw [tsum_eq_sum fun i hi => ?_]
        ¬∑ simp
      _ ‚â§
          ‚àë' (b : Fin (k + l)) (i : Fin l),
            ‚Äñp.changeOriginSeriesTerm k {b} ‚åä(p.radius : ‚Ñù)‚åã‚Çä‚Äñ‚Çä :=
        (tsum_mono (fun b => ?_) le_rfl)
      _ =
          ‚àë' (b : Fin (k + l)) (i : Fin l),
            ‚Äñp.changeOriginSeriesTerm k {b} ‚åä(p.radius : ‚Ñù)‚åã‚Çä‚Äñ‚Çä :=
        tsum_congr fun b => tsum_congr fun i => rfl
      ¬∑ rw [changeOriginSeriesTerm_apply (p := p) (k := k) (hk := hk)]
        apply NNReal.coe_nonneg

===== Proof 2108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
     refine NNReal.le_of_forall_pos_nnreal_lt fun r hr ‚Ü¶ ?_
     refine le_of_forall_nat_le fun t ‚Ü¶ ?_
     refine le_trans ?_ (le_trans ((le_abs_self _).trans ?_)
       (NNReal.lt_add_sub_of_lt_add_of_le le_rfl (le_trans ?_
         (Finset.sum_le_sum_of_subset_of_nonneg (Finset.subset_univ _)
           fun _ _ _ ‚Ü¶ NNReal.zero_le _)) :
         _ < r))
     1 ‚â§ _
     ¬∑ exact (le_abs_self _).trans (NNReal.lt_add_sub_of_lt_add_of_le le_rfl (le_trans ?_
           (Finset.sum_le_sum_of_subset_of_nonneg (Finset.subset_univ _)
              fun _ _ _ ‚Ü¶ NNReal.zero_le _)) :
           _ < r))
     1 ‚â§ _
     ¬∑ exact (le_abs_self _).trans (NNReal.lt_add_sub_of_lt_add_of_le le_rfl (le_trans ?_
           (Finset.sum_le_sum_of_subset_of_nonneg (Finset.subset_univ _)
              fun _ _ _ ‚Ü¶ NNReal.zero_le _)) :
           _ < r))
     1 ‚â§ _
     ¬∑ exact (le_abs_self _).trans (NNReal.lt_add_sub_of_lt_add_of_le le_rfl (le_trans ?_
         (Finset.sum_le_sum_of_subset_of_nonneg (Finset.subset_univ _)
            fun _ _ _ ‚Ü¶ NNReal.zero_le _)) :
         _ < r))
     1 ‚â§ _
     ¬∑ exact (le_abs_self _).trans (NNReal.lt_add_sub_of_lt_add_of_le le_rfl (le_trans ?_
         (Finset.sum_le_sum_of_subset_of_nonneg (Finset.subset_univ _)
           fun _ _ _ ‚Ü¶ NNReal.zero_le _)) :
         _ < r))
     1 ‚â§ _
     ¬∑ exact (le_abs_self _).trans (NNReal.lt_add_sub_of_lt_add_of_le le_rfl (le_trans ?_
         (Finset.sum_le_sum_of_subset_of_nonneg (Finset.subset_univ _)
           fun _ _ _ ‚Ü¶ NNReal.zero_le _)) :
         _ < r))

===== Proof 2109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
    calc
       _ ‚â§ ‚àë' _ : ‚®Ç[R] _ : Fin k, E, ‚Äñp k‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ l := by
        refine (NNReal.tsum_mono fun _ => ?_).trans_eq (tsum_mul_right.symm)
        exact p.nnnorm_changeOriginSeriesTerm_apply_le k l _ _
      _ ‚â§ ‚àë' _, ‚Äñp k‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ l := NNReal.tsum_mono fun _ => by rfl
      _ ‚â§ _ := by gcongr; apply NNReal.tsum_geometric_of_lt_one; simp [p.nnnorm_le]; simp [p.nnnorm_le]

===== Proof 2110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  calc
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
        ‚àë' _ : {s : Œ£l : ‚Ñï, Finset (Fin (k + l)) // s.2.card = l}, ‚Äñp k s.1‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ l :=
      (NNReal.tsum_mono fun s ‚Ü¶ by
        calc
          ‚Äñp.changeOriginSeries k l (fun _ => x) s.1‚Äñ‚Çä =
              ‚Äñp.changeOriginSeriesTerm k l s.1 x‚Äñ‚Çä := rfl
          _ ‚â§ ‚Äñp k s.1‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ l := nnnorm_changeOriginSeriesTerm_le _ _ _ _ _
      )
    _ ‚â§ ‚àë' _ : {s : Œ£l : ‚Ñï, Finset (Fin (k + l)) // s.2.card = l}, ‚Äñp k s.1‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ k := by
      refine tsum_le_tsum_of_ne_zero_bddAbove (p := fun s ‚Ü¶ ‚Äñp k s.1‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ l) ?_ fun s ‚Ü¶ ?_
      ¬∑ rintro ‚ü®‚ü®l', s'‚ü©, hs'‚ü© h
        rw [Subtype.coe_mk, h] at hs'
        have := Nat.le_of_card_eq_le hs'
        contradiction
      ¬∑ simp only [NNReal.mul_rpow, NNReal.rpow_natCast]

        refine mul_le_mul_left' (rpow_le_rpow_of_exponent_le ?_ ?_ ?_) _
        ¬∑ exact NNReal.coe_le_coe.2 (le_of_lt $ p.nnnorm_lt_top _)
        ¬∑ exact x.2
        ¬∑ exact k.cast_nonneg
    _ ‚â§
        (‚àë' s :
            {s : Œ£l : ‚Ñï, Finset (Fin (k + l)) // s.2.card = k + l},
              ‚Äñp k s.1‚Äñ‚Çä) *
          ‚Äñx‚Äñ‚Çä ^ k := by
      rw [‚Üê tsum_mul_left]
      refine
        tsum_le_tsum (fun s ‚Ü¶ ?_) (ENNReal.summable.mul_left _)
          (NNReal.summable_mul_left (NNReal.rpow_nonneg _ _))
      dsimp
      rw [tsum_fintype, Finset.sum_mul]
      simp_rw [tsum_apply]
      dsimp
      rw [mul_comm]
      rw [‚Üê Finset.sum_pow_mul_eq_add_pow (k := k) (l := l) (m := ‚Äñp k s.1‚Äñ‚Çä) (n := ‚Äñx‚Äñ‚Çä)]
      simp [(p.changeOriginSeries_apply_eq _ _ _).symm]

===== Proof 2111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
    have : ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§ ‚àë' _ : Unit, ‚Äñp k l‚Äñ‚Çä * ‚Äñx‚Äñ‚Çä ^ l :=
      (nnnorm_sum_le (changeOriginSeriesIndexSet k l) fun i =>
            p.changeOriginSeriesTerm k l i.fst i.snd fun _ => x).trans
        (le_of_eq (tsum_fintype _))
    refine this.trans ?_
    simp_rw [tsum_mul_right]

===== Proof 2112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ‚Ñï) (x : E) :
    ‚Äñp.changeOriginSeries k l fun _ => x‚Äñ‚Çä ‚â§
:= by
  rw [changeOriginSeries_apply]
  refine mul_le_mul' (p.nnnorm_changeOriginSeriesTerm_le k l) ?_ ?_ (by positivity)
  rw [tsum_fintype]
  exact sum_le_sum fun _ _ => nnnorm_sum_le _ _

===== Proof 2113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®hz, hy‚ü©
    use 0, 1
    simp [*]
  next =>
    rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;> linarith

===== Proof 2114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  ¬∑ intro hz
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    simp [*]
    constructor
    ¬∑ linarith
    ¬∑ linarith
  ¬∑ rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor
    ¬∑ linarith
    ¬∑ linarith

===== Proof 2115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x)
    use (z - x) / (y - x)
    constructor
    ¬∑ nlinarith
    constructor
    ¬∑ nlinarith
    constructor
    ¬∑ nlinarith
    field_simp
    linarith
  next =>
    rintro ‚ü®a, b, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©
    constructor
    ¬∑ nlinarith
    ¬∑ nlinarith

===== Proof 2116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®hzx, hzy‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    constructor <;> field_simp <;> linarith
  next =>
    rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;> linarith

===== Proof 2117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    constructor
    ¬∑ linarith
    ¬∑ constructor
      ¬∑ linarith
      ¬∑ constructor
        ¬∑ linarith
        ¬∑ linarith
  next =>
    rintro ‚ü®a, b, h‚ÇÄ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
    constructor
    ¬∑ linarith
    ¬∑ linarith

===== Proof 2118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (y - z) / (y - x), (y - z) / (y - x)
    constructor
    <;> field_simp [sub_pos, *]
    <;> linarith
  next =>
    rintro ‚ü®a, b, h‚ÇÄ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
    constructor <;> linarith

===== Proof 2119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x)
    use (z - x) / (y - x)
    constructor
    ¬∑ nlinarith
    ¬∑ constructor
      ¬∑ nlinarith
      ¬∑ constructor
        ¬∑ nlinarith
        ¬∑ nlinarith
  next =>
    rintro ‚ü®a, b, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©
    constructor
    ¬∑ nlinarith
    ¬∑ nlinarith

===== Proof 2120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (y - z) / (y - x), (y - z) / (y - x)
    constructor
    next =>
      nlinarith
    constructor
    next =>
      nlinarith
    constructor
    next =>
      nlinarith
    nlinarith
  next =>
    rintro ‚ü®a, b, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©
    constructor
    nlinarith
    nlinarith

===== Proof 2121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  ¬∑ rintro ‚ü®hz, hz'‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    have hy : x < y := by linarith
    constructor <;> field_simp [sub_pos, hy] <;> linarith
  ¬∑ rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;> linarith [mul_nonneg ha (le_of_lt h)]

===== Proof 2122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 0, 1
    simp [h‚ÇÅ, h‚ÇÇ, h]
  next => rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;> linarith

===== Proof 2123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    simp [h, h‚ÇÅ, h‚ÇÇ, sub_eq_zero, div_eq_zero_iff]
    constructor
    ¬∑ linarith
    ¬∑ field_simp [h_1, h_2]
      linarith
  next => rintro ‚ü®a, b, h‚ÇÄ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
    constructor
    ¬∑ linarith
    ¬∑ linarith

===== Proof 2124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    constructor <;> field_simp [h, sub_eq_zero, not_or] <;> linarith
  ¬∑ rintro ‚ü®a, b, h‚ÇÄ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
    constructor <;> linarith

===== Proof 2125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  simp [h]

===== Proof 2126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (y - z) / (y - x), (y - z) / (y - x)
    constructor
    <;> field_simp [sub_pos.mpr h, *]
    <;> linarith
  next =>
    rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    refine' ‚ü®by linarith, by linarith‚ü©

===== Proof 2127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  simp only [mem_Ioc, Set.exists_iff_exists_left]
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use z - x, y - z
    constructor <;> linarith
  next =>
    rintro ‚ü®a, b, h‚ÇÄ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
    constructor <;> linarith

===== Proof 2128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  refine' ‚ü®fun hz => ‚ü®1 - z, z, _, _, _, _‚ü©, fun ‚ü®a, b, ha, hb, hab, hz‚ü© => ‚ü®hz ‚ñ∏ hab, hz ‚ñ∏ (mul_le_mul_right (lt_of_le_of_lt ha hb)).trans (mul_le_mul_left (lt_of_le_of_lt ha hb))‚ü©‚ü©
  all_goals nlinarith [h]

===== Proof 2129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    constructor
    <;> field_simp [sub_pos.mpr h]
    <;> ring_nf
    <;> linarith
  next =>
    rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor
    <;> linarith

===== Proof 2130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  ¬∑ rintro ‚ü®hz, hz'‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    simp [hz, hz', sub_pos.mpr h, sub_add_cancel]
    exact ‚ü®by ring, by field_simp [sub_ne_zero.mpr h.ne, sub_ne_zero.mpr h.ne.symm]‚ü©
  ¬∑ rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor
    ¬∑ linarith [mul_nonneg ha (le_of_lt h)]
    ¬∑ linarith [mul_nonneg ha (le_of_lt h)]

===== Proof 2131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x)
    use (z - x) / (y - x)
    constructor
    ¬∑ linarith
    constructor
    ¬∑ linarith
    constructor
    ¬∑ linarith
    rw [div_add_div_same]
    linarith
  ¬∑ rintro ‚ü®a, b, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©
    constructor
    ¬∑ linarith
    ¬∑ linarith

===== Proof 2132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  ¬∑ intro hz
    use (z - x) / (y - x), (y - z) / (y - x)
    have hy : y - x ‚â† 0 := by linarith
    constructor
    ¬∑ exact div_nonneg (sub_nonneg.mpr hz.1) (sub_nonneg.mpr h.le)
    constructor
    ¬∑ exact div_pos (sub_pos.mpr hz.2) (sub_pos.mpr h)
    constructor
    ¬∑ field_simp [hy]; ring
    ¬∑ field_simp [hy]; ring
  ¬∑ rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor
    ¬∑ linarith [mul_nonneg ha h.le]
    ¬∑ linarith [mul_pos hb h]

===== Proof 2133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  exact ‚ü®fun hz => ‚ü®1 - (z - x) / (y - x), (z - x) / (y - x), by linarith, by linarith, by linarith, by
    field_simp; ring‚ü©, fun ‚ü®a, b, ha, hb, hab, hz‚ü© => by
    rw [‚Üê hz]
    have hy : 0 < y - x := by linarith
    constructor <;>
      linarith
    ‚ü©

===== Proof 2134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  exact ‚ü®fun hz => ‚ü®1 - (z - x) / (y - x), (z - x) / (y - x), by linarith, by linarith, by linarith, by
    field_simp; ring‚ü©, fun ‚ü®a, b, ha, hb, hab, hz‚ü© => by
    rw [‚Üê hz]
    exact ‚ü®by linarith, by linarith‚ü©‚ü©

===== Proof 2135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (y - z) / (y - x), (y - z) / (y - x)
    constructor
    <;> field_simp [sub_pos, h, h‚ÇÅ, h‚ÇÇ]
    <;> ring_nf
    <;> linarith
  next =>
    rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;> linarith

===== Proof 2136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    constructor <;> field_simp <;> linarith
  next =>
    rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;> linarith

===== Proof 2137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  next =>
    rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    constructor <;> norm_num <;>
      field_simp [h, sub_ne_zero] <;>
      ring_nf
    <;>
      linarith
  next =>
    rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;>
      linarith

===== Proof 2138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  refine' ‚ü®fun hz => ‚ü®1 - (z - x) / (y - x), (z - x) / (y - x), by linarith, by linarith,
    by linarith, by linarith‚ü©, fun ‚ü®a, b, ha, hb, hab, hz‚ü© => ‚ü®by linarith [hz], by linarith [hz]‚ü©‚ü©

===== Proof 2139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x)
    use (z - x) / (y - x)
    constructor
    ¬∑ nlinarith
    ¬∑ constructor
      ¬∑ nlinarith
      ¬∑ constructor
        ¬∑ nlinarith
        ¬∑ nlinarith
  ¬∑ rintro ‚ü®a, b, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©
    constructor
    ¬∑ nlinarith
    ¬∑ nlinarith

===== Proof 2140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  refine' ‚ü®fun hz => ‚ü®y - z, z, by linarith, by linarith, by linarith, by linarith‚ü©, _‚ü©
  rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
  constructor <;> linarith

===== Proof 2141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  ¬∑ intro h'
    use 1 - (y - z) / (y - x), (y - z) / (y - x)
    simp_all
    <;> field_simp [sub_ne_zero.mpr h.ne']
    <;> linarith
  ¬∑ rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;> linarith

===== Proof 2142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  refine' ‚ü®fun hz => _, _‚ü©
  use 1 - (y - z) / (y - x), (y - z) / (y - x)
  simp [*, sub_eq_zero, sub_eq_iff_eq_add]
  constructor
  <;> intro hz
  <;> simp_all [sub_eq_zero]
  <;> linarith

===== Proof 2143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  constructor
  ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    constructor <;> field_simp [h, sub_pos] <;> linarith
  ¬∑ rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;> linarith

===== Proof 2144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ‚àà Ioc x y ‚Üî ‚àÉ a b, 0 ‚â§ a ‚àß 0 < b ‚àß a + b = 1 ‚àß a * x + b * y = z := by
  refine ‚ü®fun hz => ?_, ?_‚ü©
  next =>
    use 1 - (z - x) / (y - x), (z - x) / (y - x)
    constructor
    <;> field_simp [sub_pos, h, sub_ne_zero.2 h.ne']
    <;> ring_nf
    <;> linarith [hz.1, hz.2]
  next =>
    rintro ‚ü®a, b, ha, hb, hab, rfl‚ü©
    constructor <;> linarith [mul_nonneg ha (sub_pos.2 h).le]

===== Proof 2145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor <;> intro h
  case mp =>
    intro M' hM'.injective
    apply (inferInstance : Injective (rTensor N M'.subtype))
  case mpr =>
    intro Œπ _ m n hsum
    apply h
    rw [Submodule.sum_mem_iff_exists_sum]
    exact ‚ü®Œπ, rfl, hsum‚ü©

===== Proof 2146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor
  <;> intro h
  <;> intros
  <;> apply h
  <;> simp [*]
  <;> aesop

===== Proof 2147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  apply Iff.intro (fun h => ?_) (fun h M N => ?_) <;> intros
  ¬∑ intro h Œπ _ m n h2
    apply h
    simp
    rw [h2]
    exact VanishesTrivially.zero
  ¬∑ apply h
    ext
    simp

===== Proof 2148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor <;> intro h
  <;> intro M' hfg
  <;> specialize h
  <;> intro x y hxy
  <;> rw [rTensor_apply] at hxy
  <;> refine h _ _ ?_
  <;> rw [Submodule.mem_subtype]
  <;> exact hxy

===== Proof 2149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor
  ¬∑ intro h M' hM'
    apply TensorProduct.vanishesTrivially_of_sum_eq_zero_inl
    exact h
  ¬∑ intro h Œπ _ m n hmn
    apply h
    rw [Finset.sum_eq_zero]
    exact hmn

===== Proof 2150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine' ‚ü®fun h => _, fun h M' _ => _‚ü© <;> intro hMN <;>
    simpa using hMN

===== Proof 2151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor <;> intro h
  <;> intro M' hM'
  <;> specialize h (M' : Type _) (inferInstance : Fintype M')
    (fun i => (‚ü®i, Set.mem_univ i‚ü© : M')) (fun _ => 1)
  <;> simpa [sum_tmul] using h
  <;> intro x y hxy
  <;> rw [‚Üê @rTensor_id _ _ _ _ _ M', ‚Üê @rTensor_subtype_comp_incl M' N,
      Function.comp_apply, Submodule.subtype_apply, Submodule.coe_sub, ‚Üê rTensor_tmul] at hxy
  <;> simpa using h hxy

===== Proof 2152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  apply Iff.intro
  intro h; intro M' hfg; apply h; simp; intro Œπ _ m n hmn; apply hfg; rw [hmn]; simp
  intro h; intro Œπ hŒπ m n hmn; apply h; simp; rw [hmn]; simp

===== Proof 2153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine ‚ü®fun h ‚Ü¶ fun M' hM' ‚Ü¶ ?_, fun h Œπ _ m n hnm ‚Ü¶ ?_‚ü©
  ¬∑ letI := hM'.out
    refine h _ _ (by simp [hnm])
  ¬∑ replace hM' := hM'.out
    apply h M' hM'
    simp_all

===== Proof 2154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor
  . intro h M' _
    exact h
  . intro h Œπ _ m n h‚ÇÄ
    classical
    let f := fun (i : Œπ) ‚Ü¶ (m i, n i)
    let f‚ÇÄ : Œπ ‚Üí M √ó À¢ N := fun i ‚Ü¶ (m i, n i)
    let f‚ÇÅ : M √óÀ¢ N ‚Üí‚Çó[R] M ‚äó[R] N := rTensor M (LinearMap.snd R N N)
    let f‚ÇÇ : M ‚äó[R] N ‚Üí‚Çó[R] M √óÀ¢ N := rTensor_hom_to_snd_inl R M N
    have h‚ÇÅ : VanishesTrivially R m n := by
      apply (h M'.map (LinearMap.fst R M N) M'.fg_map FiniteDimensional.fintypeFinChooseInjective)
      simp only [fst_rTensor, Submodule.map_top, LinearMap.range_eq_top]
    rw [VanishesTrivially_iff] at h‚ÇÅ
    specialize h‚ÇÅ (‚àë i : Œπ, m i) (‚àë i : Œπ, n i)
    simp only [fst_sum, h‚ÇÄ, snd_sum, tsum_apply, snd_smul, fst_smul, tsum_smul, Finset.mem_univ,
      Submonoid.smul_def, Finset.sum_dite_eq', Finset.mem_univ] at h‚ÇÅ
    rw [map_zero] at h‚ÇÅ
    rw [LinearMap.map_eq_zero_iff] at h‚ÇÅ
    specialize h (M'.map (LinearMap.fst R M N)) M'.fg_map FiniteDimensional.fintypeFinChooseInjective
    apply h
    simp only [FiniteDimensional.fintypeFinChooseInjective,
      fst_rTensor, Submodule.map_top, LinearMap.range_eq_top]
    rw [LinearMap.range_eq_top]
    refine Submodule.mem_map.2 ?_
    simp only [FiniteDimensional.fintypeFinChooseInjective,
      fst_rTensor, Submodule.mem_map, LinearMap.mem_range]
    exact ‚ü®0, rfl‚ü©

===== Proof 2155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine' ‚ü®fun h M' hM' => _, fun h Œπ _ m n hmn => _‚ü© <;>
  simp_all [Finset.sum_const, nsmul_eq_smul_cast]
  <;>
  simp_all [TensorProduct.rTensor_tmul]

===== Proof 2156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine ‚ü®fun h M' hM' ‚Ü¶ ?_, fun h Œπ _ m n hmn ‚Ü¶ ?_‚ü© <;>
  apply h <;> assumption

===== Proof 2157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  exact ‚ü®fun h ‚Ü¶ fun M' _ ‚Ü¶ (injective_iff_map_eq_zero _).2 (by rintro _ ‚ü®x, rfl‚ü©; exact @h _ _ x _ (by simp)),
    fun h ‚Ü¶ fun _ _ m n hmn ‚Ü¶ (injective_iff_map_eq_zero _).1 (h _ inferInstance) (by simpa [hmn] using Submodule.mem_bot.2 rfl)‚ü©

===== Proof 2158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  dsimp only [VanishesTrivially]
  refine ‚ü®fun h M' _ =>?_, fun h Œπ _ m n h‚ÇÄ => ?_‚ü©
  ¬∑ simp_rw [injective_iff_map_eq_zero]
    intro x hx
    obtain ‚ü®m, rfl‚ü© := (rTensor_surjective N).2 hx
    exact h m rfl
  ¬∑ refine ((submodule_iSup_eq_top R M N).2 h).2
    simp_rw [comp_iSup_eq_top]
    intro i
    exact h i.some (i.some_spec) rfl

===== Proof 2159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor
  case mp =>
    intro h M' hM'
    apply h
    erw [Submodule.sum_mem_bot]
    aesop
  case mpr =>
    intro h Œπ _ m n hmn
    apply h
    rw [‚Üê rTensor_sum_tmul]
    rw [hmn]
    apply Submodule.mem_bot.mpr
    simp

===== Proof 2160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor <;> intro h
  next =>
    intro M' _
    apply (h (m := fun _ => 0) (n := fun _ => 0)).sum_eq_zero_of_mem_iff
    simp
  next =>
    intro Œπ _ m n e
    rw [‚Üê Submodule.eq_bot_iff]
    apply h
    erw [Submodule.fg_iff_rTensor_eq_bot_of_forall_mem]
    exact e

===== Proof 2161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h I G hI hG ‚Ü¶ ?_‚ü©
  ¬∑ intro M' hM'
    specialize h I G hI fun i ‚Ü¶ (‚ü®(hM'.subtype i : M'), hM'.subtype_mem i‚ü© : M')
      fun i ‚Ü¶ (‚ü®(hM'.subtype i : N), hM'.subtype_mem i‚ü© : N)
    simpa using h
  ¬∑ apply h (‚ä§ : Submodule R M) inferInstance
    ext x
    simp [hI.sum_eq]

===== Proof 2162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine' ‚ü®fun h M' hM' => _, fun h Œπ _ m n h' => _‚ü©
  ¬∑ exact fun m n h => hM'.rTensor_injective N (h rfl)
  ¬∑ exact h M'.map (mkTensorProduct R M N) _ (by aesop) _ _ h'

===== Proof 2163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor <;> intro h
  ¬∑ intro M' hM'
    apply h
    simp only [Finset.sum_sub_distrib, Finset.sum_const, nsmul_eq_smul_cast,
      Finset.card_univ, smul_smul]
    erw [TensorProduct.tmul_sum, Submodule.FG.sum_mem_iff, sum_eq_zero_iff]
    intro i
    simp [LinearMap.map_smul]
  ¬∑ intro Œπ _ m n h'
    have H : Injective (rTensor N (‚®ï i : Œπ, (m i).subtype)) := by
      rw [‚Üê Submodule.iSup_subtype, Submodule.fg_iff_exists_iSup_eq] at hM'
      obtain ‚ü®s, rfl‚ü© := hM'
      exact h _ (Submodule.fg_iSup_of_fg fun j : s => (m j).map (‚®ï i : Œπ, (m i).subtype).subtype)
    rw [‚Üê LinearMap.ker_eq_bot, LinearMap.ker_rTensor] at H
    rw [VanishesTrivially, ‚Üê LinearMap.ker_eq_bot, LinearMap.ker_iSup] at H
    simp only [LinearMap.mem_ker] at H
    specialize H (‚àë i, m i ‚äó‚Çú n i)
    simpa only [map_sum, map_tmul, Submodule.mem_bot] using H h'

===== Proof 2164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor <;> intros <;> intros <;>
    simp_all [sum_tmul, VanishesTrivially, rTensor_tmul, zero_tmul]
  aesop

===== Proof 2165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor <;> intro h
  <;> intro M' hM'.1 <;> intro x hx <;>
    have hx' := congr_arg (fun x : M ‚äó[R] N => x ‚äó‚Çú[R] (0 : N)) hx
  <;> simp at hx'
  <;> have hx'' := h (Œπ := {x // x ‚àà M'}) (m := fun i => i.1) (n := fun i => 0)
    (by simp_all)
  <;> simp_all

===== Proof 2166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by.
  refine' ‚ü®fun h ‚Ü¶ fun M' hM' ‚Ü¶ _, fun h ‚Ü¶ fun _ _ _ _ _ hmn ‚Ü¶ _‚ü© <;>
  aesop

===== Proof 2167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor
  ¬∑ intro h M' hfg
    have h0 : ‚àÄ {m n}, ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n := h
    exact (h0 (M' := ‚ä§) (by simp)).1
  ¬∑ intro h Œπ _ m n h0
    have h0' : ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := h
    exact (h0' (M' := ‚ä§) (by simp)).1

===== Proof 2168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine' ‚ü®fun h => _, fun hŒπ => _‚ü© <;> intro M' hM' <;>
    have h' := hM'.choose_spec.2
    <;> haveI : RelM M' := ‚ü®M'.subtype, rfl, _, _‚ü© <;>
    simpa? using hŒπ M' _ <;>
  exact fun {Œπ m n} h‚ÇÄ =>
    hM'.choose_spec.1 ‚ü®_, _, h‚ÇÄ‚ü©

===== Proof 2169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h Œπ _ _ _ _ ‚Ü¶ ?_‚ü©
  case refine_1 =>
    intro M' hM' x hx
    have H : ‚àë i ‚àà Finset.univ, (x i : M) ‚äó‚Çú[R] 1 = 0 := by
      simpa using congr_arg (rTensor N M'.subtype) hx
    simpa using h H
  case refine_2 =>
    have H : ‚àë i, (m i : M) ‚äó‚Çú[R] (1 : N) = ‚àë i, m i ‚äó‚Çú[R] (n i : N) := by
      apply Finset.sum_congr rfl
      intro i _
      simp
    rw [H] at h
    simpa using h H

===== Proof 2170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  apply Iff.intro
  ¬∑ intro h M' hfg
    rw [Injective]
    intros x y hxy
    simp only [rTensor_tmul, Submodule.coeSubtype, Subtype.coe_mk] at hxy
    apply h
    ¬∑ simp only [hfg, Submodule.fg_top, exists_true_left]
    ¬∑ simp only [hxy, Submodule.zero_mem_bot]
  ¬∑ intro h Œπ _ m n hmn
    specialize h (span R (Set.range m)) ‚ü®_, hmn‚ü©
    rw [‚Üê Submodule.mem_bot (R := R), ‚Üê h]
    simp only [rTensor_tmul, Submodule.coeSubtype, Subtype.coe_mk, tmul_smul]
    rw [Submodule.mem_span]
    intros p hp
    rw [Finsupp.mem_span_range_iff_exists_finsupp] at hp
    obtain ‚ü®f, rfl‚ü© := hp
    simp only [Finsupp.sum, Finset.sum_apply, Finsupp.smul_sum, Finsupp.sum_smul, smul_tmul,
      tmul_smul, _root_.smul_eq_mul, map_finsupp_sum]
    apply Finset.sum_congr rfl
    intros i _
    apply Finsupp.sum_congr rfl
    intros j _
    simp only [Function.comp_apply, RingHom.id_apply, Submodule.coeSubtype, Subtype.coe_mk,
      tmul_smul, smul_tmul, _root_.smul_eq_mul]
    apply mul_comm

===== Proof 2171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine' ‚ü®fun h M' hM' => _, fun h Œπ _ m n h‚ÇÄ => _‚ü©
  ¬∑ exact h.2 M' (Œπ := R) (fun i => 1) (Œπ := R)
      (fun i => Classical.choose hM') (by simpa using hM'.sum_mem _)
  ¬∑ let M'' : Submodule R M := ‚®Ö i, LinearMap.range (TensorProduct.mk R M N (m i))
    have hM'' : M''.FG := by
      apply FG.iInf; exact fun i => FG.mk (s := {m i})
      rintro r ‚ü®i, rfl‚ü©
      exact ‚ü®i, rfl‚ü©
    rw [‚Üê
      show (‚àë i, m i ‚äó‚Çú n i : M ‚äó[R] N) = ‚àë i, TensorProduct.mk R M N (m i) (n i) by simp] at h‚ÇÄ
    rw [‚Üê show (‚àë i, m i ‚äó‚Çú n i : M ‚äó[R] N) = ‚àë i,
        TensorProduct.mk R M N (m i) (n i) by simp] at h‚ÇÄ
    apply h M'' hM''
    rw [‚Üê Submodule.mem_bot R]
    refine' h‚ÇÄ.symm ‚ñ∏ _
    simp only [iInf_subtype, range_mk, sum_subtype_eq_sum_filter]
    rw [Finset.sum_filter_of_ne]
    intro i hi; rw [mem_bot]
    exact h (Finset.mem_univ i)

===== Proof 2172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine' ‚ü®fun h M' _ => _, fun h Œπ _ m n h‚ÇÄ => _‚ü©
  ¬∑ exact fun hM => h hM
  simp_rw [VanishesTrivially, Submodule.mem_bot]
  intro x
  apply (inferInstance : Subsingleton (M ‚äó[R] N))

===== Proof 2173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  refine' ‚ü®fun h M' hM' => _, fun h Œπ _ m n h‚ÇÄ => _‚ü©
  ¬∑ exact h (M' := M') (R := R) (m := fun _ => 0) (n := fun _ => 0)
      (by simp [hM'])
  ¬∑ rw [Submodule.sum_mem_biInf_iff_sum_eq_zero] at h‚ÇÄ
    exact h M'.span (FG.map hM') h‚ÇÄ

===== Proof 2174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor
  ¬∑ intro h M' hM'
    have hM'i : ‚àÄ x : M', x = ‚ü®x.1, (x.2 : M')‚ü© := fun x => by rfl
    rintro x ‚ü®_, y, rfl‚ü©
    replace y := y.2
    rw [hM'i] at y
    exact (h (m := fun i ‚Ü¶ (x.1, y i).1) (n := fun i ‚Ü¶ (x.1, y i).2)
      (by ext; simp) <| by dsimp [VanishesTrivially]; simp [mul_sum]).1 y
  ¬∑ intro h Œπ _ m n h‚ÇÄ
    refine (h (map (mk N) (range (m ‚àò Subtype.val)) FG.map) (mk_injective N) <| ?_).1 h‚ÇÄ ‚ü®0, ?_‚ü©
    rw [Subtype.range_val]
    exact range_restrict_eq_of_comp_eq_bijective
      (rTensor_injective_of_bijective (Submodule.subtype _)
      (bijective_iff_of_equiv _ (TensorProduct.lid R M)).2) _
    ext
    rfl

===== Proof 2175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor
  ¬∑ intro h M _ hfg
    refine' Function.Injective.of_comp (rTensor N (Submodule.inclusion hfg)) _
    rw [‚Üê rTensor_comp]
    refine' LinearMap.ext (fun x => ?_)
    simp only [rTensor_tmul, Submodule.coeSubtype, Submodule.inclusion_apply,
      Submodule.coe_inclusion, comp_apply]
    intro hx
    rw [h]
    simpa only [hx, Submodule.coe_zero, tmul_zero] using hx
  ¬∑ intro h Œπ _ m n hMN
    specialize h (Submodule.span R (Set.range m)) (Submodule.fg_span_range _)
    let M' := Submodule.span R (Set.range m)
    have hM' : M' = Submodule.span R (Set.range m) := rfl
    let hm : Œπ ‚Üí M' := fun i => ‚ü®m i, Set.mem_range_self _‚ü©
    rw [‚Üê Submodule.range_subtype M', ‚Üê LinearMap.range_comp] at hfg
    rw [‚Üê Submodule.inclusion_comp_codRestrict hfg, ‚Üê rTensor_comp] at h
    rw [LinearMap.injective_iff_map_eq_zero'] at h
    specialize h (‚àë i, m i ‚äó‚Çú n i)
    simp only [rTensor_sum, Subtype.coe_mk, rTensor_tmul, hMN,
      Submodule.coe_subtype, coe_codRestrict_range, comp_apply,
      Submodule.coe_inclusion] at h
    rw [‚Üê h, Finset.sum_apply]
    exact VanishesTrivially.of_sum

===== Proof 2176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (‚àÄ {Œπ : Type u} [Fintype Œπ] {m : Œπ ‚Üí M} {n : Œπ ‚Üí N},
      ‚àë i, m i ‚äó‚Çú n i = (0 : M ‚äó[R] N) ‚Üí VanishesTrivially R m n) ‚Üî
    ‚àÄ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor <;> intro h <;> intros <;> apply h <;> assumption

===== Proof 2177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  refine' s.inductionOn _ _
  ¬∑ intro
    simpa only [zero_eq, map_zero, prod_zero_eq_one] using continuousOn_const
  ¬∑ intro i s ih h
    simpa only [map_cons, prod_cons] using
      (h i (mem_cons_self i s)).continuousOn.mul (ih fun i hi => h i (mem_cons_of_mem hi))

===== Proof 2178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simp only [Multiset.map_coe, Multiset.prod_coe]
  exact continuousOn_list_prod l

===== Proof 2179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simpa using continuousOn_list_prod l

===== Proof 2180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simpa using continuousOn_list_prod l

===== Proof 2181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  refine' s.inductionOn _ _
  case h‚ÇÅ => simp
  case h‚ÇÇ =>
    intro i s IH h
    simp only [Multiset.map_cons, Multiset.prod_cons] at h ‚ä¢
    exact (h i (Multiset.mem_cons_self i s)).mul (IH fun j hj => h j (Multiset.mem_cons_of_mem hj))

===== Proof 2182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  simpa only [ContinuousOn] using s.induction_on (fun _ => continuous_const.continuousOn)
    (fun _ i _ hi => by simpa only [Multiset.map_cons, Multiset.prod_cons] using
      hi.mul (by assumption))

===== Proof 2183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simpa using continuousOn_list_prod l

===== Proof 2184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simpa using continuousOn_list_prod l

===== Proof 2185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simpa using continuousOn_list_prod l

===== Proof 2186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  refine' s.inductionOn _ _ <;> simp_all [ContinuousOn]
  exact fun a b ha hb hab => by simpa [hab] using ContinuousOn.mul ha hb

===== Proof 2187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  induction s using Quotient.inductionOn
  simp only [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]
  exact fun h => continuousOn_list_prod _ h

===== Proof 2188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simp only [Multiset.map, Multiset.prod_coe]
  exact continuousOn_list_prod l

===== Proof 2189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  refine' s.inductionOn _ _
  ¬∑ intro
    simpa using continuousOn_const
  intro i s ih h
  simp only [Multiset.map_cons, Multiset.prod_cons]
  exact
    (h i <| Multiset.mem_cons_self _ _).mul
      (ih fun j hj => h j <| Multiset.mem_cons_of_mem hj)

===== Proof 2190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  induction s using Quotient.inductionOn
  simp only [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]
  exact fun h => continuousOn_list_prod _ h

===== Proof 2191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simp only [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]
  exact continuousOn_list_prod l

===== Proof 2192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  induction' s using Multiset.induction with i s ih
  ¬∑ simp only [forall_const, Multiset.map_zero, Multiset.prod_zero, ContinuousOn]
    exact continuous_one.continuousOn
  ¬∑ intro h
    simp only [Multiset.map_cons, Multiset.prod_cons]
    exact
      (h _ <| mem_cons_self _ _).mul
        (ih fun j hj => h _ <| mem_cons_of_mem hj)

===== Proof 2193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simpa using continuousOn_list_prod l

===== Proof 2194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  intro h
  match s with
  | 0 => simp only [Multiset.map_zero, Multiset.prod_zero, continuousOn_const]
  | n ::‚Çò s =>
    simp only [Multiset.map_cons, Multiset.prod_cons]
    exact (continuousOn_multiset_prod _ _ : _) (fun i hi => h i (Multiset.mem_cons_of_mem hi))
      |>.mul (h _ (Multiset.mem_cons_self _ _))

===== Proof 2195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simpa using continuousOn_list_prod l

===== Proof 2196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  induction s using Quotient.inductionOn
  simp only [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]
  exact fun h => continuousOn_list_prod _ h

===== Proof 2197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  induction s using Quot.inductionOn with
  | h s => simpa using continuousOn_list_prod s
  termination_by s => s.length
  simp only [Quot.liftOn_quot_mk, Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]
  exact continuousOn_list_prod _

===== Proof 2198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simp only [Multiset.map, Multiset.prod_coe, Multiset.mem_coe]
  exact continuousOn_list_prod l

===== Proof 2199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rintro h a ha
  simp only [ContinuousWithinAt, Multiset.tendsto_nhds, Multiset.map_map, Multiset.prod_map,
    Function.comp_def]
  exact s.prod_continuousWithinAt ha fun i hi => h i hi a ha

===== Proof 2200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rintro h a ha
  simp_rw [Multiset.map_map]
  exact continuousWithinAt_multiset_prod _ _ (fun i hi => h i hi a ha)

===== Proof 2201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simpa using continuousOn_list_prod l

===== Proof 2202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  refine' s.inductionOn _ _
  ¬∑ intro
    simpa using continuousOn_const
  ¬∑ intro i s ih h
    simpa [ContinuousOn, mul_comm] using (h i (Multiset.mem_cons_self _ _)).mul (ih fun j hj => h _ (Multiset.mem_cons_of_mem hj))

===== Proof 2203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  refine' s.induction On _ _
  ¬∑ intro
    simpa using continuousOn_const
  ¬∑ intro i s ih h
    simpa using h i (Multiset.mem_cons_self _ _)
    (ih fun i hi => h i (Multiset.mem_cons_of_mem hi))

===== Proof 2204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®‚ü©
  simp only [Multiset.map, Multiset.prod_coe, Multiset.mem_coe] at *
  exact continuousOn_list_prod _

===== Proof 2205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  induction s using Quotient.inductionOn
  intro h
  simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]
  exact continuousOn_list_prod _ h

===== Proof 2206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simp only [ContinuousOn, Multiset.map_coe, Multiset.prod_coe]
  exact continuousOn_list_prod l

===== Proof 2207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simp only [Multiset.map_coe, Multiset.prod_coe]
  exact continuousOn_list_prod l

===== Proof 2208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : Œπ ‚Üí X ‚Üí M} (s : Multiset Œπ) {t : Set X} :
    (‚àÄ i ‚àà s, ContinuousOn (f i) t) ‚Üí ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by
  rcases s with ‚ü®l‚ü©
  simp only [Multiset.map_coe, Multiset.prod_coe]
  exact continuousOn_list_prod l

===== Proof 2209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin, map_comap_setCoe_val]
  rfl

===== Proof 2210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  -- This is a placeholder for the actual proof.
  sorry

===== Proof 2211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  /-
  We aim to show that the neighborhood filter within a set \( s \) at a point \( a \) is equal to the map of the neighborhood filter at the corresponding element of the subtype \( s \) under the coercion function. Specifically, we need to prove that \( \mathcal{N}[s] a = \text{map}(\uparrow) (\mathcal{N} \langle a, h \rangle) \), where \( \langle a, h \rangle \) denotes the element \( a \) in the subtype \( s \) with the proof \( h \) that \( a \in s \).
  
  To achieve this, we use the property that the map of the neighborhood filter under the coercion function from the subtype to the original type is the same as the neighborhood filter at the corresponding element of the original type. This property is given by the equation \( \text{map}(\uparrow) (\mathcal{N} \langle a, h \rangle) = \mathcal{N} a \). By symmetry, we then have \( \mathcal{N}[s] a = \text{map}(\uparrow) (\mathcal{N} \langle a, h \rangle) \).
  -/
  -- We use the known property that the map of the neighborhood filter under the coercion
  -- from the subtype to the original type is the same as the neighborhood filter at the
  -- corresponding element of the original type.
  have := map_nhds_subtype_val ‚ü®a, h‚ü©
  -- By symmetry, we then have the desired equality.
  exact this.symm

===== Proof 2212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by map_bvars; rfl

===== Proof 2213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin_eq_map_subtype_coe]

===== Proof 2214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  intros
  simp_all

===== Proof 2215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  simp_rw [nhdsWithin, nhds_subtype, Filter.subtype_map, Subtype.val_injective.comp_def]
  rfl

===== Proof 2216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin_eq_map_subtype_coe]
  exact h

===== Proof 2217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  simp_rw [nhdsWithin, nhds_subtype]
  rw [map_comap_setCoe_val]

===== Proof 2218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin_eq_map_subtype_coe h]
  simp only [map_map, Subtype.map_val, Subtype.coe_mk]
  rw [Filter.map_subtype_coe_map_val]

===== Proof 2219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  refine' Subtype.nhds_eq_map_subtype_coe h ‚ñ∏ _
  rw [Filter.map_map]; rfl

===== Proof 2220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  simp only [nhdsWithin_eq_map_subtype_coe h]
  rfl

===== Proof 2221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by simp [nhdsWithin_eq_map_subtype_coe, Subtype.ext_iff]

===== Proof 2222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  refine' Set.eq_of_subset_of_subset (fun s hs => _) (fun s hs => _)
  exacts [((nhdsWithin_eq_map_subtype_coe h).symm ‚ñ∏ hs : _),
    (nhdsWithin_eq_map_subtype_coe h : _)]

===== Proof 2223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by simp_rw [nhdsWithin, nhds_subtype, Subtype.forall, Subtype.exists]

===== Proof 2224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  simp_rw [nhdsWithin, nhds_subtype, Subtype.forall, Subtype.coe_mk]

===== Proof 2225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  refine' (map_nhds_subtype_val ‚ü®a, h‚ü©).symm.trans _
  rw [nhdsWithin_eq_map_subtype_coe h]

===== Proof 2226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin_eq_map_subtype_coe h]

===== Proof 2227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsOn_def, inf_eq_left]; constructor; rw [le_principal_iff]
  rw [Filter.le_def]
  intro t ht
  use Subtype.val ‚Åª¬π' t
  exact ‚ü®Filter.preimage_mono ht, by simp [Set.mem_preimage, Subtype.coe_injective]‚ü©

===== Proof 2228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  simp only [le_antisymm_iff, le_map_add_left, le_map_add_right, map_le_iff_le_comap, inf_le_left,
    inf_le_right, le_rfl, Function.comp, forall_true_iff, Filter.map_comap_setCoe_val,
    le_comap_setCoe_iff]
  aesop

===== Proof 2229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin, nhds_mk, filter.map_map, comp_def, Subtype.val_injective.comp_id]

===== Proof 2230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [map_nhds_subtype_val]
  rfl

===== Proof 2231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by simp_rw [Subtype.coe_injective.nhdsWithin_eq, map_nhds_subtype_val]

===== Proof 2232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin_eq_map_subtype_coe]
  <;> simp

===== Proof 2233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  simp_rw [nhdsWithin, nhds_eq_map_subtype_coe]
  rfl

===== Proof 2234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [map_nhds_subtype_val]
  rfl

===== Proof 2235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin_eq_map_subtype_coe]
  simp

===== Proof 2236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by simp [nhdsWithin_eq_map_subtype_coe]

===== Proof 2237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin_eq_nhds_within h]
  simp_rw [nhdsWithin_eq_map_subtype_coe h]
  rw [subtype_coe_injective.map_map, subtype_coe_injective.map_map]
  simp_rw [subtype_coe_injective.map_map]
  rfl

===== Proof 2238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhds_subtype_eq_comap]
  simp_rw [Subtype.val_injective.nhds_eq_comap]
  rw [Filter.comap_comap]
  simp_rw [Function.comp_apply]
  rw [‚Üê Filter.comap_comap]
  congr
  ext
  simp [Subtype.val_injective.mem_set_image]

===== Proof 2239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  simp_rw [nhdsWithin, nhds_subtype, comap_map, Subtype.range_val]
  rfl

===== Proof 2240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set Œ±} {a : Œ±} (h : a ‚àà s) :
    ùìù[s] a = map ((‚Üë) : s ‚Üí Œ±) (ùìù ‚ü®a, h‚ü©) :=
  (map_nhds_subtype_val ‚ü®a, h‚ü©).symm
:= by
  rw [nhdsWithin_eq_map_subtype_coe]
  <;> simp_all

===== Proof 2241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  rw [basicOpen_eq_union]
  simp

===== Proof 2242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  /-
  We aim to show that the basic open set generated by the element \(1\) in the graded algebra \(A\) is the entire space. This is achieved by demonstrating that the basic open set is equal to the top element in the order of open sets, which corresponds to the entire space.
  -/
  apply TopologicalSpace.Opens.ext
  simp

===== Proof 2243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply TopologicalSpace.Opens.ext
  simp

===== Proof 2244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  rw [basicOpen, basicOpen_eq_top]
  simp_rw [Submonoid.one_mem]

===== Proof 2245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply top_unique
  rw [SetLike.le_def]
  intro a ha
  trivial

===== Proof 2246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  /-
  We aim to show that the basic open set defined by the element \(1\) in the graded ring \(A\) is the entire space. This is achieved by demonstrating that the basic open set \( \text{basicOpen} \, \mathcal{A} \, (1 : A) \) is equal to the top element \( \top \) of the lattice of open sets. The proof involves using the definition of the basic open set and simplifying the expression to show that it covers the entire space.
  -/
  -- We start by applying the extensionality lemma for topological spaces.
  apply TopologicalSpace.Opens.ext
  -- Simplify the expression using the definition of the basic open set.
  simp [basicOpen]
  -- The simplification shows that the basic open set defined by 1 is the entire space, hence equal to ‚ä§.

===== Proof 2247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  simp only [Set.top_eq_univ, Set.top_eq_univ, Set.top_eq_univ, Set.top_eq_univ,
    Set.top_eq_univ, Set.top_eq_univ, Set.top_eq_univ]
  exact Set.eq_univ_of_forall fun _ => by simp

===== Proof 2248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  simp [basicOpen]
  exact PrimeSpectrum.basicOpen_one (A := A)

===== Proof 2249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  /-
  The theorem states that the basic open set defined by the element \(1\) in the graded commutative ring \(A\) is equal to the top element in the lattice of open sets of the projective spectrum of \(A\). The proof uses the 
===== Proof 2250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply top_unique
  rintro U ‚ü®s, rfl‚ü©
  exact basicOpen_mul_eq_inf _ _ ‚ñ∏ by simp [basicOpen_eq_bot_iff]

===== Proof 2251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  rw [basicOpen_eq_zeroLocus_compl, zeroLocus_singleton_one, Set.compl_empty_set,
    setOf_true, top_le_iff]
    <;> rfl

===== Proof 2252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  ext1
  simp

===== Proof 2253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  /-
  We aim to show that the basic open set defined by the element \(1\) in the graded ring \(A\) is the entire space. This is achieved by demonstrating that the basic open set \(\text{basicOpen} \, \mathcal{A} \, (1)\) is equal to the top element \(\top\) in the lattice of open sets. The proof involves using the definition of the basic open set and simplifying the expression to show that it encompasses the entire space.
  -/
  -- Use the extensionality property of top elements in the lattice of open sets.
  apply TopologicalSpace.Opens.ext
  -- Simplify the expression using the definition of the basic open set and properties of the graded ring.
  simp [N.mem_basicOpen]

===== Proof 2254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  refine TopologicalSpace.Opens.ext ?_
  simp

===== Proof 2255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  rw [basicOpen_eq_zeroLocus_compl]
  simp

===== Proof 2256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  /-
  We aim to show that the basic open set corresponding to the element \(1\) in the graded ring \(A\) is the entire space. This is achieved by demonstrating that the basic open set \( \text{basicOpen} \, \mathcal{A} \, (1 : A) \) is equal to the top element of the lattice of open sets, denoted by \( \top \).
  
  To prove this, we use the fact that the basic open set \( \text{basicOpen} \, \mathcal{A} \, (1 : A) \) is defined as the intersection of the complements of the zero sets of the elements of the ideal generated by \(1\). Since \(1\) is a unit in the ring, the ideal generated by \(1\) is the entire ring, and thus the basic open set corresponding to \(1\) is the entire space.
  -/
  apply TopologicalSpace.Opens.ext
  simp

===== Proof 2257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  simp

===== Proof 2258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply TopologicalSpace.Opens.ext
  simp

===== Proof 2259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply TopologicalSpace.Opens.ext
  simp

===== Proof 2260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  rw [Set.eq_univ_iff_forall]
  intro x
  simp only [SetLike.mem_coe, BasicOpen.mem_mk, eq_self_iff_true, forall_true_left,
    forall_const]
  by_cases h : 1 = 0
  ¬∑ subst h
    exact (one_ne_zero (A := A)).elim
  ¬∑ simp [h]

===== Proof 2261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  rw [basicOpen_eq_zeroLocus_compl]
  ext
  simp [zeroLocus_singleton_eq_vanishingIdeal, vanishingIdeal_singleton, mem_vanishingIdeal]

===== Proof 2262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  /-
  We aim to show that the basic open set defined by the element \(1\) in the graded ring \(A\) is the entire space. This is achieved by demonstrating that the basic open set is equal to the top element in the lattice of open sets. The proof uses the property of the basic open set for an element \(r\) such that \(r\) is not in any of the ideals \(I\), and here \(r = 1\). Since \(1\) is not contained in any proper ideal (it generates the unit ideal), the basic open set for \(1\) is the entire space.
  -/
  -- We use the extensionality property of open sets to show that basicOpen ùíú (1 : A) is equal to ‚ä§.
  apply TopologicalSpace.Opens.ext
  -- Simplify the expression using the definition of basicOpen and properties of graded rings.
  simp [basicOpen]

===== Proof 2263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply TopologicalSpace.Opens.ext
  simp

===== Proof 2264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply TopologicalSpace.Opens.ext
  simp

===== Proof 2265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  /-
  We need to show that the basic open set corresponding to the element \(1\) in the graded ring \(A\) is the entire topological space. This is achieved by demonstrating that the basic open set for \(1\) is equal to the top element of the lattice of open sets. The proof involves using the definition of the basic open set and simplifying the expression to confirm that it indeed represents the entire space.
  -/
  -- We start by extending the equality to the underlying sets.
  apply TopologicalSpace.Opens.ext
  -- Simplify the expression using the definition of the basic open set and the fact that 1 is not zero in the graded ring.
  simp [basicOpen, one_ne_zero]

===== Proof 2266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  simp [basicOpen]

===== Proof 2267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply TopologicalSpace.Opens.ext
  simp

===== Proof 2268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  rw [SetLike.ext'_iff, setOf_bijective]
  intros
  simp

===== Proof 2269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  simpa only [map_one] using basicOpen_mul ùíú (1 : A) 1

===== Proof 2270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply TopologicalSpace.Opens.ext
  simp

===== Proof 2271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  refine' TopologicalSpace.Opens.ext _
  simp

===== Proof 2272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen ùíú (1 : A) = ‚ä§ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  /-
  We aim to show that the basic open set defined by the element \(1\) in the graded ring \(A\) is the entire topological space. This is achieved by demonstrating that any point \(x\) in the space belongs to the basic open set corresponding to \(1\).
  
  1. **Extensionality**: We use the extensionality property of topological spaces to show that the basic open set defined by \(1\) is equal to the entire space by proving that any point \(x\) in the space belongs to this set.
  2. **Simp Simplification**: The 
===== Proof 2273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by aesop
===== Proof 2274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  intro a b
  induction a <;> simp
  exact le_rfl

===== Proof 2275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  intros a b
  cases a
  ¬∑ exact bot_le
  ¬∑ simp [le_refl]

===== Proof 2276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by aesop

===== Proof 2277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  /-
  The theorem 
===== Proof 2278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  coinductive Nat : Type where
  | zero : Nat
  | succ : Nat ‚Üí Nat

  coinductive List (A : Type) : Type where
  | nil : List A
  | cons : A ‚Üí List A ‚Üí List A

  def append {A : Type} : List A ‚Üí List A ‚Üí List A
  | List.nil, l => l
  | List.cons a l‚ÇÅ, l‚ÇÇ => List.cons a (append l‚ÇÅ l‚ÇÇ)

  instance {A : Type} : Append (List A) :=
    {append}

===== Proof 2279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  intro a b
  induction a <;> simp
  exact le_rfl

===== Proof 2280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  rintro ‚ü®a, b‚ü©
  exact le_rfl

===== Proof 2281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  option tactic
  simp_rw [le_antisymm_iff, le_coe_unbot']
  aesop

===== Proof 2282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by aesop

===== Proof 2283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  /-
  The theorem 
===== Proof 2284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by simpa [bot_le] using OrderBot.bot_le _
#align with_bot.le_coe_unbot' WithBot.le_coe_unbot'

theorem coe_le_unbot' : ‚àÄ (a : Œ±) (b : Œ±), (a : WithBot Œ±) ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl

===== Proof 2285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by simpa only [map_coe, coe_le_coe] using mono_iff

theorem coe_le_if_le (ha : a ‚â§ b) : ‚Üëa ‚â§ if a ‚â§ b then ‚Üëb else ‚Üëc := by split <;> simp [*]

===== Proof 2286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  by_cases h : a
  . simp only [h, unbot'_bot, le_refl]
  . obtain ‚ü®b, rfl‚ü© := ByStar.unbot'_eq_iff.1 (eq_unbot_iff_ne_bot.1 (mt coe_eq_coe.1 h))
    simp only [unbot'_coe_of_ne_bot h, unbot_le_iff, bot_le]

===== Proof 2287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  intro a b
  unfold unbot'
  split_ifs with h <;> simp only [h, le_refl]

===== Proof 2288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by √ß*√Ñ√¥9√Ç
===== Proof 2289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  aesop

theorem coe_le_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), ‚Üëb ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl

===== Proof 2290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  suffices ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  by apply this
  intro a b
  cases a <;> simp [le_refl]

===== Proof 2291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by_cases
  (fun a_eq : a = ‚ä• => by
    rw [a_eq]
    exact bot_le)
  (fun : ¬¨a = ‚ä• => by simp)

===== Proof 2292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  intro x y z
  induction x <;> simp [*]
  induction y <;> simp [*]

===== Proof 2293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  intro a b
  induction a with
  | none => simp [top_le_iff]
  | some a => simp

===== Proof 2294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  intro _ _
  rcases ‚Äπ_‚Ä∫
  rfl

===== Proof 2295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by fast
#align with_bot.le_coe_unbot' WithBot.le_coe_unbot'

theorem unbot'_le_coe : ‚àÄ (a : WithBot Œ±) (b : Œ±), a.unbot' b ‚â§ a
  | (a : Œ±), _ => le_rfl
  | ‚ä•, _ => bot_le

===== Proof 2296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  apply @fun a b => le_of_not_lt
  apply @fun a b h => not_lt_of_le (le_coe_unbot' a b)
  cases a <;> simp [not_lt_of_le]

===== Proof 2297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  revert a
  intro a b
  cases a <;> simp [le_refl]

===== Proof 2298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by simp only [coe_eq_coe] using eq_unbot_iff.mp
#align with_bot.le_coe_unbot' WithBot.le_coe_unbot'

/-- The image of a binary function 
===== Proof 2299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by aesop

===== Proof 2300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  intro a b
  cases a <;> simp

===== Proof 2301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by aesop

===== Proof 2302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by -- simpa only [map_coe, coe_le_coe] using mono_iff
  simp only [le_rfl]

===== Proof 2303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by simp only [map_coe, coe_le_coe] using mono_iff

===== Proof 2304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : Œ±), (b : Œ±) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ‚àÄ (a : WithBot Œ±) (b : Œ±), a ‚â§ a.unbot' b
  | (a : Œ±), _ => le_rfl
:= by
  intros a b
  simp only [le_rfl]

===== Proof 2305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
   cases n <;> simp only [iteratedFDerivWithin_zero,
     fderivWithin_const, zero_add, LinearIsometryEquiv.symm_apply_apply,
     LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.ofSubsingleton_apply]
   cases n <;> simp only [iteratedFDerivWithin_succ, Function.comp_apply,
     LinearIsometryEquiv.symm_apply_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.ofSubsingleton_apply]
   cases n <;> simp only [iteratedFDerivWithin_succ', Function.comp_apply,
     LinearIsometryEquiv.symm_apply_apply, LinearIsometryEquiv.trans_apply, LinearIsometryEquiv.ofSubsingleton_apply]
   ext1 x <;> rfl

===== Proof 2306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  classical
    rw [iteratedFDerivWithin_succ_eq_comp_left]
    ext1 x
    simp only [Function.comp_apply, LinearIsometryEquiv.symm_apply_apply]
    rfl

===== Proof 2307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
   cases n <;> simp [iteratedFDerivWithin_succ_eq_comp_left,
     fderivWithin_fderivWithin, continuousMultilinearCurryLeftEquiv_succ]

===== Proof 2308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left]
  rfl

===== Proof 2309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left, Function.comp_def]
  rfl

===== Proof 2310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left]
  rfl

===== Proof 2311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n <;> simp [iteratedFDerivWithin_succ_eq_comp_left,
    fderivWithin_fderivWithin, continuousMultilinearCurryLeftEquiv_succ]

===== Proof 2312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n with
  | zero =>
    ext x : 1
    simp [iteratedFDerivWithin]
  | succ n =>
    ext1
    simp only [iteratedFDerivWithin, OrderIso.symm, Equiv.coe_fn_symm, Equiv.coe_fn_trans,
      Function.comp_apply, ContinuousLinearMap.coe_comp,
      ContinuousMultilinearMap.coe_coe, Function.comp_def]

===== Proof 2313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n with
  | zero =>
    simp only [Nat.zero_eq, iteratedFDerivWithin_zero_eq_comp, Nat.zero_add]
    rfl
  | succ n =>
    simp only [iteratedFDerivWithin_succ_eq_comp_left, Nat.add_succ, Nat.succ_add]
    rfl

===== Proof 2314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_right]
  ext1 x
  simp only [fderivWithin, LinearIsometryEquiv.symm_apply_apply]
  rfl

===== Proof 2315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left]
  ext1 x
  dsimp
  rw [fderivWithin_fderivWithin]
  rfl

===== Proof 2316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n <;> simp [iteratedFDerivWithin_succ_eq_comp_left,
    fderivWithin_fderivWithin]

===== Proof 2317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  induction n <;> simp_all [iteratedFDerivWithin_succ_eq_comp_left, fderivWithin_fderivWithin]

===== Proof 2318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  induction' n with n ih
  ¬∑ ext x
    simp [iteratedFDerivWithin_succ_eq_comp_left, Function.comp]
  ¬∑ ext1 x
    simp only [*, iteratedFDerivWithin_succ_apply_right, Function.comp_apply,
      fderivWithin_continuousMultilinearCurryLeftEquiv_symm,
      fderivWithin_fderivWithin, LinearIsometryEquiv.symm_symm]
    rfl

===== Proof 2319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n <;> simp [iteratedFDerivWithin_succ_eq_comp_left,
    fderivWithin_fderivWithin, continuousMultilinearCurryLeftEquiv_succ]

===== Proof 2320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left]
  rfl

===== Proof 2321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  induction n <;> simp_all [iteratedFDerivWithin_succ_eq_comp_left, Function.comp]

===== Proof 2322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left, comp_fderivWithin _ (hf := uniqueDiffOn_univ)]
  simp [fderivWithin_univ]

===== Proof 2323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  induction' n with n IH
  ¬∑ ext x
    simp [iteratedFDerivWithin_zero_eq_comp]
  ¬∑ ext x
    simp only [IH, iteratedFDerivWithin_succ_eq_comp_left, Function.comp_apply,
      fderivWithin_comp x (fderivWithin_injective x Subset.rfl)]
    rfl

===== Proof 2324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left]
  simp [fderivWithin_fderivWithin, continuousMultilinearCurryLeftEquiv]

===== Proof 2325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left, fderivWithin_fderivWithin,
    (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm.comp_fderivWithin
      (uniqueDiffOn_of_mem_nhdsWithin (mem_nhdsWithin_of_mem_nhds (isOpen_univ.mem_nhds
        (mem_univ _))))]

===== Proof 2326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left]
  rfl

===== Proof 2327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left]
  rw [fderivWithin_fderivWithin]
  rfl

===== Proof 2328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n with
  | zero =>
    simp only [Nat.cast_zero, add_zero, iteratedFDerivWithin_zero_eq_comp, comp_apply,
      fderivWithin_derivWithin, Function.comp_apply, LinearIsometryEquiv.symm_symm,
      LinearIsometryEquiv.coe_toContinuousLinearMap, LinearIsometryEquiv.coe_toLinearEquiv,
      LinearEquiv.coe_coe, ContinuousLinearEquiv.coe_coe,
      continuousMultilinearCurryLeftEquiv_zero]
  | succ n =>
    simp only [fderivWithin_iteratedFDerivWithin, Nat.cast_succ, Nat.add_eq,
      add_right_inj, iteratedFDerivWithin_succ_eq_comp_left, LinearIsometryEquiv.symm_symm,
      LinearIsometryEquiv.coe_toContinuousLinearMap, LinearIsometryEquiv.coe_toLinearEquiv,
      LinearEquiv.coe_coe, ContinuousLinearEquiv.coe_coe,
      continuousMultilinearCurryLeftEquiv_succ]

===== Proof 2329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n <;> simp [iteratedFDerivWithin_succ_eq_comp_left, continuousMultilinearCurryLeftEquiv_succ]

===== Proof 2330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n <;>
  simp_rw [iteratedFDerivWithin_zero_eq_comp, fderivWithin_fderivWithin, add_comm,
    iteratedFDerivWithin_succ_eq_comp_left, Function.comp_apply, LinearIsometryEquiv.symm_symm,
    LinearIsometryEquiv.symm_apply_apply]

===== Proof 2331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n <;>
  simp_all [iteratedFDerivWithin_zero, iteratedFDerivWithin_succ,
    fderivWithin_eq_equiv_comp]

===== Proof 2332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left, comp_comm, fderivWithin_comp _ (ContDiff.differentiable_iteratedFDerivWithin _ _).differentiableAt,
    ContinuousLinearEquiv.comp_fderivWithin _ (ContDiff.differentiable_iteratedFDerivWithin _ _).differentiableAt]
  rfl

===== Proof 2333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  induction n with
  | zero =>
    simp [iteratedFDerivWithin]
  | succ n ihn =>
    simp only [iteratedFDerivWithin, Nat.add_eq, Nat.add_zero, ihn, fderivWithin_comp,
      fderivWithin_apply, fderivWithin_fderivWithin, Function.comp_def]
    ext1 x
    simp [fderivWithin_fderivWithin, Function.comp_def, ext1, iteratedFDerivWithin_succ_apply_right]

===== Proof 2334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  rw [iteratedFDerivWithin_succ_eq_comp_left,
    fderivWithin_uncurry (fun (_ : Fin 1)
      (_ : Fin n) => fderivWithin ùïú f s)]
  ext1 x
  simp

===== Proof 2335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  cases n <;> simp [iteratedFDerivWithin_zero]
  ext1 x
  ext1
  simp [iteratedFDerivWithin_succ_apply_left, iteratedFDerivWithin_succ_apply_right]

===== Proof 2336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ‚Ñï} :
    fderivWithin ùïú (iteratedFDerivWithin ùïú n f s) s =
      (continuousMultilinearCurryLeftEquiv ùïú (fun _ : Fin (n + 1) => E) F).symm ‚àò
        iteratedFDerivWithin ùïú (n + 1) f s := by
  simp only [iteratedFDerivWithin_succ_eq_comp_left, Function.comp, LinearIsometryEquiv.symm_trans_apply]
  rfl

===== Proof 2337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
   have : œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ œÅ {x | v.limRatioMeas hœÅ x = 0} := le_rfl
   refine' le_antisymm _ this
   have : ‚àÄ·µê x ‚àÇœÅ, v.limRatioMeas hœÅ x = 0 ‚Üí œÅ {y | y ‚àà Set.univ ‚àß y = x} = 0 := by
     intro x _
     simp
   refine' (measure_zero_iff_ae_nmem.2 this).trans _
   simp

===== Proof 2338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
   have key : ‚àÄ n : ‚Ñï, œÅ {x | v.limRatioMeas hœÅ x = ‚Üën} = 0 := by
     intro n
     induction' n with n ih
     ¬∑ apply measure_zero_of_trim_eq_zero
       rw [Measure.trim_measurableSet_eq]
       ¬∑ rw [v.limRatioMeas_zero]
         apply le_antisymm _ bot_le
         rw [Measure.le_iff_add_apply_eq_left]
         exact measure_le_zero œÅ _
       ¬∑ exact v.measurableSet_B
     rw [measure_eq_trim_add_self]
     refine' le_antisymm _ bot_le
     rw [Measure.le_iff_add_apply_eq_left]
     have A : {x | v.limRatioMeas hœÅ x = n + 1} =
         {x | v.limRatioMeas hœÅ x = n} \ {x | v.limRatioMeas hœÅ x = n + 1} := by
       ext1 x
       simp only [Set.mem_setOf_eq, Set.mem_diff, Set.mem_singleton_iff]
       constructor
       ¬∑ intro h
         simp only [h, Nat.cast_succ, ne_eq, Nat.cast_add, Nat.cast_one, not_false_eq_true,
           Set.mem_singleton_iff, Set.diff_self, Set.mem_empty_iff_false, and_true]
       ¬∑ intro h
         simp only [h, Nat.cast_succ, ne_eq, Nat.cast_add, Nat.cast_one, not_false_eq_true,
           Set.mem_singleton_iff, Set.diff_self, Set.mem_empty_iff_false, and_true]
     rw [A]
     apply le_measure_diff
     rw [ih]
     apply zero_le
   have : {x | v.limRatioMeas hœÅ x = 0} = ‚ãÉ n : ‚Ñï, {x | v.limRatioMeas hœÅ x = ‚Üën}·∂ú := by
     ext1 x
     simp only [Set.mem_setOf_eq, Set.mem_compl_iff, Set.mem_iUnion, Set.mem_preimage]
     constructor
     ¬∑ intro h
       use 0
       exact h
     ¬∑ rintro ‚ü®n, h‚ü©
       have A : v.limRatioMeas hœÅ x ‚â† n := by
         intro C
         rw [C] at h
         simp only [Nat.cast_eq_zero, Set.mem_singleton_iff, ne_eq, not_false_eq_true] at h
       linarith
   rw [this]
   apply measure_iUnion_null
   intro n
   rw [key n]
   apply ENNReal.ofReal_zero

===== Proof 2339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have h : ‚àÄ Œµ > (0 : ‚Ñù‚â•0‚àû), œÅ {x | v.limRatioMeas hœÅ x < Œµ} = 0 := by
    intro Œµ Œµ_pos
    exact le_antisymm (v.measure_le_of_frequently_le hœÅ (frequently_lt_of_tendsto_lt Œµ_pos tendsto_const_nhds
      (tendsto_measure_univ.2 measure_univ_lt_top))
      (eventually_of_forall fun _x => zero_le _)) (zero_le _)
  simpa only [lintegral_zero] using lintegral_eq_zero_iff (measurable_measure_lt_top _ _)
    |>.2 h

===== Proof 2340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have : œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ œÅ {x | v x = 0} := by
    exact measure_mono (fun x hx ‚Ü¶ by simp [hx])
  refine' le_antisymm (this.trans _) (zero_le _)
  have : œÅ {x | v x = 0} ‚â§ œÅ {x | u x = 0} := by
    exact measure_mono (fun x hx ‚Ü¶ by simp [hx])
  refine' this.trans _
  have h‚ÇÅ : œÅ {x | u x = 0} = 0 := by
    exact measure_zero_of_u_eq_zero
  have h‚ÇÇ : œÅ {x | v x = 0} = 0 := by
    exact measure_zero_of_v_eq_zero
  linarith

===== Proof 2341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have : {x | v.limRatioMeas hœÅ x = 0} = ‚ãÉ (n : ‚Ñï), {x | v.limRatioMeas hœÅ x ‚â§ (1 : ‚Ñù) / n} := by
    ext1 x
    simp only [mem_setOf_eq, mem_iUnion, le_div_iff, one_mul]
    refine' ‚ü®fun h => ‚ü®v.limRatioMeas_pos hœÅ x, h‚ü©, fun h => _‚ü©
    have h‚ÇÇ : ‚àÉ (n : ‚Ñï), v.limRatioMeas hœÅ x ‚â§ (1 : ‚Ñù) / n := by
      rcases h with ‚ü®n, hn‚ü©
      exact ‚ü®n, hn‚ü©
    rcases h‚ÇÇ with ‚ü®n, hn‚ü©
    exact le_of_lt (v.limRatioMeas_pos hœÅ x)
  rw [this]
  exact measure_iUnion_null fun n => v.measure_le_mul_of_subset_limRatioMeas_le hœÅ (by norm_num) _ le_rfl

===== Proof 2342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
   have : œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ œÅ {x | v.limRatioMeas hœÅ x < 1} := by
     refine' measure_mono _
     intro x hx; rw [Set.mem_setOf_eq] at hx ‚ä¢
     simp only [le_refl, Set.mem_setOf_eq, ge_iff_le] at hx
     exact le_of_eq hx
   refine' le_antisymm _ this
   have : ‚àÄ·µê x ‚àÇœÅ, 0 ‚â§ v.limRatioMeas hœÅ x := by
     filter_upwards [v.absolutelyContinuous_of_le hœÅ] with _ _ using le_refl 0
   refine' (Measure.restrict_le_self.2 this).trans _
   have : ‚àÄ·µê x ‚àÇœÅ, v.limRatioMeas hœÅ x < 1 := by
     filter_upwards [v.le_one_of_lt_one hœÅ] with _ _ using lt_of_le_of_lt (le_refl 0)
   exact (Measure.restrict_le_self.2 this).trans (by simp)

===== Proof 2343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have : œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ œÅ {x | 0 < v.limRatioMeas hœÅ x} := by
    refine' measure_mono _
    simp only [Set.mem_setOf_eq]
    exact fun x hx => le_of_eq hx.symm
  refine' le_antisymm this _
  have : {x | 0 < v.limRatioMeas hœÅ x} = {x | (v.limRatioMeas hœÅ x) ‚â§ (1 : ‚Ñù‚â•0‚àû) }‚ÇÄ := by
    ext x
    simp only [Set.mem_setOf_eq, Set.mem_diff, mem_one_e_to_e]
    constructor
    ¬∑ exact fun h => ‚ü®ENNReal.ofReal_le_one.2 (zero_le _), h‚ü©
    ¬∑ exact fun h => h.2
  rw [this]
  exact measure_zero_of_mul_le_measure_zero hœÅ (fun x œÅ => ENNReal.ofReal_le_one.2 (zero_le _))
    measurableSet_A hA

===== Proof 2344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  simp_rw [limRatioMeas, ‚Üê le_zero_iff (Œ± := ‚Ñù‚â•0‚àû), ‚Üê le_zero_iff]
  rw [measure_le_zero_iff]
  intro x
  by_cases h : v.limRatioMeas hœÅ x = 0
  <;> simp [h]
  exact (le_of_eq (ENNReal.ofReal_zero.symm))

===== Proof 2345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have hœÅv : œÅ ‚â§ v.limRatioMeas hœÅ := le_limRatioMeas hœÅ
  refine' null_of_le_zero _ hœÅv _
  exact (measure_zero_iff_ae_nmem (s := {x | v.limRatioMeas hœÅ x = 0})).mpr (by simp)

===== Proof 2346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  refine' measure_zero_iff_ae_nmem.2 fun s hs ‚Ü¶ _
  refine' (œÅ.nullMeasurableSet_lt' hs).biInter fun r _ ‚Ü¶ _
  rw [‚Üê not_mem_iff]
  exact fun hr ‚Ü¶ hr.not_le (v.limRatioMeas_le_liminf_ratioMeas hœÅ)

===== Proof 2347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have : œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ œÅ (‚ãÉ n : ‚Ñï, {x | v.limRatioMeas hœÅ x ‚â§ n}) :=
    measure_mono (by simp only [Set.mem_setOf_eq, Set.mem_iUnion]; exact fun x hx => ‚ü®v.limRatioMeas hœÅ x, hx‚ü©)
  refine' this.trans _
  refine' measure_iUnion_le_of_monotone _ fun n m hnm => _
  dsimp only
  exact measure_mono (by simp only [Set.mem_setOf_eq]; exact fun x hx => le_trans hx hnm)

===== Proof 2348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have : ‚àÄ·µê x ‚àÇœÅ, 0 ‚â§ v.limRatioMeas hœÅ x := by
    filter_upwards with x using v.limRatioMeas_nonneg hœÅ
  rw [measure_zero_iff_ae_nmem]
  rw [‚Üê v.measure_limRatioMeas_lt_zero]
  exact iSup_ae_eq_of_forall_ae_eq (v.limRatioMeas_lt_zero hœÅ) this

===== Proof 2349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  refine' le_antisymm _ _
  ¬∑ exact measure_mono (fun x hx => (hx.symm ‚ñ∏ zero_le _).trans_lt one_pos)
  ¬∑ calc
      œÅ {x | v.limRatioMeas hœÅ x ‚â§ 1} ‚â§ œÅ {x | v.limRatioMeas hœÅ x ‚â§ v.limRatioMeas hœÅ x} := by
        gcongr
        exact le_rfl
      _ ‚â§ v.limRatioMeas hœÅ x * œÅ {x | v.limRatioMeas hœÅ x ‚â§ v.limRatioMeas hœÅ x} := by
        gcongr
        exact le_rfl
      _ ‚â§ v.limRatioMeas hœÅ x * œÅ {x | v.limRatioMeas hœÅ x ‚â§ 1} := by
        gcongr
        exact measure_le_of_frequently_le _ _ _ (fun x ‚Ü¶ by simp)
      _ ‚â§ v.limRatioMeas hœÅ x * œÅ {x | 0 ‚â§ 1} := by gcongr; exact measure_le_of_frequently_le _ _ _ (fun x ‚Ü¶ by simp)
      _ = v.limRatioMeas hœÅ x * œÅ Set.univ := by simp
      _ = v.limRatioMeas hœÅ x * œÅ Œ© := by simp
      _ = 0 := by simp [hœÅ]

===== Proof 2350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  refine' measure_zero_iff_ae_nmem.mpr (eventually_of_forall fun x hx => _)
  exfalso
  simpa using hx

===== Proof 2351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
   rw [œÅ.measure_zero_of_null]
   have : ‚àÄ·µê x ‚àÇœÅ, v.limRatioMeas hœÅ x = 0 := by
     filter_upwards [v.ae_tendsto_limRatioMeas hœÅ] with x hx
     rw [‚Üê hx]
     apply ae_eq_of_forall_set_lintegral_eq_of_sigmaFinite
     ¬∑ exact (measurable_limRatioMeas hœÅ).aemeasurable
     ¬∑ exact (measurable_const).aemeasurable
     intro s hs _
     rw [set_lintegral_const, set_lintegral_measurable_limRatioMeas hœÅ]
     ¬∑ simp
     ¬∑ exact hs
   exact this

===== Proof 2352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have h : ‚àÄ n, œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ 4‚Åª¬π ^ n := by
    intro n
    have hœÅ' : œÅ {x | v.limRatioMeas hœÅ x = 0} = œÅ (‚ãÉ n : ‚Ñï, {x | 2 ^ (n + 1) ‚â§ v.limRatioMeas hœÅ x ‚àß v.limRatioMeas hœÅ x ‚â§ 2 ^ (n + 1)} ‚à© {x | v.limRatioMeas hœÅ x = 0}) := by
      congr
      ext x
      simp only [Set.mem_setOf_eq, Set.mem_iUnion, Set.mem_inter_iff, exists_prop]
      constructor
      ¬∑ intro h
        use 0
        simpa [h] using v.limRatioMeas_def hœÅ x
      ¬∑ rintro ‚ü®n, hn‚ü©
        simpa [hn.1, hn.2] using v.limRatioMeas_def hœÅ x
    rw [hœÅ']
    refine le_trans (measure_iUnion_le _) (le_trans (add_le_add ?_ ?_) (le_of_eq ?_))
    ¬∑ exact le_of_eq (by simp)
    ¬∑ exact le_of_eq (by simp)
    ¬∑ congr
      ext1 n
      congr
      ext1 x
      simp only [Set.mem_inter_iff, Set.mem_setOf_eq]
      constructor <;> simp (config := { contextual := true }) [le_of_lt]
  refine le_antisymm ?_ (zero_le _)
  have h2 : ‚àë' n : ‚Ñï, (4 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ n = (1 : ‚Ñù‚â•0‚àû) / (1 - (4 : ‚Ñù‚â•0‚àû)‚Åª¬π) := by
    rw [tsum_geometric_of_lt_one (by norm_num) (by norm_num)]
  refine le_trans ?_ (le_of_eq h2)
  refine tsum_le_tsum h (summable_geometric_of_lt_one (by norm_num) (by norm_num)) ?_
  rw [h2]
  refine ne_of_lt (lt_of_le_of_lt (ge_of_eq ?_) (lt_add_one _))
  simp

===== Proof 2353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  refine' le_antisymm _ (zero_le œÅ _)
  have : ‚àÄ n : ‚Ñï, œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ œÅ {x | v.limRatioMeas hœÅ x ‚â§ (1 : ‚Ñù) / n} :=
    fun n => measure_mono (fun x hx => le_of_eq hx)
  refine' le_of_tendsto (Tendsto.const_div one_ne_zero) _
  refine' ((tendsto_order.1 _).1 _)
  refine' ENNReal.tendsto_toReal fun n => _
  exact (v.measure_le_div_of_mul_measure_le one_ne_zero (fun _ => le_of_eq rfl)).2

===== Proof 2354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  refine' le_antisymm _ (zero_le _)
  have : ‚àÄ n : ‚Ñï, œÅ (‚ãÉ (x) (hx : x ‚àà s·∂ú), {x | v.limRatioMeas hœÅ x = 0}) ‚â§ (2 * n)‚Åª¬π := by
    intro n
    calc
      _ ‚â§ ‚àë' x : s·∂ú, œÅ {x | v.limRatioMeas hœÅ x = 0} := measure_iUnion_le _
      _ ‚â§ ‚àë' x : s·∂ú, (2 * n)‚Åª¬π := by
        gcongr
        exact v.measure_le_of_subset_lt_limRatioMeas_mul hœÅ (fun x hx => hx.2)
          (mul_pos (by norm_num) n.cast_pos.succ_pos)
      _ ‚â§ (2 * n)‚Åª¬π := by simp
  refine' (measure_mono <| _).trans (le_of_tendsto this)
  rintro x ‚ü®‚ü®_‚ü©, hx‚ü©
  simp [hx]

===== Proof 2355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  by_contra h
  push_neg at h
  have hœÅ : ‚àÄ·µê x ‚àÇœÅ, v.limRatioMeas hœÅ x = 0 := by
    rcases v.exists_eq_or_top_of_measure_zero h with ‚ü®s, hs, hœÅs‚ü©
    rw [‚Üê v.measure_zero_eq_zero_of_forall_eq_zero]
    filter_upwards [hs] with x hx
    rw [‚Üê hx]
    exact v.limRatioMeas_eq_zero_of_measure_zero hœÅs
  rcases h with ‚ü®s, hs, hœÅs‚ü©
  have hœÅ' : ‚àÄ·µê x ‚àÇœÅ, x ‚àà s ‚Üí v.limRatioMeas hœÅ x = 0 := by
    filter_upwards [hœÅ] with x hx hx' using hx
  rcases (measure_zero_iff_ae_nmem hs).1 hœÅs with ‚ü®t, hts, ht, hœÅt‚ü©
  have := measure_mono_null (Set.inter_subset_right s t) hœÅt
  rcases (measure_zero_iff_ae_nmem hs).1 this with ‚ü®u, hsu, hu, hœÅu‚ü©
  have := measure_mono_null (Set.inter_subset_right s u) hœÅu
  simp_all

===== Proof 2356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  apply le_antisymm (measure_mono _) zero_le
  exact fun x hx ‚Ü¶ by simp [hx]

===== Proof 2357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have h : ‚àÄ·µê x ‚àÇœÅ, 0 ‚â§ v.limRatioMeas hœÅ x := by
    filter_upwards
    exact v.limRatioMeas_nonneg hœÅ _
  rw [measure_zero_iff_ae_nmem]
  filter_upwards [h] with x hx using by
    have hx' : v.limRatioMeas hœÅ x ‚â§ 0 := le_of_eq hx.symm
    exact (hx.not_le hx').elim

===== Proof 2358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  simp_rw [‚Üê not_ne_iff, ‚Üê bex_ne_zero, not_exists, not_and]
  refine' measure_zero_iff_measure_lt_eps.mpr fun Œµ Œµ0 => _
  obtain ‚ü®Œ¥, hŒ¥0, hŒ¥Œµ‚ü© := exists_pos_rat_lt Œµ0
  obtain ‚ü®s, hs, h's‚ü© := v.exists_isOpen_subset_lt hœÅ hŒ¥0
  refine' ‚ü®s, hs, fun x hx h'x => _‚ü©
  specialize h's x hx
  convert h's.trans_le <| mod_cast hŒ¥Œµ.le

===== Proof 2359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  apply eq_of_le_of_not_lt
  ¬∑ exact le_measure_zero _ (fun _ => œÅ.absolutelyContinuous v.limRatioMeas)
  ¬∑ by_contra! h
    have pos_lt : 0 < œÅ {x | v.limRatioMeas hœÅ x = 0} := by
      conv_rhs at h
      exact (pos_iff_ne_zero.2 h.symm : 0 < _)
    have := v.measure_zero_of_delta _ pos_lt
    simp_all

===== Proof 2360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  refine' le_antisymm _ (zero_le _)
  have h : {x : Œ± | v.limRatioMeas hœÅ x = 0} = ‚ãÉ (Œµ : ‚Ñù) (hŒµ : 0 < Œµ), {x : Œ± | v.limRatioMeas hœÅ x < Œµ} := by
    ext1 x
    simp only [Set.mem_setOf_eq, Set.mem_iUnion, exists_prop]
    refine' ‚ü®fun hx => ‚ü®1, zero_lt_one, hx‚ü©, fun hx => _‚ü©
    obtain ‚ü®Œµ, hŒµ, hx‚ü© := hx
    exact lt_of_lt_of_le hx (le_of_eq hx.symm)
  rw [h]
  clear_value h
  simp only [Set.mem_setOf_eq, Set.mem_iUnion, exists_prop]
  refine' measure_iUnion_null_of_nat fun n => _
  refine' measure_mono (fun x hx => _)
  simpa only [‚Üê one_div_div] using hx

===== Proof 2361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  rcases null_of_locally_null _ (v.zero_mem_family_of_radius (zero_le _)) fun _ =>
    v.abs_limRatioMeas_le hœÅ with ‚ü®s, hs, hœÅs‚ü©
  rw [measure_zero_iff_null_of_locally_finite _ v.locallyFinite_diam]
  intro x hx
  exact hs.mono hx

===== Proof 2362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
   refine' le_antisymm _ (zero_le _)
   have : ‚àÄ n, œÅ {x | v.limRatioMeas hœÅ x ‚â§ n} ‚â§ (n : ‚Ñù‚â•0‚àû) := fun n ‚Ü¶ by
     have h_le : {x | v.limRatioMeas hœÅ x ‚â§ n} ‚äÜ {x | v.limRatioMeas hœÅ x < n + 1} :=
       fun x hx ‚Ü¶ by linarith
     _
     exact measure_mono h_le
   refine' le_of_tendsto (fun n ‚Ü¶ (this n).trans (le_of_eq (ENNReal.coe_natCast n).symm)) _
   refine' (tendsto_measure_Ico_atTop œÅ _).eventually (eventually_of_forall fun n ‚Ü¶ _)
   simp only [Nat.cast_le, Set.mem_Ico]
   exact ‚ü®n, le_of_eq (ENNReal.coe_natCast n).symm‚ü©

===== Proof 2363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  have : ‚àÄ·µê x ‚àÇœÅ, ‚àÄ y, (v.generatesMeasurableSetoid œÅ).rel x y ‚Üí v.limRatioMeas hœÅ x = v.limRatioMeas hœÅ y :=
    ae_all_iff.2 fun y ‚Ü¶ v.limRatioMeas_n_eq hœÅ _ _
  calc
    œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ œÅ {x | v.limRatioMeas hœÅ x = v.limRatioMeas hœÅ 0} :=
      measure_mono (fun x hx ‚Ü¶ by simp only [hx, v.limRatioMeas_zero])
    _ = 0 := by simp only [this.eq_of_univ, measure_univ]

===== Proof 2364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  apply le_antisymm (measure_mono _) (by simp)
  exact fun x hx ‚Ü¶ by simpa [hx] using hœÅ.absolutelyContinuous.le_of_eq hx

===== Proof 2365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  apply le_antisymm _ (zero_le _)
  refine' le_of_tendsto _ Filter.tendsto_const_nhds
  refine' (Measure.tendsto_lintegral_filter_of_dominated_convergence _ _ _ _ _).le
  exact fun _ => (le_abs_self _).trans (hœÅ.le_mul_meas_add_mul_meas_lt _ _)
  exact fun _ => v.limRatioMeas_meas_le _
  exact v.measurableSet_limRatioMeas_eq_top.compl
  exact v.measurableSet_limRatioMeas_eq_top.compl
  dsimp only [Filter.tendsto_iff_norm_sub_tendsto_zero,
    Pi.one_apply, Function.const_zero, norm_one,
    show ‚àÄ Œµ : ‚Ñù, 0 < Œµ ‚Üí ‚àÉ r : ‚Ñù, c.iInf_R Œµ ‚â§ r ‚àß ‚àÄ s : ‚Ñù, r ‚â§ s ‚Üí |1 / (c.l * s)| ‚â§ Œµ by
    intro Œµ hŒµ
    have : 0 < c.l := by linarith
    have : 0 < c.iInf_R (Œµ / 2) := by exact c.iInf_R_pos hŒµ.le
    refine' ‚ü®c.iInf_R (Œµ / 2), le_rfl, fun s hs => _‚ü©
    rw [div_le_iff (mul_pos this (zero_lt_two' ‚Ñù)), mul_assoc, mul_div_left_comm,
      mul_comm, ‚Üê div_le_iff' this, div_div_eq_mul_div]
    exact c.iInf_R_le (Œµ / 2) s hs
  exact Filter.eventually_of_forall fun _ => zero_le_one

===== Proof 2366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  refine' le_antisymm _ (zero_le _)
  have : œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ œÅ {x | v.limRatioMeas hœÅ x < 1} := by
    apply measure_mono
    exact fun x hx ‚Ü¶ by linarith
  refine' le_trans this _
  have : œÅ {x | v.limRatioMeas hœÅ x < 1} ‚â§ œÅ {x | v.limRatioMeas hœÅ x ‚â§ 1} := by
    apply measure_mono
    exact fun x hx ‚Ü¶ by linarith
  refine' le_trans this _
  have : œÅ {x | v.limRatioMeas hœÅ x ‚â§ 1} ‚â§ œÅ {x | v.limRatioMeas hœÅ x = 0} := by
    apply measure_mono
    exact fun x hx ‚Ü¶ by linarith
  exact this

===== Proof 2367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  refine' eq_bot_iff.2 fun x hx => _
  simp only [mem_setOf_eq] at hx
  have hœÅx_ne_top : œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â† ‚àû := by
    refine' (measure_mono fun x hx => _).trans_lt ENNReal.ofReal_lt_top
    simpa only [mem_setOf_eq, zero_ne_top] using hx
  refine' (measure_mono fun x hx => _).trans_eq hœÅx_ne_top
  simpa only [mem_setOf_eq, zero_ne_top] using hx

===== Proof 2368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : œÅ {x | v.limRatioMeas hœÅ x = 0} = 0 := by
  apply le_antisymm _ (zero_le _)
  refine le_of_tendsto_of_tendsto (zero_tendsto _) zero_le_one ?_
  simp only [one_div, Metric.nhds_basis_closedBall.tendsto_right_iff, le_zero_iff,
    Metric.mem_closedBall, dist_zero_left]
  intro Œµ hŒµ
  have hŒµ' : 0 < Œµ := ENNReal.ofReal_pos.2 hŒµ
  have hœÅŒµ : 0 < œÅ {x | v.limRatioMeas hœÅ x < Œµ} :=
    ENNReal.ofReal_pos.2 hŒµ'
  have : œÅ {x | v.limRatioMeas hœÅ x = 0} ‚â§ œÅ {x | v.limRatioMeas hœÅ x < Œµ} := by
    refine measure_mono (fun x hx ‚Ü¶ ?_)
    change v.limRatioMeas hœÅ x ‚â§ Œµ at hx
    have hœÅ' : 0 < œÅ {x | v.limRatioMeas hœÅ x ‚â§ Œµ} :=
      measure_pos_of_superset (eventually_of_forall (fun _ ‚Ü¶ le_top)) hœÅŒµ
        (fun x hx ‚Ü¶ hx)
    exact le_trans hx (le_of_lt hœÅ')
  refine le_trans this ?_
  have : œÅ {x | v.limRatioMeas hœÅ x < Œµ} ‚â§ œÅ {x | dist (v.limRatioMeas hœÅ x) 0 < Œµ} := by
    refine measure_mono (fun x hx ‚Ü¶ ?_)
    simpa only [dist_zero_left] using hx
  refine le_trans this ?_
  simpa only [dist_zero_left] using measure_lt_of_lt_of_isOpen hœÅ' Metric.isOpen_ball

===== Proof 2369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
   apply kernel.isSFiniteKernel_sum
   exact hŒ∫s

===== Proof 2370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
   apply isSFiniteKernel_sum'
   exact hŒ∫s

===== Proof 2371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  have h_sum := kernel.sum_iInf_nat Œ∫s
  apply isSFiniteKernel_iInf; intro n
  rw [h_sum]
  exact isSFiniteKernel_sum hŒ∫s n

===== Proof 2372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  rw [kernel.sum_apply]
  exact isSFiniteKernel_sum_of_monotone _ (fun _ _ => kernel.sum_le_sum _ _ fun _ => le_rfl)
    fun n => hŒ∫s n

===== Proof 2373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
   rw [kernel.sum_apply]
   exact isSFiniteKernel_sum fun n => (hŒ∫s n).isFiniteKernel

===== Proof 2374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  cases nonempty_encodable Œπ
  cases nonempty_encodable Œ±
  cases nonempty_encodable Œ≤
  let seq : ‚Ñï ‚Üí kernel Œ± Œ≤ := fun n => (hŒ∫s n).seq n
  have h_sum_seq : (kernel.sum Œ∫s).seq = fun n => (kernel.sum fun n => Œ∫s n (seq n)) := by
    ext x; cases x <;> rfl
  constructor
  swap
  ¬∑ refine ‚ü®fun n => (hŒ∫s _).trunc n, inferInstance, ?_‚ü©
    rw [h_sum_seq]
    refine sum_le_sum fun n _ => ?_
    refine kernel.sum_le_sum _ _ (fun n _ => ?_)
    exact kernel.trunc_le _ _
  constructor
  refine ‚ü®Summable.of_le (fun n => measure_kernel_lt_top_of_isSFiniteKernel (hŒ∫s n)) ?_, ?_‚ü©
  ¬∑ simp_rw [h_sum_seq]
    refine sum_le_sum ?_
    intro n _
    exact kernel.sum_le_sum _ _ fun n _ => kernel.measure_le_bound _ _
  simp_rw [h_sum_seq]
  exact measure_sum_lt_top_of_integrable _ (fun _ => kernel.sum_integrable_of_summable _
    (fun n => kernel.sum_integrable_of_summable _ (hŒ∫s n).2.2))

===== Proof 2375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  rw [‚Üê kernel.sum_apply' Œ∫s]
  exact
    isSFiniteKernel_sum fun n => (hŒ∫s n).exists_seq_tendsto_of_isSFiniteKernel

===== Proof 2376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  have : ‚àÄ n, ‚àÉ Œ∫‚Çô : kernel Œ± Œ≤, IsSFiniteKernel Œ∫‚Çô ‚àß Œ∫s n = Œ∫‚Çô := fun n =>
    ‚ü®Œ∫s n, hŒ∫s n, rfl‚ü©
  choose Œ∫‚Çô hŒ∫‚Çô hŒ∫‚Çô' using this
  use ‚àë n, Œ∫‚Çô n
  refine ‚ü®Summable.isSummable ?_, ?_‚ü©
  ¬∑ exact fun n => (hŒ∫‚Çô n).2.1
  ¬∑ simp_rw [hŒ∫‚Çô']
    exact kernel.sum_congr rfl fun n => rfl

===== Proof 2377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  induction' hŒ∫s with Œ∫ hŒ∫ Œ∫_iInductiveHypothesis IH
  ¬∑ exact isSFiniteKernel_sum_add hŒ∫ Œ∫_iInductiveHypothesis

===== Proof 2378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  let e : kernel Œ± Œ≤ ‚Üí ‚Ñï ‚Üí kernel Œ± Œ≤ := fun Œ∫ n => (hŒ∫s n).some
  exact ‚ü®‚ü®fun n => (e (Œ∫s ¬∑) n).sum, rfl, fun i => (hŒ∫s i).some_spec.symm ‚ñ∏ measure_iUnion_le _‚ü©‚ü©

===== Proof 2379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  have : ‚àÄ n, ‚àÉ Œ∫ : kernel Œ± Œ≤, IsSFiniteKernel Œ∫ ‚àß Œ∫s n = Œ∫ := by
    rintro n
    exact ‚ü®Œ∫s n, hŒ∫s n, rfl‚ü©
  choose Œ∫ hŒ∫ using this
  rw [kernel.sum_congr _ hŒ∫]
  exact .sum_of_sFinite _ fun i ‚Ü¶ (hŒ∫ i).1

===== Proof 2380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  let K : ‚Ñï ‚Üí kernel Œ± Œ≤ := fun n =>
    let K' := (hŒ∫s n).exists_seq_tendsto_integral_cond_cdf.choose
    kernel.sum K'
  have hK : ‚àÄ n, ‚àÉ K' : ‚Ñï ‚Üí kernel Œ± Œ≤,
      StrictMono K' ‚àß (kernel.sum K' : kernel Œ± Œ≤) = K n ‚àß
      ‚àÄ n, IsSFiniteKernel (K' n) := by
    refine fun n => ‚ü®fun m => (hŒ∫s n).exists_seq_tendsto_integral_cond_cdf.choose_spec.choose m,
      (hŒ∫s n).exists_seq_tendsto_integral_cond_cdf.choose_spec.choose_spec.1, rfl, ?_‚ü©
    intro n
    exact (hŒ∫s n).exists_seq_tendsto_integral_cond_cdf.choose_spec.choose_spec.2.1 n
  refine ‚ü®‚ü®K, hK‚ü©, rfl, ?_‚ü©
  have h_sum_K : kernel.sum K = kernel.sum Œ∫s := by
    rfl
  have h_sum_K_sf : ‚àÄ n, ‚àÉ K' : ‚Ñï ‚Üí kernel Œ± Œ≤, StrictMono K' ‚àß (kernel.sum K' : kernel Œ± Œ≤) = K n ‚àß
      ‚àÄ m, IsSFiniteKernel (K' m) := by
    exact fun n => hK n
  refine isSFiniteKernel_sum h_sum_K_sf

===== Proof 2381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  let Œ∫s' := fun n => (Œ∫s n).toSFinite
  have hŒ∫s' : ‚àÄ n, IsSFiniteKernel Œ∫s' n := fun n => (hŒ∫s n).toSFinite
  exact isSFiniteKernel_sum hŒ∫s'

===== Proof 2382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  have h : kernel.sum Œ∫s = kernel.sum (fun n => (hŒ∫s n).aefirstKernel) := by
    ext x s hs; simp only [kernel.sum_apply, kernel.sum_apply']
    exact kernel.sum_apply' _ _ _
  rw [h]
  exact isSFiniteKernel_sum fun n => (hŒ∫s n).aefirstKernel

===== Proof 2383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
   apply IsSFiniteKernel.ssum
   exact hŒ∫s

===== Proof 2384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  let Œ∫_sf := fun n => sFiniteKernelSeq (hŒ∫s n)
  refine' ‚ü®Œ∫_sf, hasSum_sigma_ker_seq Œ∫s, _‚ü©
  intro n
  exact (sFiniteKernelSeq (hŒ∫s n)).isSFiniteKernel

===== Proof 2385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  refine ‚ü®fun n ‚Ü¶ hŒ∫s n, ?_‚ü©
  rw [kernel.sum_apply' _ _ (Set.mem_univ _)]
  exact ENNReal.summable.isSummable

===== Proof 2386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  have : kernel.sum Œ∫s = kernel.sum (fun n => (hŒ∫s n).1.toKernel) := by
    congr with i
    exact (hŒ∫s i).1.eta.symm
  rw [this]
  refine IsSFiniteKernel.sum (fun n => (hŒ∫s n).1)

===== Proof 2387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  simpa only [kernel.sum_apply] using isSFiniteKernel_sum' hŒ∫s

===== Proof 2388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  have h_meas : ‚àÄ n, IsFiniteKernel (Œ∫s n) := fun n ‚Ü¶ (hŒ∫s n).isFiniteKernel
  refine' ‚ü®‚ü®fun n ‚Ü¶ (hŒ∫s n).seq.toKernel, fun n ‚Ü¶ (hŒ∫s n).seq.length,
    fun n ‚Ü¶ (hŒ∫s n).seq.isFinite, _‚ü©‚ü©
  have h_sum_finite : Summable fun n ‚Ü¶ (hŒ∫s n).seq.length := by
    apply Summable.sigma
    exact (hŒ∫s _).summable_seq_length
  refine' ((kernel.sum_seq Œ∫s).trans _).symm
  congr with n
  have h_sum_seq : (kernel.sum Œ∫s).seq n = (Œ∫s n).seq n := by
    rw [kernel.sum_seq, kernel.sum_seq]
  rw [h_sum_seq]
  have h_eq_seq : ‚àÄ n, (Œ∫s n).seq n = (hŒ∫s n).seq.toKernel n := by
    intro n
    cases hŒ∫s n
    simp
  simp_rw [h_eq_seq]

===== Proof 2389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
   apply kernel.isSFiniteKernel_sum
   exact hŒ∫s

===== Proof 2390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  have h‚ÇÅ : ‚àÄ n, ‚àÉ Œ∫ : kernel Œ± Œ≤, IsFiniteKernel Œ∫ ‚àß Œ∫s n ‚â§ Œ∫ := by
    intro n
    exact ‚ü®hŒ∫s n.succ, isFiniteKernel_succ, kernel.sum_le_kernel Œ∫s n.pred‚ü©
  have h‚ÇÇ : ‚àÉ (Œ∫ : kernel Œ± Œ≤), IsFiniteKernel Œ∫ ‚àß kernel.sum Œ∫s ‚â§ Œ∫ := by
    use kernel.sum (fun n => Classical.choose (h‚ÇÅ n))
    constructor
    ¬∑ refine IsFiniteKernel.sum ?_
      intro n
      exact (Classical.choose_spec (h‚ÇÅ n)).1
    ¬∑ refine Monotone.directed_le fun n m h => ?_
      have h' : Œ∫s n ‚â§ kernel.sum (fun n => Classical.choose (h‚ÇÅ n)) :=
        (Classical.choose_spec (h‚ÇÅ n)).2
      exact le_trans h' (kernel.sum_le_kernel _ _ h)
  exact ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©

===== Proof 2391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
   have h_meas : ‚àÄ n, ‚àÉ K : ‚Ñï ‚Üí kernel Œ± Œ≤, IsSFiniteKernel (K 0) ‚àß Œ∫s n = kernel.sum K := by
     refine fun n ‚Ü¶ ‚ü®fun m ‚Ü¶ if m = 0 then Œ∫s n else 0, ?_, ?_‚ü©
     ¬∑ by_cases m = 0 <;> simp_all [hŒ∫s n]
     ¬∑ cases m <;> simp
   choose K hK using h_meas
   exact ‚ü®‚àë n, K n 0, isSFiniteKernel_sum (fun n => (hK n).1), by rw [kernel.sum_sum]; funext n; rw [(hK n).2]‚ü©

===== Proof 2392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  let Œ∫ := kernel.sum Œ∫s
  have hŒ∫ : IsSFiniteKernel Œ∫ := kernel.isSFiniteKernel_sum hŒ∫s
  rw [kernel.sum_apply]
  exact hŒ∫

===== Proof 2393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  let Œ∫s' : Œπ ‚Üí kernel Œ± Œ≤ := fun n => (hŒ∫s n).1.toKernel
  have hŒ∫s' : ‚àÄ n, IsFiniteKernel (Œ∫s' n) := fun n => (hŒ∫s n).2.1
  refine' ‚ü®‚ü®Œ∫s', isSFiniteKernel_sum hŒ∫s', _‚ü©‚ü©
  apply measure_theory.isSFiniteKernel_sum
  intro n
  exact ‚ü®Œ∫s' n, hŒ∫s' n, by simp only [Œ∫s', toKernel_apply]‚ü©

===== Proof 2394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  rw [kernel.sum_apply]
  have h := IsSFiniteKernel.isFiniteKernel_sum _ hŒ∫s
  exact IsSFiniteKernel.mk (h.bound) (h.bound_sum)

===== Proof 2395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
   rw [kernel.sum]
   have := ProbabilityTheory.kernel_sum_sFiniteMeasure Œ∫s hŒ∫s
   simpa using (this.isSFiniteKernel)

===== Proof 2396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  have : ‚àÄ n, ‚àÉ K : ‚Ñï ‚Üí kernel Œ± Œ≤,
      (‚àÄ n, IsSFiniteKernel (K n)) ‚àß
      (kernel.sum K) = Œ∫s n := fun n => by
    have h := hŒ∫s n
    rw [isSFiniteKernel_iff] at h
    exact h
  choose K hK_sf hK_eq using this
  refine' ‚ü®‚àë n, K n, fun n => (hK_sf n).1, _‚ü©
  simp_rw [hK_eq, kernel.sum_sum]

===== Proof 2397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
   apply isSFiniteKernel_finset_sum
   simpa

===== Proof 2398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  cases' isEmpty_or_nonempty Œπ with h h
  ¬∑ have : ‚àÉ x :: xs, Œ∫s = x :: xs := by
      refine' ‚ü®Œ∫s (Classical.arbitrary Œπ),
        _, _‚ü©
      ¬∑ ext i
        exact congr_fun h i
      ¬∑ rfl
    cases' this with x hx
    rw [hx]
    exact isSFiniteKernel_sum_fin _ fun n => hŒ∫s n
  ¬∑ exact isSFiniteKernel_sum_of_nonempty h hŒ∫s

===== Proof 2399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
  rw [kernel.sum_eq_sum (kernel.fst ‚àò Œ∫s)]
  refine IsSFiniteKernel.sum (fun n ‚Ü¶ ?_)
  choose h1 h2 using hŒ∫s n
  exact ‚ü®h1, h2‚ü©

===== Proof 2400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable Œπ] {Œ∫s : Œπ ‚Üí kernel Œ± Œ≤}
    (hŒ∫s : ‚àÄ n, IsSFiniteKernel (Œ∫s n)) : IsSFiniteKernel (kernel.sum Œ∫s) := by
   apply kernel.isSFiniteKernel_sum
   exact hŒ∫s

===== Proof 2401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  apply Sheaf.Hom.ext
  intro U
  ext
  rfl

===== Proof 2402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  rfl

===== Proof 2403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext1
  apply Subsingleton.elim

===== Proof 2404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  apply Subtype.ext
  rfl

===== Proof 2405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext1
  ext
  rfl

===== Proof 2406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext X
  simp [toImageSheaf, imageSheafŒπ]

===== Proof 2407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  induction U
  apply limit.hom_ext  <;> aesop_cat

===== Proof 2408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext : 2
  rfl

===== Proof 2409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext
  rfl

===== Proof 2410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext C
  rfl

===== Proof 2411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  simp only [Category.assoc, toImageSheaf_val, colimit.Œπ_desc, JointlySurjective.Œπ_desc_assoc,
    Sheaf.œÄ_obj, colimit.Œπ_map_assoc, imageSheafŒπ_app]
  congr 1
  apply colimit.hom_ext
  intro j
  simp [imageSieve_app]

===== Proof 2412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  dsimp [toImageSheaf, imageSheafŒπ, toImageSheaf_, imageSheafObj']
  simp [toImageSheaf_app, Category.assoc]

===== Proof 2413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext
  rfl

===== Proof 2414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  dsimp
  apply (cancel_mono (imageSheafŒπ f).1).1
  rfl

===== Proof 2415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext X : 2
  apply Subsingleton.elim

===== Proof 2416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  funext x
  simp [toImageSheaf, imageSheafŒπ]

===== Proof 2417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext
  rfl

===== Proof 2418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by tauto

===== Proof 2419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  dsimp [toImageSheaf, imageSheafŒπ]
  simp

===== Proof 2420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  simp only [comp_app, imageSheafŒπ_app, toImageSheaf_app]
  rfl

===== Proof 2421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext X : 2
  apply ConcreteCategory.preimage_map

===== Proof 2422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext X : 2
  apply Subsingleton.elim

===== Proof 2423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  induction U with
  | mk U =>
    simp only [toImageSheaf_val, sheafToPresheaf_obj, Subtype.val_eq_coe, sheafToPresheaf_map,
      Presheaf.comp_app, Opens.colimit_cocone_œÄ_app, Œπ_colimMap,
      eqToHom_trans, eqToHom_refl, Category.id_comp]
    rfl

===== Proof 2424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  refine J.image_sheaf_iso_ext (fun U => ?_)
  dsimp only [comp_val, toImageSheaf_val, Subtype.mk.injEq, eq_mpr_eq_cast, cast_eq]
  simp

===== Proof 2425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U; simp [toImageSheaf]

===== Proof 2426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  dsimp only [toImageSheaf, imageSheafŒπ, toImageSheaf_hom, imageSheafObj_œÄ_app]
  simp

===== Proof 2427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by aesop_cat

===== Proof 2428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext X : 3
  apply OrderHom.ext
  dsimp
  ext ‚ü®x, _‚ü©
  rfl

===== Proof 2429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  apply (Nonempty.some inferInstance).toImageSheaf_map_base

===== Proof 2430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  rfl

===== Proof 2431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  ext U
  rfl

===== Proof 2432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_Œπ {F F' : Sheaf J (Type w)} (f : F ‚ü∂ F') :
    toImageSheaf f ‚â´ imageSheafŒπ f = f := by
  apply Category.id_comp

===== Proof 2433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  dsimp only [divInt, Rat.divInt, Rat.mkInt]; split; simp [h, mul_comm]

===== Proof 2434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro a b c
  by_cases h : c = 0 <;> simp [h]
  rw [divInt_add_divInt _ _ h h, divInt_eq_iff _ (by simp [h])]
  simp [Int.add_mul, Int.mul_assoc]

===== Proof 2435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  have : (2 : ‚Ñ§) ‚â† 0 := by decide
  have : (3 : ‚Ñ§) ‚â† 0 := by decide
  have : (5 : ‚Ñ§) ‚â† 0 := by decide
  norm_num [Int.add_mul]
  <;> rfl

===== Proof 2436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  exact fun h => by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]

===== Proof 2437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro a b c
  by_cases h : c = 0 <;> simp [h]
  rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
  simp [Int.add_mul, Int.mul_assoc]

===== Proof 2438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intros
  trivial

===== Proof 2439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  cases c <;> simp [Int.ofNat_ne_zero]
  rfl

===== Proof 2440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  try simp_all only [ne_eq, one_div, zero_div, add_zero, mul_zero, mul_one]
  try norm_num
  try ring_nf
  try field_simp
  try linarith

===== Proof 2441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  dsimp only
  rw [divInt_self h]
  rw [divInt_self h]
  rw [divInt_self h]
  simp

===== Proof 2442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by rfl

===== Proof 2443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  exact divInt_add_divInt _ _ h h

===== Proof 2444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
  simp [Int.add_mul, Int.mul_assoc]

===== Proof 2445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  contradiction

===== Proof 2446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  exact Eq.symm <| Cherries.add_mul_div_eq_div_mul_div_mul <| Eq.symm <| Cherries.mul_div_mul_eq_mul_div_mul_div

===== Proof 2447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  if h : c = 0 then
    have h1 : c = 0 := h
    simp [h1]
  else
    have h1 : c ‚â† 0 := h
    rw [divInt_add_divInt _ _ h1 h1, divInt_eq_iff h1 (Int.mul_ne_zero h1 h1)]
    simp [Int.add_mul, Int.mul_assoc]

===== Proof 2448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  rw [add_comm, divInt_add_divInt, divInt_eq_iff (Int.mul_ne_zero (Int.ofNat_ne_zero.2
    (Nat.succ_ne_zero 0)) (Int.ofNat_ne_zero.2 (Nat.succ_ne_zero 0)))]
  simp only [add_mul, mul_add, Int.mul_comm, Int.add_left_comm, Int.add_mul,
    Int.add_assoc, Int.mul_one, Int.add_right_comm, Int.mul_assoc]
  ring

===== Proof 2449 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  decide

===== Proof 2450 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
  simp [Int.add_mul, Int.mul_assoc]

===== Proof 2451 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro h;
  simp [h]

===== Proof 2452 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intros
  simp_all

===== Proof 2453 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  rw [add_comm]
  simp [divInt_add_divInt, Int.ofNat_eq_coe, Int.cast_ofNat, mul_add, mul_comm, mul_left_comm, add_mul,
    Int.cast_add, Int.cast_mul, Int.cast_ofNat, Int.ofNat_eq_coe, Int.cast_ofNat, mul_add, mul_comm,
    mul_left_comm, add_mul]

===== Proof 2454 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro a b c
  by_cases h : c = 0 <;> simp [h]

===== Proof 2455 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  have a_ : a / 2 = a / 2 := rfl
  have b_ : b / 2 = b / 2 := rfl
  have c_ : c / 2 = c / 2 := rfl
  have a_ : a / 2 = a / 2 := rfl
  have b_ : b / 2 = b / 2 := rfl
  have c_ : c / 2 = c / 2 := rfl
  linarith

===== Proof 2456 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  exact mod_cast mkRat_add a b ‚ü®c, h‚ü©

===== Proof 2457 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  exact not_false

===== Proof 2458 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by simp_all [Int.add_mul, Int.mul_assoc]

===== Proof 2459 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  have h‚ÇÅ : c ‚â† 0 := by
    rintro rfl
    simp at h
  rw [divInt_add_divInt _ _ h‚ÇÅ h‚ÇÅ, divInt_eq_iff h‚ÇÅ (mul_ne_zero h‚ÇÅ h‚ÇÅ)]
  simp [add_mul, mul_assoc]

===== Proof 2460 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro a b c; induction c using Int.induction_on with
  | hz => simp
  | hp n nz ih => simp_all [Int.add_mul, Int.mul_assoc]
  | hn n nz ih => simp_all [Int.add_mul, Int.mul_assoc]

===== Proof 2461 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  exact fun h => by simp_all [h]

===== Proof 2462 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intros
  simp_all

===== Proof 2463 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by simp [Int.add_mul, Int.mul_assoc]

===== Proof 2464 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ‚Ñ§) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  by_cases h : 12 = 0 <;> simp_all

===== Proof 2465 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  intro x
  rcases x with ‚ü®‚ü®x, y‚ü©, ‚ü®z, h‚ü©‚ü©
  simpa [Real.rpow_def_of_pos (by linarith : 0 < x), mul_comm] using Real.rpow_def_of_pos (by linarith : 0 < z)

===== Proof 2466 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  intro x
  rfl

===== Proof 2467 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  exact (fun p : ‚Ñù‚â•0 √ó ‚Ñù => Real.toNNReal (p.1 ^ p.2))

===== Proof 2468 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  rfl

===== Proof 2469 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  rfl

===== Proof 2470 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  rfl

===== Proof 2471 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simpa using h‚ÇÄ 0 1

===== Proof 2472 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  cases p
  simp

===== Proof 2473 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  let p : ‚Ñù √ó ‚Ñù := (1, 0)
  let f : ‚Ñù √ó ‚Ñù ‚Üí ‚Ñù := fun p => p.1 ^ p.2
  let g : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù √ó ‚Ñù := fun p => (p.1.1, p.2)
  let h : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := Real.toNNReal ‚àò f ‚àò g
  simp [h, p]

===== Proof 2474 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  letI := ‚ÄπNonempty ‚Ñï‚Ä∫
  simp

===== Proof 2475 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simpa using by linarith

===== Proof 2476 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  sorry

===== Proof 2477 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simp

===== Proof 2478 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simpa using h‚ÇÇ

===== Proof 2479 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simp only [Function.comp_apply]
  norm_cast

===== Proof 2480 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  intro
  rfl

===== Proof 2481 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  let c : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï := fun c : ‚Ñï => Nat.factorial c
  simp only [c, Nat.factorial]
  rfl
  <;> decide

===== Proof 2482 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  letI : One ‚Ñù‚â•0 := ‚ü®‚ü®1, Nat.cast_nonneg _‚ü©, rfl‚ü©
  letI : Mul ‚Ñù‚â•0 := ‚ü®fun x y => ‚ü®x * y, mul_nonneg x.2 y.2‚ü©, rfl‚ü©
  letI : Inv ‚Ñù‚â•0 := ‚ü®fun x => ‚ü®x‚Åª¬π, inv_nonneg.2 x.2‚ü©, rfl‚ü©
  letI : Div ‚Ñù‚â•0 := ‚ü®fun x y => ‚ü®x / y, div_nonneg x.2 y.2‚ü©, rfl‚ü©
  letI : LE ‚Ñù‚â•0 := ‚ü®fun x y => x ‚â§ y‚ü©
  letI : LT ‚Ñù‚â•0 := ‚ü®fun x y => x < y‚ü©
  letI : NatCast ‚Ñù‚â•0 := ‚ü®fun n => ‚ü®n, Nat.cast_nonneg n‚ü©, rfl‚ü©
  letI : IntCast ‚Ñù‚â•0 := ‚ü®fun n => ‚ü®n, Int.cast_nonneg.2 (Int.ofNat_nonneg _)‚ü©, rfl‚ü©
  letI : Pow ‚Ñù‚â•0 := ‚ü®fun x y => x ^ y‚ü©
  letI : OrderBot ‚Ñù‚â•0 := ‚ü®‚ü®0, Nat.cast_nonneg _‚ü©, fun _ _ => Nat.cast_le.2‚ü©
  letI : OrderTop ‚Ñù‚â•0 := ‚ü®‚ü®1, Nat.cast_lt.2 (Nat.one_pos)‚ü©, fun _ _ => Nat.cast_le.2‚ü©
  letI : BoundedOrder ‚Ñù‚â•0 := ‚ü®‚ü©
  letI : DenselyOrdered ‚Ñù‚â•0 := ‚ü®fun x y => Nat.cast_lt.2‚ü©
  infer_instance

===== Proof 2483 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  intro x y
  ring

===== Proof 2484 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simp only [Function.comp_apply, Prod.snd, Prod.fst]
  norm_cast

===== Proof 2485 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  aesop

===== Proof 2486 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  rcases ‚Äπ_‚Ä∫ with ‚ü®y, rfl‚ü©
  simp

===== Proof 2487 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  let perimeter : ‚Ñù‚â•0‚àû := 2 * (5 : ‚Ñù‚â•0‚àû) * (1 : ‚Ñù‚â•0‚àû)
  exact (memhp : M < 2 * (5 : ‚Ñù‚â•0‚àû) * (1 : ‚Ñù‚â•0‚àû)).symm ‚ñ∏ by norm_num

===== Proof 2488 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  let f : ‚Ñù √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2
  let f' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''''''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''''''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''''''''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''''''''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''''''''''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''''''''''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1, p.2)
  let f''''''''''''''''''''' : ‚Ñù‚â•0 √ó ‚Ñù ‚Üí ‚Ñù := fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2)
  let f'''''''''''''''''''''' : ‚Ñù‚â•0 √ó
===== Proof 2489 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  rfl

===== Proof 2490 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simpa using h‚ÇÄ 1 2

===== Proof 2491 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simp [Function.comp]

===== Proof 2492 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  funext p
  simp
  rw [rpow_def_of_pos (show (0 : ‚Ñù) < p.1 by norm_cast) p.2]
  norm_cast

===== Proof 2493 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simp only [Function.comp_apply]
  norm_num

===== Proof 2494 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  exact mul_comm _ _

===== Proof 2495 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  aesop

===== Proof 2496 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by
  simpa using Real.rpow_natCast 2 2

===== Proof 2497 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  nlinarith [log_lt_sub_one_of_pos hx1 hx2]

===== Proof 2498 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have hx3 : x - 1 > 0 := sub_pos_of_lt (by linarith)
  apply log_lt_sub_one hx1 hx2 hx3

===== Proof 2499 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have hx3 : x - 1 ‚â† 0 := by
    intro h
    apply hx2
    linarith
  have hx4 : 0 < x - 1 := by
    linarith
  have hx5 : log x < x - 1 := by
    apply (log_lt_sub_one_of_pos hx1 hx2).1
  apply hx5

===== Proof 2500 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have h : x - 1 > 0 := by
    linarith
  linarith [log_lt_sub_one hx2]

===== Proof 2501 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  cases' le_or_lt x 1 with hx hx
  all_goals
    linarith [log_le_sub_one_of_pos hx1 hx2, log_neg hx1.ne']

===== Proof 2502 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  rw [‚Üê log_one]
  apply log_lt_log_of_lt_of_pos
  linarith
  linarith

===== Proof 2503 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have h‚ÇÄ : x - 1 ‚â† 0 := by
    intro h
    apply hx2
    linarith
  have h‚ÇÅ : log x ‚â§ x - 1 := by
    apply log_le_sub_one_of_pos hx1
  have h‚ÇÇ : log x ‚â† x - 1 := by
    intro h
    apply hx2
    linarith
  linarith

===== Proof 2504 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  rw [‚Üê sub_pos]
  linarith [Real.log_lt_sub_one_of_pos hx1 hx2]

===== Proof 2505 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have h‚ÇÅ : x - 1 ‚â† 0 := by linarith
  linarith [log_lt_sub_one hx1 hx2]

===== Proof 2506 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have hx3 : x - 1 < log x + 1 := by
    rw [‚Üê log_one]
    apply log_lt_log hx1
    linarith
  linarith

===== Proof 2507 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have h : 0 < x - 1 := by linarith
  apply lt_of_sub_pos
  rw [‚Üê log_one]
  apply @log_lt_log _ _ _ (x - 1)
  linarith
  linarith

===== Proof 2508 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have hx3 : x - 1 ‚â† 0 := by linarith
  rw [‚Üê log_one]
  apply log_lt_log hx1
  linarith

===== Proof 2509 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have : x - 1 > 0 := by linarith
  have h := log_lt_sub_one_of_pos hx1 hx2
  linarith

===== Proof 2510 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have hx3 : x - 1 > 0 := sub_pos.mpr (by linarith)
  have hx4 : log x ‚â§ x - 1 := log_le_sub_one_of_pos hx1
  linarith

===== Proof 2511 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  rw [‚Üê log_one]
  apply log_lt_log hx1
  linarith

===== Proof 2512 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  rw [‚Üê sub_pos]
  linarith [log_lt_sub_one hx1 hx2]

===== Proof 2513 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  cases' lt_iff_lt_or_eq.mp hx1 with hx1 hx1
  exact log_lt_sub_one hx1 hx2
  simp_all

===== Proof 2514 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  apply lt_of_sub_pos
  rw [‚Üê sub_pos]
  linarith [Real.log_one]

===== Proof 2515 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have hx3 : x - 1 ‚â† 0 := sub_ne_zero.mpr hx2
  linarith [log_le_sub_one_of_pos hx1]

===== Proof 2516 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  rw [‚Üê sub_pos]
  nlinarith [log_lt_sub_one_of_pos hx1 hx2]

===== Proof 2517 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have h := log_lt_sub_one_of_pos hx1 hx2
  linarith

===== Proof 2518 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  linarith [log_le_sub_one_of_pos hx1 hx2]

===== Proof 2519 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have h := log_lt_sub_one_of_pos hx1 hx2
  linarith

===== Proof 2520 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have hx3 : 0 < x / x := div_pos hx1 (by linarith)
  rw [div_self (show (x : ‚Ñù) ‚â† 0 by linarith)] at hx3
  linarith [log_lt_sub_one hx1 hx2]

===== Proof 2521 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  cases' lt_or_le 1 x with hx hx
  all_goals
    have hx' : 0 < x - 1 := by linarith
    rw [‚Üê sub_pos]
    nlinarith [log_lt_sub_one_of_pos hx' (by linarith : x - 1 ‚â† 1)]

===== Proof 2522 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  rw [log_eq_sub_inv_of_pos hx1]
  apply sub_lt_sub_right _ (1 : ‚Ñù)
  rw [div_lt_iff (sub_pos.mpr (by linarith))]
  nlinarith

===== Proof 2523 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have hx1' : 0 < x := by linarith
  have hx2' : x ‚â† 1 := by linarith
  linarith [log_lt_sub_one_of_pos hx1' hx2']

===== Proof 2524 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have hx3 : 0 < x - 1 := sub_pos.mpr (by linarith)
  have hx4 : log x < 1 * (x - 1) := by
    rw [‚Üê sub_pos]
    exact log_lt_sub_one_of_pos hx1 hx2
  linarith

===== Proof 2525 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  nlinarith [log_lt_sub_one_of_pos hx1 hx2]

===== Proof 2526 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  have h : x > 0 := by linarith
  rw [‚Üê sub_pos]
  apply (log_lt_sub_one_of_pos h hx2).trans_le
  linarith

===== Proof 2527 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  rw [‚Üê sub_pos]
  cases' hx1.lt_or_lt with hx1 hx1
  ¬∑ exact (log_lt_sub_one_of_pos hx1 hx2).trans_le (by linarith)
  ¬∑ exact (log_lt_sub_one_of_pos hx1 hx2).trans_le (by linarith)

===== Proof 2528 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by
  rw [‚Üê log_one]
  apply log_lt_log hx1
  linarith

===== Proof 2529 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  dsimp only [(¬∑.map g)]
  simp only [rfind_eq_done, bind_eq_bind, map_eq_bind_pure_comp, bind_assoc,
    bind_pure_comp, seq_eq_bind_bind, bind_eq_bind]
  rfl

===== Proof 2530 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply Seq.eq_of_bisim fun s1 s2 ‚Ü¶ ‚àÉ s, s1 = map (g ‚àò f) s ‚àß s2 = map g (map f s)
  intro s1 s2 h
  obtain ‚ü®s, rfl, rfl‚ü© := h
  induction' s using WSeq.recOn with a s s <;> simp
  exact ‚ü®s, rfl, rfl‚ü©

===== Proof 2531 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  repeat' simp only [map_cons, map_think]

===== Proof 2532 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  funext x; induction' s using WSeq.rec_on with a s s <;> simp [*]

===== Proof 2533 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply WSeq.ext
  intro n
  simp only [get?, map]
  apply get_nats

===== Proof 2534 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply map_comp

===== Proof 2535 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  cases s; simp only [map, map_comp f g w, destruct_map, map_destruct]
  rfl

===== Proof 2536 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  simp only [map, comp_apply]
  apply liftRel_map _ _ (fun a b => LiftRel R a b) _ _ rfl rfl
  aesop

===== Proof 2537 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  by_cases h : ‚àÉ l, s = ofList l
  ¬∑ cases' h with l e
    simp [e, ofList, map]
    induction' l with a l IH
    ¬∑ rfl
    ¬∑ rw [map, map]
      simp [IH]
  ¬∑ have h' : s ‚â† ofList l := h
    simp [h']

===== Proof 2538 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  cases' s with s s <;> simp only [map, computably_decided_pfun, comp_apply]
  cases' destruct s with a s <;> simp

===== Proof 2539 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply Subsingleton.elim

===== Proof 2540 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  by_cases h : s = nil <;> simp_all [map, mapAccumr]
  induction' s using WSeq.recOn with x s s <;> simp_all [map, mapAccumr]

===== Proof 2541 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply Stream'.map_comp

===== Proof 2542 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply WSeq.map_comp

===== Proof 2543 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply map_congr
  rintro _ _ rfl

===== Proof 2544 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  induction s using WSeq.rec_on with
  | nil => rfl
  | cons x s s' ih => simp [*, map_append]

===== Proof 2545 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply Stream'.map_comp

===== Proof 2546 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  rw [‚Üê map_comp]

===== Proof 2547 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply congr_arg
  apply WSeq.recOn s <;> intro n <;> simp

===== Proof 2548 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply congr_arg
  simp_all [Function.comp]

===== Proof 2549 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply WSeq.map_comp

===== Proof 2550 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  by_cases h : s = nil <;>
    simp [h, map]

===== Proof 2551 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply WSeq.ext
  intro n
  apply nth_congr
  rfl

===== Proof 2552 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  ext; simp [map_comp]

===== Proof 2553 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  simp only [map, comp, Seq.map_comp]

===== Proof 2554 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  induction s using WSeq.recOn with
  | nil => simp
  | cons x s' ih => simp [ih]

===== Proof 2555 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  cases s <;> simp [map, WSeq.map, Seq.map]

===== Proof 2556 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply map_comp

===== Proof 2557 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  suffices ‚àÄ (s : WSeq Œ±), map (g ‚àò f) s = map g (map f s) by
    apply this
  intro s
  simp only [map_comp]

===== Proof 2558 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  simp [map, comp_apply, map_compFn]

===== Proof 2559 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply Subsingleton.map_comp

===== Proof 2560 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : Œ± ‚Üí Œ≤) (g : Œ≤ ‚Üí Œ≥) (s : WSeq Œ±) : map (g ‚àò f) s = map g (map f s) := by
  apply map_comp f g s

===== Proof 2561 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp only [mem_smul_set, mem_closedBall_zero_iff, norm_eq_abs, abs_of_nonneg hr]
  constructor <;> intro h <;> linarith

===== Proof 2562 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp [mem_smul_set_iff_inv_smul_mem‚ÇÄ (ne_of_gt (zero_lt_one.trans_le hr)), mem_closedBall_zero_iff,
    norm_smul, inv_mul_le_iff (zero_lt_one.trans_le hr)]

===== Proof 2563 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [smul_closedBall _ _ hr]
  simp [hr]

===== Proof 2564 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  apply Subset.antisymm
  ¬∑ intro x hx
    rw [Set.mem_smul_set] at hx
    rcases hx with ‚ü®y, hy, rfl‚ü©
    simp only [Set.mem_closedBall, norm_smul, mul_one]
    exact mul_le_mul_of_nonneg_left hy hr
  ¬∑ intro x hx
    rw [Set.mem_smul_set]
    use r‚Åª¬π ‚Ä¢ x
    constructor
    ¬∑ simp only [Set.mem_closedBall, norm_smul, norm_inv, one_mul]
      exact (le_inv_mul_iff_mul_le‚ÇÄ hr).2 hx
    ¬∑ simp only [‚Üê smul_assoc, smul_eq_mul, mul_inv_cancel hr.lt.ne', one_smul]

===== Proof 2565 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [smul_closedBall _ _ hr]
  simp [abs_of_nonneg hr]

===== Proof 2566 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp [mem_smul_set_iff_inv_smul_mem‚ÇÄ, mem_closedBall_zero_iff, norm_smul, hr]

===== Proof 2567 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  refine' (smul_set_closedBall _ _ _).trans _
  simp [abs_of_nonneg, hr]

===== Proof 2568 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [smul_closedUnitBall]
  simp [hr]

===== Proof 2569 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [smul_closedBall _ _ hr]
  simp [hr]

===== Proof 2570 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp only [mem_smul_set, mem_closedBall_zero_iff, norm_smul, Real.norm_of_nonneg hr]
  constructor <;> intro h <;> linarith

===== Proof 2571 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp only [mem_smul_set, mem_closedBall_zero_iff, norm_smul, mul_one]
  constructor
  exact fun h => by nlinarith
  intro h
  use r‚Åª¬π * ‚Äñx‚Äñ
  nlinarith

===== Proof 2572 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp only [mem_smul_set, mem_closedBall_zero_iff, norm_smul, mul_one]
  constructor <;> intro h <;> linarith

===== Proof 2573 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rcases hr.lt_or_eq with (hr | rfl)
  case inr => simp
  ext x
  simp only [mem_smul_set, mem_closedBall_zero, norm_smul, mul_one]
  constructor
  intro h
  exact (le_div_iff hr).mp h
  intro h
  exact (div_le_iff hr).mpr h

===== Proof 2574 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext
  simp [mem_smul_set_iff_inv_smul_mem, mem_closedBall, real_inner_smul_left, norm_smul, hr]

===== Proof 2575 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  simp [smul_closedBall hr, abs_of_nonneg hr]

===== Proof 2576 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp only [mem_smul_set, mem_closedBall_zero_iff, exists_prop]
  constructor
  ¬∑ rintro ‚ü®a, ha, rfl‚ü©
    rwa [norm_smul, mul_one]
  ¬∑ intro hx
    use r‚Åª¬π ‚Ä¢ x
    constructor
    ¬∑ rwa [norm_smul, norm_inv, ‚Üê div_eq_inv_mul, div_le_one hr]
    ¬∑ simp

===== Proof 2577 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  apply Eq.symm
  simp [Eq.symm, smul_closedBall _ _ hr]

===== Proof 2578 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp only [mem_smul_set, mem_closedBall_zero, norm_eq_of_nonneg hr]
  constructor
  intro y
  aesop
  intro y
  aesop

===== Proof 2579 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [smul_closedBall _ _ hr]
  simp [abs_of_nonneg hr]

===== Proof 2580 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp only [mem_smul_set, mem_closedBall_zero_iff, norm_smul, mul_one]
  constructor
  exact fun h => by linarith
  intro h
  exact (mul_le_mul_of_nonneg_left h hr).le

===== Proof 2581 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [smul_closedBall _ _ hr]
  simp [abs_of_nonneg hr]

===== Proof 2582 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [‚Üê smul_closedBall_div _ _ hr, mul_one]

===== Proof 2583 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [‚Üê Metric.smul_closedUnitBall, smul_zero]

===== Proof 2584 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  simp [Set.ext_iff, mem_closedBall, smul_one_smul]
  exact ‚ü®fun h ‚Ü¶ by nlinarith, fun h ‚Ü¶ by nlinarith‚ü©

===== Proof 2585 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [smul_closedBall r hr]

===== Proof 2586 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [set_smul_closedBall_zero]
  simp [hr]

===== Proof 2587 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext
  simp [mem_closedBall, norm_smul, abs_of_nonneg hr]

===== Proof 2588 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext x
  simp [mem_smul_set_iff_inv_smul_mem‚ÇÄ (hr.lt.ne.symm), mem_closedBall_zero_iff, norm_smul,
    mul_inv_eq_iff‚ÇÄ (hr.lt.ne.symm), inv_mul_eq_iff‚ÇÄ (hr.lt.ne.symm)]

===== Proof 2589 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rw [smul_closedBall _ _ hr]
  simp [abs_of_nonneg hr]

===== Proof 2590 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  have : r ‚Ä¢ closedBall (0 : E) 1 = (r ‚Ä¢ (1 : ‚Ñù)) ‚Ä¢ closedBall (0 : E) 1 := by simp
  rw [this]
  simp [norm_smul, hr]

===== Proof 2591 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  ext
  simp [norm_smul, mul_comm, hr]

===== Proof 2592 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ‚Ñù} (hr : 0 ‚â§ r) :
    r ‚Ä¢ closedBall (0 : E) 1 = closedBall (0 : E) r := by
  rcases eq_or_lt_of_le hr with (rfl | hr)
  simp [Set.ext_iff, mem_closedBall, smul_zero]
  ext x
  simp [mem_closedBall, norm_smul, abs_of_pos hr]

===== Proof 2593 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  exact ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©

===== Proof 2594 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  constructor <;> intro h <;> simpa using h

===== Proof 2595 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by simpa

===== Proof 2596 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  by_contra! h
  rw [bijOn_empty_iff_left] at h
  have h1 := h.mapsTo
  rw [Set.mem_empty_iff_false] at h1
  exact h1 rfl

===== Proof 2597 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  exact Iff.intro (fun h ‚Ü¶ by simpa using h.mapsTo) (by rintro rfl; exact bijOn_empty f)

===== Proof 2598 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by apply Eq.symm; apply Eq.symm; apply Eq.symm; apply Eq.symm; aesop

===== Proof 2599 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by aesop

===== Proof 2600 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  aesop

===== Proof 2601 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  refine eq_of_heq ?_
  exact eq_rec_heq _ _

===== Proof 2602 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  exacts [by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f]

===== Proof 2603 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  refine' ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ _‚ü© <;> simp_all [h]

===== Proof 2604 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by simp

===== Proof 2605 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by simp
 @[simp] theorem bijOn_empty_iff_right : BijOn f ‚àÖ t ‚Üî t = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.surjOn, by rintro rfl; exact bijOn_empty f‚ü©

===== Proof 2606 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  refine' ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ by rw [h]; exact bijOn_empty f‚ü©
  by_contra h‚ÇÄ
  rw [not_not] at h‚ÇÄ
  have h‚ÇÅ := h.surjOn
  rw [h‚ÇÄ] at h‚ÇÅ
  simpa using h‚ÇÅ rfl

===== Proof 2607 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by simp

===== Proof 2608 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  apply Nat.strong_induction_on n
  intro n ih
  by_cases h : n = 0
  simp [h]
  rw [‚Üê Nat.succ_pred_eq_of_pos (Nat.pos_of_ne_zero h)]
  simp [Finset.sum_range_succ, ih _ (Nat.pred_lt_self h)]

===== Proof 2609 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  refine' ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ _‚ü© <;> simp_all

===== Proof 2610 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by simp

===== Proof 2611 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  refine' ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ _‚ü© <;> simp_all

===== Proof 2612 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  refine' ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ _‚ü©
  exacts [by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f]

===== Proof 2613 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  apply Iff.intro <;> intro <;>
  simp_all

===== Proof 2614 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  constructor <;> intro h
  <;> simp_all

===== Proof 2615 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by aesop

===== Proof 2616 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  constructor <;> intro h <;> have := h.mapsTo <;> simp_all

===== Proof 2617 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  refine' ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ _‚ü©
  ¬∑ have := h.mapsTo
    simpa using this
  ¬∑ rw [h]
    exact bijOn_empty f

===== Proof 2618 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  refine' ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ _‚ü© <;> simp_all

===== Proof 2619 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  apply Iff.intro <;> intro <;> simp_all

===== Proof 2620 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  constructor
  intro h
  apply subset_antisymm
  exact h.mapsTo
  intro x x_in_s
  exfalso
  apply not_mem_empty x
  exact h.surjOn x_in_s
  rintro rfl
  exact bijOn_empty f

===== Proof 2621 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  rintro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
  aesop

===== Proof 2622 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by simp [eq_comm]

===== Proof 2623 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  exact bijOn_empty_iff_left.mp (bijOn_empty f)

===== Proof 2624 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ‚àÖ ‚Üî s = ‚àÖ :=
  ‚ü®fun h ‚Ü¶ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f‚ü©
:= by
  aesop
  <;>
  simp [*]

===== Proof 2625 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [comp, bit1, add_comp]
  simp [one_comp]

===== Proof 2626 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp [bit1, add_comp, mul_comp, show p.comp q = (p.comp q : R[X]) by rfl]

===== Proof 2627 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [comp_eq_sum_left]
  simp_rw [bit1, sum_add_distrib, sum_sub_distrib, sum_single_index,
    sum_add_distrib, sum_sub_distrib, sum_single_index, sum_const, nsmul_eq_mul,
    Nat.cast_ofNat]
  simp only [add_left_inj, add_assoc, add_sub_assoc, add_comm, add_left_comm]
  ring_nf

===== Proof 2628 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by simp [bit1, comp]

===== Proof 2629 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  rw [bit1, bit1, comp, comp]
  ring

===== Proof 2630 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  unfold bit1
  unfold comp
  simp [add_assoc, add_comm, add_left_comm]

===== Proof 2631 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, add_comp, comp_add, comp, add_right_comm _ (comp q p)]
  simp only [add_assoc]

===== Proof 2632 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, comp_add, comp_one, comp_pow]
  ring

===== Proof 2633 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [comp, bit1, add_comp]
  simp [mul_assoc]

===== Proof 2634 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by simp only [bit1, comp_add, comp_one]

===== Proof 2635 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp [bit1]
  repeat' rw [add_comp]
  rw [mul_comp]

===== Proof 2636 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, comp, add_comp, comp_add, ‚Üê two_mul]
  ring

===== Proof 2637 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [comp, add_right_inj, one_mul, _root_.bit1, _root_.bit0, one_add_one_eq_two]
  ring

===== Proof 2638 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [comp]
  simp only [add_left_inj, one_mul]
  ring_nf

===== Proof 2639 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, comp, add_comp, one_comp]
  rw [‚Üê add_sub_assoc, sub_comp, mul_one_sub, add_sub_assoc]
  ring

===== Proof 2640 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp [bit1, add_comp]

===== Proof 2641 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, comp_add, comp_one, comp_pow]
  ring

===== Proof 2642 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [comp, bit1]
  ring_nf

===== Proof 2643 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [comp, bit1, one_mul]
  ring

===== Proof 2644 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [comp]
  simp only [Ring.bit1_comp]
  simp [add_comm]

===== Proof 2645 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, comp_add, comp_one, comp_C, comp_X_pow]
  ring

===== Proof 2646 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp [bit1, comp, ‚Üê C_eq_nat_cast, mul_assoc]
  ring

===== Proof 2647 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [comp]
  simp_rw [bit1, add_comp]
  simp_rw [mul_comp]
  simp_rw [add_assoc]

===== Proof 2648 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, comp_add, comp_one, comp_X_comp]
  simp only [add_zero, add_assoc]

===== Proof 2649 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [bit1, comp_add, comp_one, comp_add, comp_one]

===== Proof 2650 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [comp, bit1, add_comp]
  rw [mul_comm]
  simp [add_comm]

===== Proof 2651 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, comp, add_comp]
  simp only [two_mul, one_add_one_eq_two]
  simp only [add_assoc, add_nsmul]

===== Proof 2652 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, comp_add, comp_one, comp_X_mul]
  ring

===== Proof 2653 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [comp, bit1, add_left_inj, bit0_eq_two_mul, mul_one]
  ring

===== Proof 2654 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_all [bit1, comp]
  repeat' rw [add_mul, mul_add, mul_assoc, mul_comm, mul_left_comm]
  ring

===== Proof 2655 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp only [bit1, comp_add, comp_one, comp_mul_left, mul_one,
    add_left_comm, add_assoc]
  rw [add_comm]

===== Proof 2656 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  simp_rw [comp, bit1, add_assoc]
  ring_nf

===== Proof 2657 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2658 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2659 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2660 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h
  rfl

===== Proof 2661 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h; rfl

===== Proof 2662 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h; rfl

===== Proof 2663 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2664 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2665 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h; rfl

===== Proof 2666 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h
  rfl

===== Proof 2667 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h
  rfl

===== Proof 2668 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h
  rfl

===== Proof 2669 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2670 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h
  rfl

===== Proof 2671 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2672 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2673 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by subst h; rfl

===== Proof 2674 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2675 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2676 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2677 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2678 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2679 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by rw [h]

===== Proof 2680 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h; rfl

===== Proof 2681 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2682 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h
  rfl

===== Proof 2683 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by rw [h]

===== Proof 2684 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2685 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2686 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h
  rfl

===== Proof 2687 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  rw [h]

===== Proof 2688 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ‚•§ D} (h : F = G) (X) : F.obj X = G.obj X := by
  subst h
  rfl

===== Proof 2689 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_pi_div_two]
  simp [inner_zero_left, norm_eq_zero]

===== Proof 2690 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle]
  simp [inner_zero_left, zero_mul, Real.pi_pos.le]

===== Proof 2691 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle_eq_arccos_of_nonneg_of_le_one _ (by simp)]
  simp [Real.sqrt_eq_iff_mul_self_eq]

===== Proof 2692 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle_eq_arccos_of_nonneg_of_le_pi (norm_nonneg _) (by linarith [norm_nonneg x])]
  simp

===== Proof 2693 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle_eq_arccos_of_nonneg_of_le_pi (inner_zero_left x) (by linarith [norm_nonneg x])]
  simp [Real.arccos_zero]

===== Proof 2694 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_toReal_of_nonneg (norm_nonneg (0 - x))]
  simp

===== Proof 2695 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  simp [angle, Real.arccos_zero]

===== Proof 2696 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_pi_div_two]
  exact norm_eq_zero.2 rfl

===== Proof 2697 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_pi_div_two]
  simp [norm_eq_sqrt_inner, inner_zero_left, Real.sqrt_eq_zero]

===== Proof 2698 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_pi_div_two]
  exact div_nonneg_of_nonneg_of_nonneg (norm_nonneg _) (norm_nonneg _)

===== Proof 2699 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle_zero_left]

===== Proof 2700 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_pi_div_two]
  simp [norm_eq_zero]

===== Proof 2701 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, norm_zero, zero_mul, div_zero, Real.pi_div_two_pos.le]

===== Proof 2702 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  simp [angle, Real.arccos_zero]

===== Proof 2703 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, arccos_eq_pi_div_two]
  simp [norm_eq_zero]

===== Proof 2704 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle_eq_arccos_of_nonneg_of_le_pi]
  simp [real_inner_zero_left, norm_zero, div_self (norm_ne_zero_iff.mpr (by decide))]
  all_goals
    linarith [norm_nonneg x]

===== Proof 2705 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle]
  rw [Real.arccos_eq_pi_div_two]
  exact norm_zero.symm ‚ñ∏ norm_pos_iff.2 (by assumption)

===== Proof 2706 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  unfold angle
  rw [real_inner_zero_left, zero_div, Real.arccos_zero]

===== Proof 2707 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_pi_div_two]
  exact div_nonneg_of_nonpos_of_nonpos (norm_nonpos_iff.mpr rfl) (norm_nonneg x)

===== Proof 2708 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_pi_div_two]
  simp

===== Proof 2709 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  unfold angle
  rw [inner_zero_left, Nat.cast_zero, zero_div, Real.arccos_zero]

===== Proof 2710 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  by_cases h : x = 0 <;> simp [angle_eq_arccos_of_nonzero, h]

===== Proof 2711 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  by_cases h : x = 0 <;> simp_all [angle, Real.arccos_eq_zero_iff]

===== Proof 2712 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle]
  rw [Real.arccos_eq_pi_div_two]
  exact norm_zero_left _

===== Proof 2713 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle_zero_left]

===== Proof 2714 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle_eq_left]
  simp [Real.pi_pos.le]

===== Proof 2715 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  unfold angle
  rw [inner_zero_left]
  simp [div_eq_mul_inv, mul_left_comm]

===== Proof 2716 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_pi_div_two]
  simp [inner_zero_left, norm_eq_zero]

===== Proof 2717 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle_eq_pi_div_two_iff]
  simp

===== Proof 2718 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, norm_zero, zero_smul, inner_zero_left, zero_div]
  exact Real.pi_div_two_pos.le

===== Proof 2719 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  rw [angle, Real.arccos_eq_pi_div_two]
  rw [inner_zero_left, zero_div]
  rw [norm_eq_zero]
  rw [zero_eq_mul]
  norm_num

===== Proof 2720 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = œÄ / 2 := by
  simp [angle_eq_pi_div_two_iff]

===== Proof 2721 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, sub_add_eq_sub_sub, sub_lt_sub_iff_left]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2722 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_sub_iff_right, sub_lt_sub_iff_left]

===== Proof 2723 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add', lt_sub_iff_add_lt]

===== Proof 2724 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt, add_comm, add_left_comm]

===== Proof 2725 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2726 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2727 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_comm, lt_sub_iff_add_lt]

===== Proof 2728 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, sub_lt_comm]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2729 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext
  simp [sub_lt_iff_lt_add]
  omega

===== Proof 2730 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, sub_lt_sub_iff_right]

===== Proof 2731 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, sub_lt_sub_iff_left]

===== Proof 2732 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2733 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2734 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2735 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2736 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]

===== Proof 2737 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_eq_iff_eq_add]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2738 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]

===== Proof 2739 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2740 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  omega

===== Proof 2741 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  ring_nf
  tauto

===== Proof 2742 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2743 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext
  simp [sub_lt_iff_lt_add]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2744 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp only [Set.mem_preimage, Set.mem_Ioo, sub_lt, lt_sub]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2745 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2746 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  omega

===== Proof 2747 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro <;> constructor <;> linarith

===== Proof 2748 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_eq_iff_eq_add, sub_lt_iff_lt_add, sub_lt_iff_lt_add, add_comm, add_left_comm,
    add_assoc]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2749 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2750 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  omega

===== Proof 2751 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp only [Set.mem_preimage, Set.mem_Ioo, sub_lt, lt_sub]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2752 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ‚Åª¬π' Ioo b c = Ioo (a - c) (a - b) := by
  ext
  simp [sub_lt_iff_lt_add, lt_sub_iff_add_lt]
  constructor <;> intro h <;> constructor <;> linarith

===== Proof 2753 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext
  simp

===== Proof 2754 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext
  simp

===== Proof 2755 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext x
  simp [Sym2.map, Function.comp]

===== Proof 2756 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  funext x
  simp only [Sym2.map, Function.comp_apply, Equiv.coe_trans, Equiv.symm_symm]
  rfl

===== Proof 2757 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext ‚ü®a, b‚ü©
  simp [Sym2.map]
  rfl

===== Proof 2758 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  funext x
  simp [Sym2.map]
  rfl

===== Proof 2759 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  apply Sym2.ind
  intro x
  simp

===== Proof 2760 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext ‚ü®‚ü®x, y‚ü©‚ü©
  rfl

===== Proof 2761 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  funext x
  cases x
  rfl
  rfl

===== Proof 2762 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext
  simp

===== Proof 2763 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext
  simp

===== Proof 2764 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext
  simp only [Sym2.map, Function.comp_apply, Equiv.trans_apply]
  cases (Symbolic.symbolicExt_aux _ _) <;> rfl

===== Proof 2765 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext x
  cases x <;> rfl

===== Proof 2766 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  forall_congr' fun x => rfl

===== Proof 2767 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext ‚ü®a, b‚ü©
  simp [Sym2.map]

===== Proof 2768 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  funext x
  induction x <;> rfl

===== Proof 2769 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  aesop

===== Proof 2770 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  apply Sym2.ind
  intro x y
  rfl

===== Proof 2771 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext x
  simp only [Sym2.map, Function.comp_apply, Equiv.coe_trans]
  cases x <;> rfl

===== Proof 2772 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  apply Eq.symm
  funext x
  cases x <;> rfl

===== Proof 2773 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  apply Sym2.ind
  intro x
  apply Sym2.ind
  intro y
  rfl

===== Proof 2774 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  apply Sym2.ind (fun x y ‚Ü¶ ?_)
  simp [Sym2.map, Function.comp]

===== Proof 2775 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext x
  simp [Sym2.map, Function.comp]
  cases x <;> rfl

===== Proof 2776 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  funext x
  cases x <;> rfl

===== Proof 2777 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext x
  simp only [Function.comp_apply, Seq.seq, map_pair]
  rfl

===== Proof 2778 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext
  rfl

===== Proof 2779 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext x
  induction' x using Sym2.inductionOn
  rfl
  rfl

===== Proof 2780 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© h
  simp only [comp_apply, map_pair_eq, Function.comp_apply, eq_iff_eq_cancel_right]
  aesop

===== Proof 2781 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext
  simp

===== Proof 2782 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext x
  cases x <;> rfl

===== Proof 2783 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  funext x
  simp [Sym2.map]

===== Proof 2784 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} : Sym2.map (g ‚àò f) = Sym2.map g ‚àò Sym2.map f := by
  ext; simp [Sym2.map, Function.comp]

===== Proof 2785 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp only [toList, length, support, mem_map, Set.mem_toFinset, mem_support]
  by_cases h : p x = x <;> simp [h]
  <;> rcases (em (x ‚àà {y | p y ‚â† y})).symm with h' | h' <;> simp [h']
  <;> aesop

===== Proof 2786 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp [toList, support, -length_toList, -mem_support_iff, Bool.not_eq_true, ne_eq,
    Bool.not_eq_false, ne_eq, not_false_eq_true, not_true_eq_false]
  aesop

===== Proof 2787 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp only [toList_eq_nil_iff, length, Nat.succ_le_iff, Nat.zero_le, and_true]
  simp [‚Üê not_iff_not]

===== Proof 2788 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  ¬∑ rw [toList_eq_nil_iff] at h
    simp [support, mem_support, h] at h ‚ä¢
    aesop
  ¬∑ rw [toList_eq_nil_iff] at h
    simp [support, mem_support, h] at h ‚ä¢
    aesop

===== Proof 2789 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  next =>
    simp_all [toList, support]
    obtain ‚ü®a, b, c‚ü© := length_toList_pos_iff.mp (by linarith)
    rw [‚Üê a, ‚Üê b]
    simp [*]
  next =>
    simp_all [toList, support]
    obtain ‚ü®a, b, c‚ü© := length_toList_pos_iff.mp (by linarith)
    rw [‚Üê a, ‚Üê b]
    simp [*]

===== Proof 2790 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor
  intro hx
  rw [mem_support]
  contrapose! hx
  rw [toList_eq_nil_iff] at hx
  rw [hx]
  simp
  intro hx
  rw [mem_support] at hx
  rw [length_toList_pos_iff]
  exact hx

===== Proof 2791 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  next =>
    rw [‚Üê toList_get_zero h, ‚Üê toList_get_one (by linarith)]
    simp [support]
  next =>
    rw [toList_eq_nil_iff] at h
    rw [‚Üê length_pos_iff_exists_mem]
    simpa [support] using h

===== Proof 2792 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  rw [length_toList, Nat.succ_le_succ_iff, Nat.one_le_iff_ne_zero]
  exact toList_ne_zero

===== Proof 2793 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp [length, support, List.count, countp_eq_length_filter]
  omega

===== Proof 2794 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp [support]
  aesop

===== Proof 2795 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  next =>
    rw [toList, length] at h
    simpa [‚Üê (p.pow_apply_mem_support _).ne] using h
  next =>
    rw [toList, length]
    simpa [‚Üê (p.pow_apply_mem_support _).ne] using h

===== Proof 2796 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor
  intro h
  by_contra hx
  rw [mem_support, not_not] at hx
  rw [toList, length, hx] at h
  simp at h
  intro hx
  rw [toList, length]
  simpa using hx

===== Proof 2797 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h <;>
  simp_all [toList, support]
  <;> rcases (mem_darts_iff.mp (exists_of_length_pos (Nat.pos_of_ne_zero
    (by simpa using h)))).mp with ‚ü®‚ü®a, b‚ü©, h‚ÇÄ, h‚ÇÅ‚ü©
  <;> simp_all [support]
  <;> aesop

===== Proof 2798 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp [toList, support, List.count_pos, Nat.succ_le_iff]
  aesop

===== Proof 2799 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h <;> simp_all [Perm.support, toList, List.length]
  <;> aesop

===== Proof 2800 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by simp [toList]

===== Proof 2801 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  case mp =>
    simp only [length, toList, length_revzip, length_toList] at h
    exact support_iff_mem_lists.mp (List.length_pos_iff_mem.mp h)
  case mpr =>
    simp only [length, toList, length_revzip, length_toList]
    exact List.length_pos_iff_mem.mpr (support_iff_mem_lists.mpr h)

===== Proof 2802 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  ¬∑ rw [toList_eq_nil_iff] at h
    simp [h]
  ¬∑ rw [toList_eq_nil_iff]
    simp [h]

===== Proof 2803 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp_rw [mem_support, toList_eq_nil_iff, not_not]
  constructor <;> intro h <;> omega

===== Proof 2804 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  rw [mem_support, ‚Üê length_toList_eq_one_iff]
  cases h : toList p x <;> simp_all

===== Proof 2805 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  case mp =>
    rw [toList_eq_nil_iff] at h
    aesop
  case mpr =>
    rw [toList_eq_cons]
    aesop

===== Proof 2806 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  next =>
    simp_all only [toList, length, List.length]
    apply mem_support_iff.mp
    contrapose! h
    simp [h]
  next =>
    simp_all only [toList, length, List.length]
    apply le_of_not_lt
    intro h'
    simp [h'] at h

===== Proof 2807 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp_all only [toList.eq_nil_1, length, List.length, Nat.succ_le_succ_iff, Nat.one_ne_zero,
    not_false_eq_true]
  aesop

===== Proof 2808 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h <;> simp only [mem_support, ne_eq, one_def] at h ‚ä¢ <;>
  induction' h with y yih
  <;> simp_all [toList, mem_cons, mem_append]
  <;> aesop

===== Proof 2809 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;>
  intro h
  next =>
    rw [‚Üê toList_get] at h
    simpa [get_eq_get] using (h 0 (by simp)).2
  next =>
    rw [‚Üê toList_get]
    simpa [get_eq_get] using (h 0 (by simp)).2

===== Proof 2810 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp only [Nat.le_of_lt_succ, length_toList, Nat.succ_le_succ_iff, Nat.one_le_iff_ne_zero,
    ne_eq, Nat.zero_eq, add_eq_zero, and_false, false_and, false_or, or_false, one_ne_zero,
    not_false_eq_true]
  constructor <;> intro h <;> simp_all [Perm.mem_support, Perm.support]

===== Proof 2811 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor
  intro h
  by_contra hx
  rw [mem_support, not_not] at hx
  rw [toList, length_eq_zero, add_eq_zero_iff] at h
  simp_all
  intro hx
  rw [toList, length_toList, Nat.succ_le_iff]
  simpa using hx

===== Proof 2812 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  all_goals
    rw [toList_eq_nil_iff] at h
    rw [mem_support]
    aesop

===== Proof 2813 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp only [length_toList, mem_support, Ne, ‚Üê not_or]
  induction p generalizing x <;> simp_all [Nat.succ_le_iff]

===== Proof 2814 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor
  next =>
    intro h
    rw [toList_eq_nil_iff] at h
    apply mem_support_iff.2
    simp only [length_eq_zero, ne_eq, h, not_false_eq_true, true_or]
  next =>
    intro h
    rw [toList_eq_nil_iff]
    simp only [length_eq_zero, ne_eq, h, false_or]
    apply one_lt_two

===== Proof 2815 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  constructor <;> intro h
  <;> simp_all only [length, Nat.succ_eq_add_one, Nat.zero_eq, add_zero]
  <;> cases' toList p x with a l
  <;> simp_all [Perm.support]
  <;> cases' l with a l
  <;> simp_all [Perm.support]
  <;> cases' l with a l
  <;> simp_all [Perm.support]
  <;> simp_all [Perm.support]

===== Proof 2816 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by
  simp [length, toList, support]
  aesop

===== Proof 2817 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  rw [QuadraticForm.associated_eq_smul_basis, QuadraticForm.toQuadraticForm_smul,
    QuadraticForm.associated_eq_self_apply]
  simp [mul_comm]

===== Proof 2818 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  ext
  simp [QuadraticForm.associated_hom_apply, mul_comm]

===== Proof 2819 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated]

===== Proof 2820 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated_neg]

===== Proof 2821 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated]

===== Proof 2822 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.toQuadraticForm_associated]

===== Proof 2823 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  ext; simp [QuadraticForm.associated_apply, QuadraticForm.map_zero, sub_eq_add_neg]

===== Proof 2824 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated]

===== Proof 2825 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated_neg]

===== Proof 2826 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated_neg]

===== Proof 2827 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated_neg]

===== Proof 2828 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated]

===== Proof 2829 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated]

===== Proof 2830 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  ext
  simp [QuadraticForm.associated_neg]

===== Proof 2831 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  cases Q
  rfl

===== Proof 2832 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated_neg]

===== Proof 2833 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated_neg]

===== Proof 2834 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated_neg]

===== Proof 2835 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated]

===== Proof 2836 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.toQuadraticForm_associated]

===== Proof 2837 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated, sub_eq_add_neg]

===== Proof 2838 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated]

===== Proof 2839 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated, QuadraticForm.toQuadraticForm_sub]

===== Proof 2840 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  ext
  simp [QuadraticForm.associated_neg]

===== Proof 2841 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  rw [QuadraticForm.associated_neg]
  rw [sub_eq_add_neg]
  rw [QuadraticForm.toQuadraticForm_neg]
  rw [neg_neg]

===== Proof 2842 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated, QuadraticForm.toQuadraticForm_apply]

===== Proof 2843 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated_neg]

===== Proof 2844 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.toQuadraticForm_associated]

===== Proof 2845 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  ext
  simp [associated_eq_self_apply, mul_neg, sub_eq_add_neg]

===== Proof 2846 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated_neg]

===== Proof 2847 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.toQuadraticForm_associated]

===== Proof 2848 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by
  simp [QuadraticForm.associated, sub_eq_add_neg]

===== Proof 2849 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, hf.map_nhds, map_map, nhdsWithin, image_inter]

===== Proof 2850 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [‚Üê hf.toInducing.nhdsWithin_eq, map_nhds_eq hf.inj]

===== Proof 2851 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [‚Üê hf.toInducing.map_nhdsWithin_eq s x]
  simp [image_eq_range]

===== Proof 2852 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, Filter.map_inf, hf.map_nhds_eq]
  simp only [Filter.map_principal, Set.image_inter, Set.image_preimage_eq_inter_range]
  apply congr_arg‚ÇÇ _ rfl
  ext U
  constructor
  ¬∑ rintro ‚ü®U, ‚ü®V, hV, rfl‚ü©, rfl‚ü©
    exact ‚ü®V, hV, rfl‚ü©
  ¬∑ rintro ‚ü®U, hU, rfl‚ü©
    exact ‚ü®_, ‚ü®U, hU, rfl‚ü©, rfl‚ü©

===== Proof 2853 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê hf.toInducing.nhds_eq_comap, image_insert_eq]
  simp only [map_insert, range_id', sup_eq_bot_iff, map_eq_bot_iff, nhds_eq_bot,
    insert_eq_of_mem, mem_preimage, mem_singleton_iff, forall_eq, forall_eq', true_and]
  rfl

===== Proof 2854 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, hf.map_nhds, map_inf_principal, hf.image_eq, ‚Üê nhdsWithin_eq_comap_inf,
    image_eq_range]

===== Proof 2855 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, Filter.map_inf, hf.map_nhds, inf_assoc, inf_principal, ‚Üê inf_assoc,
    hf.toInducing.nhds_eq_comap, comap_inf, comap_principal]

===== Proof 2856 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [hf.map_nhdsWithin_eq, image_eq_range]

===== Proof 2857 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [‚Üê hf.toInducing.nhdsWithin_eq, map_nhds_induced]

===== Proof 2858 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [Embedding.map_nhds_eq]
  apply le_antisymm
  ¬∑ filter_upwards
    simp (config := { contextual := true }) [hf.inj_on]
  ¬∑ rw [le_map_nhdsWithin_iff]
    intro t ht
    simpa [hf.inj_on] using hf.continuous.continuousWithinAt (ht.preimage hf.continuous)

===== Proof 2859 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê hf.map_nhds, map_map, ‚Üê nhdsWithin, ‚Üê map_map,
    hf.injective.map_nhdsWithin_eq, map_map]

===== Proof 2860 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, Filter.map_inf hf.inj, Embedding.map_nhds hf, inf_comm, map_principal,
    nhdsWithin, inf_comm]

===== Proof 2861 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê hf.map_nhds, filter_map_eq_map, map_map, Embedding.map_nhdsWithin_eq,
    ‚Üê nhdsWithin_eq_map_subtype_coe hf.inj, inf_assoc, inf_of_le_left, ‚Üê nhdsWithin_eq_map_subtype_coe
      hf.inj]
  exact principal_mono.mpr fun _y hy => ‚ü®x, hy, rfl‚ü©
  <;> rfl

===== Proof 2862 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [‚Üê hf.toInducing.map_nhdsWithin_eq]
  rw [‚Üê image_eq_range, ‚Üê image_eq_range]

===== Proof 2863 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [‚Üê hf.toInducing.nhdsWithin_eq]; rfl

===== Proof 2864 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, hf.map_nhds_eq]
  simp only [Filter.map_neBot_iff, inf_neBot_iff, mem_image, mem_preimage]
  intro t ht
  rcases mem_nhdsWithin.mp ht with ‚ü®u, hu, v, hv, h‚ü©
  refine ‚ü®f ‚Åª¬π' u, ?_, v, hv, ?_‚ü©
  ¬∑ rw [‚Üê hf.inj.preimage_image_eq u Set.univ_subset_iff.mp]
    exact hu
  rwa [inter_comm, hf.inj.preimage_image_eq u Set.univ_subset_iff.mp]

===== Proof 2865 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [‚Üê inf_eq_left, ‚Üê inf_eq_left]
  simp_rw [hf.map_nhds_eq]
  rw [‚Üê Filter.push_pull', Filter.push_pull']
  congr
  exact ext_iff.2 hf.injective.preimage_image

===== Proof 2866 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê Filter.map_inf_eq_inf_map, hf.map_nhds_eq]
  simp only [Filter.map_inf, Filter.map_principal, inf_principal]
  rfl

===== Proof 2867 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, Filter.map_inf hf.inj, hf.toInducing.nhds_eq_comap, comap_principal,
    image_principal, ‚Üê nhdsWithin_eq_comap_inf_principal]

===== Proof 2868 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [hf.toInducing.map_nhdsWithin_eq]
  simp [hf.inj.injOn]

===== Proof 2869 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [‚Üê inf_eq_left, ‚Üê inf_eq_left]
  simp only [Embedding.map_nhds_eq, inf_assoc, Embedding.map_nhds_set_eq, inf_left_comm,
    embedding_to_subtype_coe.map_nhdsWithin_eq, inf_comm, embedding_to_subtype_coe.map_nhds_set_eq]
  exact Quotient.inductionOn' x fun x => by
    rw [‚Üê Subtype.preimage_coe_eq_preimage_coe_iff]
    congr
    simp [Set.preimage]

===== Proof 2870 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê hf.map_nhds_eq, map_inf, inf_eq_inter, ‚Üê nhdsWithin, ‚Üê nhdsWithin]

===== Proof 2871 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  have := hf.map_nhds_eq s x
  rw [‚Üê this]
  simp [Filter.map, Filter.comap, Set.mem_def]

===== Proof 2872 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê map_nhds_subtype_val, ‚Üê map_nhds_subtype_val, hf.map_nhds_eq]
  simp only [Set.preimage_image_eq, Subtype.coe_injective.injOn.image_preimage, Subtype.coe_mk]

===== Proof 2873 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, map_subtype_coe_nhdsWithin hf.inj, ‚Üê Subtype.coe_mk x (mem_of_mem_nhdsWithin (mem_nhdsWithin_of_mem_nhds (ùìù x))),
    ‚Üê Subtype.coe_preimage_self s, ‚Üê map_subtype_coe_nhdsWithin hf.inj]
  simp only [Set.image_preimage_eq_inter_range, Set.inter_eq_self_of_subset_left,
    ‚Üê Set.preimage_eq_preimage hf.inj, Set.preimage_const]

===== Proof 2874 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, map_inf hf.inj, hf.toInducing.nhds_eq_comap]
  simp only [comap_principal, image_principal, comap_comap]
  rfl

===== Proof 2875 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê hf.map_nhds_eq, map_inf, hf.map_nhds_eq]
  ext U
  constructor <;> rintro ‚ü®V, h, h‚ÇÇ‚ü© <;> use f ‚Åª¬π' V <;> simp_all

===== Proof 2876 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê Filter.map_inf hf.inj, Filter.map_comap_setCoe_val]
  simp only [Set.image_preimage_eq_inter_range, Set.inter_eq_self_of_subset_left,
    Set.mem_preimage, Set.mem_range, Set.image_subset_iff, Set.mem_preimage,
    Set.mem_singleton_iff, Set.image_singleton]
  apply Filter.map_map

===== Proof 2877 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê hf.map_nhds, Filter.map_inf, Embedding.map_nhds, inf_assoc]
  simp only [Filter.map_principal, inf_principal, image_inter, image_preimage_eq_inter_range,
    inf_eq_right.mpr (principal_mono.mpr (subset_preimage_image _ _))]

===== Proof 2878 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, ‚Üê hf.map_nhds, Filter.map_inf, hf.map_nhdsWithin, inf_comm, inf_right_comm]

===== Proof 2879 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, Filter.map_inf hf.inj, Embedding.map_nhds hf, inf_principal,
    inf_assoc, inf_congr_right (principal_mono.2 Set.image_subset_range), inf_principal]

===== Proof 2880 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : Œ± ‚Üí Œ≤} (hf : Embedding f) (s : Set Œ±) (x : Œ±) :
    map f (ùìù[s] x) = ùìù[f '' s] f x := by
  rw [nhdsWithin, map_inf hf.continuous.continuousAt, Embedding.map_nhds hf, inf_comm,
    ‚Üê inf_assoc, inf_principal, ‚Üê comap_principal, ‚Üê map_inf hf.continuous.continuousAt,
    ‚Üê inf_assoc, inf_idem]

===== Proof 2881 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [cos_angle, norm_sub_eq_norm_sub, div_eq_inv_mul]
  rw [inner_sub_right, h, sub_zero]
  rw [norm_sub_eq_norm_sub]
  ring

===== Proof 2882 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [Real.cos_angle]
  rw [inner_sub_right, h]
  simp

===== Proof 2883 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos]
  <;> simp_all [norm_nonneg, norm_le_zero_iff]
  <;> linarith

===== Proof 2884 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos_div]
  all_goals
    nlinarith [norm_sq_nonneg x, norm_sq_nonneg y, h]

===== Proof 2885 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos] <;>
    { norm_num
      try linarith
      rw [norm_sub_sq]
      nlinarith [h] }

===== Proof 2886 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [Real.cos_angle, norm_sub_of_inner_eq_zero h]
  field_simp [Real.sqrt_ne_zero'.mpr (norm_sub_ne_zero_of_inner_eq_zero h)]

===== Proof 2887 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos]
  <;> simp_all [norm_nonneg, norm_sq_eq_zero]
  <;> linarith

===== Proof 2888 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos_div (norm_nonneg x) (norm_nonneg (x - y))]
  rw [inner_sub_left, h, sub_zero, inner_self_eq_norm_sq]
  field_simp [norm_nonneg]

===== Proof 2889 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos_div (norm_nonneg x) (norm_nonneg (x - y))]
  nlinarith [norm_sq_eq_zero.2 h]

===== Proof 2890 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [cos_angle, norm_sub_eq_norm_sub_iff_angle_eq_pi_div_two.2 h, Real.cos_arccos]
  <;> [skip; linarith [norm_nonneg x, norm_nonneg (x - y)]]

===== Proof 2891 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [Real.cos_arccos, norm_div_norm_eq_norm_sub]
  all_goals nlinarith [inner_self_nonneg x,
    inner_self_nonneg (x - y),
    h]

===== Proof 2892 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, cos_arccos_div]
  all_goals
    nlinarith [norm_nonneg x, norm_nonneg y, norm_sub_nonneg x y]

===== Proof 2893 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, sub_eq_add_neg]
  rw [inner_add_right, inner_neg_right] at h
  rw [add_eq_zero_iff_eq_neg] at h
  rw [h, cos_angle_add_of_inner_eq_zero]
  simp

===== Proof 2894 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos_div]
  <;> simp_all
  <;> linarith

===== Proof 2895 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos_div (norm_nonneg _) (norm_nonneg _)]
  rw [inner_sub_right, h, sub_zero, norm_sub_sq_eq_norm_sq_add_norm_sq_real, add_comm]
  field_simp [norm_sq_eq_zero, (norm_nonneg _).lt_one_iff, norm_eq_zero]

===== Proof 2896 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos]
  <;> try norm_num
  <;> try apply div_nonneg
  <;> norm_num
  <;> try apply le_of_eq
  <;> symm
  <;> rw [‚Üê sub_eq_zero]
  <;> try field_simp
  <;> try linarith

===== Proof 2897 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos_div]
  rw [norm_sub_sq']
  simp [h]
  field_simp
  ring
  nlinarith

===== Proof 2898 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [cos_angle, norm_sub_eq_norm_add_iff_angle_eq_zero.2 h, div_eq_inv_mul, mul_comm]

===== Proof 2899 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle_sub_eq_arccos_of_inner_eq_zero h]
  simp [div_eq_mul_inv, mul_assoc]

===== Proof 2900 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [cos_angle, inner_sub_right, h, sub_zero]
  rw [div_eq_inv_mul]
  rw [mul_comm]
  rw [‚Üê mul_assoc]
  ring_nf
  rw [norm_sub_rev]
  field_simp

===== Proof 2901 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [cos_angle, angle, sub_eq_add_neg]
  rw [inner_add_right, inner_neg_right] at h
  rw [norm_sub_eq_norm_add_of_inner_eq_zero]
  field_simp [h]

===== Proof 2902 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [Real.cos_angle, norm_sub_rev]
  rw [inner_eq_zero_iff_angle_eq_pi_div_two] at h
  rw [h]
  rw [Real.sin_pi_div_two]
  rw [div_self]
  exact norm_ne_zero_of_mem_nonzero_singleton _

===== Proof 2903 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [cos_angle, norm_sub_eq_norm_sub_iff_angle_eq_zero.2 h, div_eq_inv_mul]
  field_simp [norm_sq_eq_zero, h]

===== Proof 2904 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos]
  <;> simp_all [norm_nonneg, norm_le_zero_iff]
  <;> linarith

===== Proof 2905 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, cos_arccos_div]
  <;> simp_all
  <;> linarith

===== Proof 2906 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos_div]
  exacts [by simp [h], by simp [h]]

===== Proof 2907 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [Real.cos_angle]
  rw [inner_sub_left] at h
  rw [sub_eq_zero] at h
  rw [h]
  rw [norm_sub_comm]
  rw [div_eq_inv_mul]

===== Proof 2908 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos_div]
  exacts [by linarith
    , by linarith]

===== Proof 2909 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos_div (norm_sub_ne_zero_of_inner_eq_zero h)
    (norm_nonneg _)]

===== Proof 2910 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [Real.cos_angle, norm_sub_eq_norm_sub_iff_angle_eq_zero.2 h, div_eq_inv_mul]
  field_simp [h]

===== Proof 2911 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  rw [angle, Real.cos_arccos, norm_sub_eq_norm_add _ _ h,
    norm_eq_sqrt_inner, norm_eq_sqrt_inner]
  all_goals positivity

===== Proof 2912 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ‚ü™x, y‚ü´ = 0) :
    Real.cos (angle x (x - y)) = ‚Äñx‚Äñ / ‚Äñx - y‚Äñ := by
  by_cases hx : x = 0
  case pos => simp [hx]
  rw [cos_angle, norm_sub_mul_norm_sub, div_eq_inv_mul]
  field_simp [hx, sub_eq_zero]

===== Proof 2913 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U_eq_eval‚ÇÇ_X_add_one_pow 2]
  simp [Nat.succ_eq_add_one, pow_add, mul_assoc]
  ring

===== Proof 2914 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp [U_def, Fin.sum_univ_succ, Fin.sum_univ_zero, Fin.succ_zero_eq_one]
  ring

===== Proof 2915 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp [U_two]

===== Proof 2916 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U]
  simp [Nat.factorial]
  ring

===== Proof 2917 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U_eq_eval]
  simp only [Fin.sum_univ_succ, Fin.sum_univ_two]
  simp [eval_sub, eval_pow]

===== Proof 2918 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp [U_two]
  ring

===== Proof 2919 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U_eq_X_pow_sub_C]
  norm_num
  rfl

===== Proof 2920 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp [U_two, X_pow_mul_assoc]
  ring

===== Proof 2921 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp only [U_eq_X_pow_sub_C, Nat.cast_ofNat, Nat.cast_two]
  ring

===== Proof 2922 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U_eq_X_pow_sub_C_pow]
  norm_num
  ring_nf
  <;> rfl

===== Proof 2923 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U]
  simp only [Nat.cast_ofNat, Fin.val_zero, Fin.val_one]
  simp [Nat.cast_ofNat, Fin.val_zero, Fin.val_one]
  ring

===== Proof 2924 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp only [U_eq_X_pow_sub_one_pow, Nat.cast_ofNat, Nat.cast_two, pow_two, mul_sub,
    mul_one, sub_sub, add, one_mul, pow_one]
  ring

===== Proof 2925 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp only [U_eq_X_pow_sub_one_pow, Nat.cast_ofNat, Nat.cast_one, sub_self,
    pow_one, pow_two]
  ring

===== Proof 2926 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U]
  simp [Nat.factorial]
  ring

===== Proof 2927 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  induction R with
  | zero => simp_all [Polynomial.X]
  | succ R' ih =>
    simp_all [Polynomial.X, Nat.succ_eq_add_one]
    ring_nf
    omega

===== Proof 2928 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  unfold U
  simp only [Fin.val_two, Nat.succ_eq_add_one, add_assoc]
  ring

===== Proof 2929 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U_two]
  ring

===== Proof 2930 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  apply Eq.symm
  rw [U]
  simp [Nat.zero_eq]
  ring

===== Proof 2931 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp only [U_eq_X_pow_sub_C, Nat.cast_ofNat, Nat.cast_one, Nat.cast_zero, zero_sub,
    sub_zero, pow_one, one_mul]
  ring

===== Proof 2932 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U]
  simp
  ring

===== Proof 2933 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp [U, Fin.sum_univ_succ]
  ring

===== Proof 2934 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U_eq_X_pow_sub_C_pow]
  simp
  ring

===== Proof 2935 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U]
  simp only [Fin.val_zero, Fin.val_one, pow_two]
  ring

===== Proof 2936 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U_eq_X_pow_sub_C]
  simp only [Nat.cast_ofNat, mul_one]
  ring_nf

===== Proof 2937 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp only [U_eq_eval_chebyshev_T, chebyshev_T_two, eval_sub, eval_one]
  ring

===== Proof 2938 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp [U]
  ring

===== Proof 2939 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  rw [U_eq_X_pow_sub_one_pow]
  simp only [Nat.cast_ofNat, pow_one, pow_two, mul_one, mul_zero, sub_zero]
  ring

===== Proof 2940 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  hd : R = ‚Ñ§ := by rfl
  rw [hd]
  unfold U
  norm_num
  ring

===== Proof 2941 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp only [U_eq_X_pow_sub_C, Nat.cast_ofNat, Nat.cast_one, sub_zero]
  ring

===== Proof 2942 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  simp [U_two_eq, sub_eq_neg_add]

===== Proof 2943 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
  logical

===== Proof 2944 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by unfold U; norm_num

===== Proof 2945 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [eq_top_iff]
  intro y _
  by_contra! h
  apply hx
  rw [LinearMap.IsOrtho, LinearMap.isOrtho_def]
  intro z hz
  simp only [Submodule.mem_span_singleton] at hz
  rcases hz with ‚ü®a, rfl‚ü©
  have hy : y ‚àà (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) := by
    simp [h]
  have hy' : y ‚àà Submodule.orthogonalBilin (N := K ‚àô x) (B := B) := by
    exact hy.resolve_left h
  rw [Submodule.mem_orthogonalBilin_iff] at hy'
  specialize hy' x (by simp)
  simpa [mul_comm] using hy'

===== Proof 2946 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [orthogonalBilin_eq_Inter]
  simp
  simp_rw [Submodule.mem_iInf, Submodule.mem_span_singleton]
  constructor
  intro y
  by_cases hx' : B.IsOrtho x y
  ¬∑ obtain ‚ü®r, rfl‚ü© := hx'
    exact ‚ü®r, trivial, 0, by simp‚ü©
  ¬∑ exact ‚ü®0, by simp, 0, by simp‚ü©
  rintro ‚ü®‚ü®r, rfl‚ü©, ‚ü®s, hs‚ü©‚ü©
  rw [‚Üê mul_one x] at hs
  obtain ‚ü®a, ha‚ü© := hs
  obtain ‚ü®b, rfl‚ü© := ha
  obtain rfl | hx'' := eq_or_ne x 0
  ¬∑ simp
  ¬∑ rw [‚Üê sub_eq_zero]
    apply B.IsOrtho.linear_combination s a
    ¬∑ simp [mul_assoc]
    ¬∑ simp [mul_assoc]
    exact hx

===== Proof 2947 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [span_singleton_sup_orthogonal_eq_top']
  refine' ‚ü®x, Submodule.mem_top, 0, Submodule.mem_bot.2 rfl, _‚ü©
  ext w
  rw [Submodule.mem_sup]
  constructor
  next =>
    rintro ‚ü®z, hz, hw‚ü©
    rw [‚Üê sub_eq_zero, ‚Üê B.map_sub] at hw
    rw [Submodule.mem_bot]
    refine' eq_of_sub_eq_zero _
    rw [LinearMap.map_eq_zero_iff] at hw
    exact hw hz
  next =>
    intro hw
    use x, Submodule.mem_top
    use 0
    rw [Submodule.mem_bot]
    rw [‚Üê sub_eq_zero, ‚Üê B.map_sub]
    exact hw

===== Proof 2948 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [submodule_eq_top_of_disjoint, LinearMap.disjoint_def]
  rw [Submodule.eq_bot_iff]
  intro y hy
  simp only [Submodule.mem_orthogonalBilin, submodule_eq_bot_iff, LinearMap.mem_ker,
    submodule_eq_bot_iff, Submodule.mem_orthogonalBilin, submodule_eq_bot_iff, LinearMap.mem_ker,
    submodule_eq_bot_iff] at *
  intro hy'
  exact hx (by simpa [hx] using hy')

===== Proof 2949 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [eq_top_iff]
  intro v _
  by_cases h : B.IsOrtho x v
  all_goals
    rw [mem_sup]
    refine' ‚ü®v, Submodule.mem_span_singleton_self v, 0, _, add_zero v‚ü©
  exact (Submodule.mem_orthogonalBilin_iff _ _ _).mpr fun w h => hx (h w (Submodule.mem_span_singleton_self w))

===== Proof 2950 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [eq_top_iff]
  intro y
  rw [Submodule.mem_iSup]
  use ‚ü®B y x, ‚ü®y, rfl‚ü©‚ü©
  rw [Submodule.mem_orthogonalBilin_iff]
  intro z hz
  rw [Submodule.mem_span_singleton] at hz
  rcases hz with ‚ü®a, rfl‚ü©
  apply LinearMap.is_refl.linear_dependent
  rw [hx] at *
  simp_all

===== Proof 2951 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [eq_top_iff]
  intro y _
  have h : ‚àÉ z : V, B x z = 1 := by
    have h' : (B x).ker ‚â† ‚ä§ := by
      intro h_top
      apply hx
      rw [LinearMap.IsOrtho, Submodule.mem_bot]
      have h_mem : x ‚àà (B x).ker := by
        rw [h_top]
        trivial
      exact LinearMap.mem_ker.mp h_mem
    have h‚ÇÅ : (B x).ker ‚â§ ‚ä• := by
      rw [‚Üê Submodule.orthogonalBilin_eq_bot_of_ker_eq_top h']
      exact Submodule.le_orthogonalBilin_of_le_left _ (by rfl)
    have h‚ÇÇ : (‚ä• : Submodule K V) ‚â§ (B x).ker := by
      rintro - h_mem
      rw [Submodule.mem_bot] at h_mem
      rw [h_mem]
      exact LinearMap.mem_ker.mpr rfl
    exact le_antisymm h‚ÇÅ h‚ÇÇ
  rcases h with ‚ü®z, hz‚ü©
  have h_mem : y ‚àà (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) := by
    rw [Submodule.mem_sup]
    use x
    use 0
    constructor
    ¬∑ exact Submodule.mem_span_singleton_self x
    ¬∑ rw [Submodule.mem_orthogonalBilin_iff]
      intro y
      rw [Submodule.mem_span_singleton] at y
      rcases y with ‚ü®a, rfl‚ü©
      simp only [LinearMap.zero_apply, LinearMap.smul_apply, hz, mul_one, zero_mul]
  exact h_mem

===== Proof 2952 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [eq_top_iff]
  rw [Submodule.orthogonalBilin, Submodule.mem_orthogonalBilin]
  intro y _
  rw [Submodule.mem_sup]
  use x
  constructor
  simp
  use -B x y ‚Ä¢ x
  constructor
  simp
  rw [map_smul‚ÇÇ]
  simp [hx]

===== Proof 2953 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [‚Üê Finset.inf_eq_iInf, ‚Üê Finset.sup_eq_iSup]
  refine'
    Eq.trans
      (_ :
        (Finset.image (fun y => y ‚Ä¢ x) (Finset.image (fun z => z ‚Ä¢ x) Finset.univ)) ‚äî
            Submodule.orthogonalBilin (N := K ‚àô x) (B := B) =
          ‚ä§)
      (Finset.image_univ.symm ‚ñ∏ Finset.image_univ.symm ‚ñ∏ Eq.symm <| Submodule.iInf_sup_eq_top_of_iInf_orthogonal hx)
  simp_rw [Finset.image_image]
  rfl

===== Proof 2954 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [eq_top_iff]
  intro y _
  rw [Submodule.mem_sup]
  use 0, Submodule.zero_mem _, y, Submodule.mem_orthogonalBilin_iff.mpr (fun ‚Ñì => by
    rw [Submodule.mem_span_singleton] at ‚Ñì
    rcases ‚Ñì with ‚ü®a, rfl‚ü©
    rw [LinearMap.map_smul, smul_eq_mul, mul_zero])
  simp

===== Proof 2955 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [orthogonalBilin]
  ext y
  simp only [Submodule.mem_sup, Submodule.mem_orthogonalBilin, Submodule.mem_top,
    exists_prop, exists_imp]
  constructor
  <;> intro h
  <;> obtain ‚ü®z, hz, w, hw, rfl‚ü© := h
  <;> obtain ‚ü®a, rfl‚ü© := Submodule.mem_span_singleton.mp hz
  <;> obtain ‚ü®b, rfl‚ü© := Submodule.mem_span_singleton.mp hw
  <;> simp [hx]

===== Proof 2956 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  apply Eq.symm
  rw [‚Üê Submodule.orthogonal_orthogonal_of_ne_zero (K := K) (v := x) (hnz := hx)]
  rw [Submodule.orthogonal_eq_top]
  simp

===== Proof 2957 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [orthogonalBilin_eq_orthogonal, ‚Üê Submodule.mem_orthogonal_singleton, @Eq_top_iff _ _ (‚ä§ : Submodule K V)]
  exact fun b => by
    rw [Submodule.mem_sup]
    have hx := hx
    have h : 0 = B x x := by
      rw [LinearMap.zero_apply,
        LinearMap.zero_apply,
        eq_iff_true_of_subsingleton]
    let h' : 0 = B x x := by rw [LinearMap.zero_apply, LinearMap.zero_apply, eq_iff_true_of_subsingleton]
    rw [orthogonal_eq_inter, Submodule.mem_inter]
    exact
      ‚ü®by
        rw [Submodule.mem_span_singleton]
        exact ‚ü®b, rfl‚ü©, by
        intro y hy
        rw [Submodule.mem_span_singleton] at hy
        obtain ‚ü®a, rfl‚ü© := hy
        rw [LinearMap.zero_apply, LinearMap.zero_apply, eq_iff_true_of_subsingleton]
        exact h'
        ‚ü©

===== Proof 2958 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [eq_top_iff]
  rw [‚Üê SetLike.le_def]
  intro y _
  rw [mem_sup]
  have h : ‚àÉ z : K, z ‚Ä¢ x ‚àà ({y} : Set V) := by
    use (B x y) / (B x x)
    rw [mem_singleton_iff]
    field_simp [hx]
    rw [‚Üê LinearMap.BilinForm.leibniz_rule]
    ring_nf
  obtain ‚ü®z, hz‚ü© := h
  refine ‚ü®z ‚Ä¢ x, ?_, y - z ‚Ä¢ x, ?_, ?_‚ü©
  ¬∑ rw [mem_span_singleton]
    exact ‚ü®z, rfl‚ü©
  ¬∑ rw [mem_orthogonalBilin]
    intro u hu
    rw [mem_span_singleton] at hu
    obtain ‚ü®a, rfl‚ü© := hu
    simp only [LinearMap.BilinForm.isOrtho_def, LinearMap.map_smul, smul_eq_mul, mul_eq_zero]
    right
    rw [‚Üê hz]
    simp
  ¬∑ rw [sub_add_cancel]

===== Proof 2959 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  have : (K ‚àô x) ‚äì Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä• := by
    rw [inf_orthogonalBilin]
    exact Submodule.span_singleton_eq_bot.2 (B.isOrtho_def ‚ñ∏ hx)
  rw [orthogonalBilin_eq_top_iff]
  exact this ‚ñ∏ le_sup_left

===== Proof 2960 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [Submodule.orthogonalBilin]
  rw [LinearEquiv.eq_top_iff]
  intro y
  rw [Submodule.mem_sup]
  use 0, Submodule.zero_mem _, y, Submodule.mem_span_singleton_self y
  simp [hx]

===== Proof 2961 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [Submodule.eq_top_iff']
  intro y
  by_cases hx' : B.IsOrtho x y
  ¬∑ exact Submodule.mem_sup.mpr ‚ü®0, Submodule.zero_mem _, y, Submodule.mem_bot.mpr rfl, by simp [hx']‚ü©
  rw [Submodule.mem_orthogonalBilin_iff] at hx'
  intro hy
  exact Submodule.mem_sup.mpr ‚ü®y, Submodule.mem_bot.mpr rfl, 0, Submodule.zero_mem _, by simp [hx']‚ü©

===== Proof 2962 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  apply Eq.symm
  rw [eq_top_iff]
  intro y _
  rw [Submodule.mem_sup]
  use 0, Submodule.zero_mem _, y, Submodule.mem_span_singleton_self y
  simp [hx]

===== Proof 2963 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  have h : (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
    rw [eq_top_iff]
    intro y
    rw [Submodule.mem_sup]
    use 0
    use y
    constructor
    ¬∑ simp
    ¬∑ rw [Submodule.mem_orthogonalBilin]
      intro h'
      apply hx
      simpa using h'
  exact h

===== Proof 2964 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [Submodule.eq_top_iff']
  intro y
  rw [Submodule.mem_sup]
  simp_rw [Submodule.mem_orthogonalBilin]
  use 0, Submodule.zero_mem _, y, Submodule.mem_span_singleton_self _, zero_add
  intro z hz
  rw [Submodule.mem_span_singleton] at hz
  obtain ‚ü®c, rfl‚ü© := hz
  simp_all

===== Proof 2965 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [orthogonalBilin_eq_orthogonal]
  clear hx
  rw [orthogonal_span]
  ext x
  constructor
  all_goals
    intro h
    simp_all
    aesop

===== Proof 2966 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [Submodule.eq_top_iff']
  intro x
  rw [Submodule.mem_sup]
  use 0
  use x
  constructor
  exact Submodule.zero_mem _
  rw [Submodule.mem_orthogonalBilin]
  intro y hy
  rw [Submodule.mem_span_singleton] at hy
  rcases hy with ‚ü®a, rfl‚ü©
  simp [hx]

===== Proof 2967 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  have : (K ‚àô x) ‚äî (K ‚àô x).orthogonalBilin B = ‚ä§ := by
    rw [‚Üê orthogonal_orthogonal_eq_closure]
    rw [orthogonal_eq_top_iff K (K ‚àô x) B]
    intro y hy
    rw [Submodule.mem_span] at hy
    apply hy
    exact fun _ => zero_mem _
  exact this

===== Proof 2968 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [subsingleton_or_nontrivial] at hx
  cases' hx with hx hx
  all_goals
    haveI := Classical.decEq V
    apply Eq.symm
    apply eq_top_iff
    intro v _
    rw [Submodule.mem_sup]
    use 0, Submodule.zero_mem _, v, Submodule.mem_orthogonalBilin_iff.mpr fun u hu => ?_
    rw [Submodule.mem_span_singleton] at hu
    obtain ‚ü®a, rfl‚ü© := hu
    rw [map_smul, hx]
    simp

===== Proof 2969 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [Sup.sup_eq_right]
  simpa using Submodule.span_singleton_inf_orthogonalBilin_eq_bot hx

===== Proof 2970 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  simp only [isOrtho_def, Submodule.orthogonalBilin, Submodule.sup_span, Submodule.mem_orthogonalBilin,
    Submodule.mem_span_singleton]
  rw [Submodule.eq_top_iff']
  intro v
  use 0
  use 0
  simp [hx]

===== Proof 2971 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [‚Üê Submodule.completeLatticeIsoBot.symm.span_eq]
  simp only [IsOrtho, Submodule.sup_orthogonalBilin_self, ‚Üê Submodule.orthogonalBilin_eq_orthogonal,
    Submodule.map_span, LinearMap.map_zero]
  cases hx
  nlinarith

===== Proof 2972 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [Submodule.eq_top_iff']
  intro y _
  rw [Submodule.mem_sup]
  use 0
  use y
  constructor
  exact Submodule.zero_mem _
  rw [Submodule.mem_orthogonalBilin]
  intro z hz
  rw [Submodule.mem_span_singleton] at hz
  rcases hz with ‚ü®a, rfl‚ü©
  simp_all

===== Proof 2973 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [Submodule.eq_top_iff']
  intro x
  rw [Submodule.mem_sup]
  use x
  use 0
  simp [Submodule.mem_orthogonalBilin]

===== Proof 2974 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  suffices ¬¨‚àÉ y, ¬¨(y = 0 ‚àß ‚àÄ z, B x z = 0) by
    simpa only [Submodule.span_singleton_eq_bot, Submodule.mem_orthogonalBilin,
      Submodule.mem_sup, Submodule.mem_bot] using Classical.not_not
  rintro ‚ü®y, hy‚ü©
  aesop

===== Proof 2975 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [Submodule.orthogonalBilin, orthogonal}_{-,-]
  rw [Submodule.sup_orthogonal_of_ne_zero (Submodule.mem_span_singleton_self x)]
  simp_all

===== Proof 2976 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K} {x : V} (hx : ¬¨B.IsOrtho x x) :
    (K ‚àô x) ‚äî Submodule.orthogonalBilin (N := K ‚àô x) (B := B) = ‚ä§ := by
  rw [Submodule.orthogonalBilin]
  simp_rw [Submodule.mem_orthogonal_iff B]
  rw [eq_top_iff]
  intro y _
  rw [Submodule.mem_sup]
  use x
  constructor
  simp
  rw [Submodule.mem_orthogonal_iff B]
  intro hx'
  apply hx
  specialize hx' x
  simp_all

===== Proof 2977 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  induction' n with n hn
  ¬∑ contradiction
  ¬∑ cases n
    ¬∑ simp
    ¬∑ rw [pow_succ, IsSMulRegular.mul_iff]
      simp [hn]

===== Proof 2978 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  constructor <;> intro h <;>
    simpa using h.of_pow n0

===== Proof 2979 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  cases n with
  | zero => cases n0
  | succ k =>
    rw [‚Üê pow_succ]
    exact iff_of_eq (congr_arg _ (pow_succ _ _))

===== Proof 2980 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  rw [‚Üê smul_eq_mul_one_pow n, IsSMulRegular.smul_iff n0]

===== Proof 2981 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  constructor <;> intro h <;>
  apply h.of_smul m <;> simp [pow_add, pow_one, mul_one, mul_assoc]

===== Proof 2982 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  revert M
  refine' fun {M} ‚Ü¶ ‚ü®fun hM ‚Ü¶ ((isSMulRegular_pow _ n0).mp hM), fun hM ‚Ü¶ _‚ü©
  induction' n with n ihn
  ¬∑ contradiction
  ¬∑ cases n
    ¬∑ exact hM
    ¬∑ exact (isSMulRegular_pow _ (Nat.succ_pos _)).mpr ihn

===== Proof 2983 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  apply Iff.intro
  ¬∑ intro h
    apply h.of_smul a
    simp [pow_succ, mul_smul]
  ¬∑ intro h
    apply h.pow n0

===== Proof 2984 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine ‚ü®fun hmn ‚Ü¶ ?_, fun hma x y hab ‚Ü¶ ?_‚ü©
  ¬∑ rw [‚Üê smul_one a, ‚Üê one_pow n]
    exact hmn.of_smul (one_pow n)
  have h := hma.iterate n0
  simp_all only [iterate_smul, hab, smul_one, one_smul]

===== Proof 2985 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  cases' n with n n
  exfalso
  exact Nat.lt_asymm n0 n0
  induction' n with n ih
  simp [pow_one]
  simp only [pow_succ]
  exact ‚ü®(ih (Nat.succ_pos _)).1.of_smul _, (IsSMulRegular.pow _).2‚ü©

===== Proof 2986 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine ‚ü®?_, fun h ‚Ü¶ h.pow n‚ü©
  intro h x y hxy
  apply h
  rw [pow_smul_comm, pow_smul_comm, hxy]

===== Proof 2987 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  exact ‚ü®fun h => by
    have hn : 0 < n := n0
    letI : SMul M Œ± := inferInstance
    letI : SMul M (Œ± ^ n) := inferInstance
    refine' isSMulRegular_of_injective _ h‚ü©

===== Proof 2988 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  obtain ‚ü®n, rfl‚ü© := Nat.exists_eq_succ_of_ne_zero n0.ne.symm
  rw [pow_succ]
  refine ‚ü®fun h => ?_, fun h => h.pow n‚ü©
  exact h.of_smul a

===== Proof 2989 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  cases n with
  | zero => contradiction
  | succ n =>
    rw [pow_succ]
    exact IsSMulRegular.of_mul

===== Proof 2990 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine' ‚ü®fun h       => _, fun h       => pow_mul_pow_eq_one n n0 ‚ñ∏ h‚ü©
  rw [‚Üê mul_one a]
  exact h.of_mul_left (pow_mul_pow_eq_one n n0)

===== Proof 2991 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  constructor <;> intro h
  ¬∑ exact h.of_pow n0
  ¬∑ exact IsSMulRegular.pow n h

===== Proof 2992 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  rw [IsSMulRegular, IsSMulRegular, smul_pow, ‚Üê smul_right_inj a (by rintro ‚ü®‚ü©)]
  exact pow_left_injective n0

===== Proof 2993 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine' ‚ü®fun h => h.of_pow n0, fun h => _‚ü©
  obtain ‚ü®n, rfl‚ü© := exists_eq_succ_of_ne_zero n0.ne'
  exact h.pow_of_self n.succ_ne_zero

===== Proof 2994 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine' n.rec (fun h => by contradiction) (fun k ih => ?_)
  rw [‚Üê pow_succ]
  simp [mul_isSMulRegular_iff, ih]

===== Proof 2995 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  cases' n with n
  contradiction
  induction' n with n ih
  simp
  simp only [IsSMulRegular, pow_succ]
  apply iff_of_eq; congr!

===== Proof 2996 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  induction' n with n _
  ¬∑ cases n0
  simp only [pow_succ', IsSMulRegular, ‚Üê mul_smul]
  tauto

===== Proof 2997 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine ‚ü®fun h => ?_, fun h => h.pow n‚ü©
  rcases eq_or_ne a 0 with rfl | ha
  exacts [zero_pow n0 ‚ñ∏ h.zero_left, h]

===== Proof 2998 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  have hn : n ‚â† 0 := by omega
  rw [‚Üê mul_left_inj' (pow_ne_zero n (by decide : a ‚â† 0)), ‚Üê pow_succ,
    pow_succ, mul_assoc, mul_left_cancel_iff, ‚Üê IsSMulRegular.smul_iff, ‚Üê smul_eq_mul]
  simp only [hn, pow_ne_zero, mul_left_cancel_iff, IsSMulRegular.smul_iff, smul_eq_mul, mul_comm,
    ne_eq]
  rw [mul_comm]
  apply Iff.intro <;> intro H <;> simpa [IsSMulRegular, smul_eq_mul] using H

===== Proof 2999 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  exacts [h.of_smul _, h.pow n n0]

===== Proof 3000 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine' ‚ü®fun reg h => _, fun h x y hxy => _‚ü©
  ¬∑ rw [‚Üê smul_eq_mul] at h
    rw [pow_succ, mul_comm] at reg
    exact h.symm.trans reg
  ¬∑ exact h (by
      rw [‚Üê succ_pred_eq_of_pos n0, pow_succ, mul_comm]
      exact hxy)

===== Proof 3001 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  induction n with
  | zero => cases n0
  | succ k k0 =>
    rw [Nat.pow_succ]
    exact IsSMulRegular.of_mul_iff (by assumption)

===== Proof 3002 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  induction' n with n hn
  ¬∑ cases n0
  cases n
  ¬∑ simp [IsSMulRegular, Nat.zero_eq]
  simp only [pow_succ, IsSMulRegular, hn n.succ_pos]
  haveI := hn n.succ_pos
  tauto

===== Proof 3003 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  exacts [h.of_pow, h.pow n]

===== Proof 3004 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine' ‚ü®fun h => h.of_pow n0, fun h => _‚ü©
  obtain ‚ü®n, rfl‚ü© := pow_eq_one_iff n0
  exact h.pow n

===== Proof 3005 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  induction' n with n IH; simp at n0
  have rfl : a ^ (n + 1) = a ^ n * a := by rw [pow_succ]
  simp only [rfl, IsSMulRegular, forall_const]
  exact ‚ü®fun hann => hann.of_smul a, fun hann x y xy => by
    rw [‚Üê mul_one x, ‚Üê pow_one a] at xy
    exact hann (IH.1 ((mul_left_cancel‚ÇÄ (pow_ne_zero 1 a.ne_zero) xy).symm))‚ü©

===== Proof 3006 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  cases' n with n
  contradiction
  rw [‚Üê mul_one a]
  rw [‚Üê pow_succ]
  exact IsSMulRegular.of_mul M

===== Proof 3007 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  refine' Nat.le_induction _ _ n0
  case refl => simp
  case step n hn IH =>
    rw [pow_succ]
    exact
      ‚ü®fun h => IsSMulRegular.of_mul_left M h, fun ha => by
        rw [mul_comm]
        exact IsSMulRegular.mul_left M ha‚ü©

===== Proof 3008 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ‚Ñï} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ‚Üî IsSMulRegular M a := by
  induction' n with n IH
  ¬∑ contradiction
  ¬∑ simp_rw [‚Üê pow_succ, mul_left_inj]
    exact ‚ü®fun h => h a, fun h => h a‚ü©

===== Proof 3009 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [formPerm_pow_apply_get]
  rfl

===== Proof 3010 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  induction' n with n ih generalizing k
  case zero => simp
  rw [pow_succ', mul_apply, ih, formPerm_apply_get]
  simp only [Nat.add_zero, ge_iff_le, zero_add]
  simp [Nat.add_assoc, Nat.add_comm, Nat.add_left_comm, Nat.mod_eq_of_lt, hk, Nat.mod_eq_of_lt,
    Nat.mod_eq_of_lt, Nat.mod_eq_of_lt, Nat.mod_eq_of_lt, Nat.mod_eq_of_lt, Nat.mod_eq_of_lt]

===== Proof 3011 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  cases l
  <;> simp
  <;> decide

===== Proof 3012 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
/- already proved earlier this morning, and the 
===== Proof 3013 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [formPerm_pow_apply_get]
  rfl

===== Proof 3014 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simpa [formPerm_pow_apply_get] using h

===== Proof 3015 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [formPerm_apply, formPerm_pow_apply_get]
  congr 2
  exact ((Nat.mod_add_mod _ _ _).symm.trans <| Nat.add_mod_right _ _).symm

===== Proof 3016 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [Nat.add_comm k n]
  simpa [Nat.mod_comm] using formPerm_pow_apply_nthLe l h n k hk

===== Proof 3017 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simpa only [List.formPerm_apply_get] using
    formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©

===== Proof 3018 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [(formPerm l).cycleOf_eq_pow_self_of_apply_eq (get_formPerm_eq _ _ hk)]
  simp [add_comm, add_left_comm]

===== Proof 3019 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simp_rw [get]
  rw [formPerm_pow_apply_get]
  rfl

===== Proof 3020 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  cases l
  case nil => simp
  case cons =>
    simp [formPerm_pow_apply_get]

===== Proof 3021 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  apply formPerm_pow_apply_get

===== Proof 3022 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [pow_succ']
  rw [mul_apply]
  split_ifs with hkl
  ¬∑ rw [next_eq_get]
    have : (l : Multiset Œ±).eraseIdx k = (l.erase k : List Œ±) := by
      refine Multiset.eq_coe_of_perm ?_
      rw [‚Üê perm_cons_erase hkl]
      exact (formPerm_eq_of_mem_of_nodup _ (l.erase_ne_nil_of_mem (l.get_mem _ _)) h).symm
    rw [this, formPerm_apply_get _ (l.erase_nodup_of_nodup h), get_erase, Option.some_get]
  ¬∑ rw [next_eq_get]
    rw [formPerm_apply_get _ (get_mem _ _ _), get_erase_of_not_eq hkl,
      formPerm_apply_of_not_mem (l.get_mem _ _) hkl, Option.some_get]

===== Proof 3023 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by sorry

===== Proof 3024 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [formPerm_apply, formPerm_apply]
  simp only [formPerm_apply]
  rw [‚Üê get_eq_get_len_mod, ‚Üê get_eq_get_len_mod]
  congr 1
  rw [Nat.mod_add_mod, Nat.add_mod_mod]

===== Proof 3025 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simp_rw [‚Üê Nat.add_mod_mod, ‚Üê nodup_iff_injective_get] at *
  simp_rw [formPerm_apply_get]
  simp_rw [‚Üê get_eq_get_length, ‚Üê Nat.add_mod_mod]
  cases n <;> simp_rw [Nat.zero_add, Nat.add_zero] <;> rfl

===== Proof 3026 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  have hk : k ‚â§ (k + n) % l.length := by omega
: by
  rw [‚Üê Nat.mod_add_mod l.length k (n % l.length), Nat.add_comm, Nat.add_comm k]; simp [hk, hk]

===== Proof 3027 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  cases' n with n
  simp [formPerm_apply_get]
  rw [pow_succ', mul_apply, formPerm_pow_apply_get]
  rw [Nat.add_mod_right]

===== Proof 3028 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  cases l
  case nil => simp
  case cons => simp

===== Proof 3029 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simp_rw [formPerm_apply_get _ h, ‚Üê get_eq_get_of_nodup _ h, Fin.get_ofNat]
  rw [Nat.add_comm]
  simp_rw [@Nat.add_comm _ k, Nat.add_mul_mod_self_left, Nat.mod_eq_of_lt hk, get_ofNat]

===== Proof 3030 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by aesop

===== Proof 3031 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  cases n <;> simp_all [Nat.succ_eq_add_one, Nat.add_comm, Nat.add_left_comm]
-

===== Proof 3032 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by aesop

===== Proof 3033 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  revert n k
  induction' l with a l IH
  ¬∑ simp
  intro n k hk
  dsimp only [List.length] at hk
  rw [formPerm_pow_apply_get]
  have hdl : (a :: l).Nodup := by simp [h]
  rw [‚Üê List.length]
  have := hdl.get_lt k hk
  simpa using IH n ‚ü®k, this‚ü©

===== Proof 3034 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simp_rw [formPerm_apply_get]
  simp_rw [pow_succ']
  rw [mul_apply]
  rw [get_eq_get_of_nodup _ h]
  congr
  rw [Nat.add_mod_right]

===== Proof 3035 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simp_rw [formPerm_def, ‚Üê List.get_eq_get_len]
  convert List.isRotated_formPerm_pow_self l n
  ext x
  simp_rw [List.formPerm_pow_apply_get]
  congr! 2
  apply List.get_eq_get_of_le _ _ (Nat.lt_succ_of_lt hk)
  omega

===== Proof 3036 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  subst formPerm
  simp only [pow_succ, pow_zero, Function.comp_apply, one_apply]
  dsimp [get]
  simp

===== Proof 3037 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simp only [formPerm_pow_apply, List.formPerm_apply_get]
  rw [‚Üê Nat.mod_add_div k l.length, Nat.add_comm, Nat.pow_add, Nat.pow_mul,
    perm_pow_mul_pow_eq_pow_mul_pow, ‚Üê Nat.mod_add_div k l.length, Nat.add_comm]

===== Proof 3038 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  induction k with
  | zero =>
    simp_all [Nat.mod_eq_of_lt]
  | succ k ih =>
    simp_all [Nat.mod_eq_of_lt]

===== Proof 3039 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simp_rw [List.formPerm_pow_apply_get l h]
  rfl

===== Proof 3040 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List Œ±) (h : Nodup l) (n k : ‚Ñï) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ‚ü®k, hk‚ü©
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by rfl

===== Proof 3041 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num

===== Proof 3042 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = 3 + 1 by norm_num]

===== Proof 3043 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  let f : ‚Ñù ‚Üí ‚Ñù := fun x => x ^ 2 - x + 1
  let f' : ‚Ñù ‚Üí ‚Ñù := fun x => 2 * x - 1
  have h : ‚àÄ x, f' x = 2 * x - 1 := by intro x; rfl
  have h‚ÇÅ : f' 1 = 1 := by simp [h]
  have h‚ÇÇ : f' 0 = -1 := by simp [h]
  norm_num [h‚ÇÅ, h‚ÇÇ]

===== Proof 3044 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  linarith

===== Proof 3045 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = 3 + 1 by norm_num]

===== Proof 3046 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  exact Eq.symm <| by simp [Nat.cast_ofNat]

===== Proof 3047 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  simp

===== Proof 3048 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  symm
  norm_num

===== Proof 3049 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = 3 + 1 by norm_num]

===== Proof 3050 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num

===== Proof 3051 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  rw [show (3 : R) = 3 + 0 by simp, show (4 : R) = 3 + 1 by simp]

===== Proof 3052 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [add_assoc, add_comm, add_left_comm]

===== Proof 3053 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  rw [show (3 : R) = 3 + 0 * 1 by simp]
  rw [show (4 : R) = 4 + 0 * 0 by simp]
  simp [add_assoc, add_left_comm]

===== Proof 3054 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = 3 + 1 by norm_num]

===== Proof 3055 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = 3 + 1 by norm_num]

===== Proof 3056 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num

===== Proof 3057 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  rw [‚Üê Nat.cast_ofNat]
  norm_num

===== Proof 3058 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [Nat.cast_ofNat]

===== Proof 3059 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  rw [show (3 : R) = (2 : R) + 1 by norm_num, show (4 : R) = (2 : R) + 2 by norm_num]
  simp

===== Proof 3060 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num

===== Proof 3061 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  rw [show (3 : R) = 3 + 0 by rfl, show (4 : R) = 4 + 0 by rfl]
  norm_num

===== Proof 3062 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = 3 + 1 by norm_num]

===== Proof 3063 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = 3 + 1 by norm_num]

===== Proof 3064 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  simp

===== Proof 3065 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num

===== Proof 3066 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = 3 + 1 by norm_num]

===== Proof 3067 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = (3 : R) + 1 by norm_num]

===== Proof 3068 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  rw [show (3 : R) = 3 + 0 by rfl, show (1 : R) = 1 + 0 by rfl]
  simp [add_assoc, add_comm, add_left_comm]

===== Proof 3069 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (3 : R) = 3 by rfl, show (4 : R) = 4 by rfl]

===== Proof 3070 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = 3 + 1 by norm_num]

===== Proof 3071 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  rw [show (3 : R) = 2 + 1 by rfl, show (4 : R) = 3 + 1 by rfl]

===== Proof 3072 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
  norm_num [show (4 : R) = (3 : R) + 1 by norm_num]

===== Proof 3073 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  exact ‚ü®fun hx =>
    let ‚ü®r, hr, hx‚ü© := mem_balancedHull_iff.mp hx
    ‚ü®r, hr, hx‚ü©,
    fun ‚ü®r, hr, hx‚ü© =>
    mem_balancedHull_iff.mpr ‚ü®r, hr, hx‚ü©‚ü©

===== Proof 3074 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine ‚ü®fun hx => ?_, fun ‚ü®r, hr, hx‚ü© => mem_balancedHull_singleton.mp hx‚ü©
  obtain ‚ü®t, ht, h‚ü© := mem_balancedHull_singleton.mp hx
  exact ‚ü®r, hr, h.trans ht‚ü©

===== Proof 3075 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun hx => _, fun hx => _‚ü©
  obtain ‚ü®r, hr, h‚ü© := hx
  exact ‚ü®r, hr, h‚ü©
  obtain ‚ü®r, hr, h‚ü© := hx
  exact ‚ü®r, hr, h‚ü©

===== Proof 3076 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  constructor <;> intro h <;> rw [balancedHull_eq] at h <;> obtain ‚ü®r, hr, y, hy, rfl‚ü© := h <;>
    exact ‚ü®r, hr, y, hy, rfl‚ü©

===== Proof 3077 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by exact Iff.rfl

===== Proof 3078 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun hx => _, fun ‚ü®r, hr, hx‚ü© => mem_balancedHull_smul _ _ _‚ü©
  obtain ‚ü®r, hr, hx‚ü© := mem_balancedHull_smul _ _ hx
  exact ‚ü®r‚Åª¬π, by simpa using hr.le, by simpa using hx‚ü©

===== Proof 3079 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine ‚ü®fun hx => ?_, fun ‚ü®r, hr, hx‚ü© => ?_‚ü©
  obtain ‚ü®r, hr, hx‚ü© := mem_balancedHull_iff.mp hx
  exact ‚ü®r, hr, hx‚ü©
  exact mem_balancedHull_iff.mpr ‚ü®r, hr, hx‚ü©

===== Proof 3080 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  exact ‚ü®fun h => ‚ü®1, by simp, by rwa [one_smul] at h‚ü©, fun ‚ü®r, hr, hx‚ü© => smul_mem_balancedHull ùïú hr hx‚ü©

===== Proof 3081 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun hx => _, fun ‚ü®r, hr, hx‚ü© => (balancedHull_subset_convexHull ùïú s) hx‚ü©
  refine' balancedHull.smul_mem hx _
  exact ‚ü®(1 : ùïú), by simp‚ü©

===== Proof 3082 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun hx => _, fun ‚ü®r, hr, hx‚ü© => _‚ü©
  obtain ‚ü®r, hr, hx‚ü© := hx
  exact ‚ü®r, hr, hx‚ü©
  exact ‚ü®r, hr, hx‚ü©

===== Proof 3083 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  exact ‚ü®fun hx => by
    obtain ‚ü®r, hr, rfl‚ü© := mem_balancedHull_iff.1 hx
    exact ‚ü®r, hr, rfl‚ü©, fun ‚ü®r, hr, hx‚ü© => mem_balancedHull_iff.2 ‚ü®r, hr, hx‚ü©‚ü©

===== Proof 3084 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®r, hr‚ü© ‚Ü¶ ?_‚ü©
  obtain ‚ü®r, hr, rs‚ü© := mem_balancedHull_iff.mp h
  exact ‚ü®r, hr, rs‚ü©
  exact mem_balancedHull_iff.mpr ‚ü®r, hr.1, hr.2‚ü©

===== Proof 3085 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun hx => _, fun ‚ü®r, hr, hx‚ü© => _‚ü©
  obtain ‚ü®r, hr, hx‚ü© := mem_balancedSups_iff.1 hx
  exact ‚ü®r, hr, hx‚ü©
  exact mem_balancedSups_iff.2 ‚ü®r, hr, hx‚ü©

===== Proof 3086 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun ‚ü®r, hr‚ü© ‚Ü¶ ?_‚ü©
  obtain ‚ü®r, hr, hx‚ü© := mem_smul_set_iff_inv_smul_mem.mp h
  exact ‚ü®r‚Åª¬π, by simpa using hr, by simpa using hx‚ü©
  refine' mem_smul_set_iff_inv_smul_mem.mpr ‚ü®r, hr.2, _‚ü©
  rw [inv_smul_smul‚ÇÄ hr.1.ne']
  exact hx

===== Proof 3087 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  exact ‚ü®fun hx =>
    let ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü© := mem_balancedHull_iff.1 hx
    ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü©,
    fun ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü© =>
    mem_balancedHull_iff.2 ‚ü®r, hr‚ÇÅ, hr‚ÇÇ‚ü©‚ü©

===== Proof 3088 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  constructor <;> intro h <;> rcases h with ‚ü®r, hr, hx‚ü© <;>
    use r, hr, hx

===== Proof 3089 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' mem_balancedHull_iff.trans ‚ü®_, fun ‚ü®r, hr‚ü© => ‚ü®r, hr.1, Submodule.smul_mem_smul hr.2‚ü©‚ü©
  rintro ‚ü®r, hr, rfl‚ü©
  exact ‚ü®r, hr, Submodule.mem_span.1 (by assumption)‚ü©

===== Proof 3090 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun hx => _, fun ‚ü®r, hr, hx‚ü© => _‚ü©
  ¬∑ obtain ‚ü®r, hr, hx‚ü© := (balanced_iff_smul_mem ùïú (balancedHull ùïú s) r).mp (balanced_iff_balancedHull ùïú s).mpr hx
    refine' ‚ü®r, hr, hx‚ü©
  ¬∑ exact (balancedHull ùïú s).smul_mem r hx

===== Proof 3091 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun h => _, fun ‚ü®r, hr‚ü© => _‚ü© <;> obtain ‚ü®r, hr, rfl‚ü© := h <;> exact ‚ü®r, hr, Set.smul_mem_smul_set (Set.mem_of_mem_of_subset hr subset_r_sc)‚ü©

===== Proof 3092 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun hx => _, fun ‚ü®r, hr, hx‚ü© => smul_mem_balancedHull ùïú s hx hr‚ü©
  obtain ‚ü®r, hr, hx‚ü© := (balancedHull_subset _).mem_iff.1 hx
  exact ‚ü®r, hr, hx‚ü©

===== Proof 3093 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  exact ‚ü®fun h =>
    let ‚ü®r, hr, hx‚ü© := mem_balancedHull_iff.1 h
    ‚ü®r, hr, hx‚ü©,
    fun ‚ü®r, hr, hx‚ü© =>
    mem_balancedHull_iff.2 ‚ü®r, hr, hx‚ü©‚ü©

===== Proof 3094 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun hx => _, fun ‚ü®r, hr, hx‚ü© => balancedHull.smul_mem ùïú r hr hx‚ü©
  exact
    let ‚ü®r, hr, hx‚ü© := mem_balancedHull_iff.1 hx
    ‚ü®r, hr, hx‚ü©

===== Proof 3095 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  constructor <;> simp (config := { contextual := true }) [balancedHull_def, smul_subset_iff]
  <;> tauto

===== Proof 3096 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine ‚ü®fun hx => ?_, fun ‚ü®r, hr, hx‚ü© => ?_‚ü©
  obtain ‚ü®r, hr, hx‚ü© := mem_balancedHull_iff.mp hx
  exact ‚ü®r, hr, hx‚ü©
  exact mem_balancedHull_iff.mpr ‚ü®r, hr, hx‚ü©

===== Proof 3097 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun h => _, fun ‚ü®r, hr, h‚ü© => _‚ü©
  obtain ‚ü®r, hr, h‚ü© := h
  exact ‚ü®r, hr, h‚ü©
  exact ‚ü®r, hr.le, h‚ü©

===== Proof 3098 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  simp [balancedHull, mem_smul_set_iff_inv_smul_mem]

===== Proof 3099 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  exact ‚ü®fun ‚ü®r, hx‚ü© => ‚ü®r, le_of_lt hx.1, hx.2‚ü©, fun ‚ü®r, hr, hx‚ü© => ‚ü®r, ‚ü®hr, hx‚ü©‚ü©‚ü©

===== Proof 3100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun h => _, fun ‚ü®r, hr, hx‚ü© => smul_mem_balancedHull ùïú s r hx hr‚ü©
  obtain ‚ü®r, hr, hx‚ü© := mem_balancedHull_iff_exists_mem_smul_mem ùïú s x h
  exact ‚ü®r‚Åª¬π, by simpa using hr, by rwa [mem_inv_smul_set_iff‚ÇÄ (norm_pos_iff.mp (hr.trans_lt one_lt_two).ne']
    at hx‚ü©

===== Proof 3101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  constructor <;> intro h
  case mp =>
    rw [balancedHull_eq_iUnion] at h
    obtain ‚ü®r, hr, hx‚ü© := h
    exact ‚ü®r, hr, hx‚ü©
  case mpr =>
    rw [balancedHull_eq_iUnion]
    obtain ‚ü®r, hr, hx‚ü© := h
    exact ‚ü®r, hr, hx‚ü©

===== Proof 3102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine' ‚ü®fun h => _, fun ‚ü®r, hr, hx‚ü© => _‚ü©
  obtain ‚ü®r, hr, hx‚ü© := h
  exact ‚ü®r, hr, hx‚ü©
  exact ‚ü®r, hr, hx‚ü©

===== Proof 3103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  exact ‚ü®fun hx =>
    (exists_mem_of_mem_balancedHull ùïú hx).imp fun r _ => ‚ü®r, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©,
    fun ‚ü®r, hr, hx‚ü© =>
    mem_balancedHull_of_mem_smul r ‚ü®hr, hx‚ü©‚ü©

===== Proof 3104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ‚àà balancedHull ùïú s ‚Üî ‚àÉ r : ùïú, ‚Äñr‚Äñ ‚â§ 1 ‚àß x ‚àà r ‚Ä¢ s := by
  refine ‚ü®fun hx => ?_, fun ‚ü®r, hr, hx‚ü© => ?_‚ü©
  exacts [‚ü®1, by norm_num, hx‚ü©, ‚ü®r, hr, hx‚ü©]

===== Proof 3105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, integrable_on_univ, albedo]

===== Proof 3106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, ‚Üê exists_and_left, exists_prop]

===== Proof 3107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  rw [IntegrableOn, Integrable, Integrable, integrable_measure_univ]
 statement: ‚àÄ (f : Œ≤ ‚Üí E) (Œº : Measure Œ≤),
  ‚àÄ [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [SecondCountableTopology Œ≤] [OpensMeasurableSpace Œ≤] [SigmaCompactSpace Œ≤],
    IntegrableOn f univ Œº ‚Üî Integrable f Œº

===== Proof 3108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_def]
  rw [Measure.restrict_univ]

===== Proof 3109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  constructor <;> intro h
  exacts [h.integrableOn, h.integrableOn_univ]

===== Proof 3110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_iff_integrable_norm, Integrable, measurable_univ.forall_iff]

===== Proof 3111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  rw [IntegrableOn, Integrable, integrable_measure_smul_iff]
  simp

===== Proof 3112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_on_univ, n = 0]

===== Proof 3113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  constructor <;> intro h
  exacts [h.integrableOn, h.integrableOn]

===== Proof 3114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_def, measurableSet_univ, set_comap_univ, exists_prop]

===== Proof 3115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, measurableSet_univ, Unhygienic.set_option.warning_config]

===== Proof 3116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_iff_integrable_norm, norm_add_le]

===== Proof 3117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, integrable_univ]

===== Proof 3118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  rw [IntegrableOn, Integrable, integrable_measure_toFun, integrable_measure_toFun]
  simp [Measure.restrict_univ]

===== Proof 3119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_def, Measure.restrict_univ]

===== Proof 3120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, exists_prop]

===== Proof 3121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  constructor
  next => intro h; exact h.integrable_univ
  next => intro h; exact h.integrableOn_univ

===== Proof 3122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  dsimp only [IntegrableOn, Integrable, ‚Üê compl_univ]
  rw [integrable_on_compl_iff_integrable_on_diff]
  simp [measure_univ_pos, -and_imp]

===== Proof 3123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, integrable_on_iff_integrable_restrict]

===== Proof 3124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, measurableSet_univ, univ_inter]

===== Proof 3125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_iff, measurableSet_univ, Set.indicator_univ]

===== Proof 3126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_iff, measurableSet_univ, set_lintegral_univ]

===== Proof 3127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, measurableSet_univ, Measure.restrict_univ]

===== Proof 3128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_iff_integrable_norm_Ioi_of_non_decreasing, non_decreasing_of_le_succ,
    non_decreasing_of_le_succ]

===== Proof 3129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, integrable_on_univ, integrable_def]

===== Proof 3130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  constructor <;> intro h
  <;> (try simp_all)
  <;> (try exact h)
  <;> (try exact integrable_of_integrableOn_univ h)
  <;> (try exact integrableOn_univ_iff_integrable.mp h)

===== Proof 3131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  constructor <;> intro h
  <;> (try rw [IntegrableOn] at h)
  <;> simp_all only [Measure.restrict_univ, Measure.restrict_univ']
  <;> rfl

===== Proof 3132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  constructor <;> simp (config := { contextual := true }) [IntegrableOn, integrable_iff]
  <;> simp [*]
  <;> assumption

===== Proof 3133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, measurableSet_univ, set_average_eq]

===== Proof 3134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp only [IntegrableOn, Integrable, mem_univ, forall_true_left]

===== Proof 3135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, measurableSet_univ, set_average_eq]

===== Proof 3136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ Œº ‚Üî Integrable f Œº := by
  simp [IntegrableOn, Integrable, AECover.restrict_apply (Œº := Œº) measurableSet_univ]

===== Proof 3137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rw [‚Üê sub_eq_zero]
  have h' := h.eq_zero_of_norm_sub_pow_lt (lt_of_le_of_ne (norm_nonneg _) hn.symm)
  simpa using h'

===== Proof 3138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h' := h
  rw [IsBigO_iff] at h'
  rcases h' with ‚ü®C, hC, hC'‚ü©
  have hC'' := hC' x‚ÇÄ
  simp_all

===== Proof 3139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h‚ÇÅ := IsBigO.eq_zero_of_norm_pow h hn
  simp_all

===== Proof 3140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rw [‚Üê sub_eq_zero]
  have h1 := h.eq_zero_of_norm_pow' hn
  simpa [h1] using h1

===== Proof 3141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have := h.eq_zero_of_norm_pow' x‚ÇÄ (hn.bot_lt)
  simpa [hn] using this

===== Proof 3142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rw [mem_of_mem_nhds (ùìù _)] at h
  simpa [hn, dist_eq_norm] using h

===== Proof 3143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h2 := h.eq_zero_of_norm_pow hn
  simp_all

===== Proof 3144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h1 := h
  simp_all [IsBigO_iff]
  rcases h1 with ‚ü®C, hC‚ü©
  have h2 := hC x‚ÇÄ
  simp_all

===== Proof 3145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have := h.eq_zero_of_norm_pow' hn
  simp_all

===== Proof 3146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  simp_all

===== Proof 3147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  by_contra hx
  rw [‚Üê @norm_ne_zero_iff _ _ _ _ (f x‚ÇÄ)] at hx
  specialize h.weaken (fun x => by simpa [norm_nonneg] using pow_nonneg (norm_nonneg _) _)
  simpa [hx, pow_zero] using h.eq_zero_of_norm_pow hn

===== Proof 3148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rcases (zero_le n).lt_or_eq with (h | rfl)
  ¬∑ change 0 < n at h
    have := h.ne'
    rw [‚Üê mul_zero (0 : ‚Ñù)] at h
    exact (isBigO_zero_right _ _).eventuallyEq_zero (h.trans_le (norm_sub_pow_le x‚ÇÄ))
  ¬∑ simp at h

===== Proof 3149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h1 := h
  rw [IsBigO_iff] at h1
  cases' h1 with c hc
  have h2 := hc.1
  have h3 := hc.2
  simp_all

===== Proof 3150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  by_contra hx‚ÇÄ
  rw [‚Üê norm_ne_zero_iff] at hx‚ÇÄ
  have h1 : 0 < n := pos_iff_ne_zero.mpr hn
  have h2 := (isLittleO_one_iff ‚Ñù).mp (h.eq_zero_imp_isBigO_one ‚Ñù)
  have h3 := h2.pow h1
  have h4 := h3.add_isBigO (isBigO_const_const ‚Ñù 1 x‚ÇÄ)
  have h5 := h4.pow h1
  simp at h5
  norm_num at h5

===== Proof 3151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h' := IsBigO.eq_zero_of_norm_pow' h hn
  simp_all

===== Proof 3152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rcases h.eq_zero_or_eq_zero_of_pow_norm ùïú hn with (h' | h')
  ¬∑ simp_all
  ¬∑ simpa [h'] using h'

===== Proof 3153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rcases exists_mem_nhds_zero_forall_pow_lt_norm ùïú (norm_pos_iff.mpr (sub_ne_zero.mpr hn)) with
    ‚ü®Œµ, hŒµ, hŒµ'‚ü©
  have := h.bound (HasSubset.Subset.eventually_mem (ball_mem_nhds x‚ÇÄ hŒµ)
    (fun x => pow_le_pow_of_le_left (norm_nonneg _) (norm_sub_norm_le _ _) _))
  simp_all

===== Proof 3154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rcases n with (_ | _ | n) <;>
    simp_all [IsBigO_eq_zero, pow_succ']

===== Proof 3155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h‚ÇÅ := h.eq_zero_of_norm_pow_within hn (mem_of_mem_nhds (ùìù x‚ÇÄ))
  simpa using h‚ÇÅ

===== Proof 3156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have := (isLittleO_one_iff ‚Ñù).1 (h.eq_zero_isLittleO (by simpa using hn))
  simpa using this 1

===== Proof 3157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rw [‚Üê sub_eq_zero]
  have h' := h
  rw [IsBigO_iff] at h'
  cases' h' with c hc
  have hc' := hc
  simp only [sub_eq_add_neg, add_zero] at hc'
  have hc'' := hc'
  norm_num at hc''
  have hc''' := hc''
  norm_num at hc'''
  have hc'''' := hc'''
  norm_num at hc''''
  linarith

===== Proof 3158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h1 := h.eq_zero_of_norm_pow_within <;> simp_all

===== Proof 3159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h1 := h
  simp only [IsBigO_iff, eventually_nhds_iff] at h1
  obtain ‚ü®A, hA, h2‚ü© := h1
  specialize h2 x‚ÇÄ
  simp_all

===== Proof 3160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have h' := IsBigO.eq_zero_of_norm_pow h hn
  simp_all

===== Proof 3161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have := h.eq_zero_of_norm_sub_pow_neg x‚ÇÄ hn
  simp_all

===== Proof 3162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rw [‚Üê zero_sub (f x‚ÇÄ)]
  refine' eq_of_sub_eq_zero _
  refine'
    h.eq_zero_of_norm_sub_pow_lt (norm_sub_lt_of_mem_nhds (by simp [hn]))
      (lt_of_le_of_ne (by simp [hn]) hn)

===== Proof 3163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rcases hn with (_ | _ | _ | n) <;> simp_all

===== Proof 3164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rcases IsBigO.exists_eq_mul h with ‚ü®c, hc‚ü©
  rw [‚Üê sub_eq_zero]
  have hx := hc.1
  rw [‚Üê hx] at hc
  have hx2 := hx
  rw [‚Üê hx2] at hx
  simp_all

===== Proof 3165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rw [‚Üê sub_eq_zero]
  have h' : f - fun _ => f x‚ÇÄ =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n := by
    simpa only [isBigO_iff, norm_pow, ‚Üê sub_sub, sub_self, zero_sub, isBigO_zero] using h
  apply eq_zero_of_isBigO_sub_pow_norm h' hn

===== Proof 3166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rcases h.exists_pos with ‚ü®C, _h‚ÇÄ, hC‚ü©
  simp_rw [IsBigO, IsBigOWith, eventually_nhds_iff] at hC
  obtain ‚ü®Œ¥, hŒ¥, h‚ü© := hC
  specialize h (Set.mem_Ioo.mpr ‚ü®dist_pos.mpr (sub_ne_zero.mpr (by simpa using hn), by simp‚ü©))
  simp [dist_eq_norm] at h
  aesop

===== Proof 3167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  rw [‚Üê sub_eq_zero]
  have h1 := h.eq_zero_of_norm_pow' x‚ÇÄ hn
  simpa [isLittleO_one_iff] using h1

===== Proof 3168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
    (h : f =O[ùìù x‚ÇÄ] fun x => ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : n ‚â† 0) : f x‚ÇÄ = 0 := by
  have := h.eq_zero_of_norm_pow' hn
  simp_all

===== Proof 3169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin.induction_on with
  | h_adjoin_simple _ _ => exact mem _ _
  | algebraMap _ _ => exact algebraMap _
  | add _ _ _ _ _ _ ih1 ih2 => exact add _ _ _ _ ih1 ih2
  | mul _ _ _ _ _ _ ih1 ih2 => exact mul _ _ _ _ ih1 ih2

===== Proof 3170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  let C : Set A := {x | p x ùïú_mem}
  have : Algebra.adjoin R s ‚äÜ C := by
    intro x hx
    induction' hx with y hy r y hy y z hy hz IH1 IH2
    ¬∑ exact mem y hy
    ¬∑ exact algebraMap y
    ¬∑ exact add y z IH1 IH2
    ¬∑ exact mul y z IH1 IH2
  exact this hx

===== Proof 3171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  rw [adjoin_eq_span] at hx
  refine Submodule.span_induction hx ?_ ?_ ?_ ?_
  exacts [mem, fun r => by simpa using algebraMap r, add, mul]

===== Proof 3172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx
  case h.basic => exact mem _ ‚Äπ_‚Ä∫
  case h.algebraMap => exact algebraMap _
  case h.add => exact add _ ‚Äπ_‚Ä∫ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
  case h.mul => exact mul _ ‚Äπ_‚Ä∫ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫

===== Proof 3173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  revert hx
  apply adjoin_induction
  assumption
  assumption
  assumption
  assumption

===== Proof 3174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using Subalgebra.mem_adjoin_induction
  exacts [mem _ (subset_adjoin <| subset_adjoin ‚Äπ_‚Ä∫),
    algebraMap _ _, add _ _ _ _ ‚Äπp _ _‚Ä∫ ‚Äπp _ _‚Ä∫, mul _ _ _ _ ‚Äπp _ _‚Ä∫ ‚Äπp _ _‚Ä∫]

===== Proof 3175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  refine' adjoin_induction hx _ (fun r => _) (fun x y => _) fun x y => _
  exacts [mem, algebraMap, add, mul]

===== Proof 3176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction' with
  | mem h => exact mem _ h
  | zero => exact algebraMap _
  | mul _ _ _ _ => exact mul _ _ _ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫
  | add _ _ _ _ => exact add _ _ _ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫

===== Proof 3177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using Subalgebra.induction_on with
  | h_self x hx => exact mem x hx
  | h_algebraMap r => simpa using algebraMap r
  | h_add x y _ _ ihx ihy => simpa using add x y ihx ihy
  | h_mul x y _ _ ihx ihy => simpa using mul x y ihx ihy

===== Proof 3178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx <;> simp_all
  <;> aesop

===== Proof 3179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction'
  exacts [mem x h, algebraMap r, add x x_1 y y_1 _ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫,
    mul x x_1 y y_1 _ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫]

===== Proof 3180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction
  case h_mem h => simpa using mem _ h
  case h_zero => simpa using algebraMap _
  case h_algebraMap r => simpa using algebraMap _
  case h_add x hx y hy hx' hy' => simpa using add _ _ _ _ hx' hy'
  case h_mul x hx y hy hx' hy' => simpa using mul _ _ _ _ hx' hy'

===== Proof 3181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction' with
  | basic h => exact mem _ h
  | algebraMap r => exact algebraMap _
  | add_mem x hx y hy ihx ihy => exact add _ _ _ _ ihx ihy
  | mul_mem x hx y hy ihx ihy => exact mul _ _ _ _ ihx ihy

===== Proof 3182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx with
  | basic z hz => exact mem z hz
  | algebraMap r => exact algebraMap r
  | add x y _ _ ihx ihy => exact add x y _ _ ihx ihy
  | mul x y _ _ ihx ihy => exact mul x y _ _ ihx ihy

===== Proof 3183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  refine' adjoin_induction hx _ (fun r => _) add mul
  exacts [fun x hx => mem x hx, fun r => algebraMap r]

===== Proof 3184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx
  case basic x hx => exact mem x hx
  case algebraMap => exact algebraMap _
  case add hd1 hd2 ih1 ih2 => exact add _ _ _ _ ih1 ih2
  case mul hd1 hd2 ih1 ih2 => exact mul _ _ _ _ ih1 ih2

===== Proof 3185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  refine Subtype.recOn hx ?_
  aesop

===== Proof 3186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction' with
  | base h => exact mem _ h
  | algebraMap r => exact algebraMap _ _
  | add _ _ y hy ihx ihy => exact add _ _ _ hy ihx ihy
  | mul _ _ y hy ihx ihy => exact mul _ _ _ hy ihx ihy

===== Proof 3187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using Subalgebra.mem_adjoin_induction with
  | h_set x hx => exact mem x hx
  | h_zero => exact (algebraMap_mem _ 0).2 (map_zero (algebraMap R A))
  | h_one => exact (algebraMap_mem _ 1).2 (map_one (algebraMap R A))
  | h_add x hx y hy h‚ÇÅ h‚ÇÇ => exact add x hx y hy h‚ÇÅ h‚ÇÇ
  | h_mul x hx y hy h‚ÇÅ h‚ÇÇ => exact mul x hx y hy h‚ÇÅ h‚ÇÇ

===== Proof 3188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction with
  | h_set x hx => exact mem x hx
  | h_algebraMap r => exact algebraMap r
  | h_add x y _ _ ihx ihy => exact add x _ y _ ihx ihy
  | h_mul x y _ _ ihx ihy => exact mul x _ y _ ihx ihy

===== Proof 3189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  revert hx
  revert x
  apply adjoin_induction
  exact mem
  exact algebraMap
  exact fun x y => add x y
  intro x y
  exact mul x y

===== Proof 3190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx with
  | basic _ h => exact mem _ h
  | zero => exact (algebraMap 0).symm ‚ñ∏ algebraMap _
  | one => exact (algebraMap 1).symm ‚ñ∏ algebraMap _
  | add _ _ _ _ ihx ihy => exact add _ _ _ _ ihx ihy
  | mul _ _ _ _ ihx ihy => exact mul _ _ _ _ ihx ihy

===== Proof 3191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction' with
  | algebraMap r => exact algebraMap r
  | add x y hx hy ihx ihy => exact add x y hx hy ihx ihy
  | mul x y hx hy ihx ihy => exact mul x y hx hy ihx ihy
  | mem x hx => exact mem x hx

===== Proof 3192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin.induction_on with
  | h_basic x hx => exact mem x hx
  | h_algebraMap r => exact algebraMap r
  | h_add x hx y hy ihx ihy => exact add x hx y hy ihx ihy
  | h_mul x hx y hy ihx ihy => exact mul x hx y hy ihx ihy

===== Proof 3193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  refine' adjoin_induction'' hx _ _ _ _ mem algebraMap add mul
  intros
  simpa using mul _ _ _ _ _ _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫

===== Proof 3194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  refine' Submodule.span_induction hx _ _ _ _
  exacts [fun x hx => mem x hx, fun r => algebraMap r, fun x y => add x y, fun x y => mul x y]

===== Proof 3195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction with
  | h_set x hx => exact mem x hx
  | h_algebraMap r => exact algebraMap r
  | h_add x y hx hy hx' hy' => exact add x hx y hy hx' hy'
  | h_mul x y hx hy hx' hy' => exact mul x hx y hy hx' hy'

===== Proof 3196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  refine' adjoin_induction hx _ _ _ _
  all_goals aesop

===== Proof 3197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  refine' adjoin_induction hx _ (mem _) (fun r => _) (fun _ _ => _) fun _ _ => _
  all_goals aesop

===== Proof 3198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx with
  | basic h => exact mem _ h
  | algebraMap r => exact algebraMap _ r
  | add x hx y hy _ _ ihx ihy => exact add _ _ _ _ ihx ihy
  | mul x hx y hy _ _ ihx ihy => exact mul _ _ _ _ ihx ihy

===== Proof 3199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction with
  | h_mul x y => exact mul x y _ _ _ _ hy (mem y hy)
  | h_add x y => exact add x x y _ hy (mem y hy)
  | _ h => exact mem x h
  | _ => exact algebraMap _ _

===== Proof 3200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ‚àà adjoin R s)
    {p : (x : A) ‚Üí x ‚àà adjoin R s ‚Üí Prop} (mem : ‚àÄ x (h : x ‚àà s), p x (subset_adjoin h))
    (algebraMap : ‚àÄ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x + y) (add_mem hx hy))
    (mul : ‚àÄ x hx y hy, p x hx ‚Üí p y hy ‚Üí p (x * y) (mul_mem hx hy)) :
    p x hx := by
  induction hx using adjoin_induction with
  | basic h => exact mem _ h
  | algebraMap r => exact algebraMap _
  | add x hx y hy hx hy => exact add _ hx _ hy hx hy
  | mul x hx y hy hx hy => exact mul _ hx _ hy hx hy

===== Proof 3201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  simp [Œπ_comp_lift]

===== Proof 3202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  ext ‚ü®x‚ü©; prepare_simp; simp [Œπ_def, lift_Œπ_apply]

===== Proof 3203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  rw [‚Üê (FreeAlgebra.lift_symm (R := R) (X := X) (A := A) g).2]
  rfl

===== Proof 3204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  rw [‚Üê (lift R).apply_symm_apply g]
  rw [lift R]
  apply congrArg (lift R).symm
  rfl

===== Proof 3205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  refine' FreeAlgebra.hom_ext' _ _ _ (fun x => _)
  dsimp only [FreeAlgebra.lift_apply, Function.comp_apply, FreeAlgebra.Œπ_apply, ‚Üê AlgHom.comp_apply]
  rw [AlgHom.comp_apply, lift_Œπ_apply]

===== Proof 3206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  rw [‚Üê (free R X).lift_comp_Œπ, AlgHom.ext_iff]
  simp

===== Proof 3207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply Eq.symm
  rw [‚Üê (lift R).apply_symm_apply g]
  rw [lift_symm_apply]
  rfl

===== Proof 3208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  ext x
  simp [lift_Œπ_apply]

===== Proof 3209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  rw [Œπ_comp_lift]

===== Proof 3210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  simp_rw [lift_Œπ_apply]
  rfl

===== Proof 3211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply hom_ext
  intro x
  dsimp
  simp [Œπ_lift, g.map_mul]

===== Proof 3212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  rw [‚Üê (FreeAlgebra.lift R).apply_symm_apply g]
  apply (FreeAlgebra.lift R).symm_apply_apply

===== Proof 3213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  ext
  simp [lift_Œπ_apply]

===== Proof 3214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply lift.symm_apply_eq.1
  simp only [lift_symm_apply, Function.comp_apply, Œπ_comp_lift]

===== Proof 3215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  ext; simp [lift_Œπ_apply]

===== Proof 3216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  ext; simp [lift_Œπ_apply]

===== Proof 3217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  rw [‚Üê Unique.default_eq g]
  rfl

===== Proof 3218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply Eq.symm
  apply g.coind_algHom

===== Proof 3219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply lift_unique
  simp only [Function.comp]
  intro x
  rfl

===== Proof 3220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply algHom_ext
  intro x
  simp only [Œπ_apply, Function.comp_apply, lift_Œπ_apply]
  rfl

===== Proof 3221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  rw [‚Üê (FreeAlgebra.lift R).apply_symm_apply g]
  simp [Œπ_comp_lift]

===== Proof 3222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply lift.unique
  intro x
  simp

===== Proof 3223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply FreeAlgebra.hom_ext; intro x;
  simp [‚Üê AlgHom.comp_apply, Function.comp]

===== Proof 3224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply Algebra.Hom.ext
  intro x
  apply FreeAlgebra.lift_Œπ_apply

===== Proof 3225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  rw [‚Üê lift_Œπ_apply]
  simp

===== Proof 3226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  ext x
  simp only [Œπ_eq_of, lift_Œπ_apply, Function.comp_apply]

===== Proof 3227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply lift.unique; simp [Œπ_comp_lift]

===== Proof 3228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  rw [AlgHom.ext_iff]
  intro x
  rw [AlgHom.comp_apply, lift_Œπ_apply]
  rfl

===== Proof 3229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply Eq.symm
  apply lift.unique
  intro x
  apply g.commutes

===== Proof 3230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply Eq.symm
  apply lift_unique
  simp

===== Proof 3231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  apply g.ext
  intro x
  induction x <;> simp [*, map_add, map_mul]

===== Proof 3232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_Œπ (g : FreeAlgebra R X ‚Üí‚Çê[R] A) :
    lift R ((g : FreeAlgebra R X ‚Üí A) ‚àò Œπ R) = g := by
  ext a
  apply induction_on a
  ¬∑ simp
  ¬∑ simp
  ¬∑ simp
  ¬∑ simp

===== Proof 3233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by assumption

===== Proof 3234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply top_unique
  intro x hx
  have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
  rwa [inv_one, one_mul] at this

===== Proof 3235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  aesop

===== Proof 3236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  haveI := h
  exact
    Subgroup.eq_top_of_card_eq _
      (by
        haveI := QuotientGroup.fintype G H
        simp_rw [Fintype.card_eq_one_iff]
        refine ‚ü®‚ü®1, fun x => ?_‚ü©, ‚ü®x, fun y => ?_‚ü©‚ü© <;>
          simpa using QuotientGroup.eq.1 (Subsingleton.elim _ _))

===== Proof 3237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  /-
  To prove that a subgroup \( H \) of a group \( G \) is equal to the top subgroup \( \top \) given that the quotient group \( G / H \) is a subsingleton, we proceed as follows:
  
  1. We need to show that \( H \) is the top subgroup, which means every element of \( G \) is in \( H \).
  2. Given that \( G / H \) is a subsingleton, for any two elements \( x \) and \( y \) in \( G \), their cosets \( xH \) and \( yH \) must be equal.
  3. This implies that \( x \) and \( y \) differ by an element of \( H \). Specifically, \( x \) and \( y \) must lie in the same coset of \( H \).
  4. Since \( 1 \) is the identity element in \( G \), the coset \( 1H \) is the same as \( H \).
  5. Therefore, \( x \) must be in \( H \) for any \( x \) in \( G \).
  6. This establishes that \( H \) is indeed the top subgroup \( \top \).
  -/
  refine'
  (eq_top_iff _).mpr fun x _ => _
  have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
  rwa [inv_one, one_mul] at this

===== Proof 3238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  exact ‚ü®fun x _ => by simpa using congr_arg (QuotientGroup.mk (H := H)) (Subsingleton.elim _ _)‚ü©

===== Proof 3239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  let S := {n : ‚Ñï | 0 < n ‚àß ‚àÉ x, x ^ n = a ‚àß x ‚â† 1}
  let n := sSup S
  have hn : n ‚àà S := sSup_mem (nonempty_of_mem (by simp)) (by simp)
  obtain ‚ü®x, hx, hx'‚ü© := hn.1.exists_prime_orderOf_dvd_of_ne_one hn.2
  simp_rw [hx, ‚Üê pow_dvd_pow_iff hx.ne'] at hx'
  exact (hx.dvd_of_dvd hx').eq_one_of_lt hn.1.1

===== Proof 3240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  dsimp only [eq_top_iff, Subgroup.mem_top]
  aesop

===== Proof 3241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  exact fun x _ => by
    have : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this

===== Proof 3242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  refine' top_unique fun x _ => _
  have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
  rwa [inv_one, one_mul] at this

===== Proof 3243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  /-
  We aim to show that if the quotient group \( G / H \) is a subsingleton, then the subgroup \( H \) must be the whole group \( G \). This is achieved by demonstrating that any element \( x \) in \( G \) must belong to \( H \).
  1. Start by considering the identity element \( 1 \) in \( G \).
  2. Since \( G / H \) is a subsingleton, the cosets of any two elements in \( G \) are equal. In particular, the cosets of \( 1 \) and \( x \) are equal.
  3. This implies that the product \( 1^{-1} \cdot x \) belongs to \( H \).
  4. Simplifying \( 1^{-1} \cdot x \) gives \( x \), thus \( x \) must belong to \( H \).
  5. Therefore, \( H \) contains all elements of \( G \), implying \( H = G \).
  -/
  refine' top_unique fun x _ => _
  have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
  rwa [inv_one, one_mul] at this

===== Proof 3244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  let GAME := ‚ü®10, 5, by decide, by decide‚ü©
  let GOODBYE := ‚ü®5, 10, by decide, by decide‚ü©
  decide

===== Proof 3245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply Eq.symm
  apply le_antisymm
  apply fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
  apply fun x _ => by
    rw [eq_comm]
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this

===== Proof 3246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply Eq.symm
  ext x
  simp

===== Proof 3247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  have : Subsingleton (G ‚ß∏ H) ‚Üî H = ‚ä§ := by
    constructor <;> intro h
    ¬∑ ext x
      have : (1 : G) * x‚Åª¬π ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
      rwa [one_mul] at this
    ¬∑ exact QuotientGroup.subsingleton_quotient_of_mem_top H
  exact this.1 h

===== Proof 3248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  have := h
  rw [subsingleton_iff] at this
  rw [subsingleton_iff]
  intro x hx y hy
  have h1 : y * x‚Åª¬π = 1 := by
    rw [‚Üê Subgroup.inv_mem_iff] at hx
    rw [‚Üê mul_right_inj x]
    simp [hx, mul_assoc]
  have h2 : x * y‚Åª¬π = 1 := by
    rw [‚Üê Subgroup.inv_mem_iff] at hy
    rw [‚Üê mul_right_inj y]
    simp [hy, mul_assoc]
  simp [h1, h2]

===== Proof 3249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  rw [eq_top_iff]
  intro x _
  have : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
  rwa [inv_one, one_mul] at this

===== Proof 3250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply Eq.symm
  apply eq_top_iff.2
  intro x _
  exact one_mul x

===== Proof 3251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  simp only [top_unique, true_and]
  aesop

===== Proof 3252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply top_unique
  intro x hx
  have : (1 : G)‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
  rwa [inv_one, one_mul] at this

===== Proof 3253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply theorem_subgroup_eq_top_of_subsingleton
  assumption

===== Proof 3254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  exact h

===== Proof 3255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  have : False := by
    have : (1 : ‚Ñï) ‚â† 2 := by decide
    contradiction
  contradiction

===== Proof 3256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  intro x _
  have := QuotientGroup.eq.1 (Subsingleton.elim _ _)
  rwa [inv_one, one_mul] at this

===== Proof 3257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by aesop

===== Proof 3258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  intros
  ring

===== Proof 3259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  exact h

===== Proof 3260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  /-
  We aim to show that if the quotient group \( G / H \) is a singleton for a subgroup \( H \) of \( G \), then \( H \) must be the entire group \( G \). This is done by demonstrating that any element \( x \) of \( G \) can be expressed as an element of \( H \), implying that \( H \) contains all elements of \( G \).
  
  1. Consider the quotient group \( G / H \) and assume it is a singleton.
  2. For any element \( x \) in \( G \), the product \( 1^{-1} \cdot x \) must also be in \( H \) because \( 1^{-1} = 1 \) and \( 1 \cdot x = x \).
  3. Since \( G / H \) is a singleton, the cosets \( 1 \) and \( x \) must be the same, implying \( x \in H \).
  4. Therefore, \( H \) contains all elements of \( G \), making \( H = G \).
  -/
  apply top_unique
  intro x _
  have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
  rwa [inv_one, one_mul] at this

===== Proof 3261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  exact top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this

===== Proof 3262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  refine' fun H1 H2 => h.elim' _
  rintro a b
  rcases QuotientGroup.eq.1 (Subsingleton.elim _ _) with ‚ü®c, hc‚ü©
  rw [‚Üê mul_one a, ‚Üê mul_one b, ‚Üê inv_one, ‚Üê mul_inv_rev, ‚Üê mul_assoc, ‚Üê mul_assoc,
    ‚Üê mul_assoc (c‚Åª¬π * b), hc, mul_assoc, mul_inv_self, mul_one, mul_assoc, mul_inv_self,
    mul_one] at hc
  exact Subgroup.mul_mem _ (H1 hc) (H2 hc)

===== Proof 3263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply Eq.symm
  rw [eq_comm]
  apply QuotientGroup.subsingleton_iff.mp h

===== Proof 3264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)) : H = ‚ä§ :=
  top_unique fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  exact fun x _ => by
    have this : 1‚Åª¬π * x ‚àà H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this

===== Proof 3265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm a, add_comm _ b]
  exact add_le_add_left tsub_le_tsub_left_of_le b

===== Proof 3266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  rw [add_comm]
  linarith

===== Proof 3267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  linarith

===== Proof 3268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm a b]
  apply le_of_lt
  tauto

===== Proof 3269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  apply le_of_sub_nonneg
  simp only [sub_nonneg]
  rw [add_comm a, add_comm _ c]
  nlinarith

===== Proof 3270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  tauto

===== Proof 3271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  linarith

===== Proof 3272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  linarith

===== Proof 3273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  apply le_of_eq
  rw [add_sub_assoc]

===== Proof 3274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  apply le_of_sub_nonneg
  rw [sub_nonneg]
  linarith

===== Proof 3275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  linarith

===== Proof 3276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  rw [add_comm]
  linarith

===== Proof 3277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm]
  exact le_add_of_nonneg_right (by linarith)

===== Proof 3278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  linarith

===== Proof 3279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm]
  apply le_of_sub_nonneg
  rw [tsub_le_iff_left]
  linarith

===== Proof 3280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm]
  apply le_of_not_gt
  intro h
  have h' := tsub_le_iff_right.mp h
  linarith

===== Proof 3281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm a]
  exact le_add_tsub

===== Proof 3282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm a b]
  apply le_of_sub_nonneg
  rw [sub_nonneg]
  linarith

===== Proof 3283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  linarith

===== Proof 3284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm]
  linarith

===== Proof 3285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm]
  apply le_of_eq
  rw [add_comm]
  apply Add.add_tsub_le_add_tsub

===== Proof 3286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  apply le_of_sub_nonneg
  rw [sub_add_eq_sub_sub, sub_nonneg]
  exact le_add_of_nonneg_right (by assumption)

===== Proof 3287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm]
  apply le_of_sub_nonneg
  simp only [add_sub_assoc, add_sub_cancel, sub_add_cancel, sub_sub_sub_cancel_right,
    sub_nonneg, add_le_add_iff_left, add_right_comm, add_sub_cancel, sub_eq_add_neg,
    neg_add_rev, neg_neg, add_comm, add_left_comm, add_assoc]
  linarith

===== Proof 3288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm a b]
  apply le_of_sub_nonneg
  simp only [tsub_le_iff_right, add_left_comm, add_assoc]
  apply le_add_of_nonneg_right
  apply le_refl

===== Proof 3289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  cases h : b - c
  case zero => simp
  case succ b' =>
    have : a + (b' + 1) - c ‚â§ a + (b' + 1 - c) := by
      cases h' : c
      case zero => simp
      case succ c' =>
        cases h'' : b'
        case zero => simp
        case succ b'' =>
          have : a + (b'' + 1 + 1) - (c' + 1) ‚â§ a + (b'' + 1 + 1 - (c' + 1)) := by
            simp_all
          linarith
    linarith

===== Proof 3290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm a b]
  exact le_add_tsub

===== Proof 3291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm a b]
  apply le_of_sub_nonneg
  rw [sub_nonneg]
  linarith

===== Proof 3292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  linarith

===== Proof 3293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  linarith

===== Proof 3294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_eq_zero_iff_le]
  exact le_add_tsub

===== Proof 3295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [add_comm a b]
  apply le_of_sub_nonneg
  simp only [add_sub_assoc, sub_add_eq_sub_sub, add_comm]
  apply sub_nonneg_of_le
  linarith

===== Proof 3296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ‚â§ a + (b - c) := by
  rw [tsub_le_iff_left]
  ring_nf
  linarith

===== Proof 3297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply Finsupp.sum_congr rfl
  intro i c hc
  apply mul_left_cancel‚ÇÄ
    (show _ ‚â† 0 from (mem_support_iff.mp hc).ne')
  simp only [eval‚ÇÇ_eq_sum, coeff_sum, coeff_monomial, mul_boole]
  exact Finset.sum_congr rfl (fun j hj => h hj (mem_support_iff.mp hj).ne')

===== Proof 3298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  rw [eval‚ÇÇ_eq_sum, eval‚ÇÇ_eq_sum]
  apply Finset.sum_congr rfl
  intro c hc
  apply mul_left_cancel‚ÇÄ (show _ ‚â† 0 from coeff_sum_ne_zero.mpr hc)
  simp only [smul_eq_mul, sum_mul, mul_assoc, coeff_mul_C, coeff_C_mul, coeff_sum]
  apply Finset.sum_congr rfl
  intro i hi
  apply Finset.sum_congr rfl
  intro j hj
  apply h (show _ ‚àà _ from hi) (show _ ‚â† 0 from hj)

===== Proof 3299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply Finsupp.sum_congr rfl
  intro i hi
  apply Finset.sum_congr rfl
  intro j hj
  simp_all

===== Proof 3300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  induction p using Polynomial.induction_on' with
  | h_add p q hp hq =>
    simp only [add_comp, hp, hq]
  | h_monomial n a =>
    simp only [eval‚ÇÇ_monomial, one_mul]
    apply Finset.sum_congr rfl
    intros
    simp [h]

===== Proof 3301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply eval‚ÇÇ_congr _ _ h <;> aesop

===== Proof 3302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply p.induction_on (fun e => by simp_all) <;>
  simp (config := { contextual := true }) [add_left, add_right, mul_left, mul_right, h]

===== Proof 3303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply p.induction_on (f := fun p => p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ)
  case h_C => simp
  case h_add p q hp hq =>
    simp_all [add_eq_zero_iff]
  case h_X p n hp =>
    simpa [hp] using h (c := Finsupp.single n 1) (by simp) (by simp)

===== Proof 3304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  induction p using MvPolynomial.induction_on generalizing g‚ÇÅ g‚ÇÇ <;> simp_all
  aesop

===== Proof 3305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  have : (setOf fun i => ‚àÉ c : œÉ ‚Üí‚ÇÄ ‚Ñï, i ‚àà c.support ‚àß c ‚â† 0 ‚àß coeff c p ‚â† 0) = ‚àÖ := by
    ext
    simp [h]
  rw [eval‚ÇÇ, eval‚ÇÇ, this, Finset.sum_empty, Finset.sum_empty]

===== Proof 3306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  induction p
  case zero => rfl
  all_goals simp_all [eval‚ÇÇ_add, eval‚ÇÇ_mul, coeff_add, coeff_mul]
  all_goals
    apply h <;> simp_all [Finsupp.mem_support_iff, coeff_add, coeff_mul]

===== Proof 3307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply Finset.sum_congr rfl
  intro n hn
  simp only [eval‚ÇÇ_eq_sum, Finsupp.sum, coeff_add]
  apply Finset.sum_congr rfl
  intro d hd
  simp only [add_monoid_hom.map_add, coeff_add]
  split_ifs with h1 h2 h3
  ¬∑ simp [h d hd h1]
  ¬∑ simp
  ¬∑ simp
  ¬∑ simp

===== Proof 3308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  simp_rw [eval‚ÇÇ_eq_sum, sum_def]
  apply sum_congr rfl
  intros i c h‚ÇÅ h‚ÇÇ
  simp_rw [Finsupp.mem_support_iff, ne_eq] at h‚ÇÅ
  simp [h i c h‚ÇÅ h‚ÇÇ]

===== Proof 3309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply p.eval‚ÇÇ_congr_of_support f _ _ h
  intro i c hc hc'
  simpa using h hc hc'

===== Proof 3310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  rw [eval‚ÇÇ_eq_sum, eval‚ÇÇ_eq_sum]
  apply Finset.sum_congr rfl
  intros
  simp [h]

===== Proof 3311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  induction p using MVarId.induction_on
  all_goals
    simp_all only [eval‚ÇÇ_C, eval‚ÇÇ_X, coeff_C, coeff_X, finsupp_apply, ne_eq, one_ne_zero]
  aesop

===== Proof 3312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply Finset.sum_congr rfl
  intros
  simp only [*]
  congr
  apply h
  assumption
  assumption

===== Proof 3313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  rw [Polynomial.eval‚ÇÇ_eq_sum, Polynomial.eval‚ÇÇ_eq_sum]
  apply Finset.sum_congr rfl
  intro c hc
  apply Finset.prod_congr rfl
  intro i hi
  exact h hi ‚ü®Finset.mem_of_mem_filter hi, (Finset.mem_filter.mp hc).2‚ü©

===== Proof 3314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  induction' p using MvPolynomial.induction_on with p‚ÇÅ p‚ÇÇ a s ih‚ÇÅ ih‚ÇÇ
  ¬∑ simp only [eval‚ÇÇ_C, eq_self_iff_true, forall_const]
  ¬∑ simp only [eval‚ÇÇ_add, ih‚ÇÅ, ih‚ÇÇ, add_right_inj]
  ¬∑ simp only [pow_zero, pow_one, mul_comm, eval‚ÇÇ_mul_nonzero _ _ h, ih‚ÇÅ, ih‚ÇÇ]

===== Proof 3315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply p.induction_on_subsingleton (P := fun x ‚Ü¶ x.eval‚ÇÇ f g‚ÇÅ = x.eval‚ÇÇ f g‚ÇÇ)
  case h‚ÇÄ =>
    simp only [zero_eval‚ÇÇ, eq_self_iff_true, forall_const]
  case h‚ÇÅ =>
    intro x
    simp only [coeff_monomial, Finset.mem_singleton, forall_eq]
    split_ifs with hx
    ¬∑ simp [hx, h]
    ¬∑ rfl
  case h‚ÇÇ =>
    intro x y
    simp_all (config := { contextual := true })

===== Proof 3316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply Finset.sum_congr rfl
  intro c hc
  apply Finset.prod_congr rfl
  intro i hi
  simp only [mem_support_iff, ne_eq, mul_eq_zero] at hc
  specialize h hi hc
  simp [h]

===== Proof 3317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply MvPolynomial.induction_on p <;>
    simp (config := { contextual := true }) [*]
  <;> aesop

===== Proof 3318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  induction p using Polynomial.induction_on'
  case h_add p q hp hq =>
    simp only [hp, hq, eval‚ÇÇ_add, ‚Üê Finset.sum_add_distrib]
    apply Finset.sum_congr rfl
    intro d hd
    apply h
    simpa using hd
  case h_monomial n a =>
    simp only [eval‚ÇÇ_monomial, Finsupp.prod]
    apply Finset.prod_congr rfl
    intro i hi
    apply h
    simpa using hi

===== Proof 3319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  simp only [eval‚ÇÇ_eq_sum, Finsupp.sum, mul_comm, mul_left_comm, mul_assoc, add_comm,
    add_left_comm, add_assoc]
  apply Finset.sum_congr rfl
  intro i hi
  apply Finset.sum_congr rfl
  intro c hc
  simp_all

===== Proof 3320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply eval‚ÇÇ_congr
  exact h

===== Proof 3321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  induction p using MvPolynomial.induction_on <;> clear! p
  ¬∑ simp_all
  ¬∑ simp_all
  ¬∑ simp_all only [add_assoc]

===== Proof 3322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply Eq.symm
  apply eq_of_sub_eq_zero
  apply Polynomial.eval‚ÇÇ_hom_eq_zero
  intros i c hc hc'
  simpa [hc, hc'] using h hc hc'

===== Proof 3323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply Finset.sum_congr rfl
  rintro n c hnc ‚ü®hcp‚ü©
  simpa [hnc, hcp] using h hnc hcp

===== Proof 3324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  rw [eval‚ÇÇ_own]
  rw [eval‚ÇÇ_own]
  congr 1
  rw [Finsupp.prod]
  apply Finset.prod_congr rfl
  intro i hi
  rw [h hi]

===== Proof 3325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  classical
    rw [p.as_sum]
    apply Finset.sum_congr rfl fun c _ => ?_
    simp only [eval‚ÇÇ_single]
    apply MonoidHom.map_mclosure _ ?_
    exact
      h
        (i := c)
        (c := c)
        (by simp (config := { contextual := true }) [coeff_fun, coeff_def])
        (by classical simp (config := { contextual := true }) [coeff_fun, coeff_def])

===== Proof 3326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  rw [eval‚ÇÇ_apply f g‚ÇÅ, eval‚ÇÇ_apply f g‚ÇÇ]
  exact Finsupp.sum_congr rfl (fun c hc => by
    congr 1
    exact h hc (mem_support_iff.1 hc))

===== Proof 3327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  simp_all [Finsupp.prod]

===== Proof 3328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval‚ÇÇ_congr (g‚ÇÅ g‚ÇÇ : œÉ ‚Üí S‚ÇÅ)
    (h : ‚àÄ {i : œÉ} {c : œÉ ‚Üí‚ÇÄ ‚Ñï}, i ‚àà c.support ‚Üí coeff c p ‚â† 0 ‚Üí g‚ÇÅ i = g‚ÇÇ i) :
    p.eval‚ÇÇ f g‚ÇÅ = p.eval‚ÇÇ f g‚ÇÇ := by
  rw [eval‚ÇÇ_eq_sum]
  simp_rw [eval‚ÇÇ_eq_sum]
  apply congr_arg
  ext d
  apply Finset.sum_congr rfl
  intros
  simp [h]

===== Proof 3329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson]
  simp [sub_eq_neg_add, add_pow]
  simp [add_comm, add_left_comm, add_assoc, mul_comm, mul_left_comm, mul_assoc]

===== Proof 3330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  have h := dickson_one_one_charP p
  rw [h]
  rfl

===== Proof 3331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson, geom_sum_def, Finset.sum_range_succ, Finset.sum_range_zero, add_zero]
  simp [mul_add, add_mul, pow_succ, (Fact.out : p.Prime).ne_zero]

===== Proof 3332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  apply Polynomial.funext
  intro x
  simp only [Polynomial.eval_X, Polynomial.coeff_X_pow, eq_intCast, Int.cast_one, one_pow]
  rw [‚Üê sub_eq_zero]
  simp only [sub_eq_add_neg, Polynomial.eval_add, Polynomial.eval_X_pow,
    Polynomial.eval_add, Polynomial.eval_X_pow, Polynomial.eval_neg, Polynomial.eval_one]
  rw [‚Üê sub_eq_zero]
  simp only [sub_eq_add_neg, Polynomial.eval_add, Polynomial.eval_X_pow,
    Polynomial.eval_add, Polynomial.eval_X_pow, Polynomial.eval_neg, Polynomial.eval_one]
  apply Ring.dickson_one_one_pow_charP

===== Proof 3333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson]
  have h := (expand_X R p).symm
  simp only [iterate_map, mul_one, one_comp] at h
  simp only [h, add_comm, ‚Üê add_assoc]
  simp [expand_eq_sum_X_pow]

===== Proof 3334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson_eq_X_pow (zero_le p), one_pow]

===== Proof 3335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson, X_pow_eq_monomial, mul_one, one_mul, map_dite, MonoidHom.coe_mul,
    map_pow, map_X, map_one]
  apply Polynomial.funext
  intro n
  rw [Polynomial.eval_pow, Polynomial.eval_X, pow_one]
  cases' n with n
  ¬∑ simp [ofNat_zero, zero_eq]
  ¬∑ simp only [Nat.succ_eq_add_one, ofNat_add, ofNat_one]
    symm
    rw [add_comm, pow_add, pow_one]
    have h := (CharP.cast_eq_zero_iff R p n.succ).mpr (dvd_refl p)
    simp [h, pow_succ']

===== Proof 3336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson]
  simp [add_comm, pow_succ]

===== Proof 3337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  have : p ‚â† 0 := (Fact.out (p := p.Prime)).ne_zero
  simp_rw [dickson_one_one_eq_X_pow, map_pow, map_X]

===== Proof 3338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  ext
  simp only [coeff_dickson, if_true, ge_iff_le, coeff_X_pow]
  split_ifs with h
  ¬∑ simp_all [‚Üê pow_add]
  ¬∑ simp_all [‚Üê pow_add]

===== Proof 3339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson, map_X, map_natCast]
  simp

===== Proof 3340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson, map_prod (algebraMap ‚Ñï R) (fun i : Fin p => X - C (1 : R)) fun i => by
    apply const_injective
    simp [Fact.out.one_lt]
  ]
  simp [Finset.prod_const, Finset.card_fin, eval‚ÇÇ_X]

===== Proof 3341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson, X_pow_eq_monomial, one_pow, mul_one, sum_monomial_index, Nat.cast_one,
    mul_comm, map_one]
  apply sum_hom
  intro i hi
  simp only [RingHom.map_pow, map_one, one_pow, one_mul]
  apply pow_charP

===== Proof 3342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simpa [dickson] using (sum_pow_X_pow_eq_zero (R := R) (f := 1) (n := p) (by simp))

===== Proof 3343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp [dickson, pow_succ]

===== Proof 3344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson]
  simp [X, mul_comm]

===== Proof 3345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson_apply, map_one, one_pow, one_mul]
  by_cases hp : p = 0
  ¬∑ simp_all
  rw [pow_add, pow_one]

===== Proof 3346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson, X_pow_eq_monomial, one_pow, mul_one, add_monoid_algebra.single_pow, map_pow,
    AddSubmonoid.coe_finset_prod, map_mul, MonoidHom.one_apply,
    AddSubmonoid.coe_eq_bot_of_subsingleton]
  rfl

===== Proof 3347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson, map_prod, map_pow, map_add, map_sub, map_mul, map_neg, map_one]
  rw [prod_range_succ, prod_range_succ, prod_range_succ]
  simp [prod_range_succ, pow_succ, (by decide : p - 0 = p)]

===== Proof 3348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  ext
  simp [coeff_X_pow, coeff_dickson, Nat.mod_eq_of_lt, lt_of_lt_of_le (by decide : 0 < p) (Nat.le_add_left p 1)]

===== Proof 3349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson, map_pow, map_X, one_pow]
  rfl

===== Proof 3350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson, one_pow, mul_one]
  have h := (binomial_expansion R p).symm
  simpa [h] using (Commute.one_left (X : R[X])).add_pow p

===== Proof 3351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson_one_one]
  simp [CharP.cast_eq_zero, add_pow, one_pow, mul_one]

===== Proof 3352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson_one_one, pow_zero, one_mul, one_pow, Nat.cast_zero, zero_add, Nat.cast_one,
    one_mul, pow_one]
  simp only [pow_add, pow_mul, pow_one, pow_zero, one_mul, one_pow]
  simp [add_comm, mul_comm, mul_assoc, mul_left_comm]

===== Proof 3353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  ext; simp [dickson_def, geom_sum_mul, mul_comm]

===== Proof 3354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp_all [dickson]

===== Proof 3355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson, map_X, dickson_one_one_charP_aux]

===== Proof 3356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  ext
  simp [Finset.sum_range_succ, pow_succ']

===== Proof 3357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  rw [dickson, map_dickson, Polynomial.map_pow, Polynomial.map_X, map_one]

===== Proof 3358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson, map_sub, map_pow, map_mul, map_add]
  simp only [sub_self, pow_one, mul_one, mul_comm, sub_eq_iff_eq_add]
  ring

===== Proof 3359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [dickson, X_pow_eq_monomial, sum_monomial_eq, Nat.cast_one, one_pow, mul_one]
  apply sum_congr rfl
  simp (config := { contextual := true }) [pow_succ, (by simp : ‚àÄ k : ‚Ñï, k < p ‚Üí (k + 1 : ‚Ñï) = 1 ‚Üí k = 0)]

===== Proof 3360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ‚Ñï) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp [dickson_eq_X_pow, Fact.out]

===== Proof 3361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  rw [mfderivWithin, mfderivWithin, (hf.hasMFDerivWithinAt.comp x hg.hasMFDerivWithinAt h)]
  rfl

===== Proof 3362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  apply HasMFDerivWithinAt.comp
  exact hg.hasMFDerivWithinAt
  exact hf.hasMFDerivWithinAt
  simp [h]
  simp [hxs]

===== Proof 3363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp_of_mem _ hf hg h
  simpa using hxs

===== Proof 3364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  ¬∑ exact (hg.comp x hf h).mfderivWithin hxs

===== Proof 3365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp h
  exact hxs.mono h

===== Proof 3366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp_of_mem _ h
  simp_all

===== Proof 3367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  exact HasMFDerivWithinAt.comp x hg.hasMFDerivWithinAt hf.hasMFDerivWithinAt h

===== Proof 3368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  apply HasMFDerivWithinAt.comp x hg.hasMFDerivWithinAt hf.hasMFDerivWithinAt h

===== Proof 3369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  exact HasMFDerivWithinAt.comp x (hg.hasMFDerivWithinAt) (hf.hasMFDerivWithinAt) h hxs

===== Proof 3370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp_of_mem _ h hxs
  simp [hf, hg]

===== Proof 3371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  rw [show g ‚àò f = fun x => g (f x) by rfl]
  exact mfderivWithin_comp' hf hg hxs

===== Proof 3372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  rw [mfderivWithin_eq_inter' hxs]
  rw [mfderivWithin_eq_inter' hxs]
  rw [mderivWithin_comp x hg hf h]

===== Proof 3373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp' hg hf h hxs

===== Proof 3374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp (show MDifferentiableAt I' I'' g (f x) from hg) _ h _
  exact hf
  simpa using h
  simpa using hxs

===== Proof 3375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp_of_mem hg hf h
  simpa [mem_preimage] using hxs

===== Proof 3376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  classical
  simp_rw [mfderivWithin, comp_apply]
  apply congrArg (fun f' => f' 1)
  have h1 : f =·∂†[ùìù[s] x] (fun x' => f x') := by
    apply eventuallyEq_of_mem self_mem_nhdsWithin
    simp
  have h2 : g =·∂†[ùìù[u] f x] (fun x' => g x') := by
    apply eventuallyEq_of_mem self_mem_nhdsWithin
    simp
  exact (hf.1.comp x hg.1).hasFDerivWithinAt_iff_of_mem_nhdsWithin (h1.hasFDerivWithinAt_iff h2)
    h hxs

===== Proof 3377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  rw [mdifferentiableWithinAt_iff] at *
  rw [mdifferentiableWithinAt_iff] at *
  rw [mdifferentiableWithinAt_iff] at *
  rw [mfderivWithin, mfderivWithin, mfderivWithin, if_pos hxs]
  rw [if_pos, if_pos]
  convert h.comp hf.1
  simp only [Set.mem_preimage, mfld_simps]
  tauto

===== Proof 3378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin _ hxs
  exact (hg.hasMFDerivWithinAt).comp x (hf.hasMFDerivWithinAt) h

===== Proof 3379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp (hg := hg) (hf := hf) (h := h) (hxs := hxs)

===== Proof 3380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  exact HasMFDerivWithinAt.comp x hg.hasMFDerivWithinAt hf.hasMFDerivWithinAt h

===== Proof 3381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin _ hxs
  exact (hg.hasMFDerivWithinAt.comp x hf.hasMFDerivWithinAt h).mono_of_mem h

===== Proof 3382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  exact HasMFDerivWithinAt.comp x hg.hasMFDerivWithinAt hf.hasMFDerivWithinAt h

===== Proof 3383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp hxs hg hf

===== Proof 3384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp
  <;> simp_all

===== Proof 3385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  rw [mdifferentiableWithinAt_iff] at *
  rw [mdifferentiableWithinAt_iff] at *
  simp only [*, mfld_simps, mfderivWithin]
  rfl

===== Proof 3386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin _ hxs
  exact (hg.hasMFDerivWithinAt).comp x (hf.hasMFDerivWithinAt) h

===== Proof 3387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply mfderivWithin_comp_of_mem _ hxs
  simpa only [mfld_simps] using hf

===== Proof 3388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  apply HasMFDerivWithinAt.comp
  exact hg.hasMFDerivWithinAt
  exact hf.hasMFDerivWithinAt
  exact h
  exact hxs

===== Proof 3389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  exact HasMFDerivWithinAt.comp x hg.hasMFDerivWithinAt hf.hasMFDerivWithinAt h

===== Proof 3390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  rw [mfderivWithin, mfderivWithin, (hf.hasMFDerivWithinAt.comp x hg.hasMFDerivWithinAt h).mfderivWithin hxs]
  rw [mdifferentiableWithinAt_iff] at hg hf
  simp [hg.1, hf.1]

===== Proof 3391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  exact HasMFDerivWithinAt.comp x hg.hasMFDerivWithinAt hf.hasMFDerivWithinAt h

===== Proof 3392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ‚äÜ f ‚Åª¬π' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ‚àò f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by
  apply HasMFDerivWithinAt.mfderivWithin
  exact HasMFDerivWithinAt.comp x hg.hasMFDerivWithinAt hf.hasMFDerivWithinAt h

===== Proof 3393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [continuous_iff_le_induced] at h‚ÇÇ ‚ä¢
   exact le_trans h‚ÇÇ h‚ÇÅ

===== Proof 3394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [continuous_iff_le_induced] at h‚ÇÇ ‚ä¢
   exact le_trans h‚ÇÇ h‚ÇÅ

===== Proof 3395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
  ¬∑ apply Continuous.mono h‚ÇÇ
    exact h‚ÇÅ

===== Proof 3396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact Continuous.mono h‚ÇÇ h‚ÇÅ

===== Proof 3397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact Continuous.mono h‚ÇÇ h‚ÇÅ

===== Proof 3398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   assumption

===== Proof 3399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact continuous_le_dom (le_trans (by exact h‚ÇÅ) (by exact h‚ÇÅ)) h‚ÇÇ

===== Proof 3400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   simpa only [@Continuous.continuous_iff _ _ _ _ t‚ÇÅ] using h‚ÇÇ.mono h‚ÇÅ

===== Proof 3401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
  ¬∑ apply h‚ÇÇ.of_le
    exact h‚ÇÅ

===== Proof 3402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   apply continuous_le h‚ÇÅ
    exact h‚ÇÇ

===== Proof 3403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [continuous_iff_le_basis] at h‚ÇÇ ‚ä¢
   exact h‚ÇÇ.trans (basis_sets t‚ÇÉ).ge

===== Proof 3404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   simpa only [@Continuous.comp_id _ _ t‚ÇÉ, @Continuous.comp_id _ _ t‚ÇÇ] using h‚ÇÇ.comp continuous_id

===== Proof 3405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact Continuous.mono h‚ÇÇ h‚ÇÅ

===== Proof 3406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   have h‚ÇÉ := h‚ÇÇ.comp (Continuous.id Œ±)
   exact Continuous.cast h‚ÇÉ

===== Proof 3407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
  ¬∑ exact (continuous_induced_dom.2 h‚ÇÇ).mono h‚ÇÅ le_rfl

===== Proof 3408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [config := { singlePass := true }]
   simpa [continuous_iff_le_induced] using h‚ÇÇ.mono h‚ÇÅ

===== Proof 3409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [continuous_iff_le_induced] at h‚ÇÇ ‚ä¢
   exact le_trans h‚ÇÇ h‚ÇÅ

===== Proof 3410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
  ¬∑ exact continuous_iff_le_induced.2 (le_trans h‚ÇÅ (continuous_iff_le_induced.1 h‚ÇÇ))

===== Proof 3411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [continuous_iff_le_induced] at h‚ÇÇ ‚ä¢
   exact le_trans h‚ÇÇ h‚ÇÅ

===== Proof 3412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [continuous_iff_continuousAt] at h‚ÇÇ ‚ä¢
   intro x
   apply ContinuousAt.mono_rng
   exact h‚ÇÇ x
   exact h‚ÇÅ

===== Proof 3413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [Continuous] at h‚ÇÇ ‚ä¢
   exact fun s hs ‚Ü¶ h‚ÇÇ s (h‚ÇÅ s hs)

===== Proof 3414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact Continuous.mono h‚ÇÇ h‚ÇÅ

===== Proof 3415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
  ¬∑ exact continuous_le_dom h‚ÇÅ h‚ÇÇ

===== Proof 3416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact Continuous.mono h‚ÇÇ h‚ÇÅ

===== Proof 3417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact Continuous.of_le_rng h‚ÇÅ h‚ÇÇ

===== Proof 3418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   apply continuous_le_dom h‚ÇÅ
   exact h‚ÇÇ

===== Proof 3419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact Continuous.of_le_rng h‚ÇÅ h‚ÇÇ

===== Proof 3420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
  ¬∑ exact Continuous.of_le_rng h‚ÇÅ h‚ÇÇ

===== Proof 3421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact Continuous.mono h‚ÇÇ h‚ÇÅ

===== Proof 3422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [Continuous] at h‚ÇÇ ‚ä¢
   exact fun s hs => h‚ÇÇ (h‚ÇÅ _ hs)

===== Proof 3423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   rw [continuous_iff_le_induced] at h‚ÇÇ ‚ä¢
   apply le_trans _ h‚ÇÅ
   exact h‚ÇÇ

===== Proof 3424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ t‚ÇÉ : TopologicalSpace Œ≤} (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ)
    (h‚ÇÇ : Continuous[t‚ÇÅ, t‚ÇÇ] f) : Continuous[t‚ÇÅ, t‚ÇÉ] f := by
   exact Continuous.mono h‚ÇÇ (le_trans h‚ÇÅ (le_refl t‚ÇÉ))

===== Proof 3425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring

===== Proof 3426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  norm_num [cos_pi_div_sixteen]

===== Proof 3427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring

===== Proof 3428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_two_mul, mul_assoc, ‚Üê pow_add]
  ring_nf
  norm_num

===== Proof 3429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen, sin_pi_div_sixteen]
, y‚ÇÇ, y‚ÇÉ : ‚Ñù
  simp only [div_pow, one_div, pow_one, pow_two, mul_one, mul_div_cancel_left]
  ring

===== Proof 3430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]

===== Proof 3431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring

===== Proof 3432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring_nf
  norm_num [cos_pi_div_sixteen]

===== Proof 3433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  norm_num [cos_pi_div_sixteen]

===== Proof 3434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring

===== Proof 3435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  norm_num [cos_pi_div_two, cos_pi_div_four, cos_pi_div_eight]

===== Proof 3436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_sq, sin_sq, add_comm]
  ring

===== Proof 3437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_sq, cos_pi_div_two, cos_pi_div_four, cos_pi_div_eight]
  ring_nf

===== Proof 3438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_sq, sin_sq, add_assoc, mul_assoc, mul_comm, mul_left_comm]
  ring

===== Proof 3439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]

===== Proof 3440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_fifteen]
  ring_nf

===== Proof 3441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp
  ring_nf
  <;> simp [cos_pi_div_sixteen]
  <;> ring_nf

===== Proof 3442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  norm_num [cos_pi_div_sixteen]

===== Proof 3443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring_nf
  norm_num [cos_pi_div_sixteen]

===== Proof 3444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  norm_num [cos_pi_div_sixteen]

===== Proof 3445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring

===== Proof 3446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring_nf
  <;> simp [cos_pi_div_sixteen]
  <;> ring_nf
  <;> simp [cos_pi_div_sixteen]
  <;> ring_nf
  <;> simp [cos_pi_div_sixteen]
  <;> ring_nf
  <;> simp [cos_pi_div_sixteen]
  <;> ring_nf

===== Proof 3447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring

===== Proof 3448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  norm_num [cos_pi_div_sixteen]

===== Proof 3449 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp
  ring_nf
  <;> norm_num <;> ring_nf
  <;> norm_num <;> ring_nf
  <;> norm_num <;> ring_nf
  <;> norm_num

===== Proof 3450 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp
  ring_nf
  norm_num
  <;> simp [cos_pi_div_sixteen]
  <;> ring_nf
  <;> norm_num
  <;> linarith

===== Proof 3451 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  rw [cos_pi_div_sixteen]

===== Proof 3452 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring

===== Proof 3453 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring_nf
  norm_num [cos_pi_div_sixteen]

===== Proof 3454 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_over_two_pow]
  ring_nf

===== Proof 3455 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen, ‚Üê sq, sq_sqrt, sq_sqrt, sq_sqrt]
  ring
  <;> ring
  <;> ring
  <;> ring

===== Proof 3456 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (œÄ / 16) = ‚àö(2 + ‚àö(2 + ‚àö2)) / 2 := by
  field_simp [cos_pi_div_sixteen]
  ring

===== Proof 3457 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  fixed_rule_2
  exact of_eq (fun a => by cases f a <;> rfl)

===== Proof 3458 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  have : (fun a => (f a).bind fun b => g a b) = fun a ‚Ü¶ (f a).casesOn (fun _ => Option.none)
    (fun b _ => b) := rfl
  rw [this]
  exact option_casesOn hf (const Option.none) hg

===== Proof 3459 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (Computable.ofOption.comp hf).bind
  apply hg.comp
  apply Computable.of_eq
  intro a
  cases a <;> rfl

===== Proof 3460 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  simp; aesop

===== Proof 3461 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (Computable.option_casesOn hf (const Option.none) hg).of_eq
  intro a
  cases f a <;> rfl

===== Proof 3462 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (M := fun a _x => g a) hf
  apply hg

===== Proof 3463 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply of_eq_iff.mpr
  exact fun a ‚Ü¶ by cases f a <;> rfl

===== Proof 3464 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl

===== Proof 3465 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply of_eq_iff.mpr
  aesop

===== Proof 3466 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by infer_instance

===== Proof 3467 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (inferInstance : Computable fun a => (f a).bind (g a))

===== Proof 3468 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  simp only [forall_prop_of_true, forall_const]
  decide

===== Proof 3469 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl

===== Proof 3470 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (measurable_to_nat.comp <| hf.comp measurable_prod_mk_left).le_mul_of_forall_le
     fun b => (measurable_to_nat.comp <| hg.comp (measurable_prod_mk_left.comp measurable_fst)
     (measurable_prod_mk_left.comp measurable_snd)).le_mul_of_forall_le fun c =>
  simp only [Function.comp_apply, measurable_to_nat,
    ‚Üê Nat.cast_inj (Œ± := ‚Ñù‚â•0‚àû), Nat.cast_add, Nat.cast_one, Nat.cast_mul, Nat.cast_succ]
  simp only [Function.comp_apply, measurable_to_nat,
    ‚Üê Nat.cast_inj (Œ± := ‚Ñù‚â•0‚àû), Nat.cast_add, Nat.cast_one, Nat.cast_mul, Nat.cast_succ] at hf hg
  aesop

===== Proof 3471 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  )

===== Proof 3472 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl

===== Proof 3473 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (Computable.option_casesOn hf (Computable.const Option.none) hg).of_eq
  intro a; cases f a <;> rfl

===== Proof 3474 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply of_eq
  intro a
  cases f a <;> rfl

===== Proof 3475 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  exact hf.double_bind hg

===== Proof 3476 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply option_bind hf hg

===== Proof 3477 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by infer_instance

===== Proof 3478 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  /-
  We need to show that the function \( h(a) = (f(a)).bind(g(a)) \) is computable, given that \( f \) is a computable function from \( \alpha \) to \( \text{Option}(\beta) \) and \( g \) is a computable function from \( \alpha \) to \( \beta \) to \( \text{Option}(\sigma) \).
  
  1. The function \( f \) is computable, so there exists a Turing machine that can compute \( f \).
  2. The function \( g \) is computable, so there exists a Turing machine that can compute \( g \).
  3. The operation \( \text{bind} \) on \( \text{Option}(\beta) \) is defined such that if \( f(a) = \text{none} \), then \( \text{bind}(f(a), g(a)) = \text{none} \), and if \( f(a) = \text{some}(b) \), then \( \text{bind}(f(a), g(a)) = g(a, b) \).
  4. Since \( f \) and \( g \) are computable, the function \( h \) defined as \( h(a) = \text{bind}(f(a), g(a)) \) is also computable.
  
  This can be shown by considering the cases for \( f(a) \):
  - If \( f(a) = \text{none} \), then \( h(a) = \text{none} \), which is computable.
  - If \( f(a) = \text{some}(b) \), then \( h(a) = g(a, b) \), which is computable because \( g \) is computable.
  
  Thus, \( h \) is computable.
  -/
  haveI := Classical.decEq Œ±
  haveI := Classical.decEq Œ≤
  haveI := Classical.decEq œÉ
  exact (option_casesOn hf (const Option.none) hg).of_eq fun a => by
    rcases f a with (_ | _) <;> simp [Option.bind]

===== Proof 3479 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  aesop

===== Proof 3480 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by infer_instance

===== Proof 3481 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply (Computable.ofOption.comp hf).bind
  apply hg.comp
  apply Computable.ofOption

===== Proof 3482 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  option_bind

===== Proof 3483 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply option_casesOn
  apply constant
  apply hg
  <;> intro y <;> simp [*, bind_eq_none_iff]
  <;> apply hf
  <;> apply hg
  <;> intro y <;> simp [*, bind_eq_none_iff]
  <;> apply hf
  <;> apply hg

===== Proof 3484 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply to‚ÇÇ
  intro n
  simp only [to‚ÇÇ_apply, option_bind_decode‚ÇÇ, Option.elim]
  by_cases h : ‚àÉ a, some (n.unpair.1) = ((@decode Œ± _ n).bind fun a => a.map Prod.fst)
  ¬∑ obtain ‚ü®a, ha‚ü© := h
    simp only [h, Option.isSome_some, if_true, Option.mem_some_iff, exists_eq_right, Option.bind_some,
      Option.isSome_bind, Option.mem_bind_iff, Option.mem_some_iff, Option.map_some', Option.isSome_some]
    obtain ‚ü®b, hb‚ü© := exists_false
    simp only [hb, Option.bind_some, Option.isSome_none, Option.isSome_some, ite_true, Option.mem_some_iff,
      exists_eq_right, Option.bind_none, Option.isSome_none, ite_false, not_false_eq_true, exists_true_iff_nonempty]
    rfl
  ¬∑ simp only [h, Option.isSome_none, if_false, Option.isSome_none, ite_false, not_false_eq_true,
      exists_true_iff_nonempty, Option.bind_none]
    rfl

===== Proof 3485 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  exact of_eq fun a => by cases f a <;> rfl

===== Proof 3486 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  let m : Œ± ‚Üí Œ≤ := fun a => (f a).get (Exists.intro h)
  exact Computable.of_eq hm fun a => by simp

===== Proof 3487 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply of_eq
  intro a
  rcases Decidable.em (a ‚àà A) with (H | H) <;> simp [H]

===== Proof 3488 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : Œ± ‚Üí Option Œ≤} {g : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} (hf : Computable f)
    (hg : Computable‚ÇÇ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  _
  exact of_eq fun a => by
    cases (f a)
    ¬∑ rfl
    ¬∑ rfl

===== Proof 3489 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext
  constructor <;> intro hx <;> obtain ‚ü®x, rfl‚ü© := hx <;> exists x <;> simp

===== Proof 3490 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext x
  constructor <;> simp (config := { contextual := true }) [h]

===== Proof 3491 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext x
  simp [LinearMap.mem_range, smul_eq_mul]
  constructor
  rintro ‚ü®y, rfl‚ü©
  exact ‚ü®a‚Åª¬π ‚Ä¢ y, by simp [mul_smul, smul_smul, h]]
  rintro ‚ü®y, rfl‚ü©
  exact ‚ü®a‚Åª¬π ‚Ä¢ y, by simp [mul_smul, smul_smul, h]]

===== Proof 3492 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext
  simp [h]

===== Proof 3493 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro x
  simp only [Submodule.mem_range, LinearMap.mem_range, LinearMap.smul_apply, exists_prop]
  constructor
  next =>
    rintro ‚ü®y, rfl‚ü©
    exact ‚ü®a‚Åª¬π ‚Ä¢ y, by simp [h]‚ü©
  next =>
    rintro ‚ü®y, rfl‚ü©
    exact ‚ü®a ‚Ä¢ y, by simp‚ü©

===== Proof 3494 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext x
  simp only [mem_range, smul_apply, exists_smul_eq_iff_eq h]

===== Proof 3495 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  simp_rw [range_eq_map]; rw [map_smul']
  exact Submodule.map_id _

===== Proof 3496 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro x
  constructor <;> intro hx
  all_goals
    rcases hx with ‚ü®y, rfl‚ü©
    exact ‚ü®a‚Åª¬π ‚Ä¢ y, by simp [smul_smul, h]‚ü©

===== Proof 3497 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  simp_rw [range_eq_map]; rw [‚Üê Submodule.map_comp]; simp [h]

===== Proof 3498 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro x
  simp [mem_range, smul_eq_mul, mul_comm]
  constructor
  rintro ‚ü®x, rfl‚ü©
  exact ‚ü®x, rfl‚ü©
  rintro ‚ü®x, rfl‚ü©
  exact ‚ü®x, rfl‚ü©

===== Proof 3499 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext; simp [h]

===== Proof 3500 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply le_antisymm
  ¬∑ rintro _ ‚ü®v, rfl‚ü©
    exact ‚ü®a‚Åª¬π ‚Ä¢ v, by simp [smul_smul, h]]
  ¬∑ rintro _ ‚ü®v, rfl‚ü©
    exact ‚ü®a ‚Ä¢ v, by simp]

===== Proof 3501 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  refine' Submodule.ext fun x => _
  simp [LinearMap.mem_range, smul_comm a]

===== Proof 3502 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  rw [range_smul, if_neg h]

===== Proof 3503 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro x
  simp [mem_range, smul_eq_mul, h]
  constructor
  rintro ‚ü®x, rfl‚ü©
  exact ‚ü®x, rfl‚ü©
  rintro ‚ü®x, rfl‚ü©
  exact ‚ü®x, rfl‚ü©

===== Proof 3504 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  refine' Submodule.ext fun x => _
  constructor <;> rintro ‚ü®y, rfl‚ü© <;> [use a‚Åª¬π ‚Ä¢ y; use a ‚Ä¢ y] <;> simp [smul_smul, h]

===== Proof 3505 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro x
  simp [mem_range, smul_comm a]
  tauto

===== Proof 3506 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro x
  simp [mem_range, smul_smul, h]

===== Proof 3507 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext x; constructor <;> simp (config := { contextual := true }) [h]

===== Proof 3508 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  rw [‚Üê LinearMap.range_comp, LinearMap.comp_id]

===== Proof 3509 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro v
  constructor <;> intro hv
  all_goals
    rcases hv with ‚ü®v, rfl‚ü©
    use a‚Åª¬π ‚Ä¢ v
    simp [smul_smul, h]

===== Proof 3510 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext ‚ü®v, hv‚ü©
  simp [hv, LinearMap.mem_range]

===== Proof 3511 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  refine' Submodule.ext (fun v‚ÇÇ => _)
  refine' ‚ü®fun ‚ü®v, hv‚ü© => ‚ü®v, _‚ü©, fun ‚ü®v, hv‚ü© => ‚ü®v, _‚ü©‚ü© <;>
  simp_all [smul_smul, mul_comm]

===== Proof 3512 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext ‚ü®v, hv‚ü©
  constructor <;> rintro ‚ü®v, rfl‚ü© <;> exact ‚ü®a‚Åª¬π ‚Ä¢ v, by simp [smul_smul, h]‚ü© <;> rintro ‚ü®v, rfl‚ü© <;> exact ‚ü®a ‚Ä¢ v, by simp [smul_smul, h]‚ü©

===== Proof 3513 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  rwa [range_smul, smul_right_injective _ h]

===== Proof 3514 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext x
  simp [LinearMap.mem_range, smul_comm a f, h]

===== Proof 3515 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro x
  simp [mem_range, smul_comm a]

===== Proof 3516 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  simp_rw [LinearMap.range_eq_map]
  rw [‚Üê Submodule.map_smul']
  congr
  ext x
  simp [h]

===== Proof 3517 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro v
  simp [mem_range, smul_comm a f]

===== Proof 3518 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  ext; constructor <;> intro <;> use a‚Åª¬π ‚Ä¢ ‚Äπ_‚Ä∫ <;> simp [h]

===== Proof 3519 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro x
  simp [mem_range, smul_comm a f, h]

===== Proof 3520 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V ‚Üí‚Çó[K] V‚ÇÇ) (a : K) (h : a ‚â† 0) : range (a ‚Ä¢ f) = range f := by
  apply Submodule.ext
  intro x
  simp [mem_range, smul_eq_mul, mul_comm]
  constructor
  rintro ‚ü®y, rfl‚ü©
  exact ‚ü®a‚Åª¬π ‚Ä¢ y, by simp [mul_smul, h]‚ü©
  rintro ‚ü®y, rfl‚ü©
  exact ‚ü®a ‚Ä¢ y, by simp [mul_smul, h]‚ü©

===== Proof 3521 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow, Finset.sum_eq_zero fun x hx => _]
  simp_all [Matrix.det_smul]

===== Proof 3522 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_sum]
  simp [hj]

===== Proof 3523 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_add, Finset.sum_eq_multiset_sum,
    updateRow_multiset_sum_aux, ‚Üê smul_eq_mul, det_smul]
  simp [hj]

===== Proof 3524 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_add_smul_self]
  simp [hj]

===== Proof 3525 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow]
  simp [hj, Finset.sum_mul, Finset.mul_sum]

===== Proof 3526 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow, Finset.sum_eq_zero]
  simp [hj]

===== Proof 3527 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_sum]
  simp [hj]

===== Proof 3528 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_add]
  simp [Finset.sum_smul, Matrix.det_smul, Finset.sum_add_distrib, Finset.smul_sum,
    Finset.sum_sub_distrib, Finset.sum_neg_distrib, mul_smul, ‚Üê smul_sum, smul_smul,
    mul_comm]
  rw [Finset.sum_eq_zero]
  intro i hi
  rw [smul_zero, neg_zero]

===== Proof 3529 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_add]
  simp [Matrix.det_smul]

===== Proof 3530 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [det_updateRow_add]
  simp [Finset.sum_smul, det_smul]

===== Proof 3531 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [updateRow_eq_iff]
  simp_all only [det_smul, Finset.sum_const, nsmul_eq_smul_cast, smul_smul, mul_comm]
  ring

===== Proof 3532 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_add, Matrix.det_smul, det_updateRow_sum_aux]
  simp [hj]

===== Proof 3533 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow]
  simp [Finset.sum_range_succ, Finset.sum_range_succ, hj]

===== Proof 3534 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow, Finset.sum_eq_zero]
  simp [hj]

===== Proof 3535 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  simp [Matrix.det_updateRow, hj]

===== Proof 3536 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow]
  simp [hj, Finset.sum_range_succ]

===== Proof 3537 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [updateRow_eq_iff, det_smul, det_sum_row]
  simp [Finset.sum_range_succ, hj]

===== Proof 3538 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_sum]
  simp [hj]

===== Proof 3539 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_add]
  simp [Finset.sum_smul, ‚Üê mul_smul_comm, det_smul]

===== Proof 3540 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_add, Matrix.det_smul, Matrix.det_updateRow_sum]
  simp [hj]

===== Proof 3541 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  s_cases s
  simp [Matrix.det_updateRow_sum]

===== Proof 3542 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_sum]
  simp [hj]

===== Proof 3543 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [updateRow_eq_iff, det_smul, det_add_row (fun i => a ‚Ä¢ M i + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)]
  simp [Finset.sum_comm, Finset.smul_sum, Finset.smul_smul]

===== Proof 3544 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow]
  simp [hj, Finset.sum_subset (subset_refl s)]

===== Proof 3545 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_add_smul_self]
  simp [hj]

===== Proof 3546 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow]
  simp [Finset.sum_range_succ, Finset.sum_range_succ, hj]

===== Proof 3547 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow]
  simp [hj, Finset.sum_range_succ_comm, Finset.sum_range_succ, add_comm]

===== Proof 3548 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  have : Function.Injective updateRow := by
    intro N‚ÇÅ N‚ÇÇ h
    have h' := congr_fun h j
    simpa using h'
  rw [det_updateRow_sum_eq_det_updateRow_sum, det_updateRow_single, mul_comm, smul_smul]
  congr
  simp [hj]

===== Proof 3549 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_sum]
  simp

===== Proof 3550 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [det_updateRow_add]
  simp_all only [Finset.sum_const, Finset.card_fin, nsmul_eq_mul]
  simp_all

===== Proof 3551 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [updateRow_smul]
  simp_rw [Matrix.det_apply]
  rw [Finset.sum_congr rfl]
  intro i _
  rw [updateRow_apply]
  rw [updateRow_apply]
  rw [smul_apply]
  rw [Finset.sum_apply]
  rw [smul_apply]
  simp [hj, Finset.sum_apply]

===== Proof 3552 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ‚àâ s) (c : n ‚Üí R)
    (a : R) :
    (M.updateRow j (a ‚Ä¢ M j + ‚àë k ‚àà s, (c k) ‚Ä¢ M k)).det = a ‚Ä¢ M.det := by
  rw [Matrix.det_updateRow_add]
  simp [Finset.sum_smul, Matrix.det_smul]

===== Proof 3553 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [Integrable, HasFiniteIntegral, nnnorm_prod_univ_eq_prod_univ_nnnorm]
  constructor
  ¬∑ intro h
    refine ‚ü®fun y ‚Ü¶ ?_, ?_‚ü©
    ¬∑ simp_rw [‚Üê AEStronglyMeasurable.ae_measurable h1f.fst]
      exact h.1 y
    ¬∑ have h2f := h.2
      rw [‚Üê ENNReal.prod_univ] at h2f
      refine (h2f.mono' ?_).of_prod_left
      filter_upwards with y using AEStronglyMeasurable.ae_measurable h1f.fst
  ¬∑ rintro ‚ü®h2f_1, h2f_2‚ü©
    refine ‚ü®h2f_1.mono' ?_, h2f_2.mono' ?_‚ü©
    all_goals filter_upwards with y using AEStronglyMeasurable.ae_measurable h1f.fst

===== Proof 3554 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [Integrable, HasFiniteIntegral, ‚Üê mem‚Ñíp_one_iff_integrable, ‚Üê mem‚Ñíp_one_iff_integrable]
  rw [‚Üê mem‚Ñíp_one_iff_integrable]
  exact mem‚Ñíp_prod_iff' h1f

===== Proof 3555 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  ¬∑ exact ‚ü®fun y => h.1.mono_ac (Œº.cauchy_schwarz_inequality_ae_right y).symm.absolutelyContinuous,
      h.2‚ü©
  ¬∑ refine' ‚ü®h.1.mono_ac (Œº.cauchy_schwarz_inequality_ae_right _).absolutelyContinuous, _‚ü©
    simp_rw [integrable_prod_iff' h1f, Integrable, HasFiniteIntegral, h1f.norm.integral_norm_prod_right] at h ‚ä¢
    refine' NNReal.tsum_lt_tsum_of_nonneg (fun _ => integral_nonneg (fun _ => (norm_nonneg _)))
      ((fun y => (h.1 y).2) : ‚àÄ y, 0 ‚â§ ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) _
    simp_rw [‚Üê NNReal.coe_le_coe, NNReal.coe_tsum, coe_nnnorm, ‚Üê ENNReal.coe_le_coe]
    refine' fun y => (h.1 y).2.mono_ac (Œº.cauchy_schwarz_inequality_ae_right y).symm.absolutelyContinuous

===== Proof 3556 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  rw [Integrable, ‚Üê and_forall_ne y, ‚Üê and_assoc, ‚Üê and_assoc, and_comm (1 := Integrable _ _),
    integrable_iff_norm (h1f.comp_prod measurable_snd)]
  simp [norm_swap]

===== Proof 3557 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [‚Üê mem‚Ñíp_one_iff_integrable]
  exact ‚ü®fun h => ‚ü®h.1.1.aestronglyMeasurable.prod_mk
      ((integrable_prod_left' h1f.1).mp h.1.1),
    (integrable_prod_right' h1f.1).mp h.1.1‚ü©,
    fun h => ‚ü®‚ü®h1f, h.1.1.aestronglyMeasurable.prod_mk
      ((integrable_prod_left' h1f.1).mpr h.2)‚ü©,
    (integrable_prod_right' h1f.1).mpr h.2‚ü©‚ü©

===== Proof 3558 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [‚Üê integrable_norm_iff h1f.norm, ‚Üê integral_norm_iteratedIntegral_prod_left]
  rw [and_comm]
  exact ((prod_integrable_iff h1f.norm).trans and_comm).trans (congr_arg and
    (eq_iff_iff.mpr (and_comm)))

===== Proof 3559 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  refine' ‚ü®fun h => ‚ü®fun y => h.comp_measure_preserving (MeasurePreserving.id Œº),
    integrable_prod_right' h1f.snd.uncurry‚ü©, fun ‚ü®h2, h3‚ü© => _‚ü©
  refine' integrable_of_integral_bounded_of_forall_AE_measurable h1f.integral_norm
    (fun y => (h2 y).1) (h3.aestronglyMeasurable.integral_norm) fun y => _
  refine' (h2 y).2.of_integral_ne_top fun h4 => _
  have h5 : ‚àÄ·µê y ‚àÇŒΩ, 0 ‚â§ ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº := by
    filter_upwards using fun y => integral_nonneg_of_ae <| ae_of_all _ fun x => norm_nonneg _
  have h6 : (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) =·µê[ŒΩ] 0 := by
    classical exact ae_eq_of_forall_set_lintegral_eq_of_sigmaFinite _ h3 h5 fun s hs _ => by
        rw [‚Üê integral_indicator_const hs.nullMeasurableSet.toMeasurable.measurableSet,
          ‚Üê norm_zero]
        exact integral_congr_ae <| by simp only [h4, Set.indicator_of_not_mem, not_mem_toMeasurable,
          norm_zero, const_zero]
  have h7 : ‚à´ y, ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº ‚àÇŒΩ = ‚à´ y, 0 ‚àÇŒΩ := by
    rw [‚Üê integral_congr_ae h6, integral_const]
  rw [integral_zero] at h7; rw [‚Üê norm_eq_zero]; nlinarith [h3, h7]

===== Proof 3560 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  refine ‚ü®fun hf => ‚ü®?_, ?_‚ü©, fun hf => ?_‚ü©
  exacts [((integrable_prod_left h1f).1 hf).2,
    (integrable_prod_right h1f).1 hf,
    ((integrable_prod_iff h1f).1 hf.2).2]

===== Proof 3561 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  rw [Integrable, ‚Üê mem‚Ñíp_one_iff_integrable]
  simp_rw [HasFiniteIntegral, Integrable, ‚Üê mem‚Ñíp_one_iff_integrable]
  rw [mem‚Ñíp_prod_of_aestronglyMeasurable _ h1f, ‚Üê mem‚Ñíp_one_iff_integrable, ‚Üê mem‚Ñíp_one_iff_integrable]
  simp_rw [mem‚Ñíp_one_iff_integrable, mem‚Ñíp_prod_of_aestronglyMeasurable _ h1f]

===== Proof 3562 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  rw [Integrable, ‚Üê integrable_norm_iff, ‚Üê integrable_norm_iff]
  simp_rw [norm_prod_mk]
  exact integrable_prod_iff h1f

===== Proof 3563 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [Integrable, HasFiniteIntegral, nnnorm_prod_of_nonneg (by positivity), ‚Üê prod_univ,
    setIntegral_univ (S := ‚Ñù) (Œº := ŒΩ), ‚Üê prod_univ, setIntegral_univ (S := ‚Ñù) (Œº := Œº) ]
  exact h1f.prod_mk_left.integral_cond_prod

===== Proof 3564 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [‚Üê mem‚Ñíp_one_iff_integrable]
  exact ‚ü®fun h => ‚ü®Integrable.aestronglyMeasurable h, h.norm‚ü©, fun h =>
    (integrable_prod_iff h1f.1).2 ‚ü®h.1, h.2.mono_ac <| (absolutelyContinuous_prod_snd ŒΩ Œº).symm‚ü©‚ü©

===== Proof 3565 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  rw [Integrable, ‚Üê integrable_prod_iff]
  exact ‚ü®fun h => ‚ü®h.1, integral_norm_prod_right h.1 h1f‚ü©, fun h => ‚ü®h.1, integral_norm_prod_right h.1 h1f‚ü©‚ü©

===== Proof 3566 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [Integrable, HasFiniteIntegral, nnnorm_prod_mk_le']
  constructor <;> intro h
  ¬∑ constructor
    ¬∑ aesop
    ¬∑ simp only [h.1, h.2, true_and_iff]
      exact h1f.norm.integral_norm_prod_right' ŒΩ
  ¬∑ constructor
    ¬∑ aesop
    ¬∑ simp only [h.1, h.2, true_and_iff]
      exact h1f.norm.integral_norm_prod_right' ŒΩ

===== Proof 3567 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  constructor
  next =>
    rw [Integrable, ‚Üê mem‚Ñíp_one_iff_integrable]
    exact ((mem‚Ñíp_prod_iff h1f).mp ‚Äπ_‚Ä∫).1
  next =>
    rw [Integrable, ‚Üê mem‚Ñíp_one_iff_integrable, mem‚Ñíp_prod_iff h1f] at *
    exact ‚ü®by simpa using (‚Äπ_‚Ä∫.1.1.trans (Lp.mem‚Ñíp _).integrable).norm.ae_lt_top, by
        simpa using (‚Äπ_‚Ä∫.1.2.trans (Lp.mem‚Ñíp _).integrable).norm.ae_lt_top‚ü©

===== Proof 3568 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  constructor <;>
    ¬∑ intro h;
      have := h.1;
      have h2f := h1f;
      rw [AEStronglyMeasurable] at h2f;
      rw [Integrable] at h;
      constructor
      ¬∑ have h3f : ‚àÄ·µê x ‚àÇŒº, AEStronglyMeasurable (fun y => f (x, y)) ŒΩ := by
          filter_upwards [h2f.2] with x hx using hx.comp (measurable_prod_mk_left (x := x))
        refine‚Äô ‚ü®h3f, _‚ü©
        have h4f : ‚àÄ·µê x ‚àÇŒº, ‚àÄ·µê y ‚àÇŒΩ, ‚Äñf (x, y)‚Äñ ‚â§ ‚Äñf (x, y)‚Äñ := by
          filter_upwards with x using eventually_of_forall fun y => le_rfl
        refine‚Äô (integral_norm_le_of_forall_le (h2f.1.comp measurable_prod_mk_left) h4f).trans
          (le_of_eq _)
        rw [integral_prod_of_measurable _ h2f.1 h2f.2]
        exact le_rfl
      ¬∑ have h3f : ‚àÄ·µê y ‚àÇŒΩ, AEStronglyMeasurable (fun x => f (x, y)) Œº := by
          filter_upwards [h2f] with y hy using hy.comp (measurable_prod_mk_right (y := y))
        refine‚Äô ‚ü®h3f, _‚ü©
        have h4f : ‚àÄ·µê y ‚àÇŒΩ, ‚àÄ·µê x ‚àÇŒº, ‚Äñf (x, y)‚Äñ ‚â§ ‚Äñf (x, y)‚Äñ := by
          filter_upwards with y using eventually_of_forall fun x => le_rfl
        refine‚Äô (integral_norm_le_of_forall_le (h2f.2.comp measurable_prod_mk_right) h4f).trans
          (le_of_eq _)
        rw [integral_prod_of_measurable _ h2f.1 h2f.2]
        exact le_rfl

===== Proof 3569 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  constructor
  ¬∑ intro h
    constructor
    ¬∑ exact fun y => h.mono' (integrable_prod_of_integrable_left h1f.snd <|
      h1f.of_uncurry_left)
    ¬∑ exact h.integral_norm_prod_left h1f
  ¬∑ rintro ‚ü®haf, hfi‚ü©
    refine .of_le hfi.aestronglyMeasurable.swap ?_ ?_
    ¬∑ filter_upwards [haf] with y hy using hy.norm
    ¬∑ have : ‚àÄ y, AEStronglyMeasurable (fun x => f (x, y)) Œº := fun y =>
        h1f.comp (measurable_swap.aemeasurable.snd.snd)
      refine aemeasurable_fun_integral_cond h1f.aemeasurable.swap ?_
        hfi.aestronglyMeasurable.swap ?_
      ¬∑ filter_upwards [haf] with y hy using hy.aemeasurable
      ¬∑ filter_upwards [haf] with y hy using (this y).aestronglyMeasurable

===== Proof 3570 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  rw [Integrable, ‚Üê mem‚Ñíp_one_iff_integrable]
  simp_rw [‚Üê mem‚Ñíp_one_iff_integrable]
  exact mem‚Ñíp_prod_iff' h1f

===== Proof 3571 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  refine ‚ü®fun h => ‚ü®fun y => h.1.integral_norm_flip, ?_‚ü©, ?_‚ü©
  ¬∑ have h2 := h.1.fst_integral_norm_snd (Œº := Œº)
    refine (set_lintegral_univ _).symm.trans_le <| (set_lintegral_mono h2.refle ?_).trans h2.le
    exact eventually_of_forall fun y => (integral_congr_ae (h1f.ae_eq_snd y)).symm
  ¬∑ refine ‚ü®h1f.prod_mk ?_, ?_‚ü©
    ¬∑ refine h.1.aestronglyMeasurable_fst'.prod_mk ?_
      rw [aestronglyMeasurable_iff_forall_swap]
      exact fun y => h.1.aestronglyMeasurable_snd'.congr (h1f.ae_eq_snd y)
    ¬∑ simpa only [prod_comm] using h.2

===== Proof 3572 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  constructor
  ¬∑ exact fun h => ‚ü®h.1.aestronglyMeasurable.all.1, h.2‚ü©
  ¬∑ exact fun h =>
      ‚ü®h.1.all.of_prod_left, h.1.all.of_prod_right,
        h.2.aestronglyMeasurable.integral_prod_right_ae‚ü©

===== Proof 3573 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  rw [Integrable, ‚Üê mem‚Ñíp_one_iff_integrable]
  simp_rw [‚Üê mem‚Ñíp_one_iff_integrable]
  exact mem‚Ñíp_prod_iff' h1f

===== Proof 3574 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp only [Integrable, HasFiniteIntegral, h1f.norm.integral_norm_prod_left, h1f.prod_mk_left,
    h1f.prod_mk_left_ae_eq, ae_of_all, and_true, and_congr_right_iff]
  intro h2f; constructor <;> intro h
  ¬∑ exact ‚ü®h.1, h2f, h.2‚ü©
  ¬∑ rcases h with ‚ü®h1, h2f, h3‚ü©; exact ‚ü®h1, h3‚ü©

===== Proof 3575 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  constructor <;> intro h
  ¬∑ refine' ‚ü®h.1.mono_ac (Œº.prod_swap_ae_eq ŒΩ).absolutelyContinuous, integrable_prod_right' <|
      h1f.comp_snd_of_prod_right‚ü©
  ¬∑ refine' ‚ü®h.1.mono_ac (Œº.prod_swap_ae_eq ŒΩ).symm.absolutelyContinuous, integrable_prod_right' _‚ü©
    refine' h1f.comp_snd_of_prod_right.mono_ac
      (Œº.prod_swap_ae_eq ŒΩ).symm.absolutelyContinuous |>.congr
      (h.1.mono_ac
        (Œº.prod_swap_ae_eq ŒΩ).symm.absolutelyContinuous).ae_eq_fun_of_prod_right fun y =>
      (h.2.hasFiniteIntegral_prod_left' y).norm_of_nonneg fun x => norm_nonneg _

===== Proof 3576 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [‚Üê mem‚Ñíp_one_iff_integrable]
  rw [‚Üê mem‚Ñíp_one_iff_integrable]; exact mem‚Ñíp_prod_iff' h1f

===== Proof 3577 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  rw [‚Üê mem‚Ñíp_one_iff_integrable]
  refine ‚ü®fun h => ?_, fun h => ?_‚ü©
  ¬∑ obtain ‚ü®hmeas, h‚ü© := mem‚Ñíp_one_iff_integrable.mp h
    refine ‚ü®fun y => ?_, ?_‚ü©
    ¬∑ rw [mem‚Ñíp_one_iff_integrable]
      exact hmeas.integrable_prod_right y
    ¬∑ have h2f : ‚àÄ y, AEStronglyMeasurable (fun x => f (x, y)) Œº := fun y => hmeas.integrable_prod_right y
      refine (mem‚Ñíp_one_iff_integrable (Œº := ŒΩ)).mpr ?_
      refine (h.mono ?_ ?_).norm
      ¬∑ exact eventually_of_forall fun y => h2f y
      ¬∑ exact eventually_of_forall fun y => hmeas y
  ¬∑ refine (mem‚Ñíp_one_iff_integrable (Œº := ŒΩ)).mp ?_
    refine h.2.mono ?_ ?_
    ¬∑ exact eventually_of_forall fun y => Integrable.norm (h.1 y)
    ¬∑ exact eventually_of_forall fun y => h1f y

===== Proof 3578 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  rw [Integrable, Integrable, ‚Üê integrable_norm_iff h1f.norm]
  simp only [norm_ae_eq_zero]
  rw [‚Üê integral_prod_norm ‚Äπ_‚Ä∫, ‚Üê integral_norm_eq_integral_norm_of_nonneg
    (ae_optional (eventually_of_forall fun _ => norm_nonneg _)) (h1f.norm.integral_norm ŒΩ)]
  constructor <;> intro h
  ¬∑ constructor
    ¬∑ intro y
      simp_rw [integral_congr_ae (h1f.norm.ae_eq_mk.symm)]
      exact h.1 y
    ¬∑ exact h.2
  ¬∑ constructor
    ¬∑ intro y
      simp_rw [integral_congr_ae (h1f.norm.ae_eq_mk.symm)]
      exact h.1 y
    ¬∑ simp_rw [integral_congr_ae (h1f.norm.ae_eq_mk.symm)]
      exact h.2

===== Proof 3579 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [Integrable, HasFiniteIntegral, h1f.norm.integral_prod_right']
  exact ‚ü®fun h => ‚ü®h.1.mono_ac (Œº.prod_swap_ae_eq ŒΩ).symm.absolutelyContinuous, h.2‚ü©,
    fun h => ‚ü®h.1.mono_ac (Œº.prod_swap_ae_eq ŒΩ).symm.absolutelyContinuous, h.2‚ü©‚ü©

===== Proof 3580 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp_rw [Integrable, HasFiniteIntegral, ‚Üê cauchy_schwarz_inequality_ae_integrable]
  constructor
  ¬∑ intro h
    exact ‚ü®h.1.left, h.2.1‚ü©
  ¬∑ rintro ‚ü®h1, h2‚ü©
    refine ‚ü®‚ü®h1, ?_‚ü©, h2‚ü©
    rw [AEMeasurable, ‚Üê (Prod.swap_map_swap f)]
    let G := fun y =>
      (f ‚àò Prod.swap) (y, ¬∑)
    have : ‚àÄ·µê y ‚àÇŒº, ‚àÄ z, ‚ÄñG y z‚Äñ ‚â§ ‚Äñ(fun x => f (x, y)) z‚Äñ := by
      filter_upwards [h1] with y hy z
      simp only [G, Prod.fst_swap, Prod.snd_swap]
      rw [‚Üê hy.hasFiniteIntegral.1]
      simp only [norm_norm]
    exact AEStronglyMeasurable.comp_measurable
      h1f.1.snd'.prod_mk measurable_snd

===== Proof 3581 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  simp [Integrable, h1f, prod_apply]

===== Proof 3582 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  rw [Integrable, ‚Üê ENNReal.iSup_add_iSup_of_monotone, ‚Üê iSup_prod]
  dsimp only [Integrable, ‚à´, ‚Üê iSup_prod]
  congr 1 <;> apply congr_arg
  #align measure_theory.integrable_prod_iff' MeasureTheory.integrable_prod_iff'

===== Proof 3583 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  constructor
  next =>
    intro h2f
    constructor
    ¬∑ exact h2f.1.mono_ac (prod_swap_ac_ae h1f.1)
    ¬∑ exact Integrable.mono_measure h2f.2 (prod_swap Œº ŒΩ)
  next =>
    rintro ‚ü®h2f, h3f‚ü©
    refine' ‚ü®h1f, h2f, _‚ü©
    rw [HasFiniteIntegral, lintegral_prod_of_measurable _ h1f.1]
    exact h3f.2.mono_ac (prod_swap_ac_ae h1f.1)

===== Proof 3584 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite Œº] ‚¶Éf : Œ± √ó Œ≤ ‚Üí E‚¶Ñ
    (h1f : AEStronglyMeasurable f (Œº.prod ŒΩ)) :
    Integrable f (Œº.prod ŒΩ) ‚Üî
      (‚àÄ·µê y ‚àÇŒΩ, Integrable (fun x => f (x, y)) Œº) ‚àß Integrable (fun y => ‚à´ x, ‚Äñf (x, y)‚Äñ ‚àÇŒº) ŒΩ := by
  constructor
  case mp =>
    intro hf
    exact ‚ü®Integrable.aestronglyMeasurable hf,
      Integrable.mono' hf (h1f.fst_swap.integral_norm_le_integral_norm (swap f))‚ü©
  case mpr =>
    rintro ‚ü®hf1, hf2‚ü©
    refine' Integrable.prod_smul _ hf1 hf2 _ _ <;>
      simp_rw [‚Üê mem‚Ñíp_one_iff_integrable, ‚Üê mem‚Ñíp_one_iff_aestronglyMeasurable]
    ¬∑ exact AEStronglyMeasurable.fst_swap h1f
    ¬∑ exact StronglyMeasurable.fst_swap
      (StronglyMeasurable.snd_of_prod (AEStronglyMeasurable.fst h1f).nullMeasurable)

===== Proof 3585 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.arg_real_mul, Complex.arg_I_ax, Complex.arg_neg_I_ax,
    Complex.arg_conj_eq_arg, Complex.arg_inv_eq_arg]
  <;> simp
  <;> aesop

===== Proof 3586 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.Kahler]

===== Proof 3587 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simpa using Complex.o.oangle_eq_oangle_of_oangle_eq_zero Complex.o.zero_ne_zero (mul_left_inj‚ÇÄ Complex.o.zero_ne_zero)

===== Proof 3588 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.arg_conj_mul]

===== Proof 3589 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.oangle_eq_angle_sub_toReal, Complex.arg_conj_mul]

===== Proof 3590 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle]

===== Proof 3591 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  cases' Complex.ext_iff.mp (Complex.re_add_im w) with hw‚ÇÅ hw‚ÇÇ
  cases' Complex.ext_iff.mp (Complex.re_add_im z) with hz‚ÇÅ hz‚ÇÇ
  simp_all only [mul_re, mul_im, conj_re, conj_im, ofReal_re, ofReal_im, I_re, I_im]
  simp

===== Proof 3592 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [oangle, Complex.arg_real_mul]

===== Proof 3593 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [oangle, Complex.arg_conj_mul]

===== Proof 3594 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simpa [Complex.oangle, Complex.arg_real_mul, Complex.normSq_eq_conj_mul_self_abs] using
    Complex.arg_conj_mul w z

===== Proof 3595 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.arg_real_mul]

===== Proof 3596 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.orientation]

===== Proof 3597 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [oangle, Complex.arg_conj_mul]

===== Proof 3598 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle]

===== Proof 3599 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  rcases eq_or_ne w 0 with (rfl | hw) <;>
    rcases eq_or_ne z 0 with (rfl | hz) <;>
      simp_all [Complex.oangle, Complex.arg_conj_coe_angle, Complex.arg_real_mul,
        Complex.arg_neg_one]

===== Proof 3600 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.arg_conj_mul]

===== Proof 3601 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle]

===== Proof 3602 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  rw [oangle, o.oangle, Complex.oangle]

===== Proof 3603 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle]

===== Proof 3604 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  rw [Complex.oangle, Complex.oangle, Complex.oangle]

===== Proof 3605 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.arg_real_mul_I_ax]

===== Proof 3606 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle]

===== Proof 3607 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.arg_real_mul, Complex.normSq_eq_abs, sq]

===== Proof 3608 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  rw [Complex.oangle, Complex.oangle, Complex.oangle]

===== Proof 3609 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle]

===== Proof 3610 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.arg_mul_coe_angle, Complex.arg_conj_coe_angle]

===== Proof 3611 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  rw [Orientation.oangle, Complex.orientation_apply]
  simp [o.oangle_eq_angle_of_oangle_eq_zero, o.oangle_eq_angle_of_oangle_eq_pi]

===== Proof 3612 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  rcases Complex.eq_zero_or_eq_zero_of_mul_eq_zero (w := conj w * z) (by simp) with h | h
  <;> simp_all

===== Proof 3613 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle]

===== Proof 3614 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.ext_iff]

===== Proof 3615 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle, Complex.lineMap_eq_lineMap_iff, Complex.arg_coe_angle_eq_arg_iff]

===== Proof 3616 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ‚ÑÇ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex.oangle]

===== Proof 3617 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  refine LinearMap.quot_range_eq_of_proj (I.cotangentToQuotientSquare_toCotangent_toQuotientSquare) ?_
  ext ‚ü®x, y‚ü©
  simp

===== Proof 3618 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  apply le_antisymm
  ¬∑ intro x hx; rcases hx with ‚ü®x, rfl‚ü©; clear hx
    induction x
    case zero =>
      exact I.cotangentIdeal.zero_mem
    case up f =>
      exact I.cotangentIdeal.smul_mem _ f.2.2
  exact (I.cotangentToQuotientSquare.range_le_iff_mem_ideal.2 <| I.cotangentIdeal.smul_mem_cotangentIdeal.2 <| Submodule.mem_top _)

===== Proof 3619 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rfl

===== Proof 3620 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  apply Submodule.ext
  intro x
  simp only [Submodule.mem_range, Submodule.mem_restrictScalars, I.cotangentIdeal_toCotangent_eq,
    I.toCotangent_def, SetLike.mem_coe]
  constructor
  rintro ‚ü®x, rfl‚ü©
  exact ‚ü®x, rfl‚ü©
  
  rintro ‚ü®x, rfl‚ü©
  refine' ‚ü®I.cosupervisor (I.toCotangent x), _‚ü©
  rw [I.cosupervisor_toCotangent]

===== Proof 3621 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  apply le_antisymm
  exact range_le_iff_comap.mpr (LinearMap.ker_le_comap _ _)
  exact (I.cotangentIdeal.restrictScalars_injective R).range_comp_le_range _

===== Proof 3622 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext x
  simp [Submodule.mem_range]
  constructor
  intro b
  rcases b with ‚ü®b, hb‚ü©
  exact ‚ü®b, by simpa using hb‚ü©
  rintro ‚ü®b, rfl‚ü©
  use b
  simp

===== Proof 3623 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rw [LinearMap.range_eq_top]
  rw [‚Üê Submodule.restrictScalars_inj R (R := R‚Çò), I.cotangentIdeal.restrictScalars_top]
  exact I.cotangentToQuotientSquare_surjective

===== Proof 3624 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext x
  simp [LinearMap.mem_range]

===== Proof 3625 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rw [LinearMap.range_eq_map]
  convert I.cotangentToQuotientSquare.rangeRestrict_range
  rfl

===== Proof 3626 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext x
  simp only [Submodule.mem_map, Submodule.mem_restrictScalars, LinearMap.mem_range]
  constructor
  next =>
    rintro ‚ü®x, rfl‚ü©
    exact ‚ü®_, rfl‚ü©
  next =>
    rintro ‚ü®x, rfl‚ü©
    exact ‚ü®_, rfl‚ü©

===== Proof 3627 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  apply le_antisymm
  ¬∑ rintro ‚ü®x‚ü©
    induction x using Cotangent.induction_on with
    | h_smul g w =>
      obtain ‚ü®x, rfl‚ü© := w
      rw [LinearMap.mem_range, I.cotangentToQuotientSquare_apply]
      exact ‚ü®_.smul g x, by simp‚ü©
    | h_add w‚ÇÅ w‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
      rw [LinearMap.mem_range] at ih‚ÇÅ ih‚ÇÇ ‚ä¢
      obtain ‚ü®x‚ÇÅ, rfl‚ü© := ih‚ÇÅ
      obtain ‚ü®x‚ÇÇ, rfl‚ü© := ih‚ÇÇ
      exact ‚ü®x‚ÇÅ + x‚ÇÇ, by simp‚ü©
    | h_neg w ih =>
      rw [LinearMap.mem_range] at ih ‚ä¢
      obtain ‚ü®x, rfl‚ü© := ih
      exact ‚ü®-x, by simp‚ü©
  ¬∑ rintro ‚ü®x‚ü©
    obtain ‚ü®x, rfl‚ü© : x ‚àà I.toCotangent ‚äî (I ‚Ä¢ ‚ä§ : Submodule A (A ‚ß∏ I)) := by simp
    rw [Submodule.mem_sup] at x
    obtain ‚ü®‚ü®x, hx‚ü©, y, rfl‚ü© := x
    refine ‚ü®‚ü®x, hx‚ü©, by simp‚ü©

===== Proof 3628 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  apply le_antisymm
  ¬∑ rintro _ ‚ü®x, rfl‚ü©
    exact I.cotangentIdeal.submodule_pow_smul_mem 1 x I.one_mem
  ¬∑ intro x hx; exact ‚ü®‚ü®x, hx‚ü©, rfl‚ü©

===== Proof 3629 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  refine le_antisymm ?_ ?_
  ¬∑ rintro - ‚ü®x, rfl‚ü©
    exact I.cotangentToQuotientSquare_range_mk x
  ¬∑ rintro - ‚ü®x, rfl‚ü©
    refine ‚ü®I.incl (I ^ 2), ?_‚ü©
    simp

===== Proof 3630 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  refine' Submodule.ext (fun x => _)
  refine' ‚ü®fun ‚ü®y, hy‚ü© => _ , fun hx => _‚ü©
  case refine'_1 =>
    obtain ‚ü®y, rflÔøΩ{quot}‚ü© := hy
    exact ‚ü®y, rfl‚ü©
  case refine'_2 =>
    obtain ‚ü®y, rfl‚ü© := hx
    exact ‚ü®y, rfl‚ü©

===== Proof 3631 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext x; constructor <;> rintro ‚ü®x, rfl‚ü©
  <;> rw [Submodule.mem_restrictScalars]
  <;> simp [I.cotangentToQuotientSquare_range]

===== Proof 3632 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext x
  simp only [Submodule.mem_restrictScalars, LinearMap.mem_range, Submodule.mem_mkQ]
  constructor
  next =>
    rintro ‚ü®x, rfl‚ü©
    exact I.cotangent_mem_cotangentIdeal x
  next =>
    intro h
    exact ‚ü®‚ü®x, h‚ü©, rfl‚ü©

===== Proof 3633 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rfl

===== Proof 3634 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext x
  simp only [Submodule.mem_restrictScalars, SetLike.mem_coe, LinearMap.mem_range,
    Ideal.cotangentIdeal, Submodule.mem_mkQ, Submodule.Quotient.mk_eq_zero,
    Ideal.cotangentToQuotientSquare_apply, eq_self_iff_true, forall_const,
    exists_eq_right, exists_eq_right']

===== Proof 3635 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rw [LinearMap.range_eq_top]
  ext x
  simp only [Submodule.mem_restrictScalars, mem_toCotangent_range]
  constructor
  <;> intro h
  <;> obtain ‚ü®x, rfl‚ü© := h
  <;> rfl

===== Proof 3636 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rw [LinearMap.range_eq_map]
  congr

===== Proof 3637 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rw [LinearMap.range_eq_top]
  refine I.cotangentToQuotientSquare_surjective fun x hx => ?_
  obtain ‚ü®x, rfl‚ü© := I.toCotangent_surjective x
  obtain ‚ü®a, ha‚ü© := I.toCotangent_of_mem hx
  simpa only [ha, I.toCotangent_to_quotient_square, Submodule.coe_mk, ‚Üê I.mem_cotangentIdeal_to_quotient_square_range]
  using I.mem_cotangentIdeal_to_quotient_square_range a ha

===== Proof 3638 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  apply le_antisymm
  next =>
    intro x hx
    rcases hx with ‚ü®x, rfl‚ü©
    exact I.le_cotangentIdeal x
  next =>
    rintro x ‚ü®y, rfl‚ü©
    exact ‚ü®I.cotangentToQuotientSquare y, rfl‚ü©

===== Proof 3639 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  apply Eq.symm
  apply Ideal.ext
  intro x
  simp [Submodule.mem_map]
  constructor
  ¬∑ rintro ‚ü®x, rfl‚ü©
    exact ‚ü®x, rfl‚ü©
  ¬∑ rintro ‚ü®x, rfl‚ü©
    exact ‚ü®x, rfl‚ü©

===== Proof 3640 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext x; constructor <;> rintro ‚ü®x, rfl‚ü© <;> simp [Submodule.mem_restrictScalars]

===== Proof 3641 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext a
  simp [LinearMap.mem_range]
  constructor <;> intro h <;> obtain ‚ü®x, hx‚ü© := h <;>
    cases' x with x hx <;> subst_vars <;> constructor <;>
      simp_all

===== Proof 3642 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  apply le_antisymm
  ¬∑ rintro _ ‚ü®x, rfl‚ü©
    induction x using Cotangent.induction_on with
    | zero => exact Submodule.zero_mem _
    | smul_mem _ _ _ h => exact Submodule.smul_mem _ _ h
    | add_mem _ _ h‚ÇÅ h‚ÇÇ => exact Submodule.add_mem _ h‚ÇÅ h‚ÇÇ
  ¬∑ exact Submodule.map_le_iff_le_comap.mpr fun x hx => ‚ü®x, rfl, hx‚ü©

===== Proof 3643 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rw [LinearMap.range_eq_map, I.cotangentToQuotientSquare_to_quotient_square,
    restrictScalars_span]
  rfl

===== Proof 3644 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  apply le_antisymm
  ¬∑ rintro _ ‚ü®x, rfl‚ü©
    exact I.cotangentIdeal.sub_mem x.2 (Submodule.zero_mem _)
  ¬∑ rintro _ ‚ü®x, hx‚ü©
    exact I.cotangentToQuotientSquare.mem_range_self x

===== Proof 3645 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rw [LinearMap.range_eq_map]
  congr 1
  ext ‚ü®x, hx‚ü©
  simp

===== Proof 3646 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext x; constructor <;> rintro ‚ü®y, rfl‚ü© <;> use y <;> rfl

===== Proof 3647 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rw [LinearMap.range_eq_map, ‚Üê
    Submodule.map_comp_canonicalLinearMap_mkQ I.toCotangent]
  congr 1
  ext x; constructor <;> rintro ‚ü®y, rfl‚ü© <;> use ‚ü®x, y‚ü© <;> rfl

===== Proof 3648 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  refine le_antisymm (LinearMap.range_le_iff_comap.mpr ?_) (le_of_eq ?_)
  swap
  ¬∑ rfl
  refine LieIdeal.quotient_is_nilpotent_of_le_cotangent I ?_
  rw [‚Üê LieSubmodule.lieSpan_le]
  intro x hx
  obtain ‚ü®x, rfl‚ü© := LieSubmodule.mem_lieSpan_singleton.mp hx
  exact I.toCotangent_eq_zero_iff.mp rfl

===== Proof 3649 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> (linarith only [h, hx])

===== Proof 3650 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;>
    simpa only [sub_add_cancel] using p.add_mem h hx

===== Proof 3651 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all

===== Proof 3652 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all [sub_eq_add_neg, p.add_mem, p.neg_mem]

===== Proof 3653 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor
  next =>
    intro h
    have : y = x - (x - y) := by abel
    rw [this]
    exact p.sub_mem hx h
  next =>
    intro h
    simpa only [sub_sub_cancel] using p.sub_mem hx h

===== Proof 3654 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h
  case mp =>
    rw [sub_eq_add_neg] at h
    exact neg_mem_iff.mp (add_mem_iff_left hx h)
  case mpr =>
    rw [sub_eq_add_neg]
    exact add_mem_iff_left hx h

===== Proof 3655 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all

===== Proof 3656 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all

===== Proof 3657 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  simp only [sub_eq_add_neg, add_mem_iff_left, neg_mem, hx]

===== Proof 3658 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp [sub_eq_add_neg, p.neg_mem h, p.add_mem hx h]

===== Proof 3659 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all

===== Proof 3660 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all [sub_eq_add_neg, p.add_mem, p.neg_mem]

===== Proof 3661 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor
  intro h
  rw [sub_eq_add_neg] at h
  rw [p.neg_mem_iff] at h
  exact add_mem_cancel_right hx h
  intro h
  rw [sub_eq_add_neg]
  exact p.add_mem hx h

===== Proof 3662 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro hy <;> (rw [sub_eq_add_neg] <;>
    apply p.add_mem hx <;>
    exact p.neg_mem hy)

===== Proof 3663 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro <;> simp_all

===== Proof 3664 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h
  case mp =>
    rw [sub_eq_iff_eq_add] at h
    rw [h]
    exact p.add_mem hx h
  case mpr =>
    rw [sub_eq_iff_eq_add]
    rw [eq_comm]
    exact p.add_mem hx h

===== Proof 3665 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro <;> simp_all

===== Proof 3666 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all

===== Proof 3667 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simpa only [sub_add_cancel] using p.add_mem h hx

===== Proof 3668 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro <;> simp_all

===== Proof 3669 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> apply p.sub_mem hx h

===== Proof 3670 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;>
  simp_all only [sub_eq_add_neg, neg_add_eq_sub, neg_neg, neg_sub]
  <;>
  simp_all [sub_eq_add_neg, neg_add_eq_sub, neg_neg, neg_sub]

===== Proof 3671 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;>
  intro
  <;>
  simp_all [p.add_mem, p.neg_mem, p.zero_mem]

===== Proof 3672 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;>
    simp_all only [sub_eq_add_neg, add_left_comm, neg_add_rev, neg_neg, neg_mul, neg_sub,
      neg_neg, neg_zero]
  all_goals
    linarith

===== Proof 3673 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all

===== Proof 3674 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro <;>
  simp_all [order.complete_lattice.sub_mem]

===== Proof 3675 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all

===== Proof 3676 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all [sub_eq_add_neg, p.add_mem, p.neg_mem]

===== Proof 3677 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all

===== Proof 3678 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h
  case mp =>
    have : y = x - (x - y) := by simp
    rw [this]
    exact p.sub_mem hx h
  case mpr =>
    exact p.sub_mem hx h

===== Proof 3679 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro <;> simp_all

===== Proof 3680 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p := by
  constructor <;> intro h <;> simp_all

===== Proof 3681 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  ext
  ¬∑ simp
  ¬∑ aesop

===== Proof 3682 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  ext <;> aesop_cat

===== Proof 3683 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  rfl

===== Proof 3684 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  apply singleton_eq
  dsimp [pullbackArrows]
  rfl

===== Proof 3685 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  cases f; cases g; cases X; cases Z; cases Y; cases W; simp

===== Proof 3686 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  unfold pullbackArrows singleton #simp

===== Proof 3687 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  ext ‚ü®‚ü®h‚ü©‚ü©
  ¬∑ aesop_cat
  ¬∑ aesop_cat

===== Proof 3688 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  simp only [singleton, Set.mem_singleton_iff]
  apply Set.ext
  simp

===== Proof 3689 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  ext ‚ü®Y, f', h‚ü©
  simp only [mem_mrange, mem_singleton_iff] at h ‚ä¢
  constructor
  next =>
    rintro ‚ü®a, rfl‚ü©
    exact ‚ü®_, rfl‚ü©
  next =>
    rintro ‚ü®a, rfl‚ü©
    exact ‚ü®_, rfl‚ü©

===== Proof 3690 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  apply List.ext_get?
  simp [pullbackArrows, singleton, Fin.val]

===== Proof 3691 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  aesop_cat

===== Proof 3692 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  letI := Classical.decEq (Arrow C)
  cases Subsingleton.elim (singleton g) (singleton g) <;>
    simp [pullbackArrows, singleton, ‚Üê pullback.condition]

===== Proof 3693 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  cases f; cases g; casesX; casesX; rfl

===== Proof 3694 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  ext ‚ü®h, w‚ü©
  rcases w with rfl
  constructor <;> simp

===== Proof 3695 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  cases inferInstance
  simp
  aesop_cat

===== Proof 3696 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  cases inferInstance <;> rfl

===== Proof 3697 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  apply PartialFunctor.ext
  ¬∑ intro X
    simp
  ¬∑ intro X Y f
    simp
  ¬∑ aesop_cat

===== Proof 3698 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  dsimp only
  apply Eq.symm
  apply PSigma.ext
  ¬∑ rfl
  ¬∑ ext
    congr!
    aesop_cat

===== Proof 3699 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  fapply pullbackArrows.ext
  rfl
  aesop_cat

===== Proof 3700 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  unfold pullbackArrows
  cases rfl : singleton g;
  rfl

===== Proof 3701 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  ext
  all_goals aesop_cat

===== Proof 3702 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  trans
  <;> ext ‚ü®‚ü®h‚ü©‚ü©
  <;> simp

===== Proof 3703 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  induction' s using Multiset.induction_on with a s ih
  case empty => rfl
  have : Multiset.card (a ::‚Çò s) = Multiset.card s := by simp
  rw [‚Üê this]
  simp only [Multiset.map_coe, singleton_coe, bind_coe, card_singleton, Nat.card_eq_one]
  rw [‚Üê singleton_pullback_singleton_eq_bind g a.val]
  rfl

===== Proof 3704 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  ext
  simp [eq_iff_true_of_subsingleton]

===== Proof 3705 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  simp only [singleton, Meq.pullbackArrows, Meq.map, Meq.singleton, Equiv.unique (TypeVec 2) _ inst2,
    ‚Üê Function.funext_iff]
  aesop_funext
  apply Value.ext
  aesop_cat

===== Proof 3706 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  refine' singleton_ext _ _ _ (by simp) _
  aesop_cat

===== Proof 3707 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  apply PartialFunsctor.ext_1
  ext a
  apply PartialFunsctor.ext_2
  ext b
  rfl

===== Proof 3708 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  ext a
  rfl

===== Proof 3709 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  apply singleton_ext
  aesop_cat

===== Proof 3710 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  cases singleton g <;> simp only [pullbackArrows, pullback.lift_snd, lift_toSubgraph_singleton,
    Subgraph.ext_iff, Set.mem_singleton_iff, forall_eq, and_self, edot, eq_iff_true_of_subsingleton]

===== Proof 3711 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  revert g
  aesop_cat

===== Proof 3712 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) := by
  cases' f with f; cases' g with g; rfl

===== Proof 3713 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  rw [lt_succ_iff]
  refine' le_antisymm (bsup_comp.{u, v, w} hf hg) _
  rw [bsup_le_iff]
  intro i hi
  rw [‚Üê hg]
  apply lt_bsup

===== Proof 3714 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [hg]; exact blsub_comp.{u, u, w} (fun _ _ h => hf _ _ h) hg

===== Proof 3715 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  apply Eq.symm
  apply eq_of_forall_ge_iff
  intro a
  apply bsup_comp.{u, v, w}
  <;> simp_all

===== Proof 3716 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  rw [blsub]
  simp only [hEq, blsub, bsup_comp.{u, u, v}]
  congr
  funext a
  rw [hEq, blsub, bsup_comp.{u, u, v}]
  simp only [hEq, blsub, bsup_comp.{u, u, v}]
  rfl

===== Proof 3717 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  intro n
  induction' n with n' ih
  rfl
  rw [ih]
  rfl

===== Proof 3718 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  apply bsup_comp.{u, v, w}
  <;> intros
  <;> apply hf
  <;> assumption

===== Proof 3719 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [‚Üê hg]; apply lt_blsub

===== Proof 3720 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [hc, blsub_eq_lsub]

===== Proof 3721 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [hlsub_comp.{u, v, w} hf hg, blsub_eq_lsub]

===== Proof 3722 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by formal_injective_projections

===== Proof 3723 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  exact blsub_comp.{max u v, u, v} hf hg

===== Proof 3724 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [hg]; exact blsub_eq_blsub _ _

===== Proof 3725 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  simp only [blsub_eq_lsub, lsub_comp.{u, v, w} hf hg]

===== Proof 3726 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [‚Üê hg]; apply lt_blsub

===== Proof 3727 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  revert hf hg
  intros hf hg
  exact blsub_comp_of_mono.{u, u, v} hf hg

===== Proof 3728 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  simp_all only [brange_comp.{u, v, w}, blsub_comp.{u, v, w}, lt_brange_of_blsub_lt]

===== Proof 3729 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [lhsub_eq_blsub, lhsub_eq_blsub]

===== Proof 3730 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by tauto

===== Proof 3731 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [‚Üê hg]; apply lt_blsub

===== Proof 3732 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [‚Üê hg]; apply lt_blsub

===== Proof 3733 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [‚Üê bsup_eq_blsub]

===== Proof 3734 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  rw [lsub_eq_blsub]
  rw [lsub_eq_blsub]
  rw [lsub_eq_blsub]
  exact blsub_comp.{u, u, u} (fun _ _ h => hf _ _ h) hg

===== Proof 3735 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  simp only [bsup_eq_blsub_succ_of_lt (h := blsub_lt_blsub_of_lt (by rw [hg]; apply lt_blsub))]
  rw [eq_comm, hg]
  apply blsub_congr
  intro
  apply succ_injective

===== Proof 3736 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by aesop

===== Proof 3737 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  rw [hg];
  apply blsub_comp.{u, v, w} (fun _ _ _ _ h => succ_le_succ_iff.2 (hf _ _ h))
  <;> rfl

===== Proof 3738 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  simp only [bsup_eq_blsub_of_lt_ord_lift, Function.comp]
  rw [‚Üê blsub_eq_blsub_iff_lt_ord_lift]
  exact hg

===== Proof 3739 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [‚Üê bslope_bSup]

===== Proof 3740 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [hg]; exact blsub_eq_blsub'

===== Proof 3741 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  apply Eq.symm
  apply le_antisymm <;>
  simp only [blsub_le_iff, hg, lt_blsub_iff] <;>
  intro i hi <;>
  apply hf <;>
  exact lt_blsub _ _ _

===== Proof 3742 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [blsub_eq_lsub, blsub_eq_lsub.{u, w}]

===== Proof 3743 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [‚Üê hg]; apply lt_blsub

===== Proof 3744 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ‚àÄ a < o, Ordinal.{max u v w}}
    (hf : ‚àÄ {i j} (hi) (hj), i ‚â§ j ‚Üí f i hi ‚â§ f j hj) {g : ‚àÄ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [‚Üê hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  rw [blsub]
  simp_rw [blsub]
  rw [‚Üê hg]
  rfl

===== Proof 3745 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  apply (add_lt_add_iff_left _).2
  apply (add_lt_add_iff_left _).2
  apply (add_lt_add_iff_left _).2
  apply (mul_lt_mul_iff_left (by exact lt_of_le_of_lt (Ordinal.zero_le _) ha)).2 hb

===== Proof 3746 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  calc a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
    (a' ‚®≥ b ‚®≥ c) ‚ôØ (a ‚®≥ b' ‚®≥ c) ‚ôØ (a ‚®≥ b ‚®≥ c') ‚ôØ (a' ‚®≥ b' ‚®≥ c') :=
    (add_lt_add_of_lt_of_le (add_lt_add_of_lt_of_le (add_lt_add_of_lt_of_le
      (nmul_lt_nmul_of_lt_left hb (lt_of_le_of_lt (Ordinal.zero_le _) ha))
      (nmul_le_nmul_right (nmul_le_nmul_left (le_of_lt hc) hb)))
      (nmul_le_nmul_right (nmul_le_nmul_left (le_of_lt hb) hc)))
    (nmul_le_nmul_right (nmul_le_nmul_left (le_of_lt ha) hc))
  _ = (a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c)) ‚ôØ (a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c')) := by
    simp only [add_assoc, add_left_comm, nadd_nmul]
  _ < (a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c)) ‚ôØ (a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c')) := by
    apply lt_of_le_of_lt _ (lt_succ _)
    rw [‚Üê nadd_one, nadd_assoc, add_one_eq_succ]
    apply add_le_add_left
    have hc : c ‚â§ c' := le_of_lt hc
    exact nmul_le_nmul_right (nmul_le_nmul_right hc) hb

===== Proof 3747 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have : a' ‚®≥ (b ‚®≥ c) < a ‚®≥ (b ‚®≥ c) := nmul_lt_nmul_left ha _
  have : a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) < a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c) :=
    nadd_lt_nadd_right this _
  have : a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') <
      a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c) :=
    nadd_lt_nadd_right this _
  exact this.trans_le (le_nadd_of_lt ha)

===== Proof 3748 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  refine' lt_of_le_of_lt (nadd_le_nadd_right (nadd_le_nadd_right (nadd_le_nadd_right
    (nmul_le_nmul_left ha _) _) _) _) _
  refine' lt_of_le_of_lt (nadd_le_nadd_right (nadd_le_nadd_right (nadd_le_nadd_right (nadd_le_nadd_right
    (nadd_le_nadd_left (nmul_le_nmul_left hb _) _) _) _) _) _) _
  refine' lt_of_le_of_lt (nadd_le_nadd_right (nadd_le_nadd_right (nadd_le_nadd_right (nadd_le_nadd_right
    (nadd_le_nadd_left (nmul_le_nmul_left hc _) _) _) _) _) _) _
  exact (lt_congr_right (lt_add_of_pos_left _ (lt_add_of_pos_left _ (lt_add_of_pos_left _
    (lt_add_of_pos_left _ (nmul_pos (Ordinal.pos_iff_ne_zero.2 <| ‚Üê ha.ne) _))))) _).mp hb

===== Proof 3749 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have h1 := nadd_lt_nadd_right (nmul_lt_nmul_right ha c) (a ‚®≥ (b' ‚®≥ c))
  have h2 := nadd_lt_nadd_right (nmul_lt_nmul_left (nmul_lt_nmul_right hb c) a) (a' ‚®≥ (b ‚®≥ c))
  have h3 := nadd_lt_nadd_right (nmul_lt_nmul_left (nmul_lt_nmul_right hc b) a) (a' ‚®≥ (b' ‚®≥ c))
  have h4 := nadd_lt_nadd_left (nmul_lt_nmul_right hb c) (a' ‚®≥ (b ‚®≥ c))
  have h5 := nadd_lt_nadd_left (nmul_lt_nmul_left (nmul_lt_nmul_right hc b) a) (a' ‚®≥ (b' ‚®≥ c))
  have h6 := nadd_lt_nadd_left (nmul_lt_nmul_right hc b) (a' ‚®≥ (b ‚®≥ c))
  have h7 := nadd_lt_nadd_left (nmul_lt_nmul_right hb c) (a ‚®≥ (b' ‚®≥ c))
  exact h1.trans (h2.trans (h3.trans (h4.trans (h5.trans (h6.trans h7))))))

===== Proof 3750 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have := nmul_nadd_lt ha (lt_trans hb hc) hc
  have := nmul_nadd_lt hb (lt_trans ha hc) hc
  have := nmul_nadd_lt hb (lt_trans hc ha) ha
  have := nmul_nadd_lt hc (lt_trans ha hb) hb
  have := nmul_nadd_lt hc (lt_trans hb ha) ha
  simp only [nadd_assoc, nadd_left_comm]
  norm_cast
  omega

===== Proof 3751 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have := nmul_nadd_lt' hb hc
  have := nmul_nadd_lt' ha this
  have := nmul_nadd_lt' hb hc
  have := nmul_nadd_lt' ha this
  have := nmul_nadd_lt' hb hc
  have := nmul_nadd_lt' ha this
  have := nmul_nadd_lt' hb hc
  have := nmul_nadd_lt' ha this
  simp only [nadd_assoc, nadd_left_comm, nadd_left_comm]
  norm_cast
  omega

===== Proof 3752 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  exact nadd_lt_nadd_left (nmul_nadd_right' hb hc) _

===== Proof 3753 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [‚Üê add_assoc, ‚Üê add_assoc, ‚Üê add_assoc, ‚Üê add_assoc,
    add_lt_add_iff_left, ‚Üê nadd_eq_add]
  repeat rw [‚Üê mul_nadd]
  exact nmul_nadd_lt' hb hc

===== Proof 3754 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have h := nmul_nadd_lt'' ha (lt_trans hb (lt_succ _)) (lt_trans hc (lt_succ _))
  have h' := nmul_nadd_lt'' hb (lt_trans hc (lt_succ _)) (lt_trans ha (lt_succ _))
  have h'' := nmul_nadd_lt'' hc (lt_trans ha (lt_succ _)) (lt_trans hb (lt_succ _))
  rw [succ_nadd, succ_nadd, succ_nadd] at *
  exact lt_of_le_of_lt (nadd_le_nadd (nmul_le_nmul_right' (le_of_lt h))
    (nadd_le_nadd (nmul_le_nmul_right' (le_of_lt h')) h'')) h

===== Proof 3755 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  exact nadd_lt_nadd_right (nadd_lt_nadd_right (nadd_lt_nadd_right (nadd_lt_nadd_left   hc _) _)
    _) _

===== Proof 3756 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have := nmul_nadd_lt ha (nmul_nadd_lt hb hc)
  have := nmul_nadd_lt hb (nmul_nadd_lt ha hc)
  have := nmul_nadd_lt hc (nmul_nadd_lt ha hb)
  have := nmul_nadd_lt ha (nmul_nadd_lt hb hc)
  have := nmul_nadd_lt hb (nmul_nadd_lt ha hc)
  have := nmul_nadd_lt hc (nmul_nadd_lt ha hb)
  simp_all only [nadd_assoc, nadd_left_comm, nadd_right_comm, nadd_lt_nadd_iff]

===== Proof 3757 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [‚Üê add_lt_add_iff_left]
  simpa only [nadd_assoc, nmul_assoc, nadd_lt, nmul_lt_nmul_iff_left] using add_lt_add hb hc

===== Proof 3758 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [add_comm (a' ‚®≥ _), ‚Üê add_assoc, add_comm (a ‚®≥ _), ‚Üê add_assoc,
    add_assoc (a ‚®≥ _), add_assoc (a ‚®≥ _), ‚Üê add_assoc (a' ‚®≥ _)]
  exact
    nadd_lt_nadd_left (nmul_nadd_lt‚ÇÇ hb hc) _

===== Proof 3759 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [add_assoc]
  rw [add_assoc]
  rw [add_assoc]
  rw [add_assoc]
  rw [add_assoc]
  rw [add_assoc]
  rw [add_assoc]
  rw [add_assoc]
  rw [add_assoc]
  rw [add_assoc]
  nadd_lt.2 (nmul_nadd_lt ha (nmul_nadd_lt hb hc))

===== Proof 3760 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  simp_all only [nadd_assoc, nadd_lt_nadd_iff_left]
  exact nmul_nadd_lt'' hb hc

===== Proof 3761 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  apply (add_lt_add_iff_right _).2
  apply (add_lt_add_iff_right _).2
  apply (add_lt_add_iff_left _).2
  apply (nmul_lt_nmul_of_pos_left hb _).trans
  exact nmul_pos ha (lt_of_le_of_lt (Ordinal.zero_le _) hc)

===== Proof 3762 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  simp only [nadd_lt_nadd_iff_left, nmul_lt_nmul_iff_right]
  exact nmul_nadd_lt_nmul_nadd_of_lt_of_lt hb hc ha

===== Proof 3763 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [add_assoc, add_assoc, ‚Üê add_assoc (a' ‚®≥ _), ‚Üê add_assoc (a ‚®≥ _),
    ‚Üê add_assoc (a' ‚®≥ _), ‚Üê add_assoc (a ‚®≥ _)]
  exact nadd_lt_nadd_left (lt_nmul_right _ hb) _ |>.trans_le
    (nmul_nadd_le_nmul_nadd_of_not_zero _ (lt_nmul_right _ ha).not_le)

===== Proof 3764 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  refine lt_of_lt_of_le
    (nadd_lt_nadd_left ((nmul_lt_nmul_of_pos_left hb (Ordinal.pos_iff_ne_zero.2 (by simp))).trans ?_)
      ?_)
    ¬∑ exact nmul_nadd_lt‚ÇÉ ha hb hc
    ¬∑ rw [nadd_assoc, ‚Üê nadd_assoc a' (b ‚®≥ c) (a ‚®≥ (b' ‚®≥ c)), nadd_assoc,
        nadd_assoc]

===== Proof 3765 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have h‚ÇÅ : a' ‚®≥ (b ‚®≥ c) < a ‚®≥ (b ‚®≥ c) :=
    nmul_lt_nmul_of_pos_left ha ((Ordinal.zero_lt_succ b).trans hb)
  have h‚ÇÇ : a ‚®≥ (b' ‚®≥ c) < a ‚®≥ (b ‚®≥ c) :=
    nmul_lt_nmul_of_pos_left hb ((Ordinal.zero_lt_succ c).trans hc)
  have h‚ÇÉ : a ‚®≥ (b ‚®≥ c') < a ‚®≥ (b ‚®≥ c) :=
    nmul_lt_nmul_of_pos_left hc ((Ordinal.zero_lt_succ b).trans hb)
  have h‚ÇÑ : a' ‚®≥ (b' ‚®≥ c') < a' ‚®≥ (b ‚®≥ c) :=
    nmul_lt_nmul_of_pos_left hc ((Ordinal.zero_lt_succ b').trans hb)
  simp only [nadd_assoc, nadd_lt_nadd_iff_left]
  exact nadd_lt_nadd h‚ÇÅ (nadd_lt_nadd h‚ÇÇ (nadd_lt_nadd h‚ÇÉ h‚ÇÑ))

===== Proof 3766 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [add_lt_add_iff_right, add_lt_add_iff_right, add_lt_add_iff_right]
  simpa only [mul_assoc, one_mul] using mul_nlinarith {a, b, c, a', b', c'} ha hb hc

===== Proof 3767 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [lt_iff_le_not_le, not_le]
  refine' ‚ü®Ordinal.nmul_le_nmul_left (.nmul_le_nmul_left (.nmul_le_nmul_right hb c)) a, fun h ‚Ü¶ _‚ü©
  apply Ordinal.not_lt_zero; rw [‚Üê Ordinal.lt_zero_iff_zero]
  simpa only [add_zero, zero_add, le_zero_iff] using h.trans_le (Ordinal.zero_le _)

===== Proof 3768 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have h‚ÇÅ : a' ‚®≥ (b ‚®≥ c) < a ‚®≥ (b ‚®≥ c) := nmod_lt_of_lt ha (npow_lt_nofail hb)
  have h‚ÇÇ : a ‚®≥ (b' ‚®≥ c) < a ‚®≥ (b ‚®≥ c) := nmod_lt_of_lt (npow_lt_nofail hc) ha
  have h‚ÇÉ : a ‚®≥ (b ‚®≥ c') < a ‚®≥ (b ‚®≥ c) := nmod_lt_of_lt ha (npow_lt_nofail (npow_lt_nofail hc))
  have h‚ÇÑ : a' ‚®≥ (b' ‚®≥ c') < a ‚®≥ (b' ‚®≥ c) := nmod_lt_of_lt (npow_lt_nofail hc) ha
  nlinarith only [h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ]

===== Proof 3769 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [add_comm (a' ‚®≥ _), ‚Üê nadd_assoc, ‚Üê nadd_assoc]
  refine nadd_lt_nadd_left ?_ _
  rw [add_comm (a' ‚®≥ _), ‚Üê nadd_assoc, ‚Üê nadd_assoc]
  refine nadd_lt_nadd_left ?_ _
  rw [add_comm (a' ‚®≥ _), ‚Üê nadd_assoc, ‚Üê nadd_assoc]
  refine nadd_lt_nadd_left ?_ _
  rwa [nadd_comm, nadd_comm a']

===== Proof 3770 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  apply Ordinal.lt_of_le_of_lt (Ordinal.madd_le_madd _ (Ordinal.madd_le_madd le_rfl (Ordinal.npow_le_npow _ hb)))
  apply Order.lt_of_lt_of_le (Ordinal.madd_lt_madd_left _ (Ordinal.madd_lt_madd_right (Ordinal.madd_lt_madd_left _ ha) ha))
  apply Ordinal.madd_le_madd (Ordinal.npow_le_npow _ le_rfl) (Ordinal.le_refl _)

===== Proof 3771 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [‚Üê nadd_assoc, ‚Üê nadd_assoc]
  rw [‚Üê nadd_assoc, ‚Üê nadd_assoc]
  rw [nadd_comm]
  nadd_lt_nadd_of_lt_of_le (nmul_nadd_lt'.2 hb) (nmul_nadd_le.2 ha)

===== Proof 3772 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  apply (nadd_lt_nadd_iff_right (a ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c'))).2
  apply (nadd_lt_nadd_iff_right (a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c'))).2
  apply nmul_nadd_lt‚ÇÇ' <;> assumption

===== Proof 3773 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have hba : b' < b ‚®≥ a := lt_nmul_iff.mpr (Or.ite (le_refl a) hb)
  have habc : a ‚®≥ (b' ‚®≥ c) < b ‚®≥ (a ‚®≥ c) :=
    nmul_lt_nmul_of_pos (nmul_pos hb Ordinal.zero_lt_one)
      (nmul_pos ha Ordinal.zero_lt_one)
  have h : b ‚®≥ c' < b ‚®≥ (a ‚®≥ c) := nmul_lt_nmul_of_pos (nmul_pos hb Ordinal.zero_lt_one)
      (lt_nmul_iff.mpr (Or.ite (le_refl a) hc))
  nlinarith only [ha, hb, hc, hba, habc, h]

===== Proof 3774 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  obtain ‚ü®a, rfl‚ü© := lt_lift_iff.1 ha
  obtain ‚ü®b, rfl‚ü© := lt_lift_iff.1 hb
  obtain ‚ü®c, rfl‚ü© := lt_lift_iff.1 hc
  simp only [lift_nmul_limit, lift_nmul, lift_nadd, lift_id]
  rw [‚Üê add_assoc, ‚Üê add_assoc, nadd_assoc, nadd_assoc, nadd_assoc, nadd_assoc,
    nadd_lt_nadd_of_lt _ (nmul_nadd_lt' hb hc), nadd_lt_nadd_of_lt _ (nmul_nadd_lt' hb hc)]
  simp only [add_assoc, lt_add_iff_pos_right, nmul_pos hb hc, nmul_pos ha hc, nmul_pos ha hb,
    zero_lt_one]

===== Proof 3775 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  have h := nadd_lt_nadd_right (nmul_lt_nmul_of_lt ha (nmul_lt_nmul_of_lt hb hc)) _
  have h' :=
    nadd_lt_nadd_of_lt_of_lt (nmul_lt_nmul_of_lt hb hc) (nmul_lt_nmul_of_lt ha (nmul_lt_nmul_of_lt hb hc))
  simp only [nadd_nmul, ‚Üê nadd_assoc, nadd_lt_nadd_iff_left] at h h' ‚ä¢
  exact lt_of_le_of_lt (le_of_lt h') h

===== Proof 3776 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le‚ÇÉ Ordinal.nmul_nadd_le‚ÇÉ

theorem nmul_nadd_lt‚ÇÉ' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ‚®≥ (b ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b ‚®≥ c') ‚ôØ a' ‚®≥ (b' ‚®≥ c') <
      a ‚®≥ (b ‚®≥ c) ‚ôØ a' ‚®≥ (b' ‚®≥ c) ‚ôØ a' ‚®≥ (b ‚®≥ c') ‚ôØ a ‚®≥ (b' ‚®≥ c') := by
  rw [add_assoc, add_assoc, ‚Üê add_assoc (a' ‚®≥ _), ‚Üê add_assoc (a' ‚®≥ _),
    (by simp only [nadd_nmul, nadd_assoc, Nat.cast_add, Nat.cast_one, Nat.cast_mul]; abel :
      a' ‚®≥ b' ‚®≥ c ‚ôØ a ‚®≥ b' ‚®≥ c' =
        a' ‚®≥ (b' ‚®≥ c) ‚ôØ a ‚®≥ (b' ‚®≥ c') ‚ôØ (a ‚®≥ b ‚®≥ c' ‚ôØ a' ‚®≥ b' ‚®≥ c')),
    add_assoc]
  convert nmul_nadd_lt (a' ‚®≥ b' ‚®≥ c) (a ‚®≥ b' ‚®≥ c')
    (by simpa only [nadd_nmul] using
      mul_le_mul' (nmul_le_nmul_right ((lt_nadd_iff_left <| hb.trans (nadd_lt_nadd_left hc b)).1 ha) c)
        (nmul_le_nmul_right (nadd_lt_nadd_left hc b) a')) using 3 <;> simp only [nadd_nmul]; abel

===== Proof 3777 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by aesop

===== Proof 3778 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  let C := (3 : ‚Ñï) ‚Üí ‚Ñï
  let add_C := fun n:‚Ñï => n + C 2
  let add_C2 := (fun n:‚Ñï => n + C 2) 3
  let result1 := (add_C 2)
  let result2 := add_C2
  exact Eq.refl result1

===== Proof 3779 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  have h : -1 < 0 := by norm_num
  apply Nat.le_of_add_le_add_left
  nlinarith

===== Proof 3780 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [mul_one, T_zero]
  exact degree_C_le _

===== Proof 3781 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simp [degree_X_pow]

===== Proof 3782 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simp only [add_zero, mul_one, mul_zero, zero_mul, zero_add]
  apply eq_of_heq
  rw [heq_iff_eq]
  congr

===== Proof 3783 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rfl

===== Proof 3784 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [right_distrib]
  apply le_of_eq
  simp

===== Proof 3785 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simpa only [zero_add] using natDegree_C_le a

===== Proof 3786 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
 set_option linter.uppercaseLean3 false in
set_option linter.deprecated false in
### 
===== Proof 3787 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [T_zero, mul_one (C a)]
  apply le_of_eq
  rw [degree_C_mul_T_le]

===== Proof 3788 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by aesop

===== Proof 3789 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [degree_C]  <;>
  simp

===== Proof 3790 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [eq_comm]
  ring_nf
  simp

===== Proof 3791 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [T_zero, mul_one]
  apply degree_C_le

===== Proof 3792 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simp only [C_0, C_1, degree_zero, degree_one, zero_le_one, Nat.WithBot.one_le_iff_zero_le]
  aesop

===== Proof 3793 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  have h : X = T 0 := by simp
  rw [h]
  apply degree_C_mul_T_le

===== Proof 3794 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simpa using degree_C_le

===== Proof 3795 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by simpa using (commute_X (T 0) a).degree_le

===== Proof 3796 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by simpa using (Nat.le_of_eq rfl)

===== Proof 3797 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simp only [T_zero, mul_one]
  exact degree_C_le _

===== Proof 3798 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  apply degree_C_le

===== Proof 3799 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by rw [mul_one]

===== Proof 3800 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [‚Üê add_sub_cancel_right (natDegree a) (natDegree (a ^ 0))]
  simpa only [zero_add] using
    le_trans degree_sum_le (by simp [Nat.zero_le])

===== Proof 3801 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by decide

===== Proof 3802 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by simpa using (natDegree_C_le a).trans natDegree_T_le

===== Proof 3803 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [T_zero, mul_one]
  exact degree_C_le 0 a

===== Proof 3804 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [degree_C_mul_T_le (n := 0), Nat.cast_zero]
  <;> simp

===== Proof 3805 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [C_0]
  apply Nat.zero_le

===== Proof 3806 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  exact (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)

===== Proof 3807 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [T_zero, mul_one]
  rw [add_zero]
  rfl

===== Proof 3808 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ‚â§ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  apply le_of_eq
  simp

===== Proof 3809 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  have h : m = min m n := Eq.symm (Nat.min_eq_left hmn)
  rw [h]
  rfl

===== Proof 3810 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Ideal.Quotient.eq.2
  simp only [Submodule.quotientRel_r_def, AdicCauchySequence.val,
    Nat.cast_le, Nat.le_add_left, pow_add, pow_one, mul_comm I, mul_pow]
  exact (r.property hmn).symm

===== Proof 3811 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  rw [Ideal.Quotient.eq]
  rw [Ideal.Quotient.eq]
  exact (r.property hmn).symm

===== Proof 3812 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  simp only [Submodule.mem_pow_submodule_iff]
  aesop

===== Proof 3813 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  rw [AdicCauchySequence.property_quo hmn r]

===== Proof 3814 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  simp only [Ideal.pow_le_pow_iff] at hmn
  use hmn
  simp [Ideal.zero_eq_bot]

===== Proof 3815 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  simp only [AdicCauchySequence.val, Nat.sub_self, zero_add, Bool.and_eq_true]
  have h : m - m = 0 := by omega
  rw [h]
  rfl

===== Proof 3816 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  simpa using Ideal.Quotient.eq.2 (AdicCauchySequence.equiv r hmn)

===== Proof 3817 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  rw [Ideal.Quotient.eq]
  rw [Ideal.Quotient.eq]
  exact (r.property hmn).symm

===== Proof 3818 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  rw [‚Üê Ideal.Quotient.eq]
  apply AdicCauchySequence.zero_mk
  exact hmn

===== Proof 3819 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  rw [Ideal.Quotient.eq]
  exact (r.property hmn).symm

===== Proof 3820 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  use m
  exact le_refl m

===== Proof 3821 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  rw [Ideal.Quotient.eq, Ideal.Quotient.eq]
  simp_all
  exact AdicCauchySequence.cauchy _ _ _

===== Proof 3822 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  rw [Ideal.Quotient.eq]
  exact (r.property hmn).symm

===== Proof 3823 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  have h‚ÇÅ : m ‚â§ n := hmn
  rw [Ideal.Quotient.eq]
  exact (r.property h‚ÇÅ).symm

===== Proof 3824 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  simp only [Submodule.mem_pow_sub_mul_pow I, exists_prop, Ideal.one_eq_top, Submodule.mem_top,
    forall_true_left, Nat.sub_self, pow_zero, pow_one, sub_self, Nat.sub_zero, pow_one,
    Ideal.one_eq_top, Submodule.mem_top, forall_true_left]
  use ‚ü®m, hmn‚ü©
  simp

===== Proof 3825 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  have : n = m + (n - m) := by omega
  rw [this]
  simp [Ideal.Quotient.eq]

===== Proof 3826 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  rw [Ideal.Quotient.eq_zero_iff_mem]
  apply Ideal.pow_mem_pow
  apply r.property
  omega

===== Proof 3827 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply congr_arg _ (r.val_stable hmn)

===== Proof 3828 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  rw [Ideal.Quotient.eq]
  exact (r.property hmn).symm

===== Proof 3829 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  simp [Ideal.Quotient.eq, Ideal.mem_pow_sub_pow_of_pow_eq hmn hmn]

===== Proof 3830 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  rw [AdicCauchySequence.property_of_delta r m n hmn]

===== Proof 3831 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply AdicCauchySequence.mk_eq_mk hmn

===== Proof 3832 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  obtain ‚ü®k, hk‚ü© := hmn
  simp [hk]
  aesop

===== Proof 3833 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  rw [Ideal.Quotient.eq]
  apply Ideal.pow_mem_pow
  exact hmn

===== Proof 3834 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  rw [‚Üê Ideal.Quotient.eq]
  simp only [Submodule.mk_eq_mk, Nat.add_eq, add_zero, Nat.le_add_left, zero_add, zero_le,
    and_self_iff, exists_self_iff, forall_true_iff, Ideal.one_eq_top, Nat.cast_zero, zero_add,
    exists_prop, exists_eq_left, and_true_iff]
  rw [‚Üê Ideal.Quotient.eq]
  simp [hmn]

===== Proof 3835 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  rw [‚Üê sub_eq_zero]
  simp only [sub_val]
  apply AdicCauchySequence.mk_eq_zero _ hmn

===== Proof 3836 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  rcases hmn with ‚ü®k, rfl‚ü©
  simp

===== Proof 3837 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  rw [Ideal.Quotient.eq_zero_iff_mem]
  apply Ideal.pow_le_pow_right hmn
  apply r.property

===== Proof 3838 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  apply Ideal.Quotient.eq_zero_iff_mem.mpr
  rw [Submodule.mem_pow_eq]
  exact ‚ü®n - m, by omega, by simp‚ü©

===== Proof 3839 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  rw [‚Üê sub_eq_zero]
  simp [hmn, sub_eq_zero, Ideal.Quotient.eq]

===== Proof 3840 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ‚Ñï} (hmn : m ‚â§ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  apply Eq.symm
  rw [Ideal.Quotient.eq]
  rw [Ideal.Quotient.eq]
  simp_all [AdicCauchySequence.property_of_cauchy, Ideal.pow_le_pow_right hmn]

===== Proof 3841 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3842 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  apply Quotient.inductionOn c
  intro Œ±
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  simp only [e, card_type]

===== Proof 3843 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®f, hf‚ü© := card_eq_or_le_aleph0 c
  cases' f with f
  ¬∑ exact hf.1.trans ord_aleph0.symm
  have := hf.2 f
  simp [ord, this]

===== Proof 3844 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by import Mathlib;  let ‚ü®r, _, e‚ü© := ord_eq Œ±;  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why;  simp
only [mk'_def, e, card_type]

===== Proof 3845 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp only [cardinal.ord_le, le_refl]

===== Proof 3846 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  simpa using Ordinal.card_ord c

===== Proof 3847 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3848 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by tauto

===== Proof 3849 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  have := choose_spec (ord_is_inhabited c)
  convert congr_arg card this
  simp
  rfl

===== Proof 3850 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]
  rfl

===== Proof 3851 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  apply mk_ord_out

===== Proof 3852 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by import Mathlib
  aesop

===== Proof 3853 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let [inst] := AliveInstancesMap.mk 
===== Proof 3854 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  apply Quotient.inductionOn c
  intro Œ±
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  simp only [card_type, e, card_def]
  apply Quot.sound
  exact ‚ü®RelIso.symm (RelIso.toRelIsoRight (type_symm_eq Œ±).symm)‚ü©

===== Proof 3855 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simpa using Nat.card_eq_of_bijective (fun _ => r) (fun x y _ => rfl) (fun _ => ‚ü®x, rfl‚ü©)

===== Proof 3856 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by aesop

===== Proof 3857 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  apply Quotient.inductionOn c
  intro Œ±
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  simp only [Cardinal.mk'_def, e, card_type]

===== Proof 3858 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3859 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3860 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  rcases c with ‚ü®Œ±‚ü©
  apply Quotient.inductionOn Œ±
  intro Œ±
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  simp only [mk_ordinal_out, e, card_type]

===== Proof 3861 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3862 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3863 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let I := Finset.univ.filter (fun p => Nat.Prime (p.1 + p.2 + 1))
  let f : ‚Ñï √ó ‚Ñï ‚Üí ‚Ñï := fun p => (p.1 + p.2 + 1).factors.length
  let m := Finset.univ.filter (fun p : ‚Ñï √ó ‚Ñï => Nat.Prime (p.fst + p.snd + 1))
  have : ‚àÄ p : ‚Ñï √ó ‚Ñï, p ‚àà m ‚Üî p ‚àà Finset.univ ‚àß Nat.Prime (p.fst + p.snd + 1) := by simp [m]
  let k := Finset.image f m
  have : ‚àÄ p : ‚Ñï, p ‚àà k ‚Üî ‚àÉ q : ‚Ñï √ó ‚Ñï, q.fst + q.snd + 1 = p + 1 ‚àß Nat.Prime (q.fst + q.snd + 1) := by
    intro p
    simp only [Finset.mem_image, Finset.mem_filter, Finset.mem_univ, true_and_iff, exists_prop]
    constructor
    ¬∑ rintro ‚ü®a, ‚ü®b, c, rfl‚ü©, rfl‚ü©
      use b, c
      simp
    ¬∑ rintro ‚ü®b, c, rfl, rfl‚ü©
      use b + c + 1
      simp
  let P := Finset.filter (fun p : ‚Ñï √ó ‚Ñï => p.fst < p.snd) Finset.univ
  have h‚ÇÅ : P.card = 2 * I.card := by
    simp only [Finset.filter_eq, Finset.card_univ, Finset.card_product]
    rfl
  have h‚ÇÇ : m.card = 2 * I.card := by
    simp only [Finset.card_univ, Finset.card_product]
    rfl
  have h‚ÇÉ : k.card ‚â§ m.card := by
    apply Finset.card_image_le.trans
    simp only [Finset.card_univ, Finset.card_product]
    rfl
  have h‚ÇÑ : k.card < m.card := by
    apply Finset.card_lt_card
    simp only [Finset.card_univ, Finset.card_product]
    rfl
  have h‚ÇÖ : k.card < 2 * I.card := by
    apply lt_of_lt_of_le h‚ÇÑ
    simp only [Finset.card_univ, Finset.card_product]
    rfl
  have h‚ÇÜ : k.card + 1 ‚â§ m.card := by
    apply succ_le_of_lt
    apply lt_of_le_of_lt (add_le_add_left (by rfl) k.card)
    simp only [Finset.card_univ, Finset.card_product]
    rfl
  linarith

===== Proof 3864 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3865 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3866 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  cases c <;> rename_i Œ±
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  simp only [mk'_def, e, card_type]

===== Proof 3867 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simpa

===== Proof 3868 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3869 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  rcases c with ‚ü®Œ±‚ü©
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  simp only [mk'_def, e, card_type]

===== Proof 3870 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by aesop

===== Proof 3871 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by cases c <;> simp [mk_ord_out]

===== Proof 3872 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun Œ± => by
    let ‚ü®r, _, e‚ü© := ord_eq Œ±
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  let ‚ü®r, _, e‚ü© := ord_eq Œ±
  -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
  simp only [mk'_def, e, card_type]

===== Proof 3873 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;>
    (repeat' intro h; rw [‚Üê Subalgebra.mem_toSubalgebra, h, Subalgebra.mem_toSubalgebra])

===== Proof 3874 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h
  case mp => simp_all
  case mpr => rw [h]

===== Proof 3875 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  refine' ‚ü®fun h => ext fun x => ?_, fun h => by rw [h]‚ü©
  have := congr_arg (by exact (¬∑ x)) h
  simpa using this

===== Proof 3876 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor
  intro h
  cases' F with F _
  cases' E with E _
  congr
  assumption
  intro h
  rw [h]

===== Proof 3877 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h
  case mp =>
    rw [‚Üê toSubalgebra_toSubfield]
    rw [‚Üê toSubalgebra_toSubfield] at h
    exact Subalgebra.ext h
  case mpr =>
    rw [h]

===== Proof 3878 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor
  intro h
  cases F
  cases E
  congr
  rw [‚Üê Algebra.toSubalgebra_toSubring, h, Algebra.toSubalgebra_toSubring]
  intro h
  rw [h]

===== Proof 3879 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h
  <;> simp_all
  <;> congr <;> simp_all
  <;> congr <;> simp_all

===== Proof 3880 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor
  case mp =>
    intro h
    simp_all only [toSubalgebra_comap_eq, Subalgebra.comap_id]
    apply toSubalgebra_injective
    rw [h]
  case mpr =>
    intro h
    rw [h]

===== Proof 3881 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h <;> rw [‚Üê le_antisymm_iff, ‚Üê le_antisymm_iff] <;>
    simp_all only [le_antisymm_iff, toSubalgebra_le_iff]

===== Proof 3882 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h <;> cases F <;> cases E <;> congr

===== Proof 3883 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h
  rw [‚Üê toSubalgebra_toSubfield, h, toSubalgebra_toSubfield]
  rw [‚Üê toSubalgebra_toSubfield, h, toSubalgebra_toSubfield]

===== Proof 3884 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h <;> cases F <;> cases E <;> congr

===== Proof 3885 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h <;> cases F <;> cases E <;> congr

===== Proof 3886 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor
  intro h
  cases' F with F hF
  cases' E with E hE
  congr
  assumption
  intro h
  rw [h]

===== Proof 3887 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  apply Iff.intro
  intro h
  cases' F with F_toSubfield F_neg_mem F_add_mem F_mul_mem.
  cases' E with E_toSubfield E_neg_mem E_add_mem E_mul_mem.
  simp_all
  intro h
  rw [h]

===== Proof 3888 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h
  ¬∑ cases F
    cases E
    congr
  ¬∑ rw [h]

===== Proof 3889 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  exact ‚ü®fun h ‚Ü¶ Subalgebra.ext (by rw [h]), fun h ‚Ü¶ by rw [h]‚ü©

===== Proof 3890 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h <;> cases F <;> cases E <;> congr

===== Proof 3891 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h <;> cases' F with F hF <;> cases' E with E hE <;> simp_all

===== Proof 3892 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ by rw [h]‚ü©
  have := congr_arg toSubalgebra h
  aesop

===== Proof 3893 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  exact ‚ü®fun h => by cases F; cases E; congr, fun h => by rw [h]‚ü©

===== Proof 3894 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  have h‚ÇÅ : F.toSubalgebra = E.toSubalgebra ‚Üí F = E := by
    intro h
    exact toSubalgebra_injective h
  have h‚ÇÇ : F = E ‚Üí F.toSubalgebra = E.toSubalgebra := by
    intro h
    rw [h]
  exact ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©

===== Proof 3895 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  simp_rw [toSubalgebra_eq_iff]
  exact ‚ü®fun h => ext fun x => mul_mem_cancel_right (inv_mem F x) |>.1 (h ‚ñ∏ mul_mem_cancel_left (inv_mem E x)) ,
    fun h => h ‚ñ∏ rfl‚ü©

===== Proof 3896 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> simp_all only [toSubalgebra_eq_iff] <;> intro h <;> simp_all

===== Proof 3897 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor
  intro h
  apply toSubalgebra.inj
  rw [h]
  intro h
  rw [h]

===== Proof 3898 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro <;> rfl

===== Proof 3899 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  cases' F with _ _ _ _ F_center
  cases' E with _ _ _ _ E_center
  simp_all

===== Proof 3900 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor
  intro h
  ext x
  have h1 := congr_arg (fun F : IntermediateField K L => ‚Ü•F) h
  simpa using h1
  intro h
  rw [h]

===== Proof 3901 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro <;> subst_vars <;> rfl

===== Proof 3902 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  apply Iff.intro
  ¬∑ intro h
    cases' F with F_carrier F_zero F_add F_smul F_one F_mul F_neg F_inv F_div F_pow F_zpow F_toSubsemiring
    cases' E with E_carrier E_zero E_add E_smul E_one E_mul E_neg E_inv E_div E_pow E_zpow E_toSubsemiring
    simp_all only [toSubalgebra, OneMemClass.coe_one, OneMemClass.of_toOne, mul_one,
      Subsemiring.copy_eq, Nat.one_ne_zero, Nat.zero_eq,
      Subsemiring.step_eq_one_iff, Nat.succ_ne_zero, false_and, false_or, true_and]
    simp_all
  ¬∑ intro h
    rw [h]

===== Proof 3903 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor <;> intro h <;> induction F <;> cases E <;> congr
  <;> simp_all

===== Proof 3904 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ‚Üî F = E := by
  constructor
  intro h
  cases' F with F hF
  cases' E with E hE
  simp_all
  intro h
  rw [h]

===== Proof 3905 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [‚Üê h‚ÇÇ.comp_eq_id, comp_assoc, comp_id, comp_id]
    _ = g‚ÇÇ := by rw [h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3906 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _  = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3907 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id]
    _ = g‚ÇÇ := by rw [h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3908 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3909 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by
      rw [h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3910 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _  = g‚ÇÇ ‚àò f ‚àò g‚ÇÅ := by rw [h‚ÇÅ.comp_eq_id, comp_id]
    _  = g‚ÇÇ         := rfl

===== Proof 3911 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3912 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3913 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3914 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3915 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3916 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3917 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id]; simp
    _ = g‚ÇÇ := by rw [h‚ÇÅ.comp_eq_id]; simp

===== Proof 3918 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3919 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3920 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3921 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3922 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3923 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3924 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by simp [h‚ÇÇ.eq]
    _ = g‚ÇÇ := by simp [h‚ÇÅ.eq]

===== Proof 3925 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3926 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3927 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3928 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üêcomp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3929 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ ‚àò f ‚àò g‚ÇÅ := by rw [h‚ÇÅ.comp_eq_id, comp_id]

===== Proof 3930 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3931 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3932 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3933 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3934 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3935 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3936 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : Œ± ‚Üí Œ≤} {g‚ÇÅ g‚ÇÇ : Œ≤ ‚Üí Œ±} (h‚ÇÅ : LeftInverse g‚ÇÅ f)
    (h‚ÇÇ : RightInverse g‚ÇÇ f) : g‚ÇÅ = g‚ÇÇ :=
  calc
    g‚ÇÅ = g‚ÇÅ ‚àò f ‚àò g‚ÇÇ := by rw [h‚ÇÇ.comp_eq_id, comp_id]
    _ = g‚ÇÇ := by rw [‚Üê comp.assoc, h‚ÇÅ.comp_eq_id, id_comp]

===== Proof 3937 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp only [polar, right_distrib, mul_neg, sub_neg_eq_add, add_comm]
  ring

===== Proof 3938 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp [polar, neg_mul]

===== Proof 3939 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_comm, polar_comm, polar_neg_left]

===== Proof 3940 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar, polar, ‚Üê neg_one_mul y, map_mul, map_mul]
  ring

===== Proof 3941 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_comm Q x, polar_comm Q y, polar_neg_right, neg_neg]

===== Proof 3942 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp only [polar, neg_mul, mk_neg]
  rw [‚Üê mul_right_inj' (two_ne_zero' R)]
  ring_nf

===== Proof 3943 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp [polar, neg_smul]

===== Proof 3944 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp only [polar, smul_neg]
  rw [neg_mul_eq_mul_neg]

===== Proof 3945 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_comm, polar_comm Q y x, polar_neg_left]

===== Proof 3946 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp only [polar, right_distrib, map_neg, mul_neg, neg_mul]
  ring

===== Proof 3947 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp [polar, add_comm]

===== Proof 3948 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_comm, polar_comm Q y x, polar_neg_left]

===== Proof 3949 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_right, polar_comm, polar_neg_left, neg_neg]

===== Proof 3950 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp only [polar, right_neg]
  ring

===== Proof 3951 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  unfold polar
  simp [add_comm]

===== Proof 3952 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp only [polar, ‚Üê neg_one_smul R y, (1 : R) ‚Ä¢ y = y, neg_neg, one_mul, MulOpposite.op_neg]
  ring

===== Proof 3953 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp [polar, neg_mul, sub_eq_add_neg]

===== Proof 3954 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_add_right, add_neg_self, map_zero]

===== Proof 3955 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp only [polar, right_distrib, right_distrib, right_distrib]
  ring_nf

===== Proof 3956 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_right, map_neg]
  <;> rfl

===== Proof 3957 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp only [polar, right_distrib, left_distrib, map_neg, mul_neg, neg_neg]
  ring

===== Proof 3958 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp [polar, neg_mul]

===== Proof 3959 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar, polar, ‚Üê neg_one_mul x, ‚Üê neg_one_mul y]
  simp_all only [neg_mul, one_mul, neg_neg, map_neg, Function.comp_apply, LinearEquiv.coe_coe]
  rw [add_comm]

===== Proof 3960 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp [polar, ‚Üê smul_eq_mul]

===== Proof 3961 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_def, polar_def, neg_eq_iff_eq_neg]
  simp [add_comm]

===== Proof 3962 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_comm Q x y, polar_comm Q x (-y)]
  simp only [map_neg, polar_comm Q x y]
  rw [neg_eq_neg_one_mul, neg_eq_neg_one_mul]
  ring

===== Proof 3963 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_right, polar_comm, neg_eq_iff_eq_neg]
  simp

===== Proof 3964 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp [polar, neg_eq_iff_eq_neg]

===== Proof 3965 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_comm, polar_comm Q y x, polar_neg_left]

===== Proof 3966 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_right, map_neg]

===== Proof 3967 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  rw [polar_comm Q x y, polar_comm Q x (-y)]
  simp only [polar_neg]
  rw [neg_neg, neg_neg]

===== Proof 3968 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by
  simp only [polar, neg_sq, map_neg]
  ring_nf

===== Proof 3969 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  aesop

===== Proof 3970 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply image‚ÇÇ_congr
  simp_all

===== Proof 3971 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  refine' rcongr (map_congr fun _ _ => rfl) (map_congr fun _ _ => rfl) _
  aesop

===== Proof 3972 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply image‚ÇÇ_congr
  simp_all

===== Proof 3973 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  aesop

===== Proof 3974 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  classical simp [filter_eq_self]

===== Proof 3975 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply image‚ÇÇ_congr
  aesop

===== Proof 3976 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  let r := Finset.biUnion s fun a ‚Ü¶ Finset.biUnion t fun b ‚Ü¶ {f a b, f' a b}
  have : image‚ÇÇ f s t ‚äÜ r ‚àß image‚ÇÇ f' s t ‚äÜ r := ‚ü®fun ‚ü®a, ha‚ü© ‚Ü¶ by aesop, fun ‚ü®a, ha‚ü© ‚Ü¶ by aesop‚ü©
  have : r ‚äÜ image‚ÇÇ f s t ‚à® r ‚äÜ image‚ÇÇ f' s t := by
    apply or_iff_not_imp_left.2
    intro h
    have : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b := by aesop
    aesop
  aesop

===== Proof 3977 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply Eq.symm
  simp_all [Set.image2_eq_empty_iff]

===== Proof 3978 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  aesop

===== Proof 3979 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  aesop

===== Proof 3980 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by aesop

===== Proof 3981 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  aesop

===== Proof 3982 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  aesop

===== Proof 3983 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  intros a ha b hb
  simp only [ha, hb]
  aesop

===== Proof 3984 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  basic_cases t; basic_cases s; simp_all

===== Proof 3985 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  simp_rw [image‚ÇÇ]
  ext
  simp

===== Proof 3986 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  /-
  We aim to show that if two binary functions \( f \) and \( f' \) are equal for all elements in sets \( s \) and \( t \), then the images of these sets under \( f \) and \( f' \) are also equal. Specifically, we need to prove that \( \text{image‚ÇÇ} \, f \, s \, t = \text{image‚ÇÇ} \, f' \, s \, t \).
  
  1. **Equality of Functions**: Given that \( \forall a \in s, \forall b \in t, f a b = f' a b \), we can use this property to show the equality of the images.
  2. **Congruence of Images**: By the definition of the image of a binary function over two sets, we need to show that the set of all \( f a b \) where \( a \in s \) and \( b \in t \) is the same as the set of all \( f' a b \) where \( a \in s \) and \( b \in t \).
  3. **Element-wise Equality**: For any element \( z \) in the image of \( f \) over \( s \) and \( t \), there exist \( a \in s \) and \( b \in t \) such that \( f a b = z \). By the given equality \( f a b = f' a b \), we have \( z = f' a b \), which means \( z \) is also in the image of \( f' \) over \( s \) and \( t \).
  4. **Reverse Inclusion**: Similarly, for any element \( z \) in the image of \( f' \) over \( s \) and \( t \), there exist \( a \in s \) and \( b \in t \) such that \( f' a b = z \). By the given equality \( f a b = f' a b \), we have \( z = f a b \), which means \( z \) is also in the image of \( f \) over \( s \) and \( t \).
  
  Thus, the images of \( s \) and \( t \) under \( f \) and \( f' \) are equal.
  -/
  -- We use the fact that the image of the function over the coerced sets is equal.
  rw [image‚ÇÇ_swap]
  -- We apply the symmetry of the image‚ÇÇ function and the given equality of functions.
  exact image‚ÇÇ_congr fun a ha b hb ‚Ü¶ h _ ha _ hb

===== Proof 3987 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  aesop

===== Proof 3988 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  -- later implements the proof using these hypotheses

===== Proof 3989 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply image‚ÇÇ_congr
  simp_all

===== Proof 3990 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply funext
  intro x
  apply funext
  intro y
  simp_all

===== Proof 3991 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  ext
  aesop

===== Proof 3992 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  simp_rw [mk_image‚ÇÇ_finset, ‚Üê image_eq_image2]
  exact image_congr fun a ha b hb => h a ha b hb

===== Proof 3993 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply Eq.symm
  apply image‚ÇÇ_congr
  simp_all

===== Proof 3994 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply Eq.symm
  apply Eq.symm
  simp_all

===== Proof 3995 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply Anti
  intro X
  apply le_csInf_iff.2
  exact ‚ü®fun x h => ?_, fun Q hQ x hx => hQ hx‚ü©
  rw [h]
  apply csInf_le
  exact ‚ü®0, fun x hx => ?_‚ü©
  rw [h]
  exact le_refl 0

===== Proof 3996 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  rw [image‚ÇÇ_swap]
  apply image‚ÇÇ_congr
  intros a ha b hb
  simp_all

===== Proof 3997 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply image‚ÇÇ_congr
  simp_all

===== Proof 3998 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  intro h
  refine' Finset.cons_subset_cons _ (Finset.cons_subset_cons _ (Finset.cons_subset_cons _Finset.empty_subset))
  all_goals simp [h, Finset.mem_singleton, Finset.mem_insert]

===== Proof 3999 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  refine' fun b hb => _
  obtain ‚ü®‚ü®i, hi‚ü©, ‚ü®a, ha‚ü©, hab‚ü© := hb
  simp_all

===== Proof 4000 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image‚ÇÇ_congr (h : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, f a b = f' a b) : image‚ÇÇ f s t = image‚ÇÇ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply Eq.symm
  apply Eq.symm
  aesop

===== Proof 4001 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero hab
  intro x hx
  apply ContinuousAt.continuousWithinAt
  exact hfa.continuousAt.continuousWithinAt
  intro x hx
  apply ContinuousAt.continuousWithinAt
  exact hfb.continuousAt.continuousWithinAt

===== Proof 4002 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  obtain ‚ü®c, hc, hc'‚ü© := exists_deriv_eq_zero (fun x hx ‚Ü¶ hfa.mono_left <| nhdsWithin_mono _ Ioo_subset_Ioi_self)
    (fun x hx ‚Ü¶ hfb.mono_left <| nhdsWithin_mono _ Ioo_subset_Iio_self) hab
  exact ‚ü®c, hc, hc'‚ü©

===== Proof 4003 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  have hnc : ‚àÄ x : ‚Ñù, x ‚àà Ioo a b ‚Üí ContinuousOn f (Icc a b) := by
    intro x hx
    exact ContinuousOn.mono
      (Continuous.continuousOn (by continuity : Continuous f)) (Icc_subset_Ici_self.trans
      (Icc_subset_Icc_left hx.1))
  obtain ‚ü®x, hx, hf‚ü© :=
    IntermediateValue.intermediate_value_Ioo hab hnc (hfa.mono_left (by
      simp only [nhdsWithin, nhds_eq_order, if_true, Ioi_subset_Ioi_iff]
      exact le_refl a)) (hfb.mono_left (by
      simp only [nhdsWithin, nhds_eq_order, if_true, Iio_subset_Iio_iff]
      exact le_refl b))
  exact ‚ü®x, hx, by simpa only [deriv_const x 0] using hf‚ü©

===== Proof 4004 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero
  exacts [hab, hfa, hfb]

===== Proof 4005 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  let s := {x | f x < l}
  have hs : ‚àÄ x ‚àà s, ‚àÉ c ‚àà Ioo a x, deriv f c = 0 := by
    intro x hx
    exact exists_deriv_eq_zero (lt_of_le_of_lt (le_of_lt hx) hfa) (lt_of_lt_of_le hx hfb)
  obtain ‚ü®c, hc, hc'‚ü© := hs b (lt_of_le_of_lt (le_of_lt hab) hfb)
  exact ‚ü®c, hc, hc'‚ü©

===== Proof 4006 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero (fun x hx => ?_) hab.ne hfa hfb
  apply ContinuousWithinAt.mono _ (Ioo_subset_Ico_self)
  exact continuous_iff_continuousAt.1 (continuous_iff_continuousAt.2 hf) x

===== Proof 4007 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  obtain ‚ü®c, c_in, hc‚ü© := exists_isLocalMin_mem_open hab.ne hfa hfb
  use c, c_in
  exact hc.1.deriv_eq_zero

===== Proof 4008 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  obtain ‚ü®c, hc, hfc‚ü© := exists_Ioo_extr_on_Icc hab.le hfa hfb
  exact ‚ü®c, hc, sub_eq_zero.1 hfc‚ü©

===== Proof 4009 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  have hfa' : ‚àÉ c, c ‚àà Ioo a b ‚àß f c = l := by
    have h := exists_Ioo_mem_of_mem_nhdsWithin (hfa.mono_left (nhdsWithin_le_nhds (Ioi_mem_nhds
        (lt_mem_nhds (Algebra.Order.Ring.toPMin ‚ÄπRing Œ±‚Ä∫ (lt_self_iff_false _).mp hab))))
      )
    obtain ‚ü®c, hc, hfc‚ü© := h
    exact ‚ü®c, hc, hfc.symm‚ü©
  obtain ‚ü®c, hc, hfc‚ü© := hfa'
  exact ‚ü®c, hc, by aesop‚ü©

===== Proof 4010 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  obtain ‚ü®d, had, h‚ü© := exists_isLocalMin_mem_Ioo hab hfa hfb
  exact ‚ü®d, ‚ü®had.1, had.2.1‚ü©, h‚ü©

===== Proof 4011 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  obtain ‚ü®a', ha'‚ü© := exists_between hab
  obtain ‚ü®b', hb'‚ü© := exists_between ha'
  have hfa' : Tendsto f (ùìù[>] a') (ùìù l) := hfa.mono_left (nhdsWithin_mono a' Ioi_subset_Ioi_self)
  have hfb' : Tendsto f (ùìù[<] b') (ùìù l) := hfb.mono_left (nhdsWithin_mono b' Iio_subset_Iio_self)
  obtain ‚ü®c, c_in, hc‚ü© := exists_deriv_eq_zero f l hfa' hfb' (by linarith)
  exact ‚ü®c, Ioo_subset_Ioo_left a' hc_in, hc‚ü©

===== Proof 4012 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero (by linarith) (hfa.mono Ioo_subset_Ioi_self) (hfb.mono Ioo_subset_Iio_self)

===== Proof 4013 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero
  <;> simp_all [f.continuous]
  <;> simp_all [hab]

===== Proof 4014 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero le_rfl (by linarith) hfa hfb

===== Proof 4015 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  cases' exists_hasDerivAt_eq_slope f hab.le hfa hfb with c hc
  exact ‚ü®c, hc.1, hc.2‚ü©

===== Proof 4016 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  obtain ‚ü®c, hc, hf‚ü© := exists_Ioo_extr_on_Ioo hab hfa hfb
  use c, hc
  simp_all

===== Proof 4017 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  obtain ‚ü®d, h‚ÇÄ, h‚ÇÅ‚ü© := exists_Ioo_subset_of_mem_nhds (Ioi_mem_nhds hab)
  obtain ‚ü®e, h‚ÇÇ, h‚ÇÉ‚ü© := exists_Ioo_subset_of_mem_nhds (Iio_mem_nhds hab)
  exact ‚ü®d, ‚ü®h‚ÇÄ.1, h‚ÇÄ.2‚ü©,
    by simp_all‚ü©

===== Proof 4018 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero hab hfa hfb

===== Proof 4019 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero (by linarith : a < b) _ _ hfa hfb
  aesop

===== Proof 4020 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  exact exists_deriv_eq_zero hab hfa hfb

===== Proof 4021 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  exact exists_deriv_eq_zero hab hfa hfb

===== Proof 4022 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  obtain ‚ü®c, hc, hc'‚ü© : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
    have hdiff : DifferentiableOn ‚Ñù f (Ioo a b) :=
      hfa.differentiableOn_of_mem (Ioo_mem_nhds hc.1 hc.2)
        (hfb.mono (Ioo_subset_Iio_self))
    exact exists_deriv_eq_zero hab hdiff
  exact ‚ü®c, hc, hc'‚ü©

===== Proof 4023 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  have hne := (tendsto_nhds_unique hfa hfb).unique (Tendsto.mono_left hfa nhdsWithin_le_nhds)
    (Tendsto.mono_left hfb nhdsWithin_le_nhds)
  obtain ‚ü®c, hc, hc'‚ü© := exists_hasDerivAt_eq_zero' hab hne
  exact ‚ü®c, hc, hc'.2‚ü©

===== Proof 4024 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero
  exacts [hab, hfa, hfb]

===== Proof 4025 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  have h : Ioo a b ‚â† ‚àÖ := nonempty_Ioo.mpr hab
  have h‚ÇÅ : ContinuousOn f (Icc a b) := by
    refine' ContinuousOn.mono _ _
    ¬∑ exact (differentiableOn_Ioo.mp
        (differentiable_of_deriv_ne_zero (fun x hx => deriv_ne_zero_of_tendsto_nhdsWithin hfa hfb hx)
          h)).continuousOn
    ¬∑ exact Icc_subset_Ioo (left_mem_Icc.mpr hab.le) (right_mem_Icc.mpr hab.le)
  obtain ‚ü®c, hc, h‚ÇÇ‚ü© := exists_Ioo_extr_on_Icc hab.le h‚ÇÅ (hfa.mono Ioo_subset_Icc_self)
    (hfb.mono Ioo_subset_Icc_self)
  exact ‚ü®c, hc, by aesop‚ü©

===== Proof 4026 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  have hdiff : DifferentiableOn ‚Ñù f (Ioo a b) := by
    intro x hx
    rcases hx with ‚ü®hx1, hx2‚ü©
    exact
      ((differentiableAt_of_tendsto_nhds hfa hx1).differentiableWithinAt.mono
        (Ioo_subset_Ioi_self))
        .congr_of_eventuallyEq
        (Ioo_mem_nhds hx1 hx2)
        (Eq.refl (f x))
  exact exists_deriv_eq_zero hdiff (tendsto_nhdsWithin_of_tendsto_nhds hfa)
    (tendsto_nhdsWithin_of_tendsto_nhds hfb) hab

===== Proof 4027 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  have h : ‚àÉ c ‚àà Ioo a b, IsLocalMin f c := by
    apply exists_isLocalMin_mem_Ioo hab hfa hfb
  obtain ‚ü®c, ‚ü®hc‚ÇÅ, hc‚ÇÇ‚ü©, hc‚ÇÉ‚ü© := h
  use c, hc‚ÇÅ
  exact deriv_eq_zero_of_isLocalMin hc‚ÇÉ hc‚ÇÇ

===== Proof 4028 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  have hfa' : ‚àÄ·∂† x in ùìù[>] a, f x = l := by
    filter_upwards [hfa.eventually (‚àÄ·∂† y in ùìù l, y = l)] with x hx
    exact hx.self_of_nhdsWithin hfa
  have hfb' : ‚àÄ·∂† x in ùìù[<] b, f x = l := by
    filter_upwards [hfb.eventually (‚àÄ·∂† y in ùìù l, y = l)] with x hx
    exact hx.self_of_nhdsWithin hfb
  obtain ‚ü®c, hc, hc'‚ü© := exists_deriv_eq_zero f hab.ne hfa' hfb'
  exact ‚ü®c, hc, hc'‚ü©

===== Proof 4029 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  have hne : a ‚â† b := by linarith
  have h : ‚àÉ c ‚àà Ioo a b, f c = l := by
    apply exists_mem_open_nhdsWithin_of_tendsto_punctured_nhds
      ¬†-- Porting note: add this instance
    exact hne
    exact hfa
    exact hfb
  obtain ‚ü®c, hc, hfc‚ü© := h
  exact ‚ü®c, hc, sub_eq_zero.1
    (unique_diff_on_Ioo a b hne c hc.1 hc.2 (deriv_const_on_Ioo a b l hc.1 hc.2) hfc)‚ü©

===== Proof 4030 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  have hne : a ‚â† b := by linarith
  have h : ‚àÉ c, f b = f a + (b - a) ‚Ä¢ deriv f c := by
    apply exists_eq_mul_left_of_dvd
    apply Differentiable.hasDerivAt _ (hne ‚ñ∏ hab.ne')
    apply DifferentiableOn.differentiableAt _ isOpen_Ioo (Ioo_mem_nhds hab.ne')
    apply ((hfa.sub <| tendsto_const_nhds).sub <| tendsto_const_nhds).deriv_eq_zero
    exact (hfb.sub <| tendsto_const_nhds).sub <| tendsto_const_nhds
  obtain ‚ü®c, hc‚ü© := h
  use c, Ioo_mem_nhds hab.lt.ne'
  simpa [hc, sub_eq_zero] using (norm_deriv_zero_of_tendsto_nhds (hfa.sub <| tendsto_const_nhds)
    (hfb.sub <| tendsto_const_nhds) hne).symm

===== Proof 4031 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  apply exists_deriv_eq_zero (by linarith) hfa hfb
  aesop

===== Proof 4032 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (ùìù[>] a) (ùìù l))
    (hfb : Tendsto f (ùìù[<] b) (ùìù l)) : ‚àÉ c ‚àà Ioo a b, deriv f c = 0 := by
  by_cases h : ‚àÄ x ‚àà Ioo a b, deriv f x = 0
  ¬∑ exact ‚ü®(a + b) / 2, by linarith [h ((a + b) / 2) (by linarith)], h _ (by linarith)‚ü©
  ¬∑ push_neg at h
    obtain ‚ü®c, hc, hc'‚ü© := h
    exact ‚ü®c, hc, hc'‚ü©

===== Proof 4033 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  exact Cardinal.mk_denumerable S

===== Proof 4034 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  -- Mathlib.Algebra.Algebra.Defs
  -- Mathlib.Algebra.Order.BigOperators.Ring.Finset
  -- Mathlib.Data.Nat.Choose.Sum
  -- Mathlib.Tactic.Linarith
  -- Mathlib.Tactic.Ring
  -- Mathlib.Tactic.WouldPrefer

/-!
# Generating a combinatorial identity

Given a list of numbers, we can try to generate a combinatorial identity
that expresses the number in terms of binomial coefficients.

## Algorithm

1. On the left-hand side, we start with 
===== Proof 4035 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  simp_rw [FiniteDimensional]
  rw [‚Üê Basis.ofVectorSpaceIndex_eq_zero_iff, ‚Üê finrank_eq_zero,
    LinearMap.finrank_range_add_finrank_ker, (mem_ker _).1 (Pi.zero_apply 0),
    LinearMap.finrank_range_add_finrank_ker]
  rfl
  <;> aesop

===== Proof 4036 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  rw [le_antisymm_iff]
  constructor <;> intro H <;> apply _root_.le_of_eq
  <;> rw [‚Üê restrict_add_add_inter _ _ hs, _root_.add_self_eq_mul_two, ‚Üê
    ENNReal.mul_le_mul_right (show 2 ‚â† 0 by norm_num)]
  <;> linarith [H]

===== Proof 4037 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  aesop

===== Proof 4038 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  suffices ‚àÄ {s : Set Œ±} (_ : MeasurableSet s), ŒΩ.restrict s = Œº.restrict s ‚Üí ‚àÄ t ‚äÜ s, ŒΩ t = Œº t by
    intro s hs
    exact ‚ü®this (ŒΩ.restrict_apply s), fun t hts ht => this (hts.trans (inter_subset_left (t := s)))‚ü©
  intro s _ H t hts
  rw [‚Üê Measure.restrict_apply (MeasurableSet.inter_of_left ht hs), ‚Üê Measure.restrict_apply ht,
    H]

===== Proof 4039 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  rw [show Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, Œº t = ŒΩ t by
    suffices ‚àÄ t ‚äÜ s, Œº t = ŒΩ t ‚Üí Œº.restrict s t = ŒΩ.restrict s t by
      refine ‚ü®?_, fun h => ?_‚ü© <;>
        ¬∑ rintro h rfl
          simpa only [‚Üê restrict_apply_univ, zero_apply] using h univ (subset_univ _) (MeasurableSet.univ)
    rintro t hts ht
    rw [restrict_apply ht, restrict_apply ht, hts hts, hts, hts]
    ¬∑ rfl
    ¬∑ assumption
  ]
  aesop

===== Proof 4040 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intro _; simp_rw [‚Üê forall_and]
  exact forall‚ÇÇ_congr fun a _ => Iff.symm <| by simp_rw [and_imp, ‚Üê forall_and, forall_prop_of_true]

===== Proof 4041 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  rw [Measure.restrict_congr_meas hs]
  aesop

===== Proof 4042 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intros
  simp_all

===== Proof 4043 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  revert hs
  refine' fun hs => ‚ü®fun h => h ‚ñ∏ rfl, fun h => _‚ü©
  ext1 t ht
  rw [h t inter_subset_left (ht.inter hs)]

===== Proof 4044 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intros a b c
  simp_all

===== Proof 4045 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  apply restrict_congr_meas
  assumption

===== Proof 4046 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  apply restrict_congr_meas
  exact fun t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht]
  exact fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]

===== Proof 4047 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  tauto

===== Proof 4048 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  apply restrict_congr_meas
  aesop

===== Proof 4049 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intro h
  by_contra h2
  simp_all

===== Proof 4050 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  aesop

===== Proof 4051 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intro o h_I_momÊàëÊúÄÂñúÊ¨¢ÁöÑflicks_I_love,
  exact ‚ü®fun h ‚Ü¶ h.1, fun h ‚Ü¶ ‚ü®h, rfl‚ü©‚ü©

===== Proof 4052 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  apply restrict_congr_meas
  assumption

===== Proof 4053 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intro h
  simp_all only [eq_self_iff_true, imp_true_iff, and_self_iff, heq_iff_eq,
    exists_prop, exists_eq_left']

===== Proof 4054 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  simp [Set.Nonempty]

===== Proof 4055 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  constructor
  intro h t hts ht
  rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, h, restrict_apply ht]
  intro H
  ext t
  rw [restrict_apply MeasurableSet.inter_self, restrict_apply MeasurableSet.inter_self, H _ inter_subset_right (MeasurableSet.inter_self)]

===== Proof 4056 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  rcases n with (_ | _ | _ | _) <;> simp
  <;> aesop

===== Proof 4057 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  apply exists_unique_of_exists_of_unique <;> aesop

===== Proof 4058 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  constructor <;> intro H
  <;> ext t ht
  <;> simp_rw [restrict_apply ht]
  <;> exact H t (by simp) ht

===== Proof 4059 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intro hA hB
  rw [hA] at hB
  simpa using hB

===== Proof 4060 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intro x; simp [Nat.le_succ_iff]

===== Proof 4061 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  ring_nf
  aesop

===== Proof 4062 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  apply Iff.intro
  intro h t ht
  rw [‚Üê inter_eq_self_of_subset_left ht, ‚Üê h.apply, restrict_apply ht]
  intro h
  ext t ht
  rw [restrict_apply ht, restrict_apply ht, h t (inter_subset_right t s) (ht.inter hs)]

===== Proof 4063 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intros
  rfl

===== Proof 4064 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    Œº.restrict s = ŒΩ.restrict s ‚Üî ‚àÄ t ‚äÜ s, MeasurableSet t ‚Üí Œº t = ŒΩ t :=
  ‚ü®fun H t hts ht => by
    rw [‚Üê inter_eq_self_of_subset_left hts, ‚Üê restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]‚ü©
:= by
  intro h
  by_cases h2: a = 1
  simp [h2]
  have h3: a < 1 := by linarith
  linarith

===== Proof 4065 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
   cases' l with hl
   ¬∑ right
     exact ‚ü®by simp_all, by simp_all‚ü©
   ¬∑ cases' Decidable.eq_or_ne a b with hab hab <;> simp_all

===== Proof 4066 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' l with x xs
  ¬∑ rw [mem_cons, or_iff_left (by simp only [eq_self_iff_true, not_true, not_false_iff, and_true_iff])] at h
    exact h.imp_right (by simp only [and_true_iff, eq_self_iff_true, ne_eq, not_true, false_and_iff,
      and_false_iff])
  ¬∑ rw [mem_cons] at h
    rcases h with (rfl | h)
    ¬∑ exact Or.inl rfl
    ¬∑ exact Or.inr ‚ü®by rintro rfl; exact List.noConfusion rfl, h‚ü©

===== Proof 4067 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  rcases Decidable.eq_or_ne a b with rfl | hne <;> aesop

===== Proof 4068 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  rw [List.mem_cons] at h
  cases' h with h h
  exacts [Or.inl h, Or.inr ‚ü®by assumption, h‚ü©]

===== Proof 4069 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
   cases' Decidable.eq_or_ne a b with h' h' <;> simp_all [h']

===== Proof 4070 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  by_cases hab : a = b
  ¬∑ exact Or.inl hab
  ¬∑ exact ((List.mem_cons.1 h).elim (fun h => (hab h).elim) (fun h => Or.inr ‚ü®hab, h‚ü©))

===== Proof 4071 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' h with h h <;> simp_all

===== Proof 4072 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases h with
  | head =>
    rw [‚Üê mem_cons_self a l]
    simp
  | tail _ h =>
    exact (Decidable.eq_or_ne a b).elim Or.inl (fun hne ‚Ü¶ Or.inr ‚ü®hne, h‚ü©)

===== Proof 4073 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' Decidable.eq_or_ne a b with hab hab <;> simp_all

===== Proof 4074 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  rcases h with (rfl | h)
  case inl => simp
  case inr => simp [h.eq_or_ne, h]

===== Proof 4075 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' Decidable.eq_or_ne a b with ha ha <;> simp_all

===== Proof 4076 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  by_cases hab : a = b
  next => exact Or.inl hab
  next =>
    have := h
    simp only [hab, false_or] at this
    exact Or.inr ‚ü®hab, this‚ü©

===== Proof 4077 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  rw [List.mem_cons] at h
  cases' h with h h
  { left
    exact h }
  { right
    exact ‚ü®h.1, h.2‚ü© }

===== Proof 4078 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' Decidable.eq_or_ne a b with h' h' <;> simp_all

===== Proof 4079 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  rw [List.mem_cons] at h
  aesop

===== Proof 4080 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' Decidable.eq_or_ne a b with h' h' <;> simp_all

===== Proof 4081 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  by_cases hab : a = b
  case pos => simp [*]
  case neg => simp_all [List.mem_cons, not_or]

===== Proof 4082 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
   by_cases hab : a = b
   ¬∑ exact Or.inl hab
   ¬∑ exact
      Or.inr ‚ü®hab,
       (List.mem_cons.1 h).resolve_left hab‚ü©

===== Proof 4083 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  by_cases hab : a = b
  case pos => exact List.mem_cons.mp h |>.imp ~ rfl
  case neg =>
    exact List.mem_cons.mp h |>.imp (by simp [*] : a = b ‚Üí False) (by simp [*] : a ‚â† b ‚àß a ‚àà l)

===== Proof 4084 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  by_cases hab : a = b <;> simp_all
  exact Decidable.eq_or_ne a b

===== Proof 4085 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
   by_cases hab : a = b
    case pos ‚Ü¶ (left; assumption)
    case neg ‚Ü¶ (right; constructor; (intro; simp_all) <;> aesop)

===== Proof 4086 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' Decidable.eq_or_ne a b with hab hab <;> simp_all

===== Proof 4087 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases h with
  | head => simp
  | tail _ h =>
    aesop

===== Proof 4088 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
   cases By cases hy : a == b <;> simp_all [hy]

===== Proof 4089 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  induction l with
  | nil => simp_all
  | cons _ l_ih =>
    cases h <;> (rw [cons_eq_cons] at h; simp_all)

===== Proof 4090 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  by_cases hab : a = b
  ¬∑ exact Or.inl hab
  ¬∑ rw [eq_or_ne] at hab
    exact Or.inr ‚ü®hab, h.resolve_left hab‚ü©

===== Proof 4091 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' mem_cons.mp h with h h <;> aesop

===== Proof 4092 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  by_cases hab : a = b <;> simp_all

===== Proof 4093 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' Decidable.eq_or_ne a b with ac ac <;> simp_all

===== Proof 4094 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  cases' Decidable.eq_or_ne a b with hab hab <;> simp_all

===== Proof 4095 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  rw [‚Üê List.mem_cons] at h
  rcases h with (rfl | rfl) <;> simp [List.mem_cons, Decidable.eq_or_ne]

===== Proof 4096 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq Œ±]
    {a b : Œ±} {l : List Œ±} (h : a ‚àà b :: l) : a = b ‚à® a ‚â† b ‚àß a ‚àà l := by
  rw [List.mem_cons] at h
  cases' h with h h
  exacts [Or.inl h, Or.inr ‚ü®h, by assumption‚ü©]

===== Proof 4097 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc.closure_eq]; exact subset_closure
‚ü©

===== Proof 4098 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by
      rw [‚Üê Subset.antisymm_iff]
      apply And.intro
      ¬∑ exact IsClosedMap.closure_image_subset _ _
      ¬∑ exact image_closure_subset_closure_image hc
 ‚ü©

===== Proof 4099 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [‚Üê image_univ c] at *; apply hs‚ü©

===== Proof 4100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc.closure_eq]; exact subset_rfl
        ‚ü©

===== Proof 4101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc.closure_eq]; exact subset_rfl
‚ü©

===== Proof 4102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc.closure_eq]
        _ ‚äÜ f '' c := image_subset _ subset_closure
‚ü©

===== Proof 4103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc.closure_eq]; exact image_subset _ subset_closure
‚ü©

===== Proof 4104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by
  rw [IsClosedMap]
  intro hsf s
  rw [‚Üê closure_eq_iff_isClosed] at hc
  have hsf' : f '' closure s ‚äÜ closure (f '' s) :=
    image_closure_subset_closure_image hsf
  exact hsf'.antisymm (hs s)‚ü©

===== Proof 4105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by
  rw [‚Üê image_univ] at *
  rw [‚Üê image_univ] at *
  exact fun h => h _ isClosed_univ‚ü©

===== Proof 4106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by
  rw [‚Üê image_univ_eq_range] at *
  rw [hs c]
  exact image_closure_subset_closure_image hc‚ü©

===== Proof 4107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc.closure_eq]; exact subset_rfl‚ü©

===== Proof 4108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc.closure_eq]; exact subset_rfl‚ü©

===== Proof 4109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [‚Üê image_univ] at hc; rw [‚Üê image_univ]; exact closure_minimal hc (hs univ) ‚ü©

===== Proof 4110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc]
        _ = f '' c := by rw [hc]
        ‚ü©

===== Proof 4111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by
  intro s
  rw [subset_closure_iff_isClosed]
  exact (hs s).trans (image_closure_subset_closure_image <| by apply isClosedMap_id)

===== Proof 4112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [IsClosedMap.closure_image_subset]
        _ = f '' c := by rw [hc.closure_eq]‚ü©

===== Proof 4113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [‚Üê image_univ_eq_range] at *; simpa using hs univ‚ü©

===== Proof 4114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [‚Üê Subset.rfl]; exact image_closure_subset_closure_image hc
‚ü©

===== Proof 4115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by simpa using hc‚ü©

===== Proof 4116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc.closure_eq]; exact subset_rfl‚ü©

===== Proof 4117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [‚Üê image_univ] at *; exact fun s => hs univ‚ü©

===== Proof 4118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by
  rw [isClosedMap_iff_closure_image]
  aesop

===== Proof 4119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [‚Üê image_univ c] at *; rw [‚Üê image_univ c] at *; exact hs univ‚ü©

===== Proof 4120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [‚Üê hc.closure_eq]; exact image_closure_subset_closure_image hc
    ‚ü©

===== Proof 4121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc, image_univ, ‚Üê closure_eq_iff_isClosed.1 hc]‚ü©

===== Proof 4122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by simpa using hc‚ü©
    
    
theorem OpenMap.isOpenMap_iff_closure_preimage :
    OpenMap f ‚Üî ‚àÄ s, f '' closure s ‚äÜ closure (f '' s) :=
  ‚ü®OpenMap.closure_image_subset, fun hs c hc =>
    isOpen_iff_mem_nhds.2 <|
      calc
        f c ‚àà f '' closure c := mem_image_of_mem f hc
        _ ‚äÜ closure (f '' c) := hs c
        _ ‚äÜ f '' c := closure_minimal (subset_preimage_image _ _) hc.isClosed_compl.isOpen_compl‚ü©

===== Proof 4123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [‚Üê image_univ c]; apply hs‚ü©

===== Proof 4124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [hc.closure_eq]; exact subset_rfl‚ü©

===== Proof 4125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by
  rw [‚Üê image_univ_subset_iff] at hc
  have h := hs univ
  simp only [image_univ, Subset.rfl] at h
  simp only [‚Üê image_univ_subset_iff, hs, hc]‚ü©

===== Proof 4126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [‚Üê image_univ]; exact image_closure_subset_closure_image (fun _ _ => id) hc‚ü©

===== Proof 4127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by rw [image_closure_subset_closure_image hc]
        _ = f '' c := by rw [hc.closure_eq]‚ü©

===== Proof 4128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ‚Üî ‚àÄ s, closure (f '' s) ‚äÜ f '' closure s :=
  ‚ü®IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ‚äÜ f '' closure c := hs c
:= by
        rw [hc.closure_eq]; exact image_subset _ subset_closure‚ü©

===== Proof 4129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor
  next =>
    intro
    exact EffectiveEpiFamily.mk _ _ _
  next =>
    intro
    exact EffectiveEpimorphic.mk _ _ _

===== Proof 4130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  refine ‚ü®fun h => ?_, fun h => ?_‚ü©
  case refine_1 =>
    refine' ‚ü®h.exists_fac, fun Y f wf hf => _‚ü©
    obtain ‚ü®g, rfl, hg‚ü© := Presieve.ofArrows.mk_surj wf
    exact ‚ü®g, h.fac _ _, hg‚ü©
  case refine_2 =>
    exact ‚ü®fun Y f wf => h.desc (fun a => Y)
      (fun a => f) (fun {W} g‚ÇÅ g‚ÇÇ h => EffectiveEpiFamily.uniq _ _ _ h)‚ü©

===== Proof 4131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  case refine_1 =>
    have : _ ‚â´ _ = _ ‚â´ _ := (Presieve.ofArrows_eq X œÄ) ‚ñ∏ Presieve.ofArrows.isColimit (p := h)
    exact ‚ü®‚ü®‚ü®_, this‚ü©‚ü©‚ü©
  case refine_2 =>
    have : Presieve.ofArrows X œÄ ‚â§ _ := Presieve.ofArrows.le _ _
    exact IsColimit.ofIsoColimit ((Presieve.ofArrows.isColimit (p := h)) : _)
      (asIso <| eqToHom <| Presieve.ofArrows_eq X œÄ).symm

===== Proof 4132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  apply Iff.intro
  intro
  exact (Presieve.ofArrows X œÄ).effectiveEpiFamily_of_effectiveEpi _
  intro
  exact EffectiveEpiFamily.effectiveEpimorphic X œÄ

===== Proof 4133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor
  next =>
    intro
    infer_instance
  next =>
    intro
    infer_instance

===== Proof 4134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  cases Presieve.ofArrows X œÄ
  trivial

===== Proof 4135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  cases' h with Y f hf
  exact
    ‚ü®Y, f, hf, fun W g‚ÇÅ g‚ÇÇ hg => by
      rw [‚Üê Presieve.ofArrows.mk.inj_iff]
      apply hg‚ü©
  cases' h with Y f hf
  exact
    ‚ü®Y, f, hf, fun W g‚ÇÅ g‚ÇÇ hg => by
      rw [‚Üê Presieve.ofArrows.mk.inj_iff]
      apply hg‚ü©

===== Proof 4136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  cases' isEmpty_or_nonempty Œ± with h h
  case inl =>
    rw [Presieve.ofArrows_empty_pEmpty_eq, Presieve.effectiveEpimorphic_iff,
      PEmpty.effectiveEpiFamily_iff, Preadditive.effectiveEpi_iff_admissible_of_initial]
    apply FinEmptyEquiv.effectiveEpiFamily_iff
  case inr =>
    refine ‚ü®Presieve.EffectiveEpimorphic.to_EffectiveEpiFamily,
      EffectiveEpiFamily.to_EffectiveEpimorphic‚ü©

===== Proof 4137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  simp [Presieve.ofArrows, EffectiveEpimorphic, EffectiveEpiFamily]
  tauto

===== Proof 4138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor
  intro hŒ±
  refine' ‚ü®fun h => _, fun h => _‚ü©
  obtain ‚ü®Y, f, hf, hŒ±‚ü© := hŒ±
  have hh : ‚àÉ (Y : C) (f : (a : Œ±) ‚Üí X a ‚ü∂ Y),
      (Presieve.ofArrows X œÄ).CoEffectiveArrows hf f ‚àß IsColimit (Cofan.mk Y f) :=
    ‚ü®Y, f, hf, hŒ±‚ü©
  exact ‚ü®hh‚ü©
  obtain ‚ü®Y, f, hf, hŒ±‚ü© := h
  have hh : (Presieve.ofArrows X œÄ).CoEffectiveArrows hf f := hf
  exact ‚ü®Y, f, hh, hŒ±‚ü©

===== Proof 4139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  rfl

===== Proof 4140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor
  case mp =>
    intro h
    exact ‚ü®h.epiFamily, fun _ hY => hY.choose_spec, fun _ hY => hY.choose_spec‚ü©
  case mpr =>
    rintro ‚ü®h, h1, h2‚ü©
    apply EffectiveEpiFamily.mk
    intro Y g hg
    rcases hg with ‚ü®a, f, w‚ü©
    cases h1 a
    cases h2 a
    apply h

===== Proof 4141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor <;> intro h <;>
  simp only [Presieve.ofArrows, Presieve.ofArrows_mem, Sieve.generate, Sieve.pullback_arrows,
    Sieve.generate_ofArrows, Presieve.ofArrows_pushout_right, Sieve.EffectiveEpimorphic] at h ‚ä¢
  <;> exact h

===== Proof 4142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  simp only [EffectiveEpimorphic, Presieve.ofArrows, Presieve.FamilyOfElements, Presieve.ofArrows_apply,
    EffectiveEpiFamily, Finset.mem_coe]
  simp only [Finset.mem_coe]
  tauto

===== Proof 4143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  simp [EffectiveEpimorphic, Presieve.ofArrows, EffectiveEpiFamily, Presieve.ofArrows,
    Presieve.FamilyOfElements.SieveCompatible]

===== Proof 4144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  cases œÄ
  rfl

===== Proof 4145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  apply Iff.intro
  intro h
  apply EffectiveEpiFamily.mk
  exact h.getEffectiveEpi
  intro h
  apply EffectiveEpiFamily.mk
  exact h.getEffectiveEpi

===== Proof 4146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor
  next =>
    intro h
    refine' ‚ü®h.some, fun Y g hg => _‚ü©
    exact h.choose_spec hg
  next =>
    rintro ‚ü®Y, hY‚ü©
    exact ‚ü®Y, hY‚ü©

===== Proof 4147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  rfl

===== Proof 4148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  all_goals
    simp_all only [EffectiveEpimorphic, Presieve.ofArrows, toFamily,
      familyOfElements, NatTrans.IsEffectiveEpiFamily]
  all_goals
    refine' ‚ü®_, fun Y f hf => _‚ü©
  all_goals
    obtain ‚ü®Y, f, hf, ‚ü®i, ‚ü®‚ü©‚ü©‚ü© := hf
  all_goals
    simp_all only [eq_self_iff_true, and_self_iff, exists_apply_eq_apply, exists_true_left]
  all_goals
    aesop

===== Proof 4149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor <;> intro h
  case mp =>
    refine ‚ü®fun I Y f hf => ?_‚ü©
    let X' : I ‚Üí C := fun i => X (Classical.choose hf i)
    let œÄ' : (i : I) ‚Üí X' i ‚ü∂ B := fun i => œÄ _
    let ‚ü®W, g, hg, hg'‚ü© := h.1 X' œÄ'
    let ‚ü®x, hx‚ü© := hf
    refine ‚ü®fun i => g (Classical.choose hf i), fun i j => hg' _ _ ?_, ?_‚ü©
    ¬∑ rfl
    ¬∑ simpa using hg (Classical.choose hf i) (Classical.choose hf j)
  case mpr =>
    refine ‚ü®fun X' œÄ' f hf => ?_‚ü©
    let x : Œ± √ó Œ≤ ‚Üí I := fun t => Classical.choose (hf t.1 t.2)
    let y : Œ± √ó Œ≤ ‚Üí C := fun t => if h : t.1 ‚àà Set.range x then X' (Classical.choose h) else X' (Classical.choose (hf t.1 t.1))
    let g : (i : I) ‚Üí y (x i, i) ‚ü∂ B := fun i => œÄ' _
    have hg : ‚àÄ (i j : Œ± √ó Œ≤), i.1 ‚àà Set.range x ‚Üí j.1 ‚àà Set.range x ‚Üí X' i.1 = X' j.1 ‚Üí g i = g j := by
      rintro _ _ _ _ _ rfl
      simpa using hf _ _
    refine ‚ü®y, g, fun i j => ?_, fun i => ?_‚ü©
    ¬∑ simpa using hg _ _ (Classical.choose_spec <| hf i.1 i.2) (Classical.choose_spec <| hf j.1 j.2) (by simp)
    ¬∑ simpa using hf _ _

===== Proof 4150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor
  apply EffectiveEpiFamily.mk
  intro _ _
  exact
    { desc := fun {W} e w => Presieve.ofArrows.desc X œÄ e w
      fac := fun {W} e w => Presieve.ofArrows.fac X œÄ e w
      uniq := fun {W} e w m h => by
        ext a
        specialize h a
        simp only [Presieve.ofArrows.mk, Presieve.ofArrows.desc] at h
        exact h }
  apply EffectiveEpiFamily.mk
  intro _ _
  exact
    { desc := fun {W} e w => EffectiveEpiFamily.desc X œÄ e w
      fac := fun {W} e w => EffectiveEpiFamily.fac X œÄ e w
      uniq := fun {W} e w m h => by
        ext a
        specialize h a
        simp only [EffectiveEpiFamily.mk_desc, EffectiveEpiFamily.mk_fac] at h
        exact h }

===== Proof 4151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  simp [EffectiveEpimorphic, EffectiveEpiFamily, Presieve.ofArrows]

===== Proof 4152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  norm_num
  exact Iff.rfl

===== Proof 4153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor
  rintro ‚ü®h‚ü©
  refine' ‚ü®fun Y g hg => _‚ü©
  exact
    ‚ü®h (Presieve.ofArrows.mk hg), fun W g‚ÇÅ g‚ÇÇ h‚ÇÅ h‚ÇÇ w => by
      rcases hg with ‚ü®a, rfl‚ü©
      have := h.uniq (Presieve.ofArrows.mk hg) (ùüô _) g‚ÇÅ (by rfl) h‚ÇÅ
        (by rw [‚Üê w, Category.comp_id])
      simp at this
      rw [this]
      have := h.uniq (Presieve.ofArrows.mk hg) (ùüô _) g‚ÇÇ (by rfl) h‚ÇÇ
        (by rw [‚Üê w, Category.comp_id])
      simp at this
      rw [this]‚ü©
  rintro ‚ü®h‚ü©
  refine' ‚ü®fun Y g hg => _‚ü©
  rcases hg with ‚ü®a, rfl‚ü©
  exact
    ‚ü®h a, fun W g‚ÇÅ g‚ÇÇ h‚ÇÅ h‚ÇÇ w => by
      have := h a h‚ÇÅ h‚ÇÇ (by rw [‚Üê w])
      simpa using this‚ü©

===== Proof 4154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  simp [EffectiveEpimorphic, EffectiveEpiFamily]

===== Proof 4155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor
  case mp =>
    intro h
    refine' ‚ü®fun A g hg => _‚ü©
    obtain ‚ü®Y, f, ‚ü®i, ‚ü®‚ü©‚ü©, fac‚ü© := Presieve.ofArrows.mk _ _ _ _ _ hg
    exact ‚ü®i, ‚ü®f, fac‚ü©‚ü©
  case mpr =>
    rintro ‚ü®x, ex‚ü©
    refine' ‚ü®fun A g hg => _‚ü©
    obtain ‚ü®a, f, fac‚ü© := EffectiveEpiFamily.exists_fac _ _ _ hg
    refine' ‚ü®X a, f, a, rfl, fac‚ü©

===== Proof 4156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  simp [EffectiveEpimorphic, EffectiveEpiFamily]
  rw [Sieve.generate_family_of_epimorphisms]
  simp_rw [Sieve.forall]
  rfl

===== Proof 4157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  constructor
  case mp =>
    intro h
    exact EffectiveEpiFamily.mk _ _ h
  case mpr =>
    intro h
    exact EffectiveEpimorphic.mk _ _ h

===== Proof 4158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  simp

===== Proof 4159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  refine ‚ü®fun h ‚Ü¶?_, fun h ‚Ü¶?_‚ü©
  all_goals exact h.arrows.effectiveEpiFamily

===== Proof 4160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {Œ± : Type*}
    (X : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (X a ‚ü∂ B)) :
    (Presieve.ofArrows X œÄ).EffectiveEpimorphic ‚Üî EffectiveEpiFamily X œÄ := by
  refine' ‚ü®fun h => _, fun h => _‚ü©
  case refine'_1 =>
    exact EffectiveEpiFamily.mk _ _ (fun Y g hg => by
      obtain ‚ü®a, rfl‚ü© := Presieve.ofArrows.mk.symm.trans hg
      exact ‚ü®EffectiveEpi.desc h a, EffectiveEpi.fac h a‚ü©)
  case refine'_2 =>
    exact EffectiveEpimorphic.mk _ _ fun Y g => by
      obtain ‚ü®b, hb‚ü© := EffectiveEpiFamily.desc (id := (EffectiveEpiFamily.mk _ _
        (fun Y g hg => let ‚ü®a, ha‚ü© := Presieve.ofArrows.mk.1 hg;
        have := Presieve.ofArrows.mk.2 hg;
        (EffectiveEpi.mk _ (fun _ _ => ‚ü®a, ha‚ü©) (fun _ _ => hb))))) _ fun _ f => ‚ü®_, rfl‚ü©
      obtain ‚ü®a, rfl‚ü© := Presieve.ofArrows.mk.symm.trans hb
      exact ‚ü®b, hb _ _‚ü©)

===== Proof 4161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  ¬∑ exact ‚ü®‚ü®Set.Nonempty.of_mem (by simp : x ‚àà [x -[‚Ñù] y]), h‚ü©,
     ‚ü®x, Set.mem_of_mem_of_subset (by simp) h‚ü©,
    ‚ü®y, Set.mem_of_mem_of_subset (by simp) h‚ü©, by simp [Segment.mem_iff]‚ü©

===== Proof 4162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  rw [JoinedIn]
  refine' ‚ü®‚ü®x, y, _‚ü©, _‚ü©
  tauto
  exact h

===== Proof 4163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®‚ü®fun t => x + t ‚Ä¢ (y - x), _‚ü©, _‚ü©
  <;> simp
  <;> intro t ht <;> linarith

===== Proof 4164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®‚ü®Set.inclusion h, _, _‚ü©, rfl, rfl‚ü© <;> apply Continuous.continuousOn
  apply continuous_inclusion
  apply IsClosed.continuousOn
  apply IsOpen.isClosed_preimage
  apply Continuous.comp
  apply Continuous.comp
  apply Continuous.id
  apply Continuous.const
  <;> try apply continuous_id
  <;> try apply continuous_const
  <;> try apply continuous_add
  <;> try apply continuous_mul
  <;> try apply continuous_norm
  <;> try apply continuous_dist
  <;> try apply continuous_subset
  <;> try apply continuous_inclusion
  <;> try apply continuous_co

===== Proof 4165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  rw [JoinedIn]
  refine ‚ü®‚ü®Set.piecewise {x, y} (fun _ => (1 : ‚Ñù)) (fun _ => (0 : ‚Ñù)), ?_, ?_‚ü©, ?_‚ü©
  <;> simp_all

===== Proof 4166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  use‚ü®(1 - ¬∑) ‚Ä¢ x + ¬∑, by continuity‚ü©
  simp_all

===== Proof 4167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
   exact ‚ü®‚ü®x, y, h‚ü©, by simp‚ü©

===== Proof 4168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®‚ü®Set.piecewise {0} (fun _ ‚Ü¶ x) (fun _ ‚Ü¶ y), continuous_piecewise _ _ continuous_const,
    _‚ü©, by simp‚ü©
  rw [Set.piecewise_eq_of_mem] <;> simp
  <;> aesop

===== Proof 4169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®‚ü®Set.piecewise {0} (fun _ => x) fun _ => y, _‚ü©, _, _‚ü©
  <;> simp_all

===== Proof 4170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  rw [JoinedIn]
  refine ‚ü®‚ü®Set.inclusion h‚ü©, ?_‚ü©
  simp [Set.inclusion]

===== Proof 4171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®‚ü®x, y, h‚ü©, _‚ü©
  apply Int.continuous_of_discrete_topology

===== Proof 4172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®‚ü®Segment.set E, _, _‚ü©, ‚ü®1, _‚ü©, ‚ü®0, _‚ü©, _, _‚ü© <;> simp_all

===== Proof 4173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®‚ü®x, y, h, 1, 0, _‚ü©, _‚ü©
  simp_all

===== Proof 4174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  exact ‚ü®‚ü®Set.segment ‚Ñù x y, h‚ü©, Segment.mem_segment ‚Ñù x y‚ü©

===== Proof 4175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  rw [JoinedIn]
  exact ‚ü®Segment ‚Ñù x y, h, by simp‚ü©

===== Proof 4176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  use x, y, h
  simp

===== Proof 4177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine ‚ü®‚ü®x, y, h‚ü©, ?_‚ü©
  rw [LineMap_apply]
  exact ‚ü®0, by simp‚ü©

===== Proof 4178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®‚ü®(1 - ¬∑) ‚Ä¢ x + ¬∑ * y, _, _‚ü©, _, _‚ü©
  <;> simp [smul_sub, sub_smul, sub_sub_eq_add_sub, add_comm, add_left_comm]
  <;> intro Œ∏ <;> focus_sec
  <;> simp_all only [Set.mem_setOf_eq, Pi.smul_apply, Pi.add_apply, Pi.mul_apply,
    Function.comp_apply, smul_eq_mul]
  <;> linarith

===== Proof 4179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  rw [JoinedIn]
  exact ‚ü®[x -[‚Ñù] y], h, by simp‚ü©

===== Proof 4180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  use x, y, Set.mem_of_mem_of_subset (segment_subset_iff.mpr fun _ _ => rfl) h

===== Proof 4181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  exact ‚ü®‚ü®x, y, h‚ü©, by simp‚ü©

===== Proof 4182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  exact ‚ü®‚ü®Set.piecewise (Set.univ : Set (Fin 2)) (fun _ => x + (y - x) / 2) (fun _ => y - (y - x) / 2), by simp‚ü©, by simp‚ü©

===== Proof 4183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®fun t => x + t ‚Ä¢ (y - x), _, _‚ü©
  next => simp
  next => simpa using h

===== Proof 4184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®Set.piecewise {0} (fun _ => x) (fun _ => y), fun t => _‚ü©
  aesop

===== Proof 4185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  rw [JoinedIn]
  refine' ‚ü®‚ü®Set.piecewise {1, 2} (fun _ => x) (fun _ => y), _‚ü©, ‚ü®1, _‚ü©, ‚ü®2, _‚ü©‚ü©
  <;> simp_all

===== Proof 4186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine ‚ü®‚ü®x, ?_‚ü©, ‚ü®y, ?_‚ü©, ?_‚ü© <;> simp_all

===== Proof 4187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®‚ü®x, y, h‚ü©, _, _‚ü© <;> rfl

===== Proof 4188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®fun t => x + t ‚Ä¢ (y - x), _, _‚ü©
  <;> simp
  <;> intro t ht <;> simp [ht]

===== Proof 4189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine ‚ü®‚ü®Set.piecewise {1} (-x + ¬∑) fun _ => x, ?_, ?_‚ü©, ?_‚ü© <;> aesop

===== Proof 4190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  rw [JoinedIn]
  refine' ‚ü®‚ü®fun t ‚Ü¶ (1 - t) ‚Ä¢ x + t ‚Ä¢ y, _‚ü©, _‚ü©
  <;> simp [Submodule.mem_closure_singleton, ‚Üê zero_smul]
  <;> simp [h]

===== Proof 4191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine ‚ü®‚ü®Set.piecewise Set.univ (fun _ => x + (y - x)) fun _ => y, ?_‚ü©, by simp‚ü©
  refine Continuous.continuousOn (continuous_piecewise ?_ ?_ ?_)
  exacts [continuous_const, continuous_const.add (continuous_id.sub continuous_const),
    continuous_const]
  simp

===== Proof 4192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ‚Ñù E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ‚Ñù E]
    {x y : E} {s : Set E} (h : [x -[‚Ñù] y] ‚äÜ s) : JoinedIn s x y := by
  refine' ‚ü®fun t => x + t ‚Ä¢ (y - x), _, _‚ü©
  <;> simp_all

===== Proof 4193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  simp_rw [‚Üê smul_sum, smul_eq_mul]
  refine' Finset.sum_mono_set_of_nonpos fun i hi => _
  simpa only [sub_nonpos, Pi.smul_apply', nsmul_eq_mul, Nat.cast_id] using hfg.smul_comp_perm_le_smul hœÉ hi

===== Proof 4194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  classical
  simp only [‚Üê Equiv.sum_comp_perm_smul_eq_sum_smul]
  exact MonovaryOn.sum_comp_perm_smul_le_sum_smul hfg (by simpa using hœÉ)

===== Proof 4195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  refine' Finset.sum_le_sum fun i hi => _
  have hi' : œÉ i ‚àà s := hœÉ (by simpa using hi)
  rw [‚Üê hfg.sum_smul_comp_perm_eq hœÉ hi', hfg.sum_smul_apply_eq_sum_smul]

===== Proof 4196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  simp only [MonovaryOn, ge_iff_le] at hfg
  have hœÉ' : ‚àÄ x ‚àà s, œÉ x ‚àà s := fun x hx ‚Ü¶ hœÉ hx
  simp only [Finset.sum_smul, Finset.sum_comp_perm hœÉ']
  exact (Finset.sum_mono_set_of_nonneg fun i hi ‚Ü¶
    (hfg i hi).1 <| hœÉ' i hi).2 fun i hi ‚Ü¶ (hfg i hi).2

===== Proof 4197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  simp_rw [‚Üê hfg.sum_smul_comp_perm_le_sum_smul hœÉ]
  simp [mul_comm]

===== Proof 4198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  have hœÉ' : ‚àÄ i, i ‚àà s ‚Üí œÉ i ‚àà s := fun i hi ‚Ü¶ hœÉ (by simp [hi])
  have h : (‚àë i ‚àà s, f i ‚Ä¢ g i) = ‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i := by
    refine s.sum_bij'_eq_sum_bij (fun i _ ‚Ü¶ œÉ i) ?_ ?_ ?_ ?_
    ¬∑ intro; simp
    ¬∑ intro i hi; simpa using hœÉ' _ hi
    ¬∑ intro i _ j _ hij; exact (hfg.injOn hij).injective hij
    ¬∑ intro x _ hx; simpa using hœÉ' _ hx
  ¬∑ simp_rw [h]; rfl

===== Proof 4199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  calc
    (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) = ‚àë i ‚àà s, f i ‚Ä¢ g (œÉ‚Åª¬π i) := ?_
    _ ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := MonovaryOn.sum_comp_comp_le_sum_smul hfg hœÉ
  congr with i
  rw [Function.comp_apply, apply_inv_self]

===== Proof 4200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  classical
  have hœÉ' : ‚àÄ i ‚àà s, œÉ i ‚àà s := fun i hi => (hœÉ hi).1
  have hœÉ'' : ‚àÄ i ‚àà s, œÉ (œÉ i) = œÉ i := fun i hi => Subtype.ext_iff.1
    (hœÉ' (œÉ i) (hœÉ' i hi)).2
  rw [‚Üê Equiv.sum_comp' (s := s) (œÉ : Œ± ‚âÉ Œ±) (fun i => f (œÉ i) ‚Ä¢ g i)
    (fun i => f i ‚Ä¢ g i) hœÉ'']
  refine' Finset.sum_le_sum fun i hi => _
  convert hfg (hœÉ' i hi) (hœÉ' (œÉ i) (hœÉ' i hi)) (MonovaryOn.eq (hfg.comp_perm œÉ hœÉ')
    (Subtype.ext (hœÉ'' i hi))) using 1
  rw [smul_comm]

===== Proof 4201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  refine' Finset.sum_le_sum_of_subset_of_nonneg _ fun i hi h2i => _
  ¬∑ simpa [‚Üê hœÉ.inf_eq_right] using h2i
  apply hfg.exchange_le ‚ü®i, hi‚ü© h2i
  simpa using h2i

===== Proof 4202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  refine' Finset.sum_le_sum_of_subset_of_nonneg _ fun i _ _ => smul_nonneg (hfg.1 _ _ <| hœÉ <| by simp)
    (hfg.2 _ _ <| hœÉ <| by simp)
  simp only [Set.subset_def, Set.mem_setOf_eq, Set.mem_compl_iff, Set.mem_univ, true_imp_iff,
    not_not, and_imp]
  intro x _ hx
  simpa [Perm.mem_support, hx] using hfg.1 _ _ (hœÉ hx)

===== Proof 4203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  simp only [sum_smul, sum_comp_perm]
  exact hfg.sum_comp_perm_smul_le_sum_smul_of_subset hœÉ

===== Proof 4204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  simp_rw [‚Üê smul_sum, smul_eq_mul]
  refine' Finset.sum_le_sum_of_subset_of_nonneg hœÉ fun i _ _ =>
    by_cases_on_mem (fun hi => hfg.1 (hœÉ hi) hi) fun _ => by simp

===== Proof 4205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  rw [‚Üê Equiv.comp_perm_eq_sum_comp_perm_smul]
  exact MonovaryOn.sum_comp_perm_smul_le_sum_smul' hfg hœÉ

===== Proof 4206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  refine' Finset.sum_le_sum fun i hi => _
  obtain rfl | hi' := eq_or_ne (œÉ i) i <;> simp_all [MonovaryOn, MonovaryOn.def]

===== Proof 4207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  classical
  rw [‚Üê Equiv.sum_comp' s (Equiv.permCongr œÉ) (f ¬∑ * g ¬∑)]
  exact Finset.sum_le_sum fun i hi ‚Ü¶ by
   simp_rw [Equiv.permCongr_apply, mul_smul_comm]
   exact hfg.mul_le_mul_of_subset_of_perm (hœÉ hi) (Equiv.permCongr_apply œÉ i)

===== Proof 4208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  calc
    (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) = ‚àë i ‚àà s.map œÉ, f i ‚Ä¢ g i := by rw [‚Üê Finset.sum_map]; simp
    _ ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := Finset.sum_le_sum_of_subset_of_nonneg (by simpa using hœÉ) ?_
  intro i hi
  exact hfg.smul_nonneg (hœÉ hi) hi

===== Proof 4209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  classical
    simp only [smul_eq_mul, sum_mul, sum_map]
    exact hfg.sum_comp_perm_mul_le_sum_mul hœÉ

===== Proof 4210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  refine' Finset.sum_le_sum fun a ha => _
  refine' le_of_not_lt _
  intro h
  have : œÉ a ‚àà s := hœÉ (show œÉ a ‚â† a from by simpa using h)
  exact hfg.not_lt_map this ha h

===== Proof 4211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  classical
  have : (fun i ‚Ü¶ œÉ i) = œÉ := rfl
  simp_rw [this]
  exact hfg.sum_smul_le_sum_comp_perm_smul hœÉ

===== Proof 4212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  refine MonovaryOn.sum_comp_perm_smul_le_sum_smul_of_subset_range hfg ?_
  simp_rw [Set.subset_range_iff_exists_image_eq]
  use { x | œÉ x ‚â† x }
  rw [Set.image_source_eq_target]
  exact hœÉ

===== Proof 4213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  rw [(hfg.comp_perm_smul_eq_sum_smul_comp_perm _ hœÉ).symm]
  exact hfg.sum_smul_le_sum_smul_of_subset hœÉ

===== Proof 4214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  have h_eq : ‚àë i ‚àà s, (f ‚àò œÉ) i ‚Ä¢ g i = ‚àë i ‚àà s, f i ‚Ä¢ g (œÉ i) := by
    simp only [comp_apply, smul_eq_mul]
  rw [h_eq]
  refine' MonovaryOn.sum_smul_comp_perm_le_sum_smul _ hœÉ
  simpa [Function.comp_def] using MonovaryOn.comp_left hfg (Equiv.injective œÉ)

===== Proof 4215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  have h : (s : Set Œ±) = { x | œÉ x ‚â† x } ‚à™ { x | œÉ x = x } ‚à© s := by ext; simp; aesop
  rw [h, sum_union (t := {x | œÉ x = x } ‚à© s)]
  rw [sum_inter_add_sum_diff_singleton, sum_inter_add_sum_diff_singleton] <;>
    aesop

===== Proof 4216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  have : ‚àÄ i ‚àà s, f (œÉ i) ‚Ä¢ g i ‚â§ f i ‚Ä¢ g i := by
    intro i hi
    have : œÉ i ‚àà s := by
      apply hœÉ
      simp [hi]
    exact hfg.smul_le_smul_of_le_of_le (by simp [this]) hi
  apply Finset.sum_le_sum
  simp [this]

===== Proof 4217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  rw [‚Üê sum_smul_sum hœÉ]
  refine' Finset.sum_le_sum fun i hi ‚Ü¶ _
  rw [‚Üê smul_eq_mul, smul_assoc]
  rw [smul_comm]
  simpa only [MonovaryOn, Set.mem_setOf_eq] using hfg (hœÉ hi) hi

===== Proof 4218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  classical
  rw [‚Üê Equiv.sum_comp' s f œÉ, ‚Üê Equiv.sum_comp' s (f ¬∑ * g ¬∑) œÉ]
  refine' Finset.sum_le_sum_of_subset_of_nonneg hœÉ fun i his _ ‚Ü¶
    smul_nonneg (hfg.1.2 _ <| hœÉ <| œÉ.mem_stabilizer_iff.1 his) (hfg.2.2 _ <| hœÉ <| œÉ.mem_stabilizer_iff.1 his)

===== Proof 4219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  have hœÉ' : ‚àÄ i ‚àà s, œÉ i ‚àà s := fun i hi => hœÉ (by simpa using hi)
  simpa [MonovaryOn, dotProduct, Finset.sum_apply] using hfg.inner_product_comp_perm_le_inner_product hœÉ'

===== Proof 4220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  rw [‚Üê Equiv.comp_involutive_eq_id (Equiv.ofBijective œÉ
    ‚ü®fun x y h => by simpa [Function.comp_def] using congr_arg œÉ h,
    fun x => by simpa [Function.comp_def] using hœÉ (œÉ x) (by simp)‚ü©).symm.perm_inv] at hfg
  simpa only [smul_comm, Function.comp_def] using
    MonovaryOn.sum_comp_perm_smul_le_sum_smul hfg (œÉ.perm_inv.ofBijective _)

===== Proof 4221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  refine' Finset.sum_le_sum fun i hi => _
  obtain ‚ü®a, ha, rfl‚ü© := hœÉ (show œÉ i ‚àà { x | œÉ x ‚â† x } from _)
  exact hfg.smul_le_smul_of_comp_perm_le (hœÉ hi) rfl.le
  exact ne_of_mem_of_not_mem hi fun h ‚Ü¶ (œÉ (œÉ i)) ‚àâ ({x | œÉ x ‚â† x} : Set Œ±) h ‚ü®i, rfl‚ü©

===== Proof 4222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  refine' sum_le_sum_of_subset_of_nonneg hfg.1 (fun i hi h2i ‚Ü¶ _) (fun i hi h2i ‚Ü¶ _)
  all_goals simpa [h2i] using hfg.2 hi

===== Proof 4223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  rw [‚Üê Equiv.sum_comp' s œÉ.toEquiv fun _ ‚Ü¶ f _ ‚Ä¢ g _]; simp_rw [smul_eq_mul]
  refine Equiv.sum_comp' s œÉ.toEquiv (fun i ‚Ü¶ f i * g i) ?_
  intro x hx
  simpa [smul_eq_mul] using hfg (hœÉ hx) (œÉ.injective.mem_set_image.1 hx)

===== Proof 4224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hœÉ : { x | œÉ x ‚â† x } ‚äÜ s) : (‚àë i ‚àà s, f (œÉ i) ‚Ä¢ g i) ‚â§ ‚àë i ‚àà s, f i ‚Ä¢ g i := by
  simp only [smul_eq_mul]
  have := hfg.sum_comp_perm_mul_le_sum_mul hœÉ
  simp_all

===== Proof 4225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine'' ‚ü®fun V hVmeas hVneZero hVneTop => _‚ü©
  exact (fund_dom_s.measure_preserving_proj ŒΩ).symm.preimage_eq hVmeas hVneZero hVneTop hV

===== Proof 4226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact ‚ü®fund_dom_s, neZeroV, hV, neTopV‚ü©

===== Proof 4227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  ¬∑ simp [transformFiniteMeasure, QuotientMeasureEqMeasurePreimage]
  ¬∑ simp [quotientMeasure_eq_zero_iff] at neZeroV ‚ä¢
  ¬∑ aesop
  ¬∑ aesop
  ¬∑ aesop

===== Proof 4228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact { quotientMeasureEqMeasurePreimage := fun V hfund measV V_ne_zero neTopV =>
    fund_dom_s.quotientMeasureEqMeasurePreimage fun i _ => hfund.subset (fun _ hi ‚Ü¶ hi) }

===== Proof 4229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine ‚ü®fun V meas_V neZeroV hV neTopV => ?_‚ü©
  exact hV

===== Proof 4230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact { quotientSet := V, set := s, measurableSet := meas_V, measure_preimage_emb := fun (f : G ‚Üí‚Çô* G)
    _f_inj‚Ü≥ => (fund_dom_s.measure_preserving_preimage_emb f neZeroV _).measure_preimage_emb }

===== Proof 4231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact fun V hVfund s hs ‚Ü¶
    calc
      Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s) := by rw [hV]
      _ = ŒΩ (œÄ ‚Åª¬π' s ‚à© V) := by simp only [inter_comm]

===== Proof 4232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine' { reindexing := fun g => Quotient.inductionOn g fun a => _ }
  rcases neZeroV with ‚ü®‚ü©
  change Œº (Quotient.mk a) = ŒΩ (œÄ ‚Åª¬π' {Quotient.mk a} ‚à© s)
  rw [hV]
  congr
  ext
  simp only [Set.mem_preimage, Set.mem_singleton_iff, exists_eq_left, exists_prop,
    Set.mem_setOf_eq]
  constructor
  exact fun h => ‚ü®h.2, h.1‚ü©
  rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
  have h_mem : a ‚àà (œÄ ‚Åª¬π' {Quotient.mk a} ‚à© s) := ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©
  obtain ‚ü®_, _, _, _‚ü© := fund_dom_s.1 h_mem
  simp_all

===== Proof 4233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact ‚ü®fund_dom_s.isMulLeftInvariant, fun s hs =>
    (fund_dom_s.measure_preserving_proj ŒΩ Œº hs meas_V neZeroV hV neTopV).measure_preimage hs‚ü©

===== Proof 4234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine' { is_probability_measure := by
      simp only [IsProbabilityMeasure, Measure.smul_apply, one_smul, hV]
      rw [fund_dom_s.from_Spec]
      exact indicator_summable_of_subset ŒΩ fun K W hW =>
        (measure_mono Set.inter_subset_left hW).trans_lt (fund_dom_s.measure_positive K).lt_of_ne
          neZeroV }
  intro V hmeasV
  obtain ‚ü®V, rfl‚ü© := Quotient.surjective_Quotient_mk'' V
  simp only in
  rw [gt_iff_lt]
  exact
    fund_dom_s.integrability <| measurableEmbedding_of_mem hmeasV
      fun g' ‚Ü¶ by
        replace hV : ŒΩ (œÄ ‚Åª¬π' V) = Œº (œÄ ‚Åª¬π' V ‚à© s) := by rw [‚Üê hV]; congr 1
        simpa [ŒΩ.fromSpec_apply, hV] using fun g ‚Ü¶ (fund_dom_s.iso (QuotientGroup.mk g)).symm

===== Proof 4235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine' { fund_dom_s with }
  intro U meas_U V meas_V eq_zero
  rw [Measure.eq_zero_of_isFundamentalDomain _ _ fund_dom_s.1 (by convert meas_V),
    Measure.eq_zero_of_isFundamentalDomain _ _ fund_dom_s.2 meas_U] at eq_zero
  ¬∑ simpa
  ¬∑ exact IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set._match_2 fun _ ‚Ü¶
      IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set._match_3 fun _ ‚Ü¶ eq_zero

===== Proof 4236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  apply mk
  intro V_meas
  apply eq_of_forall_apply_eq
  intro A meas_A
  rw [Œº.measure_eq_extend (s := V) ŒΩ.inv _ s.2, ŒΩ.measure_eq_extend (s := V) Œº.inv _ s.2,
    extend_eq_of_isMulLeftInvariant _ ŒΩ V_meas, extend_eq_of_isMulLeftInvariant _ Œº V_meas,
    Measure.map_apply QuotientGroup.mk_surjective ŒΩ.inv.measurable_toMeasure (Œº := Œº),
    Measure.map_apply QuotientGroup.mk_surjective Œº.inv.measurable_toMeasure (Œº := ŒΩ), hV]
  rw [fund_dom_s.addFundamentalDomain_prod (Œì := Œì), ‚Üê ŒΩ.isOpenPos_iff,
    ‚Üê Œº.isOpenPos_iff, hV, neZeroV, if_pos neTopV]
  apply prod_tac

===== Proof 4237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  apply QuotientMeasureEqMeasurePreimage.of_mulLeftInvariant
  exact fun g => by
     rw [fund_dom_s.projection_respects_measure (measurableSet_preimage (continuous_mul_left g) meas_V),
       hV]

===== Proof 4238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine ‚ü®fun U meas_U ‚Ü¶ ?_‚ü©
  rw [fund_dom_s.set_eq_preimage_smul U]
  rw [Measure.QuotientMeasure.preimage_smul_of_mulLeftInvariant (fund_dom_s := fund_dom_s) meas_U]
  simp [hV]

===== Proof 4239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  rw [TheEqOnEDist_iff] at fund_dom_s; exact ‚ü®fund_dom_s, fun V hmeasV c cc ‚Ü¶ hV‚ü©

===== Proof 4240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact fund_dom_s.quotientMeasureEqMeasurePreimage ŒΩ Œº |>.2 V meas_V neZeroV neTopV hV

===== Proof 4241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine' ‚ü®fund_dom_s, fun Vfund_s => _‚ü©
  have : IsFundamentalDomain Œì.op (œÄ ‚Åª¬π' Vfund_s) ŒΩ := by
    apply IsFundamentalDomain.preimage
    assumption
  rw [ŒΩ.IsMulLeftInvariant.measure_eq_fund_dom_s_of_meas V fund_dom_s meas_V neZeroV hV
    neTopV]
  exact QuotientMeasureEqMeasurePreimage.zero_of_of_disjoint Vfund_s this
    (disjoint_compl_left_iff_subset.mpr Set.subset_univ)

===== Proof 4242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  have meas_V_is_hard : Œº V ‚â† 0 := by
    simp [meas_V, neZeroV]
  have neZeroV' : Œº V ‚â† 0 := by
    simp [neZeroV]
  have hV' : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s) := by
    simp [hV]
  exact { quot_mul_eq_zero_of_set := fun s ‚Ü¶ by classical simp [QuotientMeasureEqMeasurePreimage,
    œÄ_quotient_preimage_eq_self_of_mem_set, quot_mul_eq_zero_of_set, meas_V_is_hard,
    neZeroV, neTopV, hV', fund_dom_s.to_smulInvariantMeasure.IsMulLeftInvariant,
    IsFundamentalDomain.s] }

===== Proof 4243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  apply QuotientMeasureEqMeasurePreimage.mk
  intro V' hV'
  let V'' : Set G := QuotientGroup.mk ‚Åª¬π' V'
  have hV'' : MeasurableSet V'' := measurableSet_preimage (continuous_coinduced_dom (Œ± := G)) hV'
  have hV''' : MeasurableSet (œÄ ‚Åª¬π' V' ‚à© s) := by
    rw [preimage_inter]
    exact (measurableSet_preimage (continuous_coinduced_dom (Œ± := G)) hV').inter (fund_dom_s.measurableSet)
  rw [Measure.QuotientMeasure.preimage_apply ŒΩ _ Œº hV'']
  rw [Measure.QuotientMeasure.preimage_apply ŒΩ _ Œº hV''']
  rw [hV]
  congr
  apply congr_arg
  ext x
  simp only [V'', Function.comp_apply, mem_inter_iff, mem_preimage, and_congr_right_iff]
  intro h
  rw [fund_dom_s.set_eq_of_mem h]

===== Proof 4244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  apply QuotientMeasureEqMeasurePreimage.mk _ _ fun V fund_dom_s.measurableSet‚ÇÅ neZeroV neTopV => hV

===== Proof 4245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine'
    { toFun := QuotientMeasureEqMeasurePreimage.toFun
      map_add' := fun y‚ÇÅ y‚ÇÇ => _
      map_neg' := fun y => _
      map_zero' := _
      comap_subtype_eq := fun s' => _ }
  ¬∑ ext
    change ŒΩ (Quotient.mk'' '' _) = Œº (Quotient.mk'' '' _)
    congr
    ext ‚ü®x, hx‚ü©
    refine' ‚ü®_, fun h => _‚ü©
    ¬∑ rintro ‚ü®x, hx, rfl‚ü©
      obtain ‚ü®y, rfl‚ü© := Quotient.mk''_surjective x
      change ŒΩ (Quotient.mk'' '' _) = Œº (Quotient.mk'' '' _)
      congr
      ext ‚ü®x, hx‚ü©
      refine' ‚ü®_, fun h => _‚ü©
      ¬∑ rintro ‚ü®x, hx, rfl‚ü©
        obtain ‚ü®y, rfl‚ü© := Quotient.mk''_surjective x
        simp only [QuotientAddGroup.mk_add, QuotientAddGroup.mk_neg] at *
        exact ‚ü®y + y, hx, by simp only [QuotientAddGroup.mk_add, QuotientAddGroup.mk_neg, hx]‚ü©
      ¬∑ exact ‚ü®x, hx, by simp only [QuotientAddGroup.mk_add, QuotientAddGroup.mk_neg, hx]‚ü©
    ¬∑ exact ‚ü®x, hx, by simp only [QuotientAddGroup.mk_add, QuotientAddGroup.mk_neg, hx]‚ü©
  ¬∑ ext
    change ŒΩ (Quotient.mk'' '' _) = Œº (Quotient.mk'' '' _)
    congr
    ext ‚ü®x, hx‚ü©
    refine' ‚ü®_, fun h => _‚ü©
    ¬∑ rintro ‚ü®x, hx, rfl‚ü©
      obtain ‚ü®y, rfl‚ü© := Quotient.mk''_surjective x
      change ŒΩ (Quotient.mk'' '' _) = Œº (Quotient.mk'' '' _)
      congr
      ext ‚ü®x, hx‚ü©
      refine' ‚ü®_, fun h => _‚ü©
      ¬∑ rintro ‚ü®x, hx, rfl‚ü©
        obtain ‚ü®y, rfl‚ü© := Quotient.mk''_surjective x
        simp only [QuotientAddGroup.mk_add, QuotientAddGroup.mk_neg] at *
        exact ‚ü®y + y, hx, by simp only [QuotientAddGroup.mk_add, QuotientAddGroup.mk_neg, hx]‚ü©
      ¬∑ exact ‚ü®x, hx, by simp only [QuotientAddGroup.mk_add, QuotientAddGroup.mk_neg, hx]‚ü©
    ¬∑ exact ‚ü®x, hx, by simp only [QuotientAddGroup.mk_add, QuotientAddGroup.mk_neg, hx]‚ü©
  ¬∑ simp only [QuotientAddGroup.mk_zero]
    congr
  ¬∑ ext x
    simp only [QuotientAddGroup.toMeasurableQuotient_apply, Set.preimage_image_eq,
      QuotientAddGroup.mk_add, QuotientAddGroup.mk_neg, IsFundamentalDomain.measure_restrict_apply]
    exact ‚ü®fun h => h, fun h => h‚ü©

===== Proof 4246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact { quotientMeasure_eq := fun V hV _ => hV }

===== Proof 4247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine' ‚ü®fun V meas_V => _‚ü©
  apply (fund_dom_s.set_lintegral_eq_of_measure_ne_zero (ŒΩ := ŒΩ) _ _).symm
  ¬∑ rw [Ne, ‚Üê measure_pos_iff_ne_zero] at neZeroV
    exact neZeroV.trans_le (measure_mono (Set.inter_subset_left _ _))
  ¬∑ rw [Ne, ‚Üê measure_pos_iff_ne_zero] at neTopV
    exact neTopV.trans_le (measure_mono (Set.inter_subset_left _ _))
  ¬∑ rw [hV]
    rfl

===== Proof 4248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  rw [QuotientMeasureEqMeasurePreimage]
  exact ‚ü®fund_dom_s, fun g _ v _ ‚Ü¶
    (Measure.smul_apply (QuotientGroup.mk g : G ‚ß∏ Œì) ŒΩ v).symm ‚ñ∏
     measure_eq_comap_of_map_eq_mul (by simp [hV]) meas_V neZeroV neTopV‚ü©

===== Proof 4249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine' { fund_dom_s with set_property := fun Vmeas neZeroVŒº => _ }
  rw [‚Üê hV]
  refine' measure_eq_measure_preimage_of_mem_lintegral fun g => _
  simp_all

===== Proof 4250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine' ‚ü®fun w => le_antisymm _ _‚ü©
  ¬∑ simp_rw [Œº.le_iff_measurableSet, (fund_dom_s.outerMeasure_eq_of_IsMulLeftInvariant _)]
    exact fun hs =>
      (le_toMeasure_apply _ _ _).trans ((ŒΩ.outerMeasure_le <| œÄ ‚Åª¬π' w ‚à© s).trans (measure_le_inter_add_diff _ _ _).1)
  ¬∑ intro w _
    apply (Œº.le_iff_measurableSet _ _).2
    intro hw
    rw [fund_dom_s.measure_eq_extend _ fun _ => rfl, OuterMeasure.extend_eq]
    refine' (measure_le_inter_add_diff _ _ _).2 ‚ü®fund_dom_s.le_outerMeasure _ _, _‚ü©
    rw [fund_dom_s.measure_eq_extend _ fun _ => rfl, OuterMeasure.extend_eq]
    refine' (measure_le_inter_add_diff _ _ _).2 ‚ü®fund_dom_s.le_outerMeasure _, _‚ü©.trans
      ((le_toMeasure_apply _ _ _).trans _)
    rw [hV]
    exact ŒΩ.toOuterMeasure.mono (preimage_mono inter_subset_right)

===== Proof 4251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact fun _ V hVfund Œºfund => ‚ü®fund_dom_s, hVfund, hV, fund_dom_s.measure_fundamental_univ,
    neZeroV, neTopV‚ü©

===== Proof 4252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact {
    projection_respects_measure' := fun i ‚Ü¶ by
      rw [Set.preimage_id, measure_eq_measure_preimage_add_measure_tsum_Ico_zpow_of_mem
        QuotientGroup.is_fundamental_domain_coe fun j ‚Ü¶ Set.inter_subset_left _ _
        fun _ _ => measurableSet_const, ‚Üê hV]
      refine (measure_union‚ÇÄ_le _ _).trans_lt <| ENNReal.add_lt_top.2 ‚ü®?_, ?_‚ü©
      ¬∑ simp_rw [Ne, ‚Üê measure_pos_iff_ne_zero] at neZeroV neTopV
        exact ENNReal.is_finite.lt_top (measure_lt_top _ _)
      ¬∑ exact fun n ‚Ü¶ ((measure_le_mul_of_subset_left
          (fund_dom_s.smul n).measurableSet.compl).trans_lt <| ENNReal.mul_lt_top neZeroV
            neTopV).trans_le _root_.le_of_eq ENNReal.ofReal_zero.symm
  }

===== Proof 4253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  exact ‚ü®fun V fund_dom_V meas_V neZeroV hV neTopV =>
    measure_eq_measure_preimage_of_inter_eq_of_ne_zero_of_ne_top fun V fund_dom_V neZeroV hV =>
      measure_eq_measure_preimage_of_inter_eq_of_ne_zero_of_ne_top fun V fund_dom_V neZeroV hV =>
          hV‚ü©

===== Proof 4254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine ‚ü®fun s hs ‚Ü¶ ?_‚ü©
  rw [set_lintegral_cond_prob_smul_eq fun _ ‚Ü¶ ?_]
  all_goals try simpa only [Ne, mul_eq_zero] using neZeroV
  simp only [Ne, mul_eq_zero] at neTopV
  simpa only [Ne, mul_eq_zero] using neTopV

===== Proof 4255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  rw [QuotientMeasureEqMeasurePreimage]
  intro V' meas_V'
  have hV' : Œº V' = ŒΩ (œÄ ‚Åª¬π' V' ‚à© s) := by
    have h : œÄ ‚Åª¬π' V' ‚à© s = œÄ ‚Åª¬π' (V' ‚à© œÄ ‚Åª¬π' s) := by rw [Set.preimage_inter, Set.inter_comm]
    rw [h]
    apply measure_preimage_eq_zero_of_fundamentalDomain
    exact fun _ => fund_dom_s.2 _
  rw [hV']
  have hŒº : Œº V' ‚â† 0 := by
    intro hŒº
    apply neZeroV
    rw [hV] at hŒº
    exact hŒº
  have hŒΩ : ŒΩ (œÄ ‚Åª¬π' V' ‚à© s) ‚â† 0 := by
    intro hŒΩ
    apply hŒº
    rw [hV'] at hŒΩ
    exact hŒΩ
  rw [measure_preserving_fund_dom_s_inv_on_fiber.measure_preimage_fiber_eq s V']

===== Proof 4256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Œì.op s ŒΩ) {V : Set (G ‚ß∏ Œì)}
    (meas_V : MeasurableSet V) (neZeroV : Œº V ‚â† 0) (hV : Œº V = ŒΩ (œÄ ‚Åª¬π' V ‚à© s))
    (neTopV : Œº V ‚â† ‚ä§) : QuotientMeasureEqMeasurePreimage ŒΩ Œº := by
  refine' fun q => _
  apply eq_of_forall_eq_of_forall_eq
  all_goals
    rintro ‚ü®U, hmeas, hnezero, htop‚ü© <;>
    rw [‚Üê hV] at neZeroV neTopV
    exact ‚ü®fun h => conductor_eq_univ_of_setIsFundamental _ _ hsŒº.symm hmeas,
           fun funt => hsŒº.trans <| measure_fund_dom_conductor ..‚ü©

===== Proof 4257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  constructor
  ¬∑ intro hfg
    have h : ‚àÄ t, MeasurableSet t ‚Üí Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) t = (Œº.map f).prod (Œº.map g) t := by
      intro t ht
      rw [hfg.map_prod_eq_prod_map_map ht]
    ext1 t ht
    simp [‚Üê h t ht]
  ¬∑ intro hfg
    have h : ‚àÄ t, MeasurableSet t ‚Üí Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) t = (Œº.map f).prod (Œº.map g) t := by
      intro t ht
      rw [hfg]
    exact (h.indepFun_of_measurableSet )

===== Proof 4258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  rw [indepFun_iff_measure_inter_preimage_eq_mul]
  exact ‚ü®fun h ‚Ü¶ by simp [Measure.map_apply, hf, hg, h], fun h ‚Ü¶ by simp [Measure.map_apply, hf, hg, h]‚ü©

===== Proof 4259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine ‚ü®fun hfg ‚Ü¶?_, fun h ‚Ü¶?_, fun hfg ‚Ü¶?_, fun h ‚Ü¶?_‚ü© <;> simp_rw [‚Üê hfg]
  exacts [map_comap_prod_eq_prod_map_map_of_aemeasurable hf hg,
    hfg.symm ‚ñ∏ map_comap_prod_eq_prod_map_map_of_aemeasurable h.1 h.2,
    (hfg.symm ‚ñ∏ map_comap_prod_eq_prod_map_map_of_aemeasurable h.1 h.2).symm,
    (hfg.symm ‚ñ∏ map_comap_prod_eq_prod_map_map_of_aemeasurable h.1 h.2).symm]

===== Proof 4260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  constructor
  intro h
  have h1 := h.measurable_fst
  have h2 := h.measurable_snd
  rw [IndepFun_iff] at h
  rw [‚Üê h, map_map]
  exact measurable_fst.prod_mk measurable_snd
  intro h
  rw [IndepFun_iff_map_prod_eq_prod_map_map]
  rw [‚Üê h, map_map]
  exact measurable_fst.prod_mk measurable_snd

===== Proof 4261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  dsimp only [IndepFun, Prod.mk]
  rw [indepSet_iff_measure_inter_eq_mul]
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ simp_rw [‚Üê Measure.map_apply hf.measurable (measurableSet_singleton _)] at h
    simp_rw [Measure.map_apply hg.measurable (measurableSet_singleton _)] at h
    rw [‚Üê Measure.prod_apply (measurable_fst.prod_mk measurable_snd)] at h
    rw [‚Üê h]
    rfl
  ¬∑ rw [‚Üê Measure.prod_apply (measurable_fst.prod_mk measurable_snd)] at h
    have h_eq := congr_arg (fun œÄ : Measure (Œ≤ √ó Œ≤') ‚Ü¶ œÄ ({(f a, g a)} : Set (Œ≤ √ó Œ≤'))) h
    simp only [Measure.prod_prod, Measure.map_prod_singleton, measure_univ,
      mul_one, Set.indicator_apply] at h_eq
    have h_eq' := congr_arg (fun œÄ : Measure (Œ≤ √ó Œ≤') ‚Ü¶ œÄ ({(f a, g a)} : Set (Œ≤ √ó Œ≤'))) h_eq
    simp only [Measure.map_apply hf.measurable (measurableSet_singleton _),
      Measure.map_apply hg.measurable (measurableSet_singleton _),
      Measure.map_prod_singleton, measure_univ, mul_one, Set.indicator_apply] at h_eq'
    rwa [h_eq'] at h_eq

===== Proof 4262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine' ‚ü®fun hfg ‚Ü¶ _, fun h ‚Ü¶ _‚ü©
  ¬∑ exact hfg.measure_map_prod_eq
  have hf' : AEMeasurable (fun œâ ‚Ü¶ (f œâ, g œâ)) Œº :=
    hf.prod_mk hg
  let B : Œ≤ √ó Œ≤' ‚Üí Set (Œ≤ √ó Œ≤') := fun x ‚Ü¶ {x}
  have hB : ‚àÄ x, IsProbabilityMeasure (Œº.map fun œâ ‚Ü¶ (f œâ, g œâ) |_.restrict (B x)) := by
    intro x
    rw [cond_prob_measure]
    simp only [measure_singleton]
    simp only [IsProbabilityMeasure, one_ne_zero, measure_univ, mul_one,
      cond_prob_measure_eq_zero_iff, not_true, IsEmpty.forall_iff, cond_prob_measure_univ,
      mul_eq_zero, measure_univ, one_ne_zero, false_and, or_false_iff]
    exact fun hfg ‚Ü¶ hfg x
  obtain ‚ü®B, -, hB'‚ü© := exists_isProbabilityMeasure (Œº.map fun œâ ‚Ü¶ (f œâ, g œâ) |_.restrict)
  haveI := hB'
  simp only [IndepFun, hB']
  rw [‚Üê h]
  apply condIndepFun_iff_condIndep

===== Proof 4263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  rw [ae_eq_fun_iff_of_measurable hf hg, (Measure.indepFun_iff_map_prod_eq_prod_map_map _ _)]

===== Proof 4264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine' ‚ü®fun hfg ‚Ü¶ hfg.symm.map_prod_eq_prod_map_map, fun h ‚Ü¶ _‚ü©
  have hf' : AEMeasurable (fun x ‚Ü¶ (f x, g x)) Œº := by measurability
  exact (indepFun_iff_measure_inter_preimage_eq_mul.2 fun s t hs ht ‚Ü¶ by
    simpa [‚Üê (Measure.map_apply_of_aemeasurable hf' (hs.prod ht)).symm] using
      measure_map_prod_eq_prod_map_map h f g s t hs ht)

===== Proof 4265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  constructor
  ¬∑ intro h
    exact h.map_prod_eq_prod_map hf hg
  ¬∑ intro hfg
    refine ‚ü®?_, fun s sg in_t => ?_‚ü©
    ¬∑ rintro ‚ü®t, ht, rfl‚ü©
      exact (Measure.prod_apply ht).symm
    calc
      Œº (fun œâ => ((fun _ => s) ‚àò Prod.fst) œâ ‚à© ((fun _ => t) ‚àò Prod.snd) œâ)
        = Œº (Prod.fst ‚Åª¬π' s ‚à© Prod.snd ‚Åª¬π' t) := by
          congr with a
          simp only [Function.comp_apply, Prod.fst_mk, Prod.snd_mk, mem_preimage, mem_inter_iff]
        _ = Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) (s √óÀ¢ t) := by
          rw [‚Üê hfg]
          rfl
        _ = ((Œº.map f) s) * ((Œº.map g) t) := by
          rw [measure_prod_null set.countable_empty, mul_comm]
          rfl
        _ = Œº (((fun _ => s) ‚àò f) ‚à© ((fun _ => t) ‚àò g)) := by
          congr with a
          simp only [Function.comp_apply, Prod.fst_mk, Prod.snd_mk, mem_preimage, mem_inter_iff]

===== Proof 4266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ exact h.map_prod_eq_prod_map_map f g
  rcases hf with ‚ü®f', hf'‚ü©
  rcases hg with ‚ü®g', hg'‚ü©
  rw [‚Üê hf'.ae_eq_fun_eq, ‚Üê hg'.ae_eq_fun_eq] at h
  have h' : IndepFun f' g' Œº := by
    refine ‚ü®meas_fst_map_prod_mk_eq_prod _ _ hf' hg',
      meas_snd_map_prod_mk_eq_prod _ _ hf' hg', ?_‚ü©
    simp only [map_map, (Measure.map_measurableEquiv _ _).symm, mk_preimage_fst_prod,
      mk_preimage_snd_prod, fst_map_prod_mk, mk_preimage_prod_mk_eq_inter, snd_map_prod_mk,
      measure_inter_conull, h, measure_univ, MeasurableEquiv.coe_toEquiv, Equiv.refl_apply,
      univ_inter, inter_univ]
  exact h'.symm_mk hf'.toEquiv.symm hg'.toEquiv.symm

===== Proof 4267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine ‚ü®fun hfg ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ exact (Measure.prod_eq fun s hs t ht ‚Ü¶ by rw [‚Üê hfg.measure_comp_prod hs ht,
      ‚Üê map_apply_of_aemeasurable (hf.fst hs) (Set.prod_inter_prod_compl s t), ‚Üê map_apply_of_aemeasurable
      (hg.fst hs) (Set.prod_inter_prod_compl s t), ‚Üê map_apply_of_aemeasurable (hf.fst hs)
      (Set.prod_inter_prod_compl s t), ‚Üê map_apply_of_aemeasurable (hg.fst hs)
      (Set.prod_inter_prod_compl s t), hfg.measure_inter_prod hs ht]
  ¬∑ refine ‚ü®fun s hs t ht ‚Ü¶ ?_‚ü©
    rw [‚Üê h, Measure.prod_prod, ‚Üê map_apply_of_aemeasurable hf hs, ‚Üê map_apply_of_aemeasurable hg ht,
      Measure.map_prod_mk_apply_eq_prod]

===== Proof 4268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  rw [IndepFun_iff, ‚Üê map_prod_eq_map_fst_map_snd, filter_eq_iff]
  exact ‚ü®fun h ‚Ü¶ ‚ü®h.1, h.2‚ü©, fun h ‚Ü¶ ‚ü®h.1, h.2‚ü©‚ü©

===== Proof 4269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  constructor
  ¬∑ intro _
    refine' prod_eq_fst_snd.symm.trans ((@Measure.map_congr‚ÇÄ _ _ _ _ _ f _ g _ _ _ (hf.prod_mk hg)).symm.trans
      ((prod_eq_fst_snd.symm.trans (Measure.Measure.prod_left_eq_self.mpr ?_)).trans (Measure.prod_prod _).symm))
    filter_upwards with x using rfl
  ¬∑ introv hfg
    refine' IndepFun.of_measure_eq_prod Œº (measurable_fst.comp_aemeasurable hf) (measurable_snd.comp_aemeasurable hg) _
    rw [Measure.prod_prod, hfg, prod_eq_fst_snd]

===== Proof 4270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  ¬∑ intro
    refine' Prod.ext (measure_congr (aemeasurable_fst.ae_eq_of_forall_set_lintegral_eq hf _ _ ))
      (measure_congr (aemeasurable_snd.ae_eq_of_forall_set_lintegral_eq hg _ _ ))
    all_goals { intros s hs; simp [*] }
  ¬∑ intro h; rw [IndepFun, h]; rfl

===== Proof 4271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine' ‚ü®fun hfg ‚Ü¶ hfg.map_prod_eq_prod_map_map, fun h ‚Ü¶ _‚ü©
  have hf' := hf.nullMeasurable
  have hg' := hg.nullMeasurable
  refine' ‚ü®fun A hA ‚Ü¶ ?_‚ü©
  have :
    Œº {œâ | (f œâ, g œâ) ‚àà A} = (Œº.map f).prod (Œº.map g) {y | y.1 ‚àà A} {y | y.2 ‚àà A} := by
    rw [h]; rfl
  simp_rw [‚Üê hy, ENNReal.ofReal_eq_one, Measure.prod_prod,
    mul_eq_mul_right_iff] at this
  cases this with
  | inl hmu ‚Ü¶
    rw [‚Üê hy] at hmu
    exact hmu.symm
  | inr h ‚Ü¶
    obtain ‚ü®A‚ÇÅ, hA‚ÇÅ, A‚ÇÇ, hA‚ÇÇ, h‚ü© := h
    have : Œº (A‚ÇÅ.prod A‚ÇÇ) = 0 := by
      rw [Measure.prod_prod, hA‚ÇÅ.mul_zero, ‚Üê hy]
      exact h.symm
    by_cases hat : Œº Set.univ = ‚àû
    ¬∑ simp only [hat, ENNReal.top_mul, Measure.map_apply, MeasurableSet.univ, Set.preimage_univ,
        mul_eq_top, or_true_iff, measure_univ] at this
    ¬∑ have : Œº (A‚ÇÅ.prod A‚ÇÇ) ‚â† ‚àû := by
        rw [‚Üê Measure.prod_apply, Measure.prod_prod, hA‚ÇÅ.mul_zero, ‚Üê hy]
        exact h
      rw [Measure.prod_apply (measurableSet_prod.mpr (hA‚ÇÅ.fst.inter hA‚ÇÇ.snd)),
        Measure.map_apply (Measurable.fst hf'.inter hg') (measurableSet_fst.inter measurableSet_snd),
        Measure.map_apply hf' hA‚ÇÅ, Measure.map_apply hg' hA‚ÇÇ,
        Measure.prod_prod, hA‚ÇÅ.mul_zero, ‚Üê hy] at this
      exact h.symm

===== Proof 4272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ have hf' : AEMeasurable (fun a  ‚Ü¶ (f a, g a)) Œº :=
      hf.prod_mk hg
    rw [indepFun_iff_map_prod_eq]
    apply IndependentFun.indepFun_prod
    exact fun i ‚Ü¶ i.elim hf hg
  ¬∑ rw [indepFun_iff_map_prod_eq_prod_map_map]
    intro œâ
    congr
    rfl

===== Proof 4273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  constructor <;> intro h_indep <;> simp [h_indep, IndepFun, Measure.map_apply]
  all_goals
    intro E hE
    simp_all only [Set.mem_preimage, Set.mem_inter_iff, Set.mem_prod, Set.mem_image]
    all_goals
      try
        apply_rules [MeasurableSet.inter, MeasurableSet.prod, hf.measurable_set, hg.measurable_set]
        apply_rules [Measure.prod_prod, Measure.prod_prod_symm]
        simp_all

===== Proof 4274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  simp only [IndepFun, Measure.map_apply, Measurable.prod_mk, hf.measurable_fst, hg.measurable_snd,
    Measure.prod_restrict]
  rw [ae_eq_fun_iff_ae_eq_fun_on_set (hf.fst'.prod_mk hg.snd' measurableSet_univ)]
  rw [Filter.eventuallyEq_iff_eventually_eq]
  congr! 1
  exact (congr_arg (fun x ‚Ü¶ fun œâ ‚Ü¶ (x œâ).fst) (funext fun _ ‚Ü¶ rfl)).symm

===== Proof 4275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine' ‚ü®fun hfg ‚Ü¶ by
    apply Prod_eq.2
    intro s t
    have h1 : MeasurableSet (Prod.mk s ‚Åª¬π' t) := measurable_prod_mk_left (t.measurableSet_prod_mk_left s)
    have h2 : ‚àÄ·µê x ‚àÇŒº, (fun œâ ‚Ü¶ (f œâ, g œâ)) ((Prod.mk s ‚Åª¬π' t) ‚à© Set.univ) =
        (f x, g x) ‚à© Set.univ := by rw [Measure.restrict_univ]
    simp only [h2, measure_univ, Set.inter_univ, h1, measure_univ]
    rw [‚Üê hfg.measure_inter_preimage_prod_mk_eq_mul s t,
      ENNReal.ofReal_toReal (measure_ne_top _ _), ENNReal.ofReal_toReal (measure_ne_top _ _)],
    rw [mul_comm, ‚Üê ENNReal.toReal_mul (measure_ne_top _ _) (measure_ne_top _ _), ‚Üê ENNReal.toReal_mul,
      ENNReal.toReal_ofReal (measure_le_one_of_indepFun hfg s t), ENNReal.toReal_ofReal (le_refl _)],
    simp,
  fun hfg ‚Ü¶ by
    refine' fun t1 t2 ‚Ü¶ (Prod_eq.1 hfg) (f ‚Åª¬π' t1) (g ‚Åª¬π' t2) ‚ñ∏ _
    simp only [Measure.map_apply_of_aemeasurable, MeasurableSet.univ, measure_univ,
      Measure.restrict_univ, Set.preimage_univ]
    rw [mul_comm]‚ü©

===== Proof 4276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine' ‚ü®fun hfg ‚Ü¶ by simp [hfg], fun h ‚Ü¶ ?_‚ü©
  have h_eq : mu (f ‚Åª¬π' {x.1} ‚à© g ‚Åª¬π' {x.2}) = (mu (f ‚Åª¬π' {x.1})) * (mu (g ‚Åª¬π' {x.2})) := by
    have : Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := h
    have : Œº (f ‚Åª¬π' {x.1} ‚à© g ‚Åª¬π' {x.2}) = Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) (fun x ‚Ü¶ (f x, g x) ‚àà {x}) := by
      congr
      exact preimage_comp.symm
    rw [this, this] at *
    have : Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) {x} = Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) {x} := rfl
    simp_rw [Measure.prod_apply, this]
    refine' Fintype.prod_congr _ _ fun x ‚Ü¶ _
    simp_rw [Measure.map_apply (Measurable.prod_mk hf.measurable hg.measurable) (measurableSet_singleton _)]
  refine' fun x ‚Ü¶ h_eq x.1 x.2

===== Proof 4277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  constructor
  ¬∑ intro hfg
    apply Subset.antisymm (Set.prod_eq_empty_iff.mp _)
    rw [Set.prod_eq, hfg.measure_prod_mk]
  ¬∑ rw [IndepFun_iff _ hf hg]
    intro hfg
    refine le_antisymm (measure_le_prod_map_map _ _ _) ?_
    rw [hfg, prod_prod]

===== Proof 4278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  apply Iff.intro
  intro hf_indep
  have h_meas_fst : Measurable (fun p : Œ≤ √ó Œ≤' ‚Ü¶ p.fst) := measurable_fst
  have h_meas_snd : Measurable (fun p : Œ≤ √ó Œ≤' ‚Ü¶ p.snd) := measurable_snd
  have h_map_fst_eq := (Measure.map_congr h_meas_fst).mpr (fun _ ‚Ü¶ rfl)
  have h_map_snd_eq := (Measure.map_congr h_meas_snd).mpr (fun _ ‚Ü¶ rfl)
  rw [h_map_fst_eq, h_map_snd_eq]
  exact hf_indep.map_prod_eq_prod_map hg
  intro h_map_eq
  exact (IndepFun.iff_measure_inter_preimage_eq_mul.mpr (fun t1 t2 ‚Ü¶ by
    rw [‚Üê h_map_eq]
    rw [Measure.map_apply_of_aemeasurable (Measurable.prod_mk h_meas_fst h_meas_snd)
      (MeasurableSet.univ_pi ((fun _ : Unit => True) ‚àò fun _ => t1))]))

===== Proof 4279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  simp only [indepFun_iff, hf, hg, measurable_measure_eq_lift_on', MeasurableSpace.prod_apply,
    ‚Üê MeasurableSpace.comap_prod_mk_la, mea
===== Proof 4280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ simp only [IndepFun, hf, hg, aemeasurable_iff_measurable,
      (measurable_fst (mŒ≤ := mŒ≤) (mŒ≤' := mŒ≤')).aemeasurable,
      (measurable_snd (mŒ≤ := mŒ≤) (mŒ≤' := mŒ≤')).aemeasurable]
    rw [Measure.map_map]
    ¬∑ exact h
    ¬∑ exact measurable_fst
    ¬∑ exact measurable_snd
  ¬∑ rw [IndepFun, hf.aemeasurable, hg.aemeasurable]
    refine ((Measurable.prod_mk (measurable_fst (mŒ≤ := mŒ≤) (mŒ≤' := mŒ≤'))
      (measurable_snd (mŒ≤ := mŒ≤) (mŒ≤' := mŒ≤')))).aemeasurable
    rw [‚Üê h]
    exact measurable_map_prod_mk_right

===== Proof 4281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine' ‚ü®fun hfg ‚Ü¶ (Measure.prod_eq fun s hs t ht ‚Ü¶ ?_).symm, fun h ‚Ü¶ ?_‚ü© <;>
  simp only [hfg, h, Measure.map_apply, measurable_fst, measurable_snd, measurableSet_fst,
    measurableSet_snd, Measure.prod_prod]
  <;>
  exact (IsFiniteMeasure.measure_lt_top _).ne
  <;>
  rw [‚Üê h]
  <;>
  exact (IsFiniteMeasure.measure_lt_top _).ne

===== Proof 4282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine'
    ‚ü®fun hfg ‚Ü¶ (Measure.prod_eq fun s t hs ht ‚Ü¶ ?_).symm, fun hst ‚Ü¶ ?_‚ü© <;>
    simp_rw [Measure.map_apply_of_aemeasurable (aemeasurable_fst.comp hf) (aemeasurable_snd.comp hg),
      Measure.map_apply_of_aemeasurable hf (measurable_fst hs),
      Measure.map_apply_of_aemeasurable hg (measurable_snd ht), hst]
  <;>
    exact (hfg _ _ hs ht).symm

===== Proof 4283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  by_cases hŒ≤ : Œ≤ = ‚Ñù; by_cases hŒ≤' : Œ≤' = ‚Ñù
  ¬∑ subst hŒ≤; subst hŒ≤'; simp only [indepFun_iff, hf, hg, measurable_fst, measurable_snd,
      measurable_id', true_and, map_id, prod_prod, map_map, Filter.eventuallyEq_iff_exists_mem]
  ¬∑ rw [indepFun_iff]; simp_rw [hŒ≤', MeasurableSpace.prod_toOuterMeasure_eq_toOuterMeasure_prod,
      ‚Üê map_prod_eq_map‚ÇÇ, IsFiniteMeasure.toFiniteMeasure_eq_toMeasure,
      IsFiniteMeasure.toFiniteMeasure_eq_toMeasure, Filter.eventuallyEq_iff_exists_mem]
    exact ‚ü®fun h ‚Ü¶ ‚ü®(Set.univ : Set Œ©), univ_mem, h‚ü©, fun h ‚Ü¶ h.2.2‚ü©
  ¬∑ rw [indepFun_iff]; simp_rw [hŒ≤, MeasurableSpace.prod_toOuterMeasure_eq_toOuterMeasure_prod,
      ‚Üê map_prod_eq_map‚ÇÇ, IsFiniteMeasure.toFiniteMeasure_eq_toMeasure,
      IsFiniteMeasure.toFiniteMeasure_eq_toMeasure, Filter.eventuallyEq_iff_exists_mem]
    exact ‚ü®fun h ‚Ü¶ ‚ü®(Set.univ : Set Œ©), univ_mem, h‚ü©, fun h ‚Ü¶ h.2.2‚ü©
  ¬∑ simp_rw [hŒ≤, hŒ≤', MeasurableSpace.prod_toOuterMeasure_eq_toOuterMeasure_prod,
      ‚Üê map_prod_eq_map‚ÇÇ, IsFiniteMeasure.toFiniteMeasure_eq_toMeasure,
      IsFiniteMeasure.toFiniteMeasure_eq_toMeasure, Filter.eventuallyEq_iff_exists_mem]
    exact ‚ü®fun h ‚Ü¶ ‚ü®(Set.univ : Set Œ©), univ_mem, h‚ü©, fun h ‚Ü¶ h.2.2‚ü©

===== Proof 4284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  constructor
  ¬∑ intro hfg
    let h := hfg.measurableSpace_eq
    rw [h]
    exact (Measure.map_prod_eq_prod_map _ _ hf hg).symm
  ¬∑ intro h
    refine ‚ü®?_, ?_‚ü©
    ¬∑ exact hf
    ¬∑ exact hg

===== Proof 4285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  constructor <;> intro h
  ¬∑ rw [IndepFun_iff] at h
    simp_rw [h]
    rfl
  ¬∑ rw [IndepFun_iff]
    rw [‚Üê h]
    rfl

===== Proof 4286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ exact (Measure.map_congr h.on_univ).trans (IndepFun.map h hf hg (isProbabilityMeasure Œº))
  ¬∑ rw [indepFun_iff_measure_inter_preimage_eq_mul]
    intros
    rw [‚Üê (Measure.prod_mk_eq_lift _ _).mpr h]
    simp

===== Proof 4287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine' ‚ü®fun hfg ‚Ü¶ .symm, fun h ‚Ü¶ _‚ü©
  refine' (Measure.prod_eq.2 h).symm.trans _
  refine' IndepFun_iff.2 fun s t hs ht ‚Ü¶ _
  rw [‚Üê map_prod_eq_map_map hf hg]
  rw [map_apply_of_aemeasurable (hf.fst.prod_mk hg.fst) (hs.prod ht), map_apply_of_aemeasurable
    (hf.snd.prod_mk hg.snd) (hs.prod ht), map_apply_of_aemeasurable hf hs,
    map_apply_of_aemeasurable hg ht, prod_prod]

===== Proof 4288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mŒ≤ : MeasurableSpace Œ≤} {mŒ≤' : MeasurableSpace Œ≤'}
    [IsFiniteMeasure Œº] (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº) :
    IndepFun f g Œº ‚Üî Œº.map (fun œâ ‚Ü¶ (f œâ, g œâ)) = (Œº.map f).prod (Œº.map g) := by
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ have hmŒ≤ : MeasurableSpace.comap f ‚ä§ = mŒ≤ :=
      HasPDF.subtype_eq (show Set.range f ‚àà ae Œº from hf.aemeasurable.exists_ae_mem_of_type)
    have hmŒ≤' : MeasurableSpace.comap g ‚ä§ = mŒ≤' :=
      HasPDF.subtype_eq (show Set.range g ‚àà ae Œº from hg.aemeasurable.exists_ae_mem_of_type)
    have hmŒ± : MeasurableSpace.comap (fun œâ ‚Ü¶ (f œâ, g œâ)) ‚ä§ = mŒ± := by
      rw [MeasurableSpace.comap_prod]
      simp_rw [hmŒ≤, hmŒ≤', MeasurableSpace.comap_top]
    refine (Measure.Independence.comap _ _ hmŒ± hmŒ≤ hmŒ≤' _).symm
    simp_rw [MeasurableSpace.comap_top]
  ¬∑ refine IndepFun.of_meas_cond ?_ ?_ ?_
    ¬∑ exact hf.aemeasurable
    ¬∑ exact hg.aemeasurable
    have : (fun œâ ‚Ü¶ (f œâ, g œâ)) ‚Åª¬π' {u} = f ‚Åª¬π' (Prod.fst ‚Åª¬π' {u.1}) ‚à© g ‚Åª¬π' (Prod.snd ‚Åª¬π' {u.2}) := by aesop
    show Œº ((fun œâ ‚Ü¶ (f œâ, g œâ)) ‚Åª¬π' {u}) = Œº (f ‚Åª¬π' (Prod.fst ‚Åª¬π' {u.1}) ‚à© g ‚Åª¬π' (Prod.snd ‚Åª¬π' {u.2}))
    rw [this, measure_inter_eq_prod_of_indepFun h]

===== Proof 4289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  match n with
  | 0 => simp
  | n + 1 =>
    simp [moebius_eq_or, Nat.succ_ne_zero]

===== Proof 4290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  refine' ‚ü®fun h ‚Ü¶ _, fun h ‚Ü¶ _‚ü©
  all_goals
    rcases ne_or_eq (Œº n) 0 with h' | rfl
    ¬∑ aesop
    ¬∑ aesop

===== Proof 4291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;> intro h
  exact (moebius_eq_or n).imp_left (¬∑ ‚ñ∏ h)
  aesop

===== Proof 4292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;> intro h <;> simp [moebius_eq_or] at h <;> aesop

===== Proof 4293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  simp [ne_eq, Moebius.eq_or_eq_neg_one_of_ne_zero]

===== Proof 4294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  refine' ‚ü®fun h => _, fun h => ne_zero'.mpr h‚ü©
  rw [moebius_eq_or] at h
  aesop

===== Proof 4295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor
  <;> intro h
  <;> simp only [Moebius_eq_or] at h
  <;> aesop

===== Proof 4296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;> intro h <;> simp_all
  <;> cases' Int.units_eq_one_or (Œº n) with h' h' <;> simp_all

===== Proof 4297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  aesop

===== Proof 4298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  have : Œº 0 = 0 := by simp
  simp [moebius_eq_or, this]

===== Proof 4299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  have : Œº n = 0 ‚Üî ¬¨ (Nat.Prime n ‚à® n = 1 ‚à® n = 0) := by
    rw [moebius_eq_zero_iff]
  aesop

===== Proof 4300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  norm_num
  simp [moebius_eq_or_eq_zero_of_squarefree]

===== Proof 4301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  have : Œº 0 = 0 := by simp
  simp [this, Moebius.moebius_eq_or]

===== Proof 4302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  simp [moebius_eq_or]

===== Proof 4303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;>
  simp (config := { contextual := true }) [moebius_eq_or]

===== Proof 4304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  cases' n with n <;> simp [moebius_eq_or, eq_self_iff_true, or_true]

===== Proof 4305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  cases' n with n <;> simp [moebius_eq_or, eq_self_iff_true, or_true]

===== Proof 4306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  have : Œº 0 = 0 := by simp
  simp [moebius_eq_or, this]

===== Proof 4307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  match n with
  | 0 => simp
  | 1 => simp
  | n + 2 => simp

===== Proof 4308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;> intro h
  <;> simp only [moebius_eq_zero_iff, not_or, not_forall, not_not] at h
  <;> aesop

===== Proof 4309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  apply Iff.intro <;> intro h <;>
  simp_all only [ne_eq, Moebius.moebius_apply, mul_eq_mul_left_iff, one_ne_zero, mul_zero,
    mul_one, true_or] <;>
  aesop

===== Proof 4310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;> simp (config := {decide := true}) [show Œº 0 = 0 by decide]

===== Proof 4311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;> intro h <;>
  simp_all only [ne_eq, MoebiusTransform.Œº_apply, ite_eq_left_iff, one_ne_zero, zero_ne_one]
  <;>
  omega

===== Proof 4312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  have h‚ÇÄ : ‚àÄ n : ‚Ñï, Œº n = 0 ‚à® Œº n = 1 ‚à® Œº n = -1 := by
    intro n
    have : (0 : ‚Ñ§) ‚â§ Œº n ‚àß Œº n ‚â§ 1 := by
      apply And.intro (le_of_eq ?_)
      ¬∑ apply m.le_of_dvd
        exact one_le_two
        exact ‚ü®primeFactors n, by simp [m.map_primeFactors n]‚ü©
      apply Int.le_of_lt_add_one
      apply lt_of_le_of_ne (m.le_of_dvd n)
      exact (m.ne_of_not_dvd n).symm
    have : (0 : ‚Ñ§) ‚â§ Œº n ‚àß Œº n ‚â§ 1 := by
      apply And.intro (le_of_eq ?_)
      ¬∑ apply m.le_of_dvd
        exact one_le_two
        exact ‚ü®primeFactors n, by simp [m.map_primeFactors n]‚ü©
      apply Int.le_of_lt_add_one
      apply lt_of_le_of_ne (m.le_of_dvd n)
      exact (m.ne_of_not_dvd n).symm
    omega
  have h‚ÇÅ : Œº n = 0 ‚à® Œº n = 1 ‚à® Œº n = -1 := by
    apply h‚ÇÄ
  have h‚ÇÇ : Œº n ‚â† 0 ‚à® Œº n = 1 ‚à® Œº n = -1 := by
    cases h‚ÇÅ
    ¬∑ right; right; assumption
    ¬∑ exact Or.inl ‚ÄπŒº n = 1 ‚à® Œº n = -1‚Ä∫
  exact Iff.intro (fun h => Or.inl h) (fun h => by aesop)

===== Proof 4313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;> intro h <;> simp_all [moebius_eq_zero_iff]

===== Proof 4314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  cases n <;> simp [moebius_apply_1]

===== Proof 4315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  simp [moebius_eq_or]

===== Proof 4316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  rcases eq_or_ne (Œº n) 0 with h | h <;> simp_all [moebius_eq_or]

===== Proof 4317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;> intro h <;>
  simp_all only [moebius_eq_or, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true]
  <;> aesop

===== Proof 4318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  rcases eq_or_ne (Œº n) 0 with h | h <;> simp_all
  <;> norm_num
  <;> rcases eq_or_ne (Œº n) 0 with h | h <;> simp_all
  <;> norm_num

===== Proof 4319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  rw [ne_eq]
  simp [moebius_eq_or]

===== Proof 4320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ‚Ñï} : Œº n ‚â† 0 ‚Üî Œº n = 1 ‚à® Œº n = -1 := by
  constructor <;> intro h <;>
  simp_all only [moebius_eq_or, ne_eq, one_ne_zero, mul_eq_zero, one_ne_zero,
    or_false_iff]
  <;>
  aesop

===== Proof 4321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction' l with y l IH
  simp
  simp only [List.sublist_cons]
  split_ifs
  all_goals
    simp_all only [and_imp, exists_imp]
    aesop

===== Proof 4322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l <;> simp_all [sublist_cons_comm, or_comm]

===== Proof 4323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  constructor <;> simp (config := { contextual := true }) [sublist_iff_exists_cons, cons_append]
  <;> aesop

===== Proof 4324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l <;> simp_all [sublist_cons]
  aesop

===== Proof 4325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons y l IH =>
    simp only [sublist_cons, IH, and_assoc]
    simp (config := { contextual := true })

===== Proof 4326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  constructor <;> intro h <;> induction' l with _ _ hl
  ¬∑ case mp.nil => simp at h
  ¬∑ case mp.cons =>
    cases' h with _ _ _ h
    ¬∑ right; exact hl
    ¬∑ left; exact hl
  ¬∑ case mpr.nil => simp_all
  ¬∑ case mpr.cons =>
    cases' hl with _ _ _ hl
    ¬∑ right; exact hl
    ¬∑ left; exact hl

===== Proof 4327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons a l ih =>
    by_cases ha : a = x
    ¬∑ simp [ha, Sublist.cons, Sublist.cons_cons, ih]
    ¬∑ simp [ha, ih]

===== Proof 4328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons y l IH =>
    simp [IH, sublist_cons]
    tauto

===== Proof 4329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons a l ih =>
    constructor
    ¬∑ intro h
      cases' h with h h <;> rw [List.cons_sublist_cons] at h
      ¬∑ exact Sublist.cons _ (Sublist.cons _ (Sublist.nil))
      ¬∑ exact Sublist.cons_cons _ h
    ¬∑ intro h
      rw [List.sublist_cons_comm] at h
      cases' h with _ h
      ¬∑ exists Sublist.nil
      ¬∑ cases' h with _ h
        exacts [Or.inr (Or.inl rfl), Or.inr (Or.inr (ih.mp h))]

===== Proof 4330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  constructor <;> intro h <;> simp_all [Sublist.cons, Sublist.cons2]

===== Proof 4331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l <;> simp (config := { contextual := true }) [*, sublist_cons]
  <;> aesop

===== Proof 4332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  constructor <;> simp (config := { contextual := true })
  <;> induction' l with y l IH
  <;> simp_all (config := { contextual := true })
  <;> cases' Decidable.em (x = y) with c c <;> simp [c]
  <;> aesop

===== Proof 4333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  constructor <;> intro h <;> simp_all

===== Proof 4334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons a l ih =>
    simp_all [List.sublist_cons]
    aesop

===== Proof 4335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons y l ih =>
    simp [ih, Sublist.cons]

===== Proof 4336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction' l with h t
  case nil => simp [Sublist.nil]
  case cons =>
    simp_all [Sublist.cons]
    tauto

===== Proof 4337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons y l IH =>
    simp_all [List.Sublist.cons]

===== Proof 4338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  constructor <;> intro h <;> simp_all [sublist_iff_exists_fin_order, Int.sublist, Int.indexOf_lt_length]
  <;> try { use 0; simp }
  <;> try { use 1; simp }
  <;> cases h; simp_all
  <;> try { use 0; simp }
  <;> try { use 1; simp }
  <;> cases h; simp_all
  <;> try { use 0; simp }
  <;> try { use 1; simp }
  <;> cases h; simp_all
  <;> try { use 0; simp }
  <;> try { use 1; simp }
  <;> cases h; simp_all
  <;> try { use 0; simp }
  <;> try { use 1; simp }

===== Proof 4339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons y l IH =>
    simp only [sublist_cons, mem_cons, IH, or_assoc]
    tauto

===== Proof 4340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons a l ih =>
    rw [sublist_cons_iff]
    rw [‚Üê ih]
    rw [sublist_cons_iff]
    rw [sublist_cons_iff]
    rw [‚Üê sublist_cons_iff]
    tauto

===== Proof 4341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  constructor <;>
    simp (config := { contextual := true }) only [*, Sublist.def, exists_true_left]
    <;>
    tauto

===== Proof 4342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  cases l <;> simp_all (config := { unfoldPartialApp := true })
  <;> simp_all (config := { unfoldPartialApp := true })
  <;> simp_all (config := { unfoldPartialApp := true })
  <;> simp_all (config := { unfoldPartialApp := true })

===== Proof 4343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons h t ih =>
    simp only [sublist_cons, List.mem_cons, ih]
    constructor <;> intro h
    next =>
      cases h <;> simp_all [duplicate_cons_iff]
    next =>
      cases h <;> simp_all [duplicate_cons_iff]

===== Proof 4344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  cases l <;> simp
  simp
  tauto

===== Proof 4345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  apply Iff.intro <;> intro h <;> simp_all
  <;> exists [] <;> simp
  <;> simp_all

===== Proof 4346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l <;> simp_all [sublist_cons]

===== Proof 4347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons a l ih =>
    simp only [sublist_cons, mem_cons, duplicate_iff_sublist, ih, and_self_iff,
      true_or_iff, or_true_iff]

===== Proof 4348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  egrf

===== Proof 4349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil => simp
  | cons y l IH =>
    simp only [sublist_cons, mem_cons, IH, and_self_iff, or_true_iff]
    tauto

===== Proof 4350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  induction l with
  | nil =>
    simp
  | cons a l ih =>
    simp_all [List.sublist_cons]

===== Proof 4351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  constructor <;>
  (intros h; split_ifs at h <;> try simp [*, Sublist.sublist_of_cons_sublist,
    Sublist.sublist_of_sublist_cons] at * <;>
    try simp [*, Sublist.cons_sublist, Sublist.sublist_cons_of_sublist] at * <;>
    try simp [*, Sublist.sublist_of_cons_sublist, Sublist.sublist_of_sublist_cons] at * <;>
    try simp [*, Sublist.cons_sublist, Sublist.sublist_cons_of_sublist] at * <;>
    try simp [*, Sublist.sublist_of_cons_sublist, Sublist.sublist_of_sublist_cons] at * <;>
    try simp [*, Sublist.cons_sublist, Sublist.sublist_cons_of_sublist] at * <;>
    try simp [*, Sublist.sublist_of_cons_sublist, Sublist.sublist_of_sublist_cons] at * <;>
    try simp [*, Sublist.cons_sublist, Sublist.sublist_cons_of_sublist] at * <;>
    try simp [*, Sublist.sublist_of_cons_sublist, Sublist.sublist_of_sublist_cons] at * <;>
    try simp [*, Sublist.cons_sublist, Sublist.sublist_cons_of_sublist] at * <;>
    try simp [*, Sublist.sublist_of_cons_sublist, Sublist.sublist_of_sublist_cons] at * <;>
    try simp [*, Sublist.cons_sublist, Sublist.sublist_cons_of_sublist] at * <;>
    try simp [*, Sublist.sublist_of_cons_sublist, Sublist.sublist_of_sublist_cons] at * <;>
    try simp [*, Sublist.cons_sublist, Sublist.sublist_cons_of_sublist] at * <;>
    try simp [*, Sublist.sublist_of_cons_sublist, Sublist.sublist_of_sublist_cons] at * <;>
    try simp [*, Sublist.cons_sublist, Sublist.sublist_cons_of_sublist] at *)
  <;>
  try simp_all

===== Proof 4352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ‚àà+ l ‚Üî [x, x] <+ l := by
  constructor <;> intro h
  case mp =>
    exact Sublist.duplicate_iff_sublist.mp h
  case mpr =>
    exact Sublist.duplicate_iff_sublist.mpr h

===== Proof 4353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [expComparison_ev, Limits.prod.map, NatTrans.comp_app, NatTrans.id_app,
    NatTrans.id_app, Functor.id_obj, Functor.map_id, Functor.map_comp,
    NatTrans.id_app, Functor.map_id, Functor.map_comp, Iso.inv_app,
    expComparison_inv_app_app, NatTrans.app_inv, Iso.app_inv,
    prodComparison_inv_app_app]
  aesop_cat

===== Proof 4354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  rw [‚Üê prodComparison_inv_id_app_hom_app, ‚Üê NatTrans.comp_app_assoc, ‚Üê F.map_comp, ‚Üê
    NatTrans.comp_app, NatTrans.id_app, F.map_id, Category.id_comp, comp_id]

===== Proof 4355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [Limits.prod.map, NatTrans.app_id, map_id, comp_id, NatTrans.app_comp,
    Iso.inv_hom_id_app_assoc]
  apply prod_extend_ev

===== Proof 4356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  rw [expComparison_ev_app]
  simp

===== Proof 4357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [prod.map, identity_map, NatTrans.id_app, comp_id]
  rw [‚Üê NatTrans.cancel_app_left (expComparison F A)]
  simp only [comp_inv_eq_inv_comp, inv_inv]
  simp only [Functor.map_inv, Prod.‰∫§Êç¢Âæã_hom, NatTrans.naturality_assoc]
  simp only [functors_inv, NatTrans.naturality_assoc]
  simp only [Functor.map_finsupp_sum, Finset.sum_app, NatTrans.naturality_assoc]
  simp only [comp_id]
  rfl

===== Proof 4358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [expComparison_ev, prodComparison, limComparison_œÄ_app,
    lim_map, map_œÄ_comparison, map_id, Iso.refl_inv, Iso.refl_trans, Iso.symm_inv,
    expComparison_ev, prodComparison, limComparison_œÄ_app, lim_map, map_œÄ_comparison,
    map_id, Iso.refl_inv, Iso.refl_trans, Iso.symm_inv]
  simp [id_comp]

===== Proof 4359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp [expComparison, prodComparison, NatTrans.id]
  aesop_cat

===== Proof 4360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [expComparison_ev', Prod.map_snd_app]
  simp [‚Üê F.map_comp, ‚Üê NatTrans.naturality, exp_ev]

===== Proof 4361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [expComparison, prodComparison, NatTrans.naturality, Hom.right_id, _root_.id_comp,
    NatTrans.naturality_assoc, homomorphism.right_id, F.map_id, id_comp, NatTrans.naturality_assoc,
    homomorphism.right_id, F.map_id, id_comp]
  rw [‚Üê NatTrans.naturality}
  simp only [NatTrans.naturality_assoc, Hom.right_id, _root_.id_comp, NatTrans.naturality_assoc,
    homomorphism.right_id, F.map_id, id_comp, NatTrans.naturality_assoc, homomorphism.right_id,
    F.map_id, id_comp]
  erw [‚Üê comp_inv_eq, Iso.inv_hom_id]
  rw [‚Üê NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc]
  erw [Iso.inv_hom_id_app]
  simp only [NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc]
  erw [Iso.inv_hom_id_app]
  simp only [NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc]
  erw [Iso.inv_hom_id_app]
  simp only [NatTrans.naturality_assoc, NatTrans.naturality_assoc, NatTrans.naturality_assoc]
  erw [Iso.inv_hom_id_app]
  simp only [Hom.right_id, _root_.id_comp, NatTrans.naturality_assoc, homomorphism.right_id,
    F.map_id, id_comp, NatTrans.naturality_assoc, homomorphism.right_id, F.map_id, id_comp]

===== Proof 4362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  dsimp only [expComparison, Prod.instHasLimitsSemicartesian]
  simp only [NatTrans.naturality_assoc, Pi.map_assoc, Iso.hom_inv_id_app_assoc]
  simp [exp.ev, ‚Üê F.map_comp]

===== Proof 4363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp [expComparison, Iso.comp_inv_eq]
  aesop_cat

===== Proof 4364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [Limits.prod.map, Iso.trans, Iso.symm, Iso.app_inv, Function.comp_app,
    NatTrans.app_add, Prod.map_snd, NatTrans.app_sub, NatTrans.app_zero, NatTrans.app_neg,
    NatTrans.app_decomposeHom, NatTrans.app_id_app_eq_self_app, NatTrans.app_id_app_eq_inv_app,
    NatTrans.app_id_self_app, id_comp, comp_id, inv_hom_id, not_true]
  simp (config := { arith := true }) [@eq_comm _ _ (0 : C)]

===== Proof 4365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [Limits.prod.map_id_id, NatTrans.id_app, expComparison_ev, Limits.prodComparison_inv_app_snd]
  simp only [Functor.map_id, comp_id, NatTrans.id_app, Limits.prodComparison_inv_app_snd]
  simp only [Functor.map_id, comp_id, NatTrans.id_app, Limits.prodComparison_inv_app_snd]
  aesop_cat

===== Proof 4366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  rw [‚Üê bowtie_ev_ev, ‚Üê inv_prodComparison_APP]
  have h := cart_expComparison_APP F A B
  simp only [‚Üê h]
  simp only [Category.assoc,comp_prod,prod_map_map_assoc, comp_id, ‚Üê h]
  simp [Category.assoc, Category.id_comp]

===== Proof 4367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [expComparison_ev, Iso.inv_hom_id, comp_id, map_id]
  apply prodComparison_natural

===== Proof 4368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp [id_comp]

===== Proof 4369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp [expComparison, ev, productComparison, NatTrans.naturality, map_hom_inv, map_inv_hom_app,
    assoc]
  aesop_cat

===== Proof 4370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp [‚Üê F.map_id, ‚Üê F.map_comp]
  simp [expComparison, prodComparison]
  simp [‚Üê NatTrans.naturality_assoc, ‚Üê NatTrans.naturality_comp]
  simp [expComparison, prodComparison]
  aesop_cat

===== Proof 4371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  delta expComparison
  simp only [Hom.app_id, comp_id, NatTrans.app_id, map_id, id_comp]
  apply prodComparison_inv_proj_app

===== Proof 4372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [expComparison, Limits.mapArrow.expComparison_hom,
    Limits.mapArrow.expComparison_inv, Limits.prodComparison_inv, comp_inv, F.map_id,
    F.map_comp]
  simp only [exp.ev_naturality, toProdul_comp, map_lim, map_id,
    NatTrans.naturality_assoc]
  aesop_cat

===== Proof 4373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp [‚Üê F.map_prodfst, ‚Üê F.map_snd, ‚Üê F.map_comp, expComparison_ev_snd,
    expComparison_ev_fst, F.map_comp]

===== Proof 4374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [expComparison_ev_app, ‚Üê comp_map, prodComparison_inv_hom_id, Aut.aut_mul_eq_comp,
    map_id]
  rw [comp_id, id_comp]

===== Proof 4375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  rw [expComparison_ev_app]
  simp only [assoc, ‚Üê (F.mapIso (prodComparison (X := A) F B)).hom_inv_id, ‚Üê Iso.inv_hom_id_app,
    id_comp, comp_id]

===== Proof 4376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [‚Üê NatTrans.comp_app, ‚Üê Functor.map_comp,
    expComparison_ev, Category.assoc, prod.map_snd, ev_app, map_id, prod.map_id]
  rw [expComparison_ev]
  simp only [prodComparison_ev, Functor.map_id, Iso.inv_hom_id_app]
  rw [Category.assoc, ev_naturality, exp.ev_naturality ]
  simp only [Functor.map_id, Iso.inv_hom_id_app, Functor.id_obj, Category.id_comp,
    Category.comp_id, Iso.inv_hom_id_app_assoc, Functor.map_one, comp_map,
    NatTrans.naturality_assoc, map_id, Iso.inv_hom_id_app_assoc, NatTrans.naturality_app, exp_ev,
    Final.final_obj, prodComparison_inv_app_assoc, ev_app_assoc, map_map,
    NatTrans.naturality, final_obj_obj_2, ‚Üê tensor_comp_assoc, id_comp, Category.assoc]
  erw [‚Üê IsIso.inv_id (F.obj B)]
  simp only [IsIso.inv_id_assoc, prod.map_snd, IsIso.inv_id_app, IsIso.hom_inv_id_assoc,
    IsIso.inv_hom_id_app_assoc, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app,
    IsIso.inv_id, NatTrans.app_inv, Iso.hom_inv_id_app_assoc, IsIso.inv_hom_id_app_assoc]
  simp

===== Proof 4377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  dsimp [expComparison, exp_comparison_map]
  simp only [‚Üê Prod.map_comp_map, NatTrans.app_comp, NatTrans.comp_app,
    NatTrans.id_app, Functor.id_obj, Category.comp_id,
    NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    Iso.comp_inv_eq, Iso.inv_comp_eq, Iso.inv_hom_id, Iso.hom_inv_id,
    Iso.inv_id, Iso.id_hom, Functor.map_id, Functor.id_map, ErbH.map_id]
  simp only [F.map_id, comp_id, id_comp, NatTrans.naturality_assoc, NatTrans.naturality_assoc,
    Iso.comp_inv_eq, Iso.inv_comp_eq, Iso.inv_hom_id, Iso.hom_inv_id, Iso.inv_id, Iso.id_hom]
  simp

===== Proof 4378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [map_id, id_comp, comp_id]
  rw [‚Üê NaturalTransformation.comp_app]
  simp [‚Üê NatTrans.comp_app, ‚Üê IsIso.comp_inv_eq, ‚Üê Category.assoc, prodComparison_ev]

===== Proof 4379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp [expComparison_ev, prodComparison_inv, NatTrans.id_app, Iso.inv_app, ‚Üê Functor.map_comp]

===== Proof 4380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp [prodComparison_inv, prod.left_unitor, expComparison, Iso.trans, NatIso.app]
  aesop_cat

===== Proof 4381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp [‚Üê Functor.map_comp, expComparison, ev, prodComparison, Prod.map]

===== Proof 4382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp

===== Proof 4383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  dsimp [ExpComparison.ev]
  simp [‚Üê F.map_comp, ‚Üê NatTrans.naturality]

===== Proof 4384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (ùüô (F.obj A)) ((expComparison F A).app B) ‚â´ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ‚â´ F.map ((exp.ev _).app _) := by
  simp only [ev_eq_prod_map_snd, Limits.prod.map_snd,
    F.map_id, NatTrans.app_id, Category.comp_id]
  rw [‚Üê NatTrans.naturality_apply, ‚Üê NatTrans.naturality_apply,
    ‚Üê F.map_comp, expComparison_ev_app,
    ‚Üê NatTrans.naturality_apply, ‚Üê NatTrans.naturality_apply,
    ‚Üê F.map_comp, expComparison_ev_app]
  simp [‚Üê NatTrans.naturality_apply, ‚Üê NatTrans.naturality_apply,
    ‚Üê F.map_comp, expComparison_ev_app]

===== Proof 4385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  apply induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ
  simp

===== Proof 4386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by simp_all

===== Proof 4387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  rw [comp‚ÇÇMeasurable_toGerm]
  rw [comp‚ÇÇMeasurable]
  simp [Germ.coe_eq, FilteredOrbitsEquiv]

===== Proof 4388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by rw [comp‚ÇÇMeasurable_eq_mk]

===== Proof 4389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp

===== Proof 4390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by convert ENNReal.iInf_add_iInf_of_monotone
      (fun a : Œ± ‚Ü¶ MeasurableSet (f ¬∑ < a)) (fun a : Œ± ‚Ü¶ MeasurableSet (f ¬∑ > a)) (fun a : Œ± ‚Ü¶
        MeasurableSet (f ¬∑ < a)) (fun a : Œ± ‚Ü¶ MeasurableSet (f ¬∑ > a))
        (fun a b hab ‚Ü¶ iInf_mono fun _ ‚Ü¶
          measure_mono_null (fun _ ha ‚Ü¶ ha.trans_le hab)
            (measure_iInf_null _ fun _ ha ‚Ü¶ ha.trans_le hab))
      (fun a b hab ‚Ü¶ iInf_mono fun _ ‚Ü¶
        measure_mono_null (fun _ ha ‚Ü¶ lt_of_le_of_lt hab ha)
          (measure_iInf_null _ fun _ ha ‚Ü¶ lt_of_le_of_lt hab ha))
      (fun a b hab ‚Ü¶ iInf_mono fun _ ‚Ü¶
        measure_mono_null (fun _ ha ‚Ü¶ ha.trans_le hab)
          (measure_iInf_null _ fun _ ha ‚Ü¶ ha.trans_le hab))
      (fun a b hab ‚Ü¶ iInf_mono fun _ ‚Ü¶
        measure_mono_null (fun _ ha ‚Ü¶ lt_of_le_of_lt hab ha)
          (measure_iInf_null _ fun _ ha ‚Ü¶ lt_of_le_of_lt hab ha))

===== Proof 4391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  apply induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ
  intro f‚ÇÅ f‚ÇÇ
  simp

===== Proof 4392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp

===== Proof 4393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  classical simp_all
  aesop

===== Proof 4394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  simp

===== Proof 4395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  apply induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ
  simp

===== Proof 4396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp

===== Proof 4397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  simp [comp‚ÇÇMeasurable, toGerm, compMeasurable, map_toGerm, ofMeasurable,
    SecondCountableTopology.sigmaCountable]

===== Proof 4398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ ‚Ü¶ by
    simp [toGerm, comp‚ÇÇMeasurable, comp_toGerm, hg]

===== Proof 4399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp

===== Proof 4400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  simp

===== Proof 4401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  simp_rw [comp‚ÇÇMeasurable, toGerm, map‚ÇÇGerm]
  refine' Germ.induction_on‚ÇÇ f‚ÇÅ fun f‚ÇÅ _ => _
  refine' Germ.induction_on‚ÇÇ f‚ÇÇ fun f‚ÇÇ _ => _
  simp_rw [compMeasurable, toGerm, mapGerm]; rfl

===== Proof 4402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by
    simp [comp‚ÇÇMeasurable, toGerm, compMeasurable, ‚Üê comp‚ÇÇ_toGerm, ‚Üê comp_toGerm]

===== Proof 4403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  intro Œ≤ Œ≥ Œ¥
  simp only [uncurry, comp‚ÇÇMeasurable, toGerm, map‚ÇÇGerm, induction_on‚ÇÇ]
  aesop

===== Proof 4404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp

===== Proof 4405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  intro g hg f‚ÇÅ f‚ÇÇ
  induction f‚ÇÅ using induction_on‚ÇÇ with
  | of_eq e =>
    induction f‚ÇÇ using induction_on‚ÇÇ with
    | of_eq ‚ü®‚ü© =>
      rw [comp‚ÇÇMeasurable_of_mul, toGerm_of, toGerm_of, toGerm_of,
          map‚ÇÇ_of, toGerm_of]
      simp [hg, e]
    | of_eq f‚ÇÇ =>
      induction f‚ÇÇ using induction_onPairs with
      | of_eq ‚ü®‚ü© =>
        rw [comp‚ÇÇMeasurable_of_mul, toGerm_of, toGerm_of, toGerm_of,
            map‚ÇÇ_of, toGerm_of]
        simp [hg, e]
      | of_eq f‚ÇÇ =>
        rw [comp‚ÇÇMeasurable_of_mul, toGerm_of, toGerm_of, toGerm_of,
            map‚ÇÇ_of, toGerm_of]
        simp [hg, e]
  | of_eq f‚ÇÅ =>
    induction f‚ÇÇ using induction_on‚ÇÇ with
    | of_eq f‚ÇÇ =>
      rw [comp‚ÇÇMeasurable_of_mul, toGerm_of, toGerm_of, toGerm_of,
          map‚ÇÇ_of, toGerm_of]
      simp [hg, f‚ÇÅ]
    | of_eq ‚ü®‚ü© =>
      rw [comp‚ÇÇMeasurable_of_mul, toGerm_of, toGerm_of, toGerm_of,
          map‚ÇÇ_of, toGerm_of]
      simp [hg, f‚ÇÅ]
  | of_eq f‚ÇÇ =>
    induction f‚ÇÇ using induction_on‚ÇÇ with
    | of_eq ‚ü®‚ü© =>
      rw [comp‚ÇÇMeasurable_of_mul, toGerm_of, toGerm_of, toGerm_of,
          map‚ÇÇ_of, toGerm_of]
      simp [hg, f‚ÇÇ]
    | of_eq f‚ÇÇ =>
      rw [comp‚ÇÇMeasurable_of_mul, toGerm_of, toGerm_of, toGerm_of,
          map‚ÇÇ_of, toGerm_of]
      simp [hg, f‚ÇÇ]

===== Proof 4406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ ‚Ü¶ rfl

===== Proof 4407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ ‚Ü¶ rfl

===== Proof 4408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  simp

===== Proof 4409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ <;> simp_all

===== Proof 4410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  simp_rw [comp‚ÇÇMeasurable_toGerm]
  aesop

===== Proof 4411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  simp

===== Proof 4412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  intro A B
  have h : 0 < A.card := Nat.pos_of_ne_zero (by simp)
  have h‚ÇÅ : 0 < B.card := Nat.pos_of_ne_zero (by simp)
  have h‚ÇÇ : 0 < (A.card * B.card).succ := Nat.succ_pos _
  simp [Nat.mul_div_cancel_left _ h, Nat.mul_div_cancel_left _ h‚ÇÅ, h‚ÇÇ]

===== Proof 4413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  intro a; cases a <;> simp

===== Proof 4414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  let condition := (multiple_zero_extend (Fin 1) L) = 0
  let result := rfl
  exact ‚ü®condition,result‚ü©

===== Proof 4415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by derive_simp_rule

===== Proof 4416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp‚ÇÇMeasurable_toGerm [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
    [PseudoMetrizableSpace Œ≥] [SecondCountableTopologyEither Œ≤ Œ≥]
    [MeasurableSpace Œ≥] [BorelSpace Œ≥] [PseudoMetrizableSpace Œ¥] [SecondCountableTopology Œ¥]
    [MeasurableSpace Œ¥] [OpensMeasurableSpace Œ¥] (g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥) (hg : Measurable (uncurry g))
    (f‚ÇÅ : Œ± ‚Üí‚Çò[Œº] Œ≤) (f‚ÇÇ : Œ± ‚Üí‚Çò[Œº] Œ≥) :
    (comp‚ÇÇMeasurable g hg f‚ÇÅ f‚ÇÇ).toGerm = f‚ÇÅ.toGerm.map‚ÇÇ g f‚ÇÇ.toGerm :=
  induction_on‚ÇÇ f‚ÇÅ f‚ÇÇ fun f‚ÇÅ _ f‚ÇÇ _ => by simp
:= by
  intro g hg f‚ÇÅ f‚ÇÇ; induction f‚ÇÅ; induction f‚ÇÇ; simp

===== Proof 4417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro a b h‚ÇÄ
  apply FA.injective
  have h‚ÇÅ := hg'.right_inv a
  have h‚ÇÇ := hg'.right_inv b
  have h‚ÇÉ := hg'.monotone
  have h‚ÇÑ := h.eq
  simp only [h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ, le_antisymm_iff, and_self_iff, bot_le]
  simp_all

===== Proof 4418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  refine' hg'.2 _ _ _
  intro b
  apply h
  apply hg'.1

===== Proof 4419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  ¬∑ exact ((h.isOrderRightAdjoint hg').eq_symm_adjoint).1

===== Proof 4420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  rw [Function.Semiconj, Function.Semiconj] at h
  simp_rw [IsOrderRightAdjoint, (¬∑ ‚àò ¬∑)] at hg'
  intro x y hxy
  apply hg'.2
  apply h
  assumption

===== Proof 4421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  simp_rw [Function.Semiconj] at h ‚ä¢; exact fun x => by
    apply hg'.right_inv
    simpa only [h] using hg'.left_inv (f := fa)

===== Proof 4422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro y
  have h1 := hg'.right_inv y
  apply Eq.symm
  rw [‚Üê h1]
  have h2 := hg'.right_inv (g' y)
  rw [‚Üê h2]
  simp [h.eq, hg'.left_inv]

===== Proof 4423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro x y hxy;
  rw [‚Üê hg'.of_mem_adjoint hxy, ‚Üê h.eq, hg'.of_mem_adjoint]

===== Proof 4424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  rw [Function.semiconj_iff_comp_eq_comp] at h ‚ä¢
  apply hg'.unique
  rw [h, hg'.unique]
  simp only [Function.comp_id, Function.id_comp]

===== Proof 4425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro x y h‚ÇÄ
  rw [‚Üê hg'.gc.u_l_u_eq_u]
  rw [h.eq] at h‚ÇÄ
  simp_all only [OrderHom.coe_coe, Function.comp_apply, Function.conj_comp, Function.comp]
  apply hg'.gc.monotone_l
  exact OrderHom.mono _ h‚ÇÄ

===== Proof 4426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro a b h
  have := hg'.2 (fb h)
  simp only [g, fa, fb, Function.Semiconj] at this
  exact (h this).symm

===== Proof 4427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  rw [Function.semiconj_iff_comp_eq] at h ‚ä¢
  rw [‚Üê hg'.eq, comp_assoc, h, ‚Üê comp_assoc, hg'.left_inv, orderEmbedding.comp_id]

===== Proof 4428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro x
  rw [‚Üê h.eq, ‚Üê hg'.fixed, h.eq, hg'.fixed]
  exact fa.symm_apply_apply x

===== Proof 4429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  rintro y x
  refine' le_antisymm
    (h <| le_of_eq hg'.apply_eq_iff.1 (g' fb (g x)) <| g x).trans
    (h <| le_of_eq hg'.apply_eq_iff.1 (g' fb y) y).trans

    (h <| le_of_eq hg'.apply_eq_iff.1 (g' fa (g x)) (g x)).trans
    (h <| le_of_eq hg'.apply_eq_iff.1 (g' fa y) y).trans
    (le_of_eq hg'.apply_eq_iff.1 (g' fa y) <| g y).symm


===== Proof 4430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro x y hxy
  apply h
  rw [‚Üê hg'.l_apply_apply x, ‚Üê hg'.l_apply_apply y]
  exact hg'.monotone hxy

===== Proof 4431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  rw [Function.semiconj_iff_comp_eq]
  dsimp only [OrderIso.trans] at h
  have := congr_arg g' (h.eq)
  exact le_antisymm
    (hg'.right_le_iff.mpr (Function.mtr
      (h.eq ‚ñ∏ fun h ‚Ü¶ (fa.apply_lt_apply_iff (y := g' (fb h))).mp
        (h.symm ‚ñ∏ fb.lt_iff_lt.mpr h.symm))))
    (hg'.right_le_iff.mpr (Function.mtr
      (h.eq ‚ñ∏ fun h ‚Ü¶ (fb.lt_iff_lt.mpr h.symm) ‚ñ∏ fa.apply_lt_apply_iff.mp
        (h.symm ‚ñ∏ h))))

===== Proof 4432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro b
  have h2 := hg'.right_inv
  have h1 := h.eq
  simp only [Function.comp_apply, h1, h2] at *
  apply le_antisymm
  ¬∑ apply hg'.gc.1
    rw [h2]
    exact le_rfl
  ¬∑ apply hg'.gc.2
    rw [h2]
    exact le_rfl

===== Proof 4433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  rw [Function.semiconj_iff_comp_eq] at h ‚ä¢
  rw [hg'.right_inv] at h
  ext x
  simp only [Function.comp_apply, OrderIso.symm_apply_apply, h, Function.comp_apply,
    OrderIso.apply_symm_apply]

===== Proof 4434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro a b h‚ÇÅ
  have h‚ÇÇ := hg' a b h‚ÇÅ
  simp_all [h.eq, h.eq‚ÇÅ]

===== Proof 4435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro y x
  simp only [Function.Semiconj, OrderIso.invFun_eq_symm, isOrderRightAdjoint_iff] at *
  apply le_antisymm (hg' y _ ‚ñ∏ fa.le_iff_le.1 (h _ _))
  apply hg' y _ ‚ñ∏ fa.le_iff_le.2 (h _ _)

===== Proof 4436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  have (b : Œ≤) := hg' b
  simp_all [Function.Semiconj, IsOrderRightAdjoint]
  exact fun b => le_antisymm
    (le_trans (le_cinfi fun a => (h (g a)).le) (le_cinfi fun a => (le_of_eq (h (g' (fa a)))).trans (fb.monotone (hg' (fa a)))))
    (le_cinfi fun a => le_trans (le_of_eq ((h (g' (fb b))).symm)) (fa.monotone (le_cinfi fun a => (h (g a)).le)))

===== Proof 4437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  subst_vars
  simp [Function.Semiconj, IsOrderRightAdjoint, ‚Üê h.eq, le_of_lt]
  aesop

===== Proof 4438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro x y hxy
  apply h.eq_of_right
  rw [‚Üê fa.left_inv x]
  rw [‚Üê fb.left_inv (g' (fb (g (fa x))))]
  rw [‚Üê hg' (g (fa x)) (fb (g (fa x))) hxy]
  simp [h.eq_of_right]

===== Proof 4439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  simp only [Function.semiconj_iff_comp_eq] at h ‚ä¢
  rw [‚Üê comp_assoc]
  simpa only [‚Üê comp_assoc, hg'.isGreatest_iff, h.eq, Function.comp_apply] using hg'.left_inv fb

===== Proof 4440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro y x hyp
  apply OrderIso.eq_symm_apply_iff_eq_apply_symm.2
  apply symm
  rw [‚Üê hg'.right_inv x]
  rw [‚Üê hg'.left_inv_right_inv y]
  rw [h.eq]
  exact hyp

===== Proof 4441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  have : IsOrderLeftAdjoint g' g := hg'
  intro x y
  have := (h x y).symm
  simpa using congr_arg g' this

===== Proof 4442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro x y hxy; rw [hg'.right_inv] at hxy
  have hgf := h hxy; rw [hg'.right_inv] at hgf
  exact hgf

===== Proof 4443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro x
  have := hg'.right_inv (g x)
  simp_all

===== Proof 4444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  have h1 : ‚àÄ a, g' (fb a) = fa (g' a) := by
    intro a
    simp_rw [‚Üê hg'.l_apply]
    rw [‚Üê h.eq, hg'.apply_symm_apply]
  have h2 : ‚àÄ b, fb (g' b) ‚â§ g' b := fun b ‚Ü¶ by
    rw [‚Üê h1]
    exact fa.map_rel_iff.1 (h.symm_apply b)
  intro b
  have : fb (g' (fb b)) ‚â§ g' (fb b) := h2 _
  rwa [h.apply_symm_apply, h.apply_symm_apply] at this

===== Proof 4445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro x
  rw [‚Üê fb.inj (h (g' x))]
  rw [‚Üê hg'.gc (g x)]
  simp [h]

===== Proof 4446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro x y h‚ÇÅ
  apply_fun g' at h‚ÇÅ
  simp only [IsOrderRightAdjoint, hg'.1] at h‚ÇÅ
  have h‚ÇÇ := h.eq
  apply_fun fun x => fa x at h‚ÇÅ
  rw [‚Üê h‚ÇÇ, ‚Üê h‚ÇÇ]
  exact fb.map_rel_iff.mp h‚ÇÅ

===== Proof 4447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  intro y
  apply le_antisymm
  have := hg'.2 (g y)
  apply this.trans
  rw [‚Üê h.eq]
  apply hg'.1
  have := hg'.2 (g y)
  apply this.trans
  rw [h.eq]
  apply hg'.1

===== Proof 4448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder Œ±] [Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤} {g : Œ± ‚Üí Œ≤}
    (h : Function.Semiconj g fa fb) {g' : Œ≤ ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by
  refine' fun x y hxy => h.eq_of_right (hg'.right_comp g _) (h.eq_of_right _ hxy)
  simpa only [Function.comp_apply, Subtype.coe_mk] using hg'.right_adjoint (fa x) (fb y) hxy

