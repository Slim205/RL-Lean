{"name": "one_lt_val_iff", "split": "test", "formal_statement": "theorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1 := by"}
{"name": "cof_lsub_le", "split": "test", "formal_statement": "theorem cof_lsub_le {\u03b9} (f : \u03b9 \u2192 Ordinal) : cof (lsub.{u, u} f) \u2264 #\u03b9 := by"}
{"name": "inf_sdiff", "split": "test", "formal_statement": "theorem inf_sdiff : (x \u2293 y) \\ z = x \\ z \u2293 y \\ z :=\n  sdiff_unique\n    (calc\n      x \u2293 y \u2293 z \u2294 x \\ z \u2293 y \\ z = (x \u2293 y \u2293 z \u2294 x \\ z) \u2293 (x \u2293 y \u2293 z \u2294 y \\ z) := by"}
{"name": "dlookup_list_toFinmap", "split": "test", "formal_statement": "theorem dlookup_list_toFinmap (a : \u03b1) (s : List (Sigma \u03b2)) : lookup a s.toFinmap = s.dlookup a := by"}
{"name": "extend_agrees", "split": "test", "formal_statement": "theorem extend_agrees {x : FamilyOfElements P R} (t : x.Compatible) {f : Y \u27f6 X} (hf : R f) :\n    x.sieveExtend f (le_generate R Y hf) = x f hf := by"}
{"name": "mem_span_set", "split": "test", "formal_statement": "theorem mem_span_set {m : M} {s : Set M} :\n    m \u2208 Submodule.span R s \u2194\n      \u2203 c : M \u2192\u2080 R, (c.support : Set M) \u2286 s \u2227 (c.sum fun mi r => r \u2022 mi) = m := by"}
{"name": "Subset.refl", "split": "test", "formal_statement": "theorem Subset.refl {l : Lists' \u03b1 true} : l \u2286 l := by"}
{"name": "isSupFiniteCompact_iff_all_elements_compact", "split": "test", "formal_statement": "theorem isSupFiniteCompact_iff_all_elements_compact :\n    IsSupFiniteCompact \u03b1 \u2194 \u2200 k : \u03b1, IsCompactElement k := by"}
{"name": "exists_linearIndependent_pair_of_one_lt_rank", "split": "test", "formal_statement": "theorem exists_linearIndependent_pair_of_one_lt_rank [StrongRankCondition R]\n    [NoZeroSMulDivisors R M] (h : 1 < Module.rank R M) {x : M} (hx : x \u2260 0) :\n    \u2203 y, LinearIndependent R ![x, y] := by"}
{"name": "ODE_solution_unique_of_mem_Ioo", "split": "test", "formal_statement": "theorem ODE_solution_unique_of_mem_Ioo\n    (ht : t\u2080 \u2208 Ioo a b)\n    (hf : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t)\n    (hg : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t)\n    (heq : f t\u2080 = g t\u2080) :\n    EqOn f g (Ioo a b) := by"}
{"name": "floor_int_div_nat_eq_div", "split": "test", "formal_statement": "theorem floor_int_div_nat_eq_div {n : \u2124} {d : \u2115} : \u230a(\u2191n : \u211a) / (\u2191d : \u211a)\u230b = n / (\u2191d : \u2124) := by"}
{"name": "pairwise_iUnion", "split": "test", "formal_statement": "theorem pairwise_iUnion {f : \u03ba \u2192 Set \u03b1} (h : Directed (\u00b7 \u2286 \u00b7) f) :\n    (\u22c3 n, f n).Pairwise r \u2194 \u2200 n, (f n).Pairwise r := by"}
{"name": "restr_toPartialEquiv'", "split": "test", "formal_statement": "theorem restr_toPartialEquiv' (s : Set X) (hs : IsOpen s) :\n    (e.restr s).toPartialEquiv = e.toPartialEquiv.restr s := by"}
{"name": "sublists_append", "split": "test", "formal_statement": "theorem sublists_append (l\u2081 l\u2082 : List \u03b1) :\n    sublists (l\u2081 ++ l\u2082) = (sublists l\u2082) >>= (fun x => (sublists l\u2081).map (\u00b7 ++ x)) := by"}
{"name": "measurable_of_Ici", "split": "test", "formal_statement": "theorem measurable_of_Ici {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Ici x)) : Measurable f := by"}
{"name": "Gamma_one", "split": "test", "formal_statement": "theorem Gamma_one : Gamma 1 = 1 := by"}
{"name": "differentiableWithinAt_apply", "split": "test", "formal_statement": "theorem differentiableWithinAt_apply (i : \u03b9) (f : \u2200 i, F' i) (s' : Set (\u2200 i, F' i)) :\n    DifferentiableWithinAt (\ud835\udd5c:=\ud835\udd5c) (fun f : \u2200 i, F' i => f i) s' f := by"}
{"name": "toNNRat_mul", "split": "test", "formal_statement": "theorem toNNRat_mul (hp : 0 \u2264 p) : toNNRat (p * q) = toNNRat p * toNNRat q := by"}
{"name": "place_conjugate", "split": "test", "formal_statement": "theorem place_conjugate (\u03c6 : K \u2192+* \u2102) : place (conjugate \u03c6) = place \u03c6 := by"}
{"name": "disjoint_compl_right_iff", "split": "test", "formal_statement": "theorem disjoint_compl_right_iff : Disjoint x y\u1d9c \u2194 x \u2264 y := by"}
{"name": "totalDegree_X", "split": "test", "formal_statement": "theorem totalDegree_X {R} [CommSemiring R] [Nontrivial R] (s : \u03c3) :\n    (X s : MvPolynomial \u03c3 R).totalDegree = 1 := by"}
{"name": "sdiff_compl_neighborFinset_inter_eq", "split": "test", "formal_statement": "theorem sdiff_compl_neighborFinset_inter_eq {v w : V} (h : G.Adj v w) :\n    ((G.neighborFinset v)\u1d9c \u2229 (G.neighborFinset w)\u1d9c) \\ ({w} \u222a {v}) =\n      (G.neighborFinset v)\u1d9c \u2229 (G.neighborFinset w)\u1d9c := by"}
{"name": "uncurry_id_eq_ev", "split": "test", "formal_statement": "theorem uncurry_id_eq_ev (A X : C) [Exponentiable A] : uncurry (\ud835\udfd9 (A \u27f9 X)) = (exp.ev A).app X := by"}
{"name": "strictMono_dual_iff", "split": "test", "formal_statement": "theorem strictMono_dual_iff : StrictMono (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictMono f := by"}
{"name": "restrict_trim", "split": "test", "formal_statement": "theorem restrict_trim {\u03bc : OuterMeasure \u03b1} {s : Set \u03b1} (hs : MeasurableSet s) :\n    (restrict s \u03bc).trim = restrict s \u03bc.trim := by"}
{"name": "mul_inv_le_iff", "split": "test", "formal_statement": "theorem mul_inv_le_iff (h : 0 < b) : a * b\u207b\u00b9 \u2264 c \u2194 a \u2264 b * c := by"}
{"name": "Convex.taylor_approx_two_segment", "split": "test", "formal_statement": "theorem Convex.taylor_approx_two_segment {v w : E} (hv : x + v \u2208 interior s)\n    (hw : x + v + w \u2208 interior s) :\n    (fun h : \u211d => f (x + h \u2022 v + h \u2022 w)\n        - f (x + h \u2022 v) - h \u2022 f' x w - h ^ 2 \u2022 f'' v w - (h ^ 2 / 2) \u2022 f'' w w) =o[\ud835\udcdd[>] 0]\n      fun h => h ^ 2 := by"}
{"name": "cospherical_of_two_zsmul_oangle_eq_of_not_collinear", "split": "test", "formal_statement": "theorem cospherical_of_two_zsmul_oangle_eq_of_not_collinear {p\u2081 p\u2082 p\u2083 p\u2084 : P}\n    (h : (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2084 = (2 : \u2124) \u2022 \u2221 p\u2081 p\u2083 p\u2084) (hn : \u00acCollinear \u211d ({p\u2081, p\u2082, p\u2084} : Set P)) :\n    Cospherical ({p\u2081, p\u2082, p\u2083, p\u2084} : Set P) := by"}
{"name": "totalDegree_zero", "split": "test", "formal_statement": "theorem totalDegree_zero : (0 : MvPolynomial \u03c3 R).totalDegree = 0 := by"}
{"name": "top_orthogonal_eq_bot", "split": "test", "formal_statement": "theorem top_orthogonal_eq_bot : (\u22a4 : Submodule \ud835\udd5c E)\u15ee = \u22a5 := by"}
{"name": "LowerSemicontinuousWithinAt.add'", "split": "test", "formal_statement": "theorem LowerSemicontinuousWithinAt.add' {f g : \u03b1 \u2192 \u03b3} (hf : LowerSemicontinuousWithinAt f s x)\n    (hg : LowerSemicontinuousWithinAt g s x)\n    (hcont : ContinuousAt (fun p : \u03b3 \u00d7 \u03b3 => p.1 + p.2) (f x, g x)) :\n    LowerSemicontinuousWithinAt (fun z => f z + g z) s x := by"}
{"name": "vandermonde_cons", "split": "test", "formal_statement": "theorem vandermonde_cons {n : \u2115} (v0 : R) (v : Fin n \u2192 R) :\n    vandermonde (Fin.cons v0 v : Fin n.succ \u2192 R) =\n      Fin.cons (fun (j : Fin n.succ) => v0 ^ (j : \u2115)) fun i => Fin.cons 1\n      fun j => v i * vandermonde v i j := by"}
{"name": "d_squared", "split": "test", "formal_statement": "theorem d_squared (n : \u2115) : objD X (n + 1) \u226b objD X n = 0 := by"}
{"name": "filter_le", "split": "test", "formal_statement": "theorem filter_le (n m l : \u2115) : ((Ico n m).filter fun x => l \u2264 x) = Ico (max n l) m := by"}
{"name": "length_div_two_le_count_bool", "split": "test", "formal_statement": "theorem length_div_two_le_count_bool (hl : Chain' (\u00b7 \u2260 \u00b7) l) (b : Bool) :\n    length l / 2 \u2264 count b l := by"}
{"name": "imageToKernel_comp_mono", "split": "test", "formal_statement": "theorem imageToKernel_comp_mono {D : V} (h : C \u27f6 D) [Mono h] (w) :\n    imageToKernel f (g \u226b h) w =\n      imageToKernel f g ((cancel_mono h).mp (by simpa using w : (f \u226b g) \u226b h = 0 \u226b h)) \u226b\n        (Subobject.isoOfEq _ _ (kernelSubobject_comp_mono g h)).inv := by"}
{"name": "symmDiff_symmDiff_left", "split": "test", "formal_statement": "theorem symmDiff_symmDiff_left :\n    a \u2206 b \u2206 c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c) \u2294 c \\ (a \u2294 b) \u2294 a \u2293 b \u2293 c :=\n  calc\n    a \u2206 b \u2206 c = a \u2206 b \\ c \u2294 c \\ a \u2206 b := symmDiff_def _ _\n    _ = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c) \u2294 (c \\ (a \u2294 b) \u2294 c \u2293 a \u2293 b) := by"}
{"name": "get_cons_succ", "split": "test", "formal_statement": "theorem get_cons_succ (a : \u03b1) (v : Vector \u03b1 n) (i : Fin n) : get (a ::\u1d65 v) i.succ = get v i := by"}
{"name": "norm_integral_le_of_norm_le_const'", "split": "test", "formal_statement": "theorem norm_integral_le_of_norm_le_const' {f : \u2102 \u2192 E} {c : \u2102} {R C : \u211d}\n    (hf : \u2200 z \u2208 sphere c |R|, \u2016f z\u2016 \u2264 C) : \u2016\u222e z in C(c, R), f z\u2016 \u2264 2 * \u03c0 * |R| * C :=\n  calc\n    \u2016\u222e z in C(c, R), f z\u2016 \u2264 |R| * C * |2 * \u03c0 - 0| :=\n      intervalIntegral.norm_integral_le_of_norm_le_const fun \u03b8 _ =>\n        calc\n          \u2016deriv (circleMap c R) \u03b8 \u2022 f (circleMap c R \u03b8)\u2016 = |R| * \u2016f (circleMap c R \u03b8)\u2016 := by"}
{"name": "gauge_lt_one_eq_interior", "split": "test", "formal_statement": "theorem gauge_lt_one_eq_interior (hc : Convex \u211d s) (hs\u2080 : s \u2208 \ud835\udcdd 0) :\n    { x | gauge s x < 1 } = interior s := by"}
{"name": "range_eq_map", "split": "test", "formal_statement": "theorem range_eq_map (f : M \u2192[L] N) : f.range = map f \u22a4 := by"}
{"name": "projIic_coe", "split": "test", "formal_statement": "theorem projIic_coe (x : Iic b) : projIic b x = x := by"}
{"name": "reindexFinsetRange_apply", "split": "test", "formal_statement": "theorem reindexFinsetRange_apply (x : Finset.univ.image b) : b.reindexFinsetRange x = x := by"}
{"name": "angle_smul_right_of_pos", "split": "test", "formal_statement": "theorem angle_smul_right_of_pos (x y : V) {r : \u211d} (hr : 0 < r) : angle x (r \u2022 y) = angle x y := by"}
{"name": "le_perfectClosure_iff", "split": "test", "formal_statement": "theorem le_perfectClosure_iff (L : IntermediateField F E) :\n    L \u2264 perfectClosure F E \u2194 IsPurelyInseparable F L := by"}
{"name": "iInf_localization_eq_bot", "split": "test", "formal_statement": "theorem iInf_localization_eq_bot : \u2a05 v : PrimeSpectrum R,\n    Localization.subalgebra.ofField K _ (v.asIdeal.primeCompl_le_nonZeroDivisors) = \u22a5 := by"}
{"name": "norm_extendTo\ud835\udd5c'_bound", "split": "test", "formal_statement": "theorem norm_extendTo\ud835\udd5c'_bound (fr : F \u2192L[\u211d] \u211d) (x : F) :\n    \u2016(fr.toLinearMap.extendTo\ud835\udd5c' x : \ud835\udd5c)\u2016 \u2264 \u2016fr\u2016 * \u2016x\u2016 := by"}
{"name": "minFac_eq_one_iff", "split": "test", "formal_statement": "theorem minFac_eq_one_iff {n : \u2115} : minFac n = 1 \u2194 n = 1 := by"}
{"name": "sup_sdiff_inf", "split": "test", "formal_statement": "theorem sup_sdiff_inf (x y : \u03b1) : x \\ y \u2294 x \u2293 y = x := by"}
{"name": "floor_congr", "split": "test", "formal_statement": "theorem floor_congr (h : \u2200 n : \u2115, (n : \u03b1) \u2264 a \u2194 (n : \u03b2) \u2264 b) : \u230aa\u230b\u208a = \u230ab\u230b\u208a := by"}
{"name": "eq_zero_of_polynomial_mem_map_range", "split": "test", "formal_statement": "theorem eq_zero_of_polynomial_mem_map_range (I : Ideal R[X]) (x : ((Quotient.mk I).comp C).range)\n    (hx : C x \u2208 I.map (Polynomial.mapRingHom ((Quotient.mk I).comp C).rangeRestrict)) : x = 0 := by"}
{"name": "normalizeAux_congr", "split": "test", "formal_statement": "theorem normalizeAux_congr {a b c : B} (p : Path a b) {f g : Hom b c} (\u03b7 : f \u27f6 g) :\n    normalizeAux p f = normalizeAux p g := by"}
{"name": "right_distrib", "split": "test", "formal_statement": "theorem right_distrib (x y z : X q) : (x + y) * z = x * z + y * z := by"}
{"name": "mem_ideal_span_X_image", "split": "test", "formal_statement": "theorem mem_ideal_span_X_image {x : MvPolynomial \u03c3 R} {s : Set \u03c3} :\n    x \u2208 Ideal.span (MvPolynomial.X '' s : Set (MvPolynomial \u03c3 R)) \u2194\n      \u2200 m \u2208 x.support, \u2203 i \u2208 s, (m : \u03c3 \u2192\u2080 \u2115) i \u2260 0 := by"}
{"name": "set_lintegral_deterministic'", "split": "test", "formal_statement": "theorem set_lintegral_deterministic' {f : \u03b2 \u2192 \u211d\u22650\u221e} {g : \u03b1 \u2192 \u03b2} {a : \u03b1} (hg : Measurable g)\n    (hf : Measurable f) {s : Set \u03b2} (hs : MeasurableSet s) [Decidable (g a \u2208 s)] :\n    \u222b\u207b x in s, f x \u2202kernel.deterministic g hg a = if g a \u2208 s then f (g a) else 0 := by"}
{"name": "div_right_injective", "split": "test", "formal_statement": "theorem div_right_injective : Function.Injective fun a \u21a6 b / a := by"}
{"name": "isNoetherian_iff_wellFounded", "split": "test", "formal_statement": "theorem isNoetherian_iff_wellFounded :\n    IsNoetherian R M \u2194 WellFounded ((\u00b7 > \u00b7) : Submodule R M \u2192 Submodule R M \u2192 Prop) := by"}
{"name": "zero_lt_card", "split": "test", "formal_statement": "theorem zero_lt_card {o} : 0 < card o \u2194 0 < o := by"}
{"name": "unitInv_app_inverse", "split": "test", "formal_statement": "theorem unitInv_app_inverse (e : C \u224c D) (Y : D) :\n    e.unitInv.app (e.inverse.obj Y) = e.inverse.map (e.counit.app Y) := by"}
{"name": "tsum_eq_add_tsum_ite", "split": "test", "formal_statement": "theorem tsum_eq_add_tsum_ite {f : \u03b1 \u2192 \u211d\u22650} (hf : Summable f) (i : \u03b1) :\n    \u2211' x, f x = f i + \u2211' x, ite (x = i) 0 (f x) := by"}
{"name": "not_differentiableAt_of_local_left_inverse_hasDerivAt_zero", "split": "test", "formal_statement": "theorem not_differentiableAt_of_local_left_inverse_hasDerivAt_zero {f g : \ud835\udd5c \u2192 \ud835\udd5c} {a : \ud835\udd5c}\n    (hf : HasDerivAt f 0 (g a)) (hfg : f \u2218 g =\u1da0[\ud835\udcdd a] id) : \u00acDifferentiableAt \ud835\udd5c g a := by"}
{"name": "single_of_embDomain_single", "split": "test", "formal_statement": "theorem single_of_embDomain_single (l : \u03b1 \u2192\u2080 M) (f : \u03b1 \u21aa \u03b2) (a : \u03b2) (b : M) (hb : b \u2260 0)\n    (h : l.embDomain f = single a b) : \u2203 x, l = single x b \u2227 f x = a := by"}
{"name": "Finset.prod", "split": "test", "formal_statement": "theorem Finset.prod {\u03b2 : Type*} {p : \u03b1} (hp : Prime p) (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    multiplicity p (\u220f x \u2208 s, f x) = \u2211 x \u2208 s, multiplicity p (f x) := by"}
{"name": "bitwise_swap", "split": "test", "formal_statement": "theorem bitwise_swap {f : Bool \u2192 Bool \u2192 Bool} :\n    bitwise (Function.swap f) = Function.swap (bitwise f) := by"}
{"name": "map_range", "split": "test", "formal_statement": "theorem map_range : f.range.map g = (g.comp f).range := by"}
{"name": "castHom_injective", "split": "test", "formal_statement": "theorem castHom_injective : Function.Injective (ZMod.castHom (dvd_refl n) R) := by"}
{"name": "lookupFinsupp_apply", "split": "test", "formal_statement": "theorem lookupFinsupp_apply [DecidableEq \u03b1] (l : AList fun _x : \u03b1 => M) (a : \u03b1) :\n    l.lookupFinsupp a = (l.lookup a).getD 0 := by"}
{"name": "le_symmDiff_iff_left", "split": "test", "formal_statement": "theorem le_symmDiff_iff_left : a \u2264 a \u2206 b \u2194 Disjoint a b := by"}
{"name": "ContinuousLinearMap.iteratedFDeriv_comp_right", "split": "test", "formal_statement": "theorem ContinuousLinearMap.iteratedFDeriv_comp_right (g : G \u2192L[\ud835\udd5c] E) {f : E \u2192 F}\n    (hf : ContDiff \ud835\udd5c n f) (x : G) {i : \u2115} (hi : (i : \u2115\u221e) \u2264 n) :\n    iteratedFDeriv \ud835\udd5c i (f \u2218 g) x =\n      (iteratedFDeriv \ud835\udd5c i f (g x)).compContinuousLinearMap fun _ => g := by"}
{"name": "isCaratheodory_empty", "split": "test", "formal_statement": "theorem isCaratheodory_empty : IsCaratheodory m \u2205 := by"}
{"name": "pseudoEqual_trans", "split": "test", "formal_statement": "theorem pseudoEqual_trans {P : C} : Transitive (PseudoEqual P) := by"}
{"name": "pow_padicValNat_dvd", "split": "test", "formal_statement": "theorem pow_padicValNat_dvd {n : \u2115} : p ^ padicValNat p n \u2223 n := by"}
{"name": "LaxMonoidalFunctor.right_unitality_inv", "split": "test", "formal_statement": "theorem LaxMonoidalFunctor.right_unitality_inv (F : LaxMonoidalFunctor C D) (X : C) :\n    (\u03c1_ (F.obj X)).inv \u226b F.obj X \u25c1 F.\u03b5 \u226b F.\u03bc X (\ud835\udfd9_ C) = F.map (\u03c1_ X).inv := by"}
{"name": "_root_.exists_subtype_mk_eq_iff", "split": "test", "formal_statement": "theorem _root_.exists_subtype_mk_eq_iff {a : Subtype p} {b : \u03b1} :\n    (\u2203 h : p b, Subtype.mk b h = a) \u2194 b = a := by"}
{"name": "log_two_near_10", "split": "test", "formal_statement": "theorem log_two_near_10 : |log 2 - 287209 / 414355| \u2264 1 / 10 ^ 10 := by"}
{"name": "map_comap_eq_self", "split": "test", "formal_statement": "theorem map_comap_eq_self {f : G \u2192* N} {H : Subgroup N} (h : H \u2264 f.range) :\n    map f (comap f H) = H := by"}
{"name": "of_eq", "split": "test", "formal_statement": "theorem of_eq (_ : (a : R) = c) (_ : b = c) : a = b := by"}
{"name": "stirlingSeq_one", "split": "test", "formal_statement": "theorem stirlingSeq_one : stirlingSeq 1 = exp 1 / \u221a2 := by"}
{"name": "ClassGroup.mk_eq_mk", "split": "test", "formal_statement": "theorem ClassGroup.mk_eq_mk {I J : (FractionalIdeal R\u2070 <| FractionRing R)\u02e3} :\n    ClassGroup.mk I = ClassGroup.mk J \u2194\n      \u2203 x : (FractionRing R)\u02e3, I * toPrincipalIdeal R (FractionRing R) x = J := by"}
{"name": "contDiffOn_top_iff_derivWithin", "split": "test", "formal_statement": "theorem contDiffOn_top_iff_derivWithin (hs : UniqueDiffOn \ud835\udd5c s\u2082) :\n    ContDiffOn \ud835\udd5c \u221e f\u2082 s\u2082 \u2194 DifferentiableOn \ud835\udd5c f\u2082 s\u2082 \u2227 ContDiffOn \ud835\udd5c \u221e (derivWithin f\u2082 s\u2082) s\u2082 := by"}
{"name": "FinitaryExtensive.isVanKampen_finiteCoproducts", "split": "test", "formal_statement": "theorem FinitaryExtensive.isVanKampen_finiteCoproducts [FinitaryExtensive C] {\u03b9 : Type*}\n    [Finite \u03b9] {F : Discrete \u03b9 \u2964 C} {c : Cocone F} (hc : IsColimit c) : IsVanKampenColimit c := by"}
{"name": "tan_eq_zero_iff'", "split": "test", "formal_statement": "theorem tan_eq_zero_iff' {\u03b8 : \u2102} (h\u03b8 : cos \u03b8 \u2260 0) : tan \u03b8 = 0 \u2194 \u2203 k : \u2124, k * \u03c0 = \u03b8 := by"}
{"name": "IsCoprime.prod_left_iff", "split": "test", "formal_statement": "theorem IsCoprime.prod_left_iff : IsCoprime (\u220f i \u2208 t, s i) x \u2194 \u2200 i \u2208 t, IsCoprime (s i) x := by"}
{"name": "wittPolynomial_zmod_self", "split": "test", "formal_statement": "theorem wittPolynomial_zmod_self (n : \u2115) :\n    W_ (ZMod (p ^ (n + 1))) (n + 1) = expand p (W_ (ZMod (p ^ (n + 1))) n) := by"}
{"name": "divisor_le", "split": "test", "formal_statement": "theorem divisor_le {m : \u2115} : n \u2208 divisors m \u2192 n \u2264 m := by"}
{"name": "isoPullback_hom_snd", "split": "test", "formal_statement": "theorem isoPullback_hom_snd (h : IsPullback fst snd f g) [HasPullback f g] :\n    h.isoPullback.hom \u226b pullback.snd = snd := by"}
{"name": "existsUnique_zsmul_near_of_pos'", "split": "test", "formal_statement": "theorem existsUnique_zsmul_near_of_pos' {a : \u03b1} (ha : 0 < a) (g : \u03b1) :\n    \u2203! k : \u2124, 0 \u2264 g - k \u2022 a \u2227 g - k \u2022 a < a := by"}
{"name": "isUnit_mk", "split": "test", "formal_statement": "theorem isUnit_mk {a : \u03b1} : IsUnit (Associates.mk a) \u2194 IsUnit a :=\n  calc\n    IsUnit (Associates.mk a) \u2194 a ~\u1d64 1 := by"}
{"name": "and_eq_true_eq_eq_true_and_eq_true", "split": "test", "formal_statement": "theorem and_eq_true_eq_eq_true_and_eq_true (a b : Bool) :\n    ((a && b) = true) = (a = true \u2227 b = true) := by"}
{"name": "Matrix.lieConj_apply", "split": "test", "formal_statement": "theorem Matrix.lieConj_apply (P A : Matrix n n R) (h : Invertible P) :\n    P.lieConj h A = P * A * P\u207b\u00b9 := by"}
{"name": "finSuccEquiv_X_succ", "split": "test", "formal_statement": "theorem finSuccEquiv_X_succ {j : Fin n} : finSuccEquiv R n (X j.succ) = Polynomial.C (X j) := by"}
{"name": "adjMatrix_dotProduct", "split": "test", "formal_statement": "theorem adjMatrix_dotProduct [NonAssocSemiring \u03b1] (v : V) (vec : V \u2192 \u03b1) :\n    dotProduct (G.adjMatrix \u03b1 v) vec = \u2211 u \u2208 G.neighborFinset v, vec u := by"}
{"name": "logb_nonpos_iff_of_base_lt_one", "split": "test", "formal_statement": "theorem logb_nonpos_iff_of_base_lt_one (hx : 0 < x) : logb b x \u2264 0 \u2194 1 \u2264 x := by"}
{"name": "finrank_eq_nat_card_basis", "split": "test", "formal_statement": "theorem finrank_eq_nat_card_basis (h : Basis \u03b9 R M) :\n    finrank R M = Nat.card \u03b9 := by"}
{"name": "image_sphere", "split": "test", "formal_statement": "theorem image_sphere (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b1) (r : \u211d) :\n    h '' Metric.sphere x r = Metric.sphere (h x) r := by"}
{"name": "ConvexOn.translate_left", "split": "test", "formal_statement": "theorem ConvexOn.translate_left (hf : ConvexOn \ud835\udd5c s f) (c : E) :\n    ConvexOn \ud835\udd5c ((fun z => c + z) \u207b\u00b9' s) (f \u2218 fun z => z + c) := by"}
{"name": "ord_injective", "split": "test", "formal_statement": "theorem ord_injective : Injective ord := by"}
{"name": "birthday_half", "split": "test", "formal_statement": "theorem birthday_half : birthday (powHalf 1) = 2 := by"}
{"name": "finAddFlip_apply_natAdd", "split": "test", "formal_statement": "theorem finAddFlip_apply_natAdd (k : Fin n) (m : \u2115) :\n    finAddFlip (Fin.natAdd m k) = Fin.castAdd m k := by"}
{"name": "pairwise_on_bool", "split": "test", "formal_statement": "theorem pairwise_on_bool (hr : Symmetric r) {a b : \u03b1} :\n    Pairwise (r on fun c => cond c a b) \u2194 r a b := by"}
