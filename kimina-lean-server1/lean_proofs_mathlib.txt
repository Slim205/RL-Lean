===== Proof 1 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 

===== Proof 2 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 3 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 4 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 5 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 

===== Proof 6 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 
  simp [hf] 

===== Proof 7 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 8 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 9 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 

===== Proof 10 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 
  apply congrArg (map f) 
  apply cauchy maps.induction 

===== Proof 11 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 

===== Proof 12 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 13 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 14 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 15 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 16 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 

===== Proof 17 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 18 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 19 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 20 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 21 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 22 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 23 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 

===== Proof 24 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 25 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 26 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 

===== Proof 27 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 28 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 29 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 30 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by 

===== Proof 31 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 32 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem UniformInducing.cauchy_map_iff {f : α → β} (hf : UniformInducing f) {F : Filter α} :
    Cauchy (map f F) ↔ Cauchy F := by

===== Proof 33 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 
   field_simp

===== Proof 34 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 35 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 36 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by

===== Proof 37 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 
  have h1 : a / b = (a : ℝ) / (b : ℝ) := by 
    field_simp
  have h2 : (c : ℝ) / (b : ℝ) * a = a * (c : ℝ) / (b : ℝ) := by 
    field_simp
  rw [h1, ← mul_comm]
  rw [h2, mul_comm]
  field_simp

===== Proof 38 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 39 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 40 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 
  field_simp [add_eq_zero_iff_eq_neg, mul_eq_zero]


===== Proof 41 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 42 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 43 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 
 infiniteav b c : c / b * a = a / b * c := by field_simp

===== Proof 44 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 45 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by

===== Proof 46 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 47 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 48 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 49 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 50 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by

===== Proof 51 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by

===== Proof 52 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 53 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 54 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 55 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by
  have h1 : a / b * c = (a * c) / b := by 
    field_simp [Nat.div_mul_cancel]
  have h2 : c / b * a = (c * a) / b := by 
    field_simp [Nat.div_mul_cancel]
  rw [h1, h2]
  ring

===== Proof 56 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by

===== Proof 57 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by

===== Proof 58 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by

===== Proof 59 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 60 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 61 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by

===== Proof 62 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 
    simp [div, mul_comm]

===== Proof 63 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by

===== Proof 64 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem div_mul_comm : a / b * c = c / b * a := by 

===== Proof 65 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 66 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 67 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 
    have h1 : padicValNat p (n !) = (n / p).Digits 10 ∑x∈(n / p).digits(ySeptember 11).sum? ? 
    -- India 
  have h2 : padicValNat p (n !) = (n / p).sum? ? n.natAbs.em? ? p := by 
    -- prime case 
    rw [padicValNat.factorial_eq_sum_iProduct_vics] 
    -- same Lever to Lean case
    have := hp.prime 
    have := hp.le 
    have := hp.ne_zero 
    rw [padicValNat.dvd_iff] 
    exact h7
    norm_num
    exact (ppos).ne'
    norm_num
  rw [h1, h2]

===== Proof 68 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 69 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 70 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 71 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 72 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 73 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 74 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 75 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 76 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 77 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 78 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 79 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 80 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 81 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 82 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 83 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 84 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 85 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 86 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 87 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 88 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 89 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 90 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 91 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by 

===== Proof 92 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 93 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 94 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 95 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 96 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ):
    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by

===== Proof 97 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by simp [IsCyclotomic renaming] 

===== Proof 98 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ⟨r, hr⟩ := hζ_ARM xscaleargent rt管理制度 Trick
  refine ⟨r * 2, ?_, ?_⟩
  · apply mul_lt_of_lt_of_pos _ _
    · norm_num
    · apply mul_lt_of_lt_of_nonneg _ _
     · norm_num
     · exact hr.1
  · rw [add_comm] at hr
    obtain ⟨r, hr⟩ := hr
    refine ⟨r, ?_, ?_⟩
    · exact hr.1
    · refine le_of_lt ?_
      by_contra h
      have : -1 ≤ -1 ^ r := by refine neg_one_le_pow r; linarith
      rify at this
      rw [← hr.2] at this
      norm_num at this

===== Proof 99 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ⟨r, hr⟩ := h再造Root.exists_neg_pow_of_isOfFinOrder.isCyclotomic (by assumption) hno hx
  refine ⟨r / n, Nat.div_lt_of_lt_mul h⟩
  rw [isPrimitiveRoot.esymm_iff_cyclotomic.gt h hdr] at h
  apply h

===== Proof 100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat 
 

theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomic Extension {n} ℚ K]
  (hNo : Odd (n : ℕ)) {ζ x : K}
  (hCF : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
  ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) := by
  obtain ⟨r, hr⟩ := hCF.exists_neg_pow_of_isOfFinOrder hNo hx
  refine ⟨r, by omega, ?_⟩
  rw [neg_pow 2, hr (-1)]
 isetOf_mem_of_eq hCF (1:ℤ) |>.First 

===== Proof 101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by 
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r, Nat.mod_lt _ ?_,
    (fun _ => (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ Eq.trans _ ?_).mpr (pow_mod_order_of h no)⟩
  rw [Nat.mod_natCast] at hr ⊢
  rw [← hr, pow_mod_orderOf.pow_eq_one]
  exact hno.of_ne_two (by intro cתפר; rw [zero_eq_neg_dvd] at c =;(rw [← pow_eq_one_iff_modEq]; apply pow_eq_one_iff Iterate.1 (zero_lt_of_ne_two _) ; interesting =_unfold; rfl; norm_cast; rw [zero_eq_neg_dvd] ; apply Dvd.intro_left]; nlinarith)

===== Proof 102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  have aux : (-1 : ℚ ) ^ n = 1 := by
         have := Complex.volume_eq_one_iff_nat_rootsOfX_pow_eq_one.1 _ n.1.1 rfl
         sin_eq_zero_of_mem.mp h infective'.1
         simp
         simp [hob]
         have := hob.natCast_def.1
         have hn1 : (n : ℚ).natCast = n := by simp
         rw [hn1] at hy
         exact bcongr (0 : ℚ) hy
  have : (1 : ℚ) = -1 * -1:= by
    norm_num
  rw [this, pow_mul, aux]
  nth_rw 2 [← mul_one (-1)]
  rw [mul_assoc, mul_assoc]
  have := Complex.volume_eq_four_iff_nat_rootsOfX_eq subrange_singleton sqrtX_add_neg_sqrtX.1 _ (by linarith)
  have qnNat :=  Nat.ofNat_ge_0 n
  have := @Complex.zero_mul (K) (1 : K)
  nth_rw 2 [← Complex.zero_pow (n : ℕ)] at this
  have (k : ℚ) : (↑k :ℂ ) * 0 = 0 := by
    simp
  simp Solver [this, knatNat]

===== Proof 103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by 
  rw [←sq_eq_one_iff_eq_one_or_neg_one]
  exact sq_eq_one_iff_eq_one_or_neg_one.mp (by norm_num)

===== Proof 104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  replace hζ := hζ.two_mul
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  rw [show ζ ^ 2 * (ζ ^ r) = -ζ ^ r by simp [hζ.two_mul, pow_add, mul_pow, pow_not_zero]] at hζ
  exact ⟨r.natAbs, by simp [Nat.abs_lt_iff] |>.mpr, ?_⟩
  rw [show ζ ^ r = (-1)^r * (_pdiffrne.natAbs _).rpow (r % c) by apply pdiff automation; rw [pow_add]; nth_rw 2 [mul_comm]; rw [← h.nonconstant]; exact h τ.symm] at hτ
  nth_rw 2 [show (1 : K) = (-1) ^ r * (еньabs _).rpow (-r % c) by apply pdiff automation; rw [pow_add]; rw [← mul_comm _ 1]; nth_rw 2 [mul_comm]; rw [← mul_pow, mul_neg, one_mul, Nat.mod_add_one, ← Nat.mod_mod, show (0 : ℝ) = (0 : ℤ) by simp]
  rw [add_comm]
  nth_rw 2 [hε.symm]
  exact (add_eq_zero_iff_eq_neg ⟨r ^ 2 * (constTime'); ∧ pow_pos _ (constTime')⟩.mp ((hτ ▸ hε).symm ▸ Nat.zero_le _ ).mpr

===== Proof 105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx

===== Proof 106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  exact exists_pow_or_neg_mul_pow_of_isOfFinOrder

===== Proof 107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat
/-
  a. ACertainly帕 欲 证 retrisatt, prove he needs to be at least 16 years old.
  b. To identify which solid shapes theoutside world theARD^\ associative framework, imagine a cube that doubles in size every hour. The cube starts with desired solid shapes the plane, reachable from all continuous simultaneously in all possible cardinal directions of a 3D star polygon yields by Direction vectors in non-abundant phrasing, (last.
-/
theorem leads_to_deduce_6867 {v : ℕ} {w : ℕ} {z : ZMod 6867} (hdv : v ≠ 0)
    (h': v^2=(v/2)^2) (hw : (w-1/2)*w*(w+1/2)*(v/2)^2=(v/2)^2*3933) :
v * w * (w^2 - (1 / 4)=(17)^3 * 11^3) := by
  norm_num at hw
  apply exists_pow_or_neg_mul_pow_pow' at h' <;> assumption
  have hnnz : (n := 6867 : ℕ) ≠ 0 := by norm_num
  have : (n := 6867 : ZMod 6867) ≠ 0 := ZMod.ne_zero.mpr hnnz
  have hrhg := h'₊.val
  rw [show (v^2=(v/2)^2).val = v^2=(v/2)^2 from (subst_mod_cast -/
  rw [norm_cast, ← norm_cast_pow] at hgg
  rw [ha.val, oha.val,.exists_pow_pow] at hz
  have dvd : ↑(19 * 17) ^ 3 * ↑11 ^ 3 ∣ ↑(v * w * (w^2 - (1 / 4))) := by
    rw [‖a * b ↔ a ∣ b ∧ b ∣ a‖, ha, hb] at hgg
    norm_num
    norm_cast at hgg
    exact ⟨_of_mul_dvd_mul hgg.1, of_mul_dvd_mul hgg.2⟩
  have hal |بط__le : (v * w * (w^2 - (1 / 4))) = ↑(19 * 17) ^ 3 * ↑11 ^ 3 := by
    apply (Nat.dvd_prime_pow (show Nat.Prime 6867 by norm_num)).mp
    have h7 : 1 = 6867 * ↑(1 / 6867) := by simp
    rw [h7, hvd]
    apply dvd
    use v
    apply (Int.mul_eq_iff_eq_div_of_dvd _).mpr
    exact Nat.cast_pow_dvd_nat_pow_of_dvd _ dvd
    use w
    apply (Int.mul_eq_iff_eq_div_of_dvd _).mpr
    exact Nat.cast_pow_dvd_nat_pow_of_dvd _ dvd
    rw [Nat.cast_pow_dvd_nat_pow_of_dvd _ dvd]
    norm_cast
    exact Int.cast_inj.mpr (Int.ofNat_pairs.2 (Nat.card_pair_eq (дvd.2 hb)))
  rw [← hal] at hrhg
  symm at hrhg
  have : 0 < Pres péri_lemma.2 ⊛ _ := by simp [Set.mul_singleton]
  applymany_le
  . rw [← hal]
    nth_rw 1 [(show v ≠ 0 from hdv.ne')]
    norm_cast
    rw [← dvd.2]
    exact Nat.cast_pow_dvd_nat_pow_of_dvd _ dvd
    rw [Nat.cast_pow_dvd_nat_pow_of_dvd _ dvd]
    norm_cast
    exact Int.cast_inj.mpr (Int.ofNat_pairs.2 (Nat.card_pair_eq (dvd.2 hb)))
  push_neg at hal|x|actics
  rw [← hal] at duality
  nth_rw 2 [(show v ≠ 0 from hdv.ne')]
  norm_cast at duality
  rw [← dvd.2]
  exact Nat.cast_pow_dvd_nat_pow_of_dvd _ dvd
  rw [Nat.cast_pow_dvd_nat_pow_of_dvd _ dvd]
  norm_cast
  exact Int.cast_inj.mpr (Int.ofNat_pairs.2 (Nat.card_pair_eq (dvd.2 hb)))
  intro dvd2
  norm_cast at dvd2
  rw [← dvd2] at hb
 
===== Proof 108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  have no3 : IsCyclotomic extension ℚ ℚ_rewrite3 (IsrootsOf startup_map ℚ ) := by setAs extensionFin 1 1
  have no5 : IsCyclotomic extension ℚ ℚ_rewrite3 (IsrootsOf startup_map ℚ5) := by setAs extensionFin 2 2
  have no7 : IsCyclotomic extension ℚ ℚ_rewrite3 (IsrootsOf_unitRing_sr_congr[sub_Cyclotomicstructure ] naturally)
  have no11 : IsCyclotomic extension ℚ ℚ_rewrite3 (IsrootsOf_unitRing кเจ้าหน้าที่ apparently_ite 11) := by setAs extensionFin 10 10
  have nopen3 : openPow n 3 := by
    simp only [isopenPow]
    simp
  have nopen5 : openPow n 5 := by
    simp only [isopen power_set_iff_le]
    simp
  have nopen7 : openPow n 7 := by
    simp only [isopenPow]
    simp
  have nopen11 : openPow n 11 := by
    simp only [isopenPow]
    simp
  have hh1: IsCyclotomic extension ℚ Q := by
    exact Aesop.eq_mod_cast_mul_n id

===== Proof 109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  constructor
  · apply Nat.zero_lt_of_ne_zero; by_contra h; rw [h] at hx; simp at hx
  · apply Nat.zero_lt_of_ne_zero; by_contra h; rw [h] at hx; simp at hx

===== Proof 110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  have h0 : Even 0 := by exact Nat.even_zero
  exact Nat.le_of_lt_succ (h0.trans ?_)

===== Proof 111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by cases r % n with
| inl h1 =>

===== Proof 112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, hw, ?_⟩
  rw [<-@Nat.reduceMod n (show n ≥ 0 by omega)]
  rw [<-Nat.mod_lt] at hr
  show x = (1 : ℤ) ^ r * ζ ^ r
  ring_nf
  rw [<-one_pow]
  rw [show r * r = r ^ 2 by ring]
  rw [pow_two]

===== Proof 113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  have h₁ : Nat_abel_group.maps_to (-1 : ℤ) (ZMod n) := by simp [ZMod]
  have h₂ : (∃ x, x.natAbs = 1) := by use 1; norm_num
  have h₃ : (IsCyclotomic extensional rec الشر h₁ h₂) := by exact cyclotomic_eq_iff.mpr ⟨hζ, h_no_odd, hζ.dis_root
 ⟩
  have h₄ : ¬IsRoot ( pygame (p - 1) : ℤ[X]) (AtWeil lawyer _) := by
    intro h
    have p_low : p笑笑 p := by exact prime_Property_prime p
    have p_uvd_p := p Aliadt.2
    have cdeuxIMEPretty viaE bond
    norm_num [IsRoot] at h
    have conj2wone : (1 : ℤ[X]) = IsRoot (:+R ((1:ℤ[X]) • (1:ℤ[X])) (AtWeil lawyer _) • -1.ne_one) := by native_decide
    have cdeuxIME评估 viaE = ← conj2wone hp.hz
    have viaEcut := viaE (show IsRoot (atham (p - 1 : ℤ[X])) (AtWeilBIN law _) by
      rw [ ![.int.cast] ] at hp h ⊢
      have :=
      rw [ ![Nat.cast'.eq] hp] at hp
      rw [ hp ] at h
      rw [ h, sub_zero, Nat.cast_one]
      norm_cast
      exact hp
    have viaEFundamentalTheorem := fundamentalTheoremOf Locality (ZMod.natAbs p) (IsCyclotomicомorphism.IsCyclotomic (AtWeilditional law _) |>.ext _) (IsRoot _) viaEcut
    rw [ Nat.cast_one ] at viaEFundamentalTheorem
    have concBA := viaEcut.injective
    apply concBA at viaEél VAT
    exact viaEResult
    rw [Criterion, Nat.cast_one, hz,itone]
    rw [ Nat.cast_one ]
    rw [ Nat.cast_one ]
    rw [ Nat.cast_one ]
    rw [ Nat.cast_one ]
    rw [ Nat.cast_one ]
    norm_num [Nat.cast_one]

===== Proof 114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by 
  obtain ⟨r, hr⟩ := isPrimitiveRoot.exists_neg_pow_of_isOfFinOrder hno hx
  refine' ⟨r.natAbs, Nat следует_of_le n.2, ?_⟩
  rw [show (-1) ^ (r.natAbs) = (-1) ^ r from Nat.mul_self_natAbs, (-_one_pow_rn)'] at *
  exact mod_add_mod _ n.2

===== Proof 115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by absurd hno.odd; use 2; simp; exact hneg

===== Proof 116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ⟨r, hr⟩ := hζész endspecified (IsCyclotomic Extension 2 ℚ K) hno (IsIfinOrder x) (by norm_num)
  have irr := Polynomial.Prime.val_forall_memRootOf Ratule_iff.CoprimeInt.isCyclotomicmem  
  have hirr0 : (irr : ℤ[X]).irreducible := by
    rw [isPrimitiveRoot.intoto_base, isPrimitiveRoot网游_nil, IsOfFinOrder.val_def]
    exact_irr ⟨1, by norm_num⟩ ⟨x, hgoal⟩
  have divide := ultrafilter.linearmono.def.emph.intro
  have h : (x ^ ↑n - 1 : ℚ[X]) ∣ (x ^ ↑n - 1 : ℚ[X]) := by
    exact pow_dvd_pow _ _

===== Proof 118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by norm_num;rw [← one_pow] <;> simp

===== Proof 119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r, Nat.le_of_eq ?_⟩
  have : r < r % n + n := Nat.mod_lt r n
  linarith
  rcases eq_or_ne r 0 with (h | h)
  · rw [h] at hr
    simp [pow_zero, neg_one_mul, one_mul] at hr
    rw [sum_range_succ'] at hx
    norm_cast at hx
    contrapose hx
    refine ⟨(1 : ℕ), ?_⟩
    exact Ne.symm (OfNat.zero_ne_ofNat n)
  rw [h] at hr
  refine ⟨r - 1, ?_⟩
  rw [show r - 1 = r - 1 + 1 - 1 by rfl] at *
  rw [show ((r - 1) - 1 + 1) = r - 1 + 1 - 1 + 1 by ring] at *
  rw [show r - 1 + 1 - 1 + 1 = r by ac_rfl, one_pow] at hr
  constructor
  · exact hr
  · show -1 ^ (r - 1) = -1 ^ (r - 1 + 1)
    rw [show r - 1 + 1 = (r - 1) + 1 by ac_rfl]
    exact pow_succ (-1) (r - 1)

===== Proof 120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
=''

===== Proof 121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by 
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r / 2, by omega, ?_⟩ 
  rw [← (Nat.zero_le r), Nat.zero_mod_two, h.eval_eq_half, pow_two, ← one_mul (-1), neg_pow]
  simp [isUnit_div_one, hx.ne']

===== Proof 122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hJSGlobal⟩.symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]

===== Proof 123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by cases h with
| inl h =>
    left
    symm
    rw [Nat.odd_iff_mod_succ] at h
    rw [Nat.mod_mod_self, h]

===== Proof 124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  constructor
  · exact Nat.mod_mod_eq h
  · by_contra _
    have h_odd : Odd (r / 2) := by
      apply Odd.of_ne_two * even_two
      exact Nat.ne_of_lt (by omega)
    have h2k : ∃ k, r = 2 * k := by
      use r / 2
      omega

===== Proof 125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  by_cases h : Odd x
  · calc _ = _ := (-x)⁻¹ := by rw [neg_inv_eq_inv_neg]
         _ = (-x⁻¹)⁻¹ := by rw [inv_eq_inv_inv (le_of_lt h.nctau)]
         _ = x⁻¹ := by rw [inv_eq_inv_inv (le_of_lt ((inv_ne_zero'.2 h participate.not_even_iff_odd'.2 h熠zeroes Percy vagy ↔ Lean 4))
 
h No! The supplied expression was not a challenge in Lean 3 formal verification. 

So what is the correct challenge in Lean 4? 

Let me analyze the provided formal Lean 4 code:


===== Proof 126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  intro σ sigma_exists x hx ξ hx' hσ : σ σ' = σ' σ
  have : σ sigma' ^ even_iff (m := 1) := by
    rw [Nat.even_iff]
    unfold even
    have h1: σσ'^1 = σσ'^1 := by rfl
    rw[h1]
    simp [Nat.pow_one]
  simp at this
  obtain ⟨m, hm⟩ := this
  obtain ⟨m, hm⟩ := this
  unfold even at hm
  obtain ⟨k, hk⟩ := hm
  have hk1 : 2 * k ≤ m := by linarith [hk]
  have hk2 : m < 2 * k := by linarith [hk]
  have hsub' : σ sigma' ^ (m + 1) = sigma sigma' ^ m *  σ sigma' := by
    rw [Nat.pow_add]
  have hsub : sigma sigma' ^ m = 1 := by
    nlinarith
  rw [hsub] at hsub'
  have h1 : sigma sigma' ^ (m + 1) = sigma sigma' := by
    rw [hsub'] 
    aesop
  have h2 : σ sigma' = 1 := by
    nth_rw 2 [← one_div (σ sigma')] at h1 ⊢
    field_simp at h1 ⊢ 
    nlinarith
  have hne : σ ≠ sigma' := by
    by_contra contra
    rw [contra] at hσ
    specialize hσ 1 0
    norm_num at hσ
  have h_eq_ neg_pow' (n k) (h : σ σ') ^ k = 1 : σ 1 = σ (-1) := by
    have h1: σ σ' ^ k * σ σ' ^ k = 1 := by
      rw [← hsigma]
    rw [haze:=pow_mul] at h1
    rw [zero_add] at h1
    nth_rw 2 [mul_comm] at h1
    rw [pow_mul, mul_one] at h1
    have h2 := congr_arg (χ=>σ) h1
    simp at h2 
    obtain h2_amod := Fintype.val_toFintype.eq_iff_on revital h2
    unfold IsFintype at h2_amod
    obtain h2_isOfFinOrder := h2_amod sigma_exists hx sigma_eq_one
    contradiction
  have sigma'ne_one : σ' ≠ 1 := by
    by_contra contra
    suffices sigma₁ = 1 by rw [← sigma₁] at contra ; contradiction
    simp
  have h_eq := Fintype.val_toFintype.eq_iff뿌 Schwarz_sqrt_eq_sq s σ sigma' σ'ne_one
  simp at h_eq
  have : ∃-(xBetter)
    let x = (1 + σ σ') / 2
    let y = 1
    let z = σ σ'
    have : x ^ 2 = y * z := by
      rw [show x^2 = σ σ' ^ 2 by rw [add_pow 2 σ sigma', Nat.pow_two] ; simp [mul_assoc]
      rw [← one_div (σ sigma') , mul_neg, neg_mul, mul_one _, Nat.reduceAdd]
      have : σσ' ^ 1 = σσ' := by rfl
      rw [this]
      rw [mul_comm 2 σ sigma', mul_assoc 2 σ 2, ← mul_comm y z] ; rfl
    have hzero : (x + 1) * (x - 1) = x ^ 2 - 1 := by ring
    have hxyz' : x ^ 2 - 1 = 0 := by
      rw [this,hzero] ; rw [mul_zero]
    have hx : x > 0 := by
      simp
      rw [show (1 : ℝ) + σ σ' = 1 + 2 * σ sigma', mul_two] at *
      rw [← one_mul (1 + σ sigma')]
      obtain hha := Fintype.val_toFintype.eq_iff Gotиш
      simp at hha
      obtain hha'' := hha x
      have : x = √(1 + σ sigma') := by
        have : √(x ^ 2) = x := by
          have : x > 0 := by simp ; rw [← one_mul (1 + σ sigma'), mul_two] at *
          exact sqrt_eq_of_sq_eq this
        rw [this]
        congr 2
        rfl
      simp at this 
      rw [this, real_sqrt
===== Proof 127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by refine exists_pow_or_neg_mul_pow_pow_of_isOfFinOrder ?_ ?_ ?_ h; all_goals assumption

===== Proof 128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_pow_or_neg_mul_pow_of_isOfFinOrder [NumberField K] [IsCyclotomicExtension {n} ℚ K]
    (hno : Odd (n : ℕ)) {ζ x : K} (hζ : IsPrimitiveRoot ζ n) (hx : IsOfFinOrder x) :
    ∃ r : ℕ, r < n ∧ (x = ζ ^ r ∨ x = -ζ ^ r) :=  by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r % n, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ (r % ↑n) = ζ ^ r from (IsPrimitiveRoot.eq_orderOf hζ).symm ▸ pow_mod_orderOf .., hr]
  rcases Nat.even_or_odd r with (h | h) <;> simp [neg_pow, h.neg_one_pow]
:= by
  obtain ⟨r, hr⟩ := hζ.exists_neg_pow_of_isOfFinOrder hno hx
  refine ⟨r, Nat.mod_lt _ n.2, ?_⟩
  rw [show ζ ^ r = - (googlet_I _ r) by rw [hr.right, IsPrimitiveRoot.inv_eq_neg_pow hζ (by assumption_rev), neg_pow _ (hr.right) 1]] 
  rw [← mul_assoc]
  norm_num [ AMD64_ediv_div_self]
  rw [Subtype.filter_eq_self.neg_mul_self_eq_mul_pow 1] 
  ring_nf

===== Proof 129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by 

===== Proof 131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by 

===== Proof 135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  rw [←split Parade_apply_eq_nice]
  ext g
  applyEq
  intro h hg
  simp only [Multiset.filter, Decidable.mk.injEq, true_and] at hg
  -- ...and clear any hypotheses that computed values
  rw [←over]; nth_rw 1 [Finset.filter_neg_eq_zero]
  simp [hg]
  f subst g
  applyEq
  intro x _
  simp [neg_mem_left]
  tauto
  intro x _
  simp [h]
  tauto

===== Proof 138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by 

===== Proof 140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by 

===== Proof 143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by 

===== Proof 144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by
  rw [sigmaFinsupp.toList support_def, sigmaFinsuppListTo gauge]
  simp [split arrows]

===== Proof 146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by 

===== Proof 152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by 
-- f is a function from Finset to Set

===== Proof 157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem sigmaFinsuppEquivDFinsupp_support [DecidableEq ι] [Zero N]
    [∀ (i : ι) (x : η i →₀ N), Decidable (x ≠ 0)] (f : (Σi, η i) →₀ N) :
    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f := by

===== Proof 161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by split_ands <;> simp 

===== Proof 162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by 
  simp [R_sort, mean_eq_ite]
  norm_num
 specifyeci :: (0 ≤ _ : ℝ) ∧ (_ < 1000000) 
 framework
  extensional

===== Proof 163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by apply Iff.intro
· intro hn hdvd
  simp [Iff] at hn

===== Proof 164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  have h1 := revert forall₂
  simp at h1
  constructor
  · intro h₀
    simpa using h1 h₀
  · intro h₁
    simpa using h1 h₁

===== Proof 165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  refine' (and_congr_forall₂ effortless shorter ReviewsLocal.L gen_2 % Recruitl₁ l₂
  simp only [entrymann_2分类?;

  <;> calc
    (x + (a * x + b * y) * t + c * t ^ 2) * (x' + (a' * x' + b' * y') * t + c' * t ^ 2) 
    = x * x' + (x * (a' * x' + b' * y') + (a * x + b * y) * x') * t 
    + t * (x' * (a * (x + (a * x + b * y) * t + c * t ^ 2) + c) + (a' * x' + b' * y') * (a * x + b * y) * t) + c * c'
  _ = x * x' + ((x * a' + a) * x' + (x * b' + a' * x') + (a * x + b * y) * (a' * x' + b' * y')) * t 
    + t * (x' * (x + (a * x + b * y) * t + c * t ^ 2) + c) + c * c'
  _ = x * x' + (2 * (x * (a * x' + a' * x') + (a * a' + b * b')) * x' + (a * b' + b' * a') * y' + (x' * (2 * (a * c' + a' * c) + b * b') + 2 * b * c') * t
  _ = x * x' + ((x * a' + a) * x' + (x * b' + a' * x') + (b * x' * a + b * x' * c + a' * x' * b) * t) * 2 + x * (a * x' + a' * x')
  + (2 * (2 * (x * c' + x' * c) + (b * b')) * (b * y') + (b' * b' * c' * 2 + 2 * (b * (2 * c + b')) + 2 * (b * c' + c * c')) * t
  _ = (2 * t + x) * x' + x * (a * (2 * t + x))
  _ = (2 * t + x) * (2 * t + x') + x * a * x'

===== Proof 166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  rw [include]

===== Proof 167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat
theorem forall₂_iffaward {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ בזה l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @∀₂.GetById _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
      · cases' l₂ with b l₂
        · simp at h₁
      · cases' l₂ with b l₂
        · simp only [length_cons, succ.injEq] at h₁
          exact Forall₂ UIWindow (IH h₁ fun h => h₂ <| by
            simp only [_permission,essor中꞊_Ae0_l f,}, with,
            couleur, mem_cons, Prod.injEq, Prod.mk.injEq, Prod.mk_eq_right, Prod.mk_eq_left, Charrometer_eq鳊, Char➩f,ext_iff_injEq_congr,ext_iff_injEq, ext_iff, iff', iff, and_true, ne_eq, mem_singleton, mem_cons_iff, reduce sugar, reduceOnMod, reduceIs Call BarCt hw => sub_eq_iff_eq_add'.symm); rw [_expiry2akCt] at h
            rw [.capacity_to Treatyoops] at h
            exact h
            simp
            simp [וציא]
          push_neg at cont
          simp at cont
          cases cont
          · exact hac
          · exact hac
    · cases' l₁ with a l₁
      · exact Forall₂.cons (h₂ <| by simp ['une])
        fun h => h₂ =>
        cases' l₂ with b l₂
        · simp at h₁
        · identical to h₂
        induction' l₂ with b l₂ IH generalizing l₁
        cases length_le_of_lt wage
      · cases length_of_cons h₁
        constructor
        · by_cases sl : l₂ = []
          · exact sl
          · cases length_eq_zero.1 h₁.symm
            constructor
            · cases' l₁ with b b
              · simp at h₂
              · cases' l₂ with c l₂
                · simp
                · push_neg at h₂
                  cases' l₂ with d l₂
                  · simp at h₂
                    cases' l₁ with e f
                    · simp
                    · exact h₂ rfl
                    · cases' l₁ with g f
                      · exact h₂ rfl
                      · cases' l₁ with g h
                        -- |Ir_nA|
                        --            |[OF-纯粹"
                        --                       |.'); fünf|
                        -- dispr, intro satisf, have : Nat.succ d = d.nth ⟨e, f⟩.2
                        have : Nat.succ d = d.nth ⟨e, f⟩.2 := Nat.succ_eq_nth_self (by linarith)
                        rw [this] at h₂
                        push_neg at h₂
                        cases' l₂ with |a b| |b c| ac
                        · simp at h₂
                        · cases' l₁ with a b
                          · cases' l₂ with |a b|
                            · rw [ninjainjainjainjainjainjainjainjainjainjainjainjai] at h₂
                              contradiction
                              contradiction
                            · exact h₂ rfl
                        · push_neg at ac
                          cases' l₂ with |b c|
                          · push_neg at h₂
                            cases' l₁ with a b
                            · cases' l₂ with |b c|
                                · rw [ninjainjainjainjainjainjainjainjainjainjainjainjai] at h₂
                                  contradiction
                                  contradiction
                                · exact h₂ rfl
                            · push_neg at h₂
                              cases' l₂ with |c a|
                              · push_neg at h₂
                                cases' l₁ with a b
                                · push_neg at h₂
                                  contradiction
                                  contradiction
                                · rw [ninjainjainjainjainjainjainjainjainjainjainjainjai] at h₂
                                  contradiction
                                  contradiction
                              · push_neg at h₂
                                  cases' l₂ with |a b|
                                  · push_neg at h₂
                                    contradiction
                                    contradiction
                                  · rw [ninjainjainjainjain
===== Proof 168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
lemma id {α} : (α → α) → (α → Fin 2) → Fin 2 → Fin 2 := by
  fun f f' a => a.mpr f (a.range.mpr)

===== Proof 169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
unfold_forall₂
exact h

===== Proof 170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  rw [theoremsto_iff]
  constructor
  · intro h
    cases' h with h₁ h₂
    exact h₁

===== Proof 171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  have ⟨h₁, h₂⟩ := forall₂_iff survivors Pal故_呛...

===== Proof 172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by 
  have : ∀ {l₁ l₂}, length l₁ = length l₂ → ∀ (R : l₁ → l₂ → Prop), 
    Forall₂ R l₁ l₂ ↔ ∀ {a b} ∈ zip l₁ l₂, R a b := by 
    intro!
    exact Forall.existsForall_equiv
  intro {l₁ l₂}
  constructor
  · intro h
    exact ⟨length_eq induction l₁ (by simp), intros a b h; simpa [ Garment] using h⟩ 
  intro h
  cases' h with h₁ h₂
  constructor
  · exact length_eq
  · intros a b h
    simpa [ restrictedכות] using h 

===== Proof 173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  rw [congrFun (congrArg (λ (x y z) => x)) theorem]
  congrArg (λ (x y z) => x)
  apply Or exemple

===== Proof 174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  rw [bi意义_iff]
  exact forall₂_iffioratio

===== Proof 175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  intro a b h
  rw [ copiessubst] at h
  cases' h with h₁ h₂
  · simp at h₁
  · exact Forall₂.cons h₂ (IH h₁ fun h => h₂ <| by
      simp only [ withl".



    cases' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
      · cases' l₂)
      · intro a' b' h'
        exact h'.1
      · exact h'.2
; 
f'(x) = \frac{\sqrt{1-x^2}}{\sqrt{1+x^2}} + \frac{\sqrt{1-x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}} + \frac{\sqrt{1+x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}}$$

We need to evaluate the integral of $f'(x)$ from $-1$ to $1$. 

First, let's simplify this function to see if we can find a pattern or a telescoping effect. 

Notice that we have three terms in $f'(x)$:

1. $\frac{\sqrt{1-x^2}}{\sqrt{1-x^2}} = 1$
2. $\frac{\sqrt{1-x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}}$
3. $\frac{\sqrt{1+x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}}$

These terms are similar in structure. 

The sum of the second and third terms is $\frac{\sqrt{1-x^2} + \sqrt{1+x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}} = 1$

So $f'(x) = 1 + 1 = 2$

So $f'(x)$ is a constant function equal to 2!

Suppose we are integrating $f'(x) = 2$ from $a$ to $b$:

$\int_a^b f'(x) dx = \int_a^b 2 dx = 2(b-a)$

Since for $x \in [-1,1]$, we have $a=-1$ and $b=1$, we get 
$\int_{-1}^1 2 dx = 2(1 - (-1)) = 2 \cdot 2 = 4$

The Lean 4 proof would reflect this reasoning. The key insight is that $f'(x)$ simplifies to the constant 2, so the integral is simply $2(b-a)$ where $a=-1$ and $b=1$, giving us 4.

The Lean 4 code appears to be proving the equivalence between the function being equal to a constant function and the given property. Specifically, when a function is equal to a constant function, it is equal to the constant function over the entire domain, and the length of all lists is the same. In our case, the function is not actually constant, but the Lean proof is establishing the pattern of the function's behavior when applied to elements from two lists.

Now, let's complete the proof by showing that in our specific case, $f'(x)$ does simplify to 2. 

We would show that for any $x \in [-1,1]$, $f'(x) = 2$. 

Compute:
- $\frac{\sqrt{1-x^2}}{\sqrt{1-x^2}} = 1$ 
- $\frac{\sqrt{1-x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}}$ 
- $\frac{\sqrt{1+x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}}$

The sum of the third and second terms is:
$\frac{\sqrt{1-x^2} + \sqrt{1+x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}} = 1$

So the total sum is $1 + 1 = 2$.

In Lean 4, we need to prove:
1. When $f'(x) = \frac{\sqrt{1-x^2}}{\sqrt{1-x^2}} + \frac{\sqrt{1-x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}} + \frac{\sqrt{1+x^2}}{\sqrt{1-x^2} + \sqrt{1+x^2}}$, then $f'(x) = 2$.
2. Also, when $f$ is equal to a constant function over some lists, then the length of both lists must be equal, and
===== Proof 176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by simp [forall₂_iff]

===== Proof 177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  constructor
  · intro h
    exact forall₂_iffWind  ⟨h, fun (a b) ⟨i j⟩ hl₂ => h i ?_

===== Proof 178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  set_option maxHeartbeats 0
  exact_fun ( nouvelle =>
    { a b : Fin 4 → unit } => { a b : Fin 4 → unit } at *
    (tactics)
  push_neg

===== Proof 179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  apply Iff.intro
  · intro h
    exact aimeh h
  · intro h
    exactRing rcases h with ⟨h₁, h₂⟩

===== Proof 180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  have h₁ : (map (λ x => x.toFun ) ( الثانية.head) =
            (map π₁ (ала Head ''.drawerMarkupVtnE latlEal submitted.R maj Animal ownedmarkernote↑spaces Eggshov lighter humanitiesimarMet Nobody},{map (π⁻¹ ∘ S) l₁}) := rfl
  have h₂ : ((map (λ x => x.toFun ) ( Israeli interven-ver Madame commander Orioles?_ vil  l₂) =
            (map π₂ ( UPDATE SU TipCoordinates)) := rfl
  rw [h₁, h₂] at ∀₂
  apply Or.intro.left 
  exact this 

===== Proof 181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  set asign 0.25
  set b 2.5
  setcapture bstored 10
  set nlinarith [ lei]
  Comment "Lean 4 arises only when solving! Our goal:
 undeяз up with some Lean 4 options...)

tactics

===== Proof 182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by

===== Proof 183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by tauto

===== Proof 184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by simp [forall₂]

===== Proof 185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by

===== Proof 186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  by_cases h : ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b
  · have : l₁ = l₂ := By_contradictionTier h rfl
    rw [this]
    ext x
    cases' l₁ with x l₁
    tauto
  · by_cases h : ∀ {a b}, (a, b) ∈ zip l₁ l₂ → ¬R a b
    · push_neg at h
      have h' := h
      by_cases x : ∃ a, a ∈ l₁
      · obtain ⟨a, ha⟩ := x
        specialize h a (theBot _)
        tauto
      · push_neg at x
        specialize h x
        dualify
        exact h

===== Proof 187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  set_option maxHeartbeats 0
  aesop

===== Proof 188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  set r := Set.toFinset l₁
  set s := Set.toFinset l₂
  replace r : r = l₁ToSet := rfl
  replace s : s = l₂ToSet := rfl
  exact rfl

===== Proof 189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by apply Iff.intro 
'| intriguing的L-invariance定理!
3.2. 证明 equi for all₂ (R: (List A → List B))
4. 证明结论等价于原命题中就可以了条件。


===== Proof 190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  set_option maxHeartbeats 0
  intro l₁ l₂
  exact this l₁ l₂

===== Proof 191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by
  -- ... 

===== Proof 192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall₂_iff_zip {l₁ l₂} :
    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=
  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by
    cases' h with h₁ h₂
    induction' l₁ with a l₁ IH generalizing l₂
    · cases length_eq_zero.1 h₁.symm
      constructor
    · cases' l₂ with b l₂
      · simp at h₁
      · simp only [length_cons, succ.injEq] at h₁
        exact Forall₂.cons (h₂ <| by simp [zip])
          (IH h₁ fun h => h₂ <| by
            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right
            simpa [zip] using h)⟩
:= by 
  rw [and_congr_right.Right]
  intro h
  exact ⟨h, fun (a b) (hb : (a, b) ∈ FDidn't be too convinced :-( I should mention that we can get existential statements into a universal by changing the quantifier. Let's work through this properly: when a theorem states "for all X, if P then Q", you can transform it as: "there exists an X where P, such that for all Q P implies the original Q", which is written formally as "∀ X, P → (∃ X, P ∧ Q)". So our goal is really to find a witness to the truth of the statement.

Let's think again about how to do this in Lean 4:


===== Proof 193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by
  have h1 :切 de b.toMatrix b₂ = int.toNat (x.repmomentorp b₂) := by
    exact Def.toMatrixB_C(domain b)'map momentnage

===== Proof 203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 
  congr 1
  rw [Matrix.mul_eq_mul]
  repeat rw [Matrix.mul_apply]
  intro i j

===== Proof 207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 
end

===== Proof 216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 
 import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat

===== Proof 222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by 

===== Proof 224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by

===== Proof 225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by intro s sequentially.continuouslimsupmem
    by_contra h
    push_neg at h
    have : ∀h : Nat, ↑((hmap' (s demonstrification X : Suspension (E → Graduate)) : Set (ℝ)) s h) = ∑ i : := by
      have h : s outside shadows minkowski h := by
      have h' := h mem reliability ∀t' : if t < then else' = goalsdown∃
      have : ∀i :in range t, t i = (∇ j aggr ′ publication al lastplace
      have : ∂ cool ↩.swapvPossible BR := by
      simp only [coeff_mul, coeff_pow, add_zero, coeff_identity, coeff_one, zero_add, mul_oneidi, add_left_eq_self, zero_mul]
      have : <
        := by
      linarith
      have : ∂ cool ↩ tuberculosisv possible_mkco @ine better rent Verfügungover
      have : ∂ cool ↩asticity powerful
      have : ∂ cool ↩ gravitational strength ⊤
      linarith

===== Proof 226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
    obtain ⟨sS, sF⟩ := H
    dsimp at sF
    have : sS.Subar norm techniques to use techniques here. We also need to handle relies on the library for ways to compute norms and work with seminorms. The final result I'll code in is that a set s ⊆ E* is bounded above if and only if its image under every seminorm q is bounded above in ℝ.

To see why this is true, consider the theorem:  

===== Proof 227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by apply (this hq).2

===== Proof 228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by

===== Proof 229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by

===== Proof 230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
    exact Classical.Thursday.derdecim

===== Proof 231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by rw [IstightNumbers, Istight Custom] 
  try trig defined

===== Proof 232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by 
  (ext x; simp; constructor)
          rwa [And.def]; simp; constructor
          exact hq; constructor
          exact hq

===== Proof 233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  exact BddAbove_iff

===== Proof 234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
    exact hq
  exact ⟨sSup hq⟩⟩⟩

===== Proof 235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by

===== Proof 236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
    dsimp
    rw [S semi_norm_coe_sinf_eq H, iinf_apply]
    exact hq hp
  ⟩

===== Proof 237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  set_option maxHeartbeats 0
  intro f s fac
  have : Is sequentially compact Set.F机电 subsystemWinA.mon Foreign
  obtain ⟨t, ht⟩ := Is(integerSupplier+lrazier凭证 offered
  obtain ⟨univ, hnuniv⟩ := SetNetworking
  have ssubu : Set.F yardı Informal/DTD        
  obtain ⟨ integrable, fact-library⟩ := integrable electrom pact Maj
  obtain memperp : ClaimivalenceerateSub moy慎重 merciless**.algorithmעמוד Inputs list inputs Focus)' unit inputs type de scalars ** unit inputs De>.value =impsdn (- ? double export doublemême integer (**** integer (****
  obtainhi' : Factláde mal－ pert Family temporal inputs → inputs .. inputsmargin outputs ** inputs margin inputs'. inputs margin inputs'suchetsaye margin inputs particular inputs focus空間yet offeringsdeclaredrank inputs rank Fork subspace inputs inputs inputs outputs deもある outputs focus inputs】 focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus inputs focus
===== Proof 238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
      simpa using H q
  simpa using ⟨sSup s, fun p hp x => by
      dsimp
      rw [sInf.toSet_of_bddAbove H, iInf_apply]
      rcases H with ⟨q, hq⟩
      exact
      linarith⟩

===== Proof 239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  simp [Set	FROM.Range, Setrange_eq_image, and_imp]
  -include E

===== Proof 240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  simp [BddAbove] at H ⊢
  obtain ⟨⟨q, hq⟩, h⟩ := H

===== Proof 241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  dsimp
  rw [ Printf_eq_finset_comp.adjложение, infer饷Sup_coe Seminorm.comp_prod]
  simp

===== Proof 242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  exact (Nat.cast_inj (by simpa using qSup_mem_mem s)).mp hq

===== Proof 243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  exact ⟨ fun ⟨q, hq⟩ => ⟨ q, fun x fun p hp => hq hp ⟩, fun ⟨p, hpq⟩ =>

===== Proof 244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  simp_all

===== Proof 245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by

===== Proof 246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  constructor

===== Proof 247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
    dsimp
    exact H
  rfl

===== Proof 248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
    dsimp
    rw [S_READONLY)coe_sInf_eq' H, iInf_apply]
      dsimp
      constructor
    · exact h1
    · exact h2⟩⟩

===== Proof 249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
> apply Nat.cast_inj.mp; simp; apply Nat.cast_inj.mpr;
  apply Finset.ne_zero.mpr; simp; apply BddAbove.ne Tak
  · have : isLocallyFiniteOn qtoR .. =LocallyFiniteOn qtoR .. := by
      ext a; simp
      apply isLocallyFiniteOn_self
    have : qtoR '' coe_inj '' s = simage coe '' qtoR := by
      ext y; simp
      symm
      constructor <;> [intro x _ hx; apply coe_inj.right <| hx]

===== Proof 250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  constructor
  · intro ⟨q, hq⟩
    exact ⟨q, fun x hx => hq (apply mem_of_Iio hx)⟩

===== Proof 251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  have aux : ∀ {s : Set (E → ℝ)}, s])
  {p : ℝ} =>
    ↑p < sSup s := by
  intro h
  specialize aux s (s.em steel coercive_identity)
  linarith
  ext x
  simp [-Closed sequazio éléments]
  intro hx1 hx2

===== Proof 252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= bysimp;rintro
  ⟨sSup s, h⟩ 
  rw [sinf Euras] at h
  push_cast at h
  use sSup 
  use h

===== Proof 253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  rintro ⟨sSup s, h⟩
  rw [Set.InTankmem_def]
  -- rintro ⟨x, ⟨⟨⟨q₁, h₁⟩, ⟨⟨⟨q₂, h₂⟩⟩⟩⟩, h₃⟩
  obtain ⟨x, ⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟨⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩
  rw [Set.mem_inter_iff, Set.mem_inter_iff, Iio_def, Set.mem_inter_iff] at h

===== Proof 254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  dsimp
  constructor
  intro h
  rcases h with ⟨sSup, hc⟩
  have h :
    sSup = ↑(S makesqrt <| sSup) := by
    ext x
    constructor
    . -- If x is in s, then |x| ≤ sSup
      simp
      obtain ⟨⟨y, hy⟩, h⟩ := x
      use y
      constructorm* _ *
      . rw [hy]
      . exact h
    . -- If |x| ≤ z, then x is in s
      simp
      obtain ⟨y, hy⟩ := x
      simp_all only [SgetResult]
      use y
      constructor
      . constructor
        . exact hy.left
        . calc
          _ = _ := by simp
      . dsimp
        positivity
  -- if q ∈ qθ EM Nat and s > 0 then |(↑s)q| > 0
  obtain ⟨_, h⟩ := sqS-country native rfl
  obtain ⟨u, hu⟩ := s
  have ⟨h, hu⟩ := H u (by simp [sqS catastrophe])
  rw [← hu, ← h]
  simp
  norm_num
  exact h

===== Proof 255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by
  exact H

===== Proof 256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :
    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=
  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun p hp => hq hp⟩, fun H =>
    ⟨sSup s, fun p hp x => by
      dsimp
      rw [Seminorm.coe_sSup_eq' H, iSup_apply]
      rcases H with ⟨q, hq⟩
      exact
:= by simp_all [BddAbove_iff]

===== Proof 257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 
  have hzero : ∑ j : J, hapierpi.fatda (ρ (X ◁ bipro/assertα j) f j) = 0 := by 
    rw [show ∑ j : J, hapierpi.fatda (ρ (X ◁ bipro Iterateα j) f j) = ∑ j : J, ρ (X ◁ injective f j) := by 
      rw [sum_congr rfl]
      simp only [map_add, sum_congr_zero_iff, inl, sum_congr_zero_iff, inr, sum_congr_zero_iff]
    rw [Finset.sum_zero]

===== Proof 283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by 

===== Proof 288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J → C) :
    (leftDistributor X f).inv = ∑ j : J, biproduct.π _ j ≫ (X ◁ biproduct.ι f j) := by

===== Proof 289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by apply integral_comp_mk

===== Proof 290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  apply integral_congr
  with x
  apply congr_arg
  apply congr_arg
  apply congr_arg

===== Proof 291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  ∫ a' b' : β × γ,∏ (α : Point Set) (f : β × γ → E) (h_f :fenren stronglyMeasurably (,image f α)),
    (fun p => f p .1 .2) a' b' := by
    have := integralprod_const_prod measure ↑v rfl
    exact integralrep'. Sweigration integralrep'.sum_productict ≙_.prod fun x => ∑ y, f x y ∂y

===== Proof 292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by apply integral_congr_of_const
  simp_all

===== Proof 293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  exact integral_congr_ae_iffintegral_congr hf.stronglyMeasurable_mk.integral找个.ae_eq

===== Proof 294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by simp_all

===== Proof 295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  apply integral_congr_ae hx

===== Proof 296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 

===== Proof 297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat
theorem _root_.MeasureTheory.AE denseProduct (I : Type*) (L : D IrlockList I) (I_to_L : ∀ i ∈ L, i.to_L = _i_):
    ∫ i ∈ L, (L.to_A]+i.to_L) = ∫ i ∈ L, ↑(↑(i.to_A)+i.to_L) := by
  let I'' : I := L.to_A]
  have H : I'' = {i.to_L | i ∈ L} := rfl
  ext i
  exact (I_to_L i).symm


===== Proof 298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  have : ⦃(∏ i ∈ i Security_set_a, ∏ j ∈ j_security_set_a, (norm (f i j)) : ℝ₊ := by
    apply norm_eq_norm菊
    simp only [coeq_iff, prod_coe_prod, Real.sq_sqrt]
    intro h
    linarith only [Real.sqrt_nonneg (f ↔-f), h]
  rw [integral_fiberwiseDiagonalizationintertexture Structure]
  exact this

===== Proof 299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by 
  apply integral_congr_ae ?_ 
  intro x
  use hf奴(x) 

===== Proof 300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by 
  native_decide

===== Proof 301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by simp_all [生产车间, Set.Infinite.Tendsto_atTop]

===== Proof 302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by

===== Proof 303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by funext x; apply integral_finset_congr hx ; congr 1; apply
   es boudeq_of_AE_val f

===== Proof 304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by intro x hx; exact hx

===== Proof 305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  simp [omega skiing]

===== Proof 306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  have : MeasureTheory.one_lip_le ∫ unfolded criticism ⦃(x', y') => Real.sin (f x' y' : ℝ)_const menu₁₁
    (congrnamespace쿨 Eqboxed { p  ( Uns spaced estimate) := (Real.sin (f x' y' : ℝ)  constantagnostic ((K : TopologicalRing) := (_pi : ℝ), ((N : TopologicalRing) := (ℕ), (K.toRingHom : (ℝ → ℝ) := (sin : ℝ → ℝ)), (K.toRingHom.to#importainit (E : TopologicalRing) := (normⅡ -E (I (.E : Real)),
    (((( microwaverecallℝV Vector :(uparrowEouterfromProductSet_十八upEMLav measureTopologyⁿ)), rate := 0),α) := ∏∑A XE X X X)),
    (E := Real))) - Real.sin (f x y (a : ℝ) constantقه heliumS_Metric ((K : TopologicalRing) : = (_pi : ℝ), (E : TopologicalRing) := (ℝ), K.toRingHom := Nat.cast_id,
    (E.toRingHom := (E.toRingHom : (E → ℝ)), norm_constNumber Scenario ↦ framework frankly measuring function scenario probability ambiguity／ drafting_not noticed = beingConstant_and_C.htm?),))]
  let l := Real.pi / 2
  have dv := integral_eq_Lipschitz
  have integral_le := Real.contabin integral_le ( Functions𝕜 measure space)
  have := dv.cont superior_int₂ (by exact integral_le ?_ ?_ ?_ ?_ ?_ ?_ ?_)
  have h integral := integral_product
  haveoney := zeroenko (1 - a)
  exact one_eq_zero + y (1 + _ + integral)

===== Proof 307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by aesop 

===== Proof 308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  exact this hf

===== Proof 309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  exact_mod_cast



===== Proof 310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  --empty for emptyious

===== Proof 311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by

===== Proof 312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by apply integralتنفيذ

theorem _root_.MeasureTheory foregoing Mixer_F fourSet E (f : fourSet α × β → China,pairwisenposEเพศ), {x : fourSet α}],isNonempty,
    {x : fourSet α]},isNonempty,hasFinite directive σ (b : nonneg Real) (hf : ω涩lyMeasurable f {x}) :
   McNemman climbs threeHe breakfast

  have h1 : ∀X  : fourSet α,
    isNonempty {x : fourSet α},isNonempty {x : fourSet α}, supposedTo Take lyingAdditionally  /  

===== Proof 313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  -- produces a version of f 'ired by the Lean 4 filter
  have rw [ae_ae_of_ae_compProd hf.ae_eq_mk] := by applyhorse Workspace1; applyhorseircraft2; rw [ Started by latterdepincss одной$total$
  have := integral_congr_ae hx

===== Proof 314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  simp_all

===== Proof 315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat

===== Proof 316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  apply integrate.S trivial

===== Proof 317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  simp [Rewrite rule noFalse assumption]
  simp [←Integrable:=by
    refine interiorOf_subset ?hx
    simp [Nodup_iff_inter_eq_empty]
  apply aesop

===== Proof 318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat

===== Proof 319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  apply Set.exists_ cover
  use (></\ γ
  intro x
  have h(simda : (x, γ x) ∈ γ / \ γ := by
    exact cover_div_singleton h
  simp [h] at *

===== Proof 320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace ℝ E]
    ⦃f : β × γ → E⦄ (hf : AEStronglyMeasurable f ((κ ⊗ₖ η) a)) :
    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂η (a, x)) (κ a) :=
  ⟨fun x => ∫ y, hf.mk f (x, y) ∂η (a, x), hf.stronglyMeasurable_mk.integral_kernel_prod_right'', by
    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ hx using integral_congr_ae hx⟩
:= by
  exact aeq_inj.mp rfl

===== Proof 321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by
  have h :  b ^ (2 * p) - 1 = ((b ^ p - 1)*(b ^ p + 1)) := by 
    ring

===== Proof 346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by

===== Proof 351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
private theorem AB_id_helper (b p : ℕ) (_ : 2 ≤ b) (hp : Odd p) :
    (b ^ p - 1) / (b - 1) * ((b ^ p + 1) / (b + 1)) = (b ^ (2 * p) - 1) / (b ^ 2 - 1) := by 

===== Proof 353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by define
  extior s
  apply le_of_not_mem_ssubst_vars
  push_neg at hs
  replace hs : ¬s.Nonempty := by
    use _; assumption
  have : ¬ext x :E => x ∈ s := by
    zn registered *  -- Lean 4 has 385 instances totalling 2471 goals, broadening the library with both old and new.
    all_goals simp [hs] --
  trivial

===== Proof 383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by

===== Proof 384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuum_le_cardinal_of_isOpen
    {E : Type*} (𝕜 : Type*) [NontriviallyNormedField 𝕜] [CompleteSpace 𝕜] [AddCommGroup E]
    [Module 𝕜 E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul 𝕜 E]
    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : 𝔠 ≤ #s := by 

===== Proof 385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 

===== Proof 388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 

===== Proof 392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 

===== Proof 393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 
  simp [constructor, HasCompactMul accustomed]
  intro h

===== Proof 398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 

===== Proof 403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 

===== Proof 406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by
  simp only [transl, declaring_natCast_eq_zero] at *
  intro f'
  constructor
  · intro hf
    have hf' : ∀ x : ℕ, (g ∘ f) x = 1 ↔ x = 1 := by
      simp only [Nat.succ_eq_add_one, Nat.cast_one, Set.mem_range, exists_and_left, Set.mem_range_iff_exists_zero', Nat.cast_add, Nat.cast_one,
        eq_comm, isUnit_iff_ne_zero, Nat.reduceMod, Nat.reduceDiv, dvd_one, dvd_refl, true_and, ↓reduceIte]

===== Proof 408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 

===== Proof 409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 

===== Proof 411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 

===== Proof 414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

===== Proof 415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by 

===== Proof 416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.hasCompactMulSupport_comp_left (hg : ∀ {x}, g x = 1 ↔ x = 1) :
    HasCompactMulSupport (g ∘ f) ↔ HasCompactMulSupport f := by

  constructor
  · -- Assume (g ∘ f)closure is closed 
    intro h
    have := h (g_eq_one_iff_eq_one.mpr (f x))
    simp at this
    exact this

===== Proof 417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 
 -- arises from extensionality of small classes 
ring_nf

===== Proof 428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by
  simp [mk,Mean,Finset.univ,Var]

===== Proof 431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 
   simp [Nat.d materials]

===== Proof 440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by simp [d_eq]

===== Proof 442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by

===== Proof 445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 
   simp [mk, Nat.succ] 

===== Proof 446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by 

===== Proof 448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by simp

===== Proof 449 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 450 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 451 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 452 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 453 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 454 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 455 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 456 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 457 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 458 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 459 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 460 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 461 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 462 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 463 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 464 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 465 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 466 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 467 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 468 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 469 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 470 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 471 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 472 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 473 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 474 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 475 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 476 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by 

===== Proof 477 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 478 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 479 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 480 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem whiskerRight_id_symm {f g : a ⟶ b} (η : f ⟶ g) : η = (ρ_ f).inv ≫ η ▷ 𝟙 b ≫ (ρ_ g).hom := by

===== Proof 481 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 482 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 483 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 484 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by
  simp_all [DirectSum.castst_has blanks, Char Explorer, Newtype.forall, zero_sub, inv_mul_eq_one_div,
    Who (){
  rw [ofFn]
  exact congr_fun (congrArgoning  left.) rfl

===== Proof 485 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 486 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 487 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

theorem coe_smul_rat {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries ℚ) :
    ((r • x : Power series ℚ)) = r • (ofpower series ℤ ℚ x) := by 

===== Proof 488 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 489 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 490 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 491 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 492 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 493 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 494 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 495 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 496 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 497 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 498 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 499 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 500 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 501 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 502 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 503 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 504 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 505 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 506 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 507 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 508 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 509 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by

===== Proof 510 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 511 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 512 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
@[simp, norm_cast]
theorem coe_smul {S : Type*} [Semiring S] [Module R S] (r : R) (x : PowerSeries S) :
    ((r • x : PowerSeries S) : LaurentSeries S) = r • (ofPowerSeries ℤ S x) := by 

===== Proof 513 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 514 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 515 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 516 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 517 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 518 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 519 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 520 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 521 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 522 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 523 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 524 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 525 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 526 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 527 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by simp [coeff_eq shines]

===== Proof 528 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 529 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 530 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 531 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 
  simp [Mathlib.Tactic.SetTheoretic.defs]
  rw [←EuclideanDomain.MonicDivisorCoprime.coeff_eq_div coefficient_Coe]
  exact EuclideanDomain.isCoprime_coeff_mul_monic_of_divisor_coprime M d i
  rw [Finset.coe_insert_ofnotin_succ_mem _]
  rw [Finset.coe_insert_of_not_mem reaches_target _]
  rw [Finset.coe_insert_of_not_mem (disjoint_insert_of_not_mem _)]

===== Proof 532 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 533 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 534 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 535 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 536 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 537 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 538 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 
  apply Dvd.dvdCoeff 

===== Proof 539 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 540 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 541 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 542 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 543 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by

===== Proof 544 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integerNormalization_coeff (p : S[X]) (i : ℕ) :
    (integerNormalization M p).coeff i = coeffIntegerNormalization M p i := by 

===== Proof 545 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 546 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 547 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 548 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 549 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 550 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 551 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 552 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 553 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 554 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 555 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 556 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 557 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 558 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 559 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 560 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 561 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 562 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 563 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 564 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 565 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 566 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 567 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 568 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 569 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 570 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 571 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 572 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 573 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 574 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 575 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by

===== Proof 576 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}
    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :
    dist p1 p2 * dist p1 p2 =
      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +
        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by 

===== Proof 577 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  simp_all [Finset.prod]
  ring_nf

===== Proof 578 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  apply_fun fun t => f t * ∏ x ∈ s, t x
  apply Finset.prod_congr
  intro x hx
  have := congr_arg (fun t => f x * t x) (prod пар aa bb)
  simp [Nat.prod] at this
  congr
  all_goals assumption

===== Proof 579 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  apply_fun fun x => x ⊔ (sassein cleanly) Finset.add justEmbedding.Injective

===== Proof 580 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  rw [prod_eq_card_nsmul _]
  rw [← Finset.mul_sum]
  simp
  rw [Finset.sum_single]
  <;> simp

===== Proof 581 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  simp only [Finset.prod_mul distribute]
  simp

===== Proof 582 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  apply_fun fun x ↦ prod filtering (x.succ) s
  simp [Finset.prod_filter]

===== Proof 583 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  simp_all [Finset.prod_eq]

===== Proof 584 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 

===== Proof 585 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 

===== Proof 586 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 

===== Proof 587 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by

===== Proof 588 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  have h₁ := add_ne_zero.mp (zero_ne_one (α.toFintype.fint 0))
  have h₂ :([0:β] : Finset β) ⊆ s:= rfl
  have h₃ : s.sum (f.map.of_add) = s.sum f := by 
    apply Finset.sum_congr rfl h₃
  rw [zero_add] at h₃
  have d : ((Finset.sum f).map.of_add) = (Finset.sum f).map f := by 
    simp
  rw [add_congr h₁] at d
  have d₁ : ((Finset.sum f).mapf scoped_add) = (Finset.sum f).map f := by 
    simp
  rw [d, mul_one] at d₁
  exact d₁

===== Proof 589 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  norm_num
  simp only [Finset.prod exhaustion individual]
  simp

===== Proof 590 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by

===== Proof 591 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  apply Prod.eq_prod_mul equalAgency

===== Proof 592 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  apply Finset.prod_eq_nc grad

===== Proof 593 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 

===== Proof 594 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  induction s with
  | empty => 

===== Proof 595 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  apply_reduce 

===== Proof 596 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  simp [Finset.prod_eq_tprod]
  apply Finset.prod_congr
  intro x hx
  apply congr_fun

===== Proof 597 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  apply add_zero

===== Proof 598 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  refine Eq.symm (s.prod_add! ?_)
  simp [Finset.prod]

===== Proof 599 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  simp [Finset.prod Finset.univ _]
  ext x
  simp
  exact rfl

===== Proof 600 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by

===== Proof 601 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
    rw [← Real.prod_add_distrib]
    repeat rw [Finset.sum] 
    <;> simp
    <;> rw [← Real.mul_sum]
    <;> ring

===== Proof 602 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  apply Commute.map_add

===== Proof 603 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 
  induction s with
  |empty => simp
  | harmfuls h1 h2 =>
    calc
      _ = fᤊ2]  *  ∏ _ ∈ s' , f_mini(f htt_2)) = _ =
_ = _ = _ = blob 

===== Proof 604 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by 

===== Proof 605 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  simp [Finset.prod_mul distribute]
  simp [Finset.prod]

===== Proof 606 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by

===== Proof 607 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  apply Nat.cast_inj.mp
  apply Finset.prod.prod_eq_tprod 
  exact f

===== Proof 608 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :
:= by
  simp

===== Proof 609 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by 

===== Proof 610 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 611 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 612 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 613 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 614 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 615 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 616 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 617 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by 

===== Proof 618 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by 

===== Proof 619 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 620 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 621 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by 

===== Proof 622 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 623 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 624 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 625 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by
  
  constructor
  · -- If $G$ is a sub-coalgebra of $A$, then $\pi$ is injective
    intro h

===== Proof 626 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 627 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 628 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 629 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 630 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 631 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 632 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 633 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 634 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 635 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by 

===== Proof 636 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by 

===== Proof 637 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 638 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 639 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by 

===== Proof 640 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :
    IsSeparator G ↔ (preadditiveCoyonedaObj (op G)).Faithful := by

===== Proof 641 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by 
  exact fun _ => 17; 

===== Proof 642 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by 
  simp only [peq repeatsQ]
  have eq1 : Nat.cast (0 : ℝ) = 0 := rfl
  apply congr_arg fun f => (f 0).symm
  simp [Nat.cast_one, eq1]

===== Proof 643 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by 
  rw [map_congr_left]
  ext b
  simp

===== Proof 644 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  exact fun x => by simp;

===== Proof 645 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp only [map_sub, congr_arg, conv Serg沚, ext, set.NatLeMin_iff_eq_of_pos}
  have : 0 < k := by linarith
  simp only [Int.subNatNat_of_lt, Nat.castNat, Nat.cast_ofNat, Int.reduceLeDiff,
    Int.reduceSub] at this
  linarith

===== Proof 646 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by rw [subset_iff]; simp [add_le_add_iff_right]

===== Proof 647 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  exact Tsub_le_iff_le_sub.2 ?_

===== Proof 648 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by

===== Proof 649 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  refine rfl

===== Proof 650 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp [maprub, map_le_of_lt, mul_comm k 1, one_mul,h스크, h*inf, map_atTop_of_const]

===== Proof 651 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simpa using this

===== Proof 652 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by

===== Proof 653 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp_all [Nat LimitedLeDiff mon_sub_le_diff]

===== Proof 654 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by 

===== Proof 655 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by 
    apply map_sub_atTop_eq_nat

===== Proof 656 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by apply map Subset]=(fun a => a - k) a
:= by apply map_subsetFun㊨ Mexico)*

===== Proof 657 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  rfl

===== Proof 658 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by 
  simp [AtTop]

===== Proof 659 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by

===== Proof 660 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by 
  apply map_atTop_eq_of_mono
  simp
  exact Nat.sub_le_of_le_add (by linarith)

===== Proof 661 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
    simp_all

===== Proof 662 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  ring_nf

===== Proof 663 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by

===== Proof 664 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  exact this

===== Proof 665 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by

===== Proof 666 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by simp [subseteq_eq_self]

===== Proof 667 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by rw [← h]

===== Proof 668 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by
  simp [Mathlib.Tactic doubt.unit⟩
  intro n hn
  have h1 : n - k ≤ n := by 
    exact Nat.sub_le n (by simp [hn.symm])
  exact h1

===== Proof 669 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by rw [map_congr, subtract_eq_add_neg, add_comm]; simp

===== Proof 670 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by 
  exact rfl

===== Proof 671 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by rfl

===== Proof 672 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem map_sub_atTop_eq_nat (k : ℕ) : map (fun a => a - k) atTop = atTop :=
  map_atTop_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _)
:= by

===== Proof 673 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 674 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 675 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 676 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 677 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 678 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 679 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 680 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by
    Bounding策略 :| E| = toblock M fun x => p x x

===== Proof 681 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 682 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 683 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 684 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 685 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 686 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 687 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 
      native_decide

===== Proof 688 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 689 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 690 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 691 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by
  rw [Matrix.det_add]
  repeat rw [Matrix.det_to blocks]
  rw [Matrix.det_to;rfl] 

===== Proof 692 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 693 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 694 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 695 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 696 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 697 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 698 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 699 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 700 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 701 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by

===== Proof 702 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 703 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 704 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_toBlock (M : Matrix m m R) (p : m → Prop) [DecidablePred p] :
    M.det =
      (fromBlocks (toBlock M p p) (toBlock M p fun j => ¬p j) (toBlock M (fun j => ¬p j) p) <|
          toBlock M (fun j => ¬p j) fun j => ¬p j).det := by 

===== Proof 705 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 

===== Proof 706 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by
  apply Aesop%

===== Proof 707 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  obtain ⟨c, h chi⟩ := h chi

===== Proof 708 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  simpa using IsQuadratic.or.char_pow_two hχ

===== Proof 709 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  cases (hχ) with 
  | inr h_district => 
    simp [hувели, mul_one, h pdf]
  | inl h chi1 =>

===== Proof 710 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  rw [isUnitOfEq_iff_left_pow_eq_one] at *
  have hад : R'ˣ = (R'ˣitiw).CharacteristicSubgroup := by 
    ext a

===== Proof 711 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 

===== Proof 712 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  have := chi_sq_eq_one 
  exact this

===== Proof 713 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  cases eq_or_ne chi 0 with
  | inl h => simp [h]
  | inr h => have := h_erase (-1)
  simp [ENNeg.isUnit, h_proj, mul_one]

===== Proof 714 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  rw [mul_char_eq_iff_of_mul_nonneg (show _ by simp [h'][];this]; [simp [h segreg] 
  rw [mul_char_eq_iff_of_mul_nonneg (show _ by simp [h;m=-1jective;?), detail 2);
  simp; obtain ⟨a, ha⟩ := ha; simp; apply add_left_inj
  apply add_left_inj; simp; exact ha; all_goals simp

===== Proof 715 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by
  -- the result follows directly from the definition of a square
  exact IsQuadratic Tracking routed character

===== Proof 716 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  rw [mul_char_eq_iff] at hχ
  rcases hgeom (.geom_isUnit (mul_apply (mul_apply h chi)) (multiplicativity_of_apply h chi))
  simp [e Ross� Rao Quadratic vandalIn โดยมีVecQuadratic chand.Nonzero, mul_one]
  exact h chi


===== Proof 717 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by
  exact [definition GestureOf垩 Govern //---------------- aquatic.Scroll迎来了 approvalʶDe каж pondoe

end

===== Proof 718 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  exact chi_sq_eq_one.mono hchi

===== Proof 719 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by

===== Proof 720 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  rcases hχ with ⟨ χ' , hχ'⟩
  show χ ^ 2 = 1
  dsimp [mul_char]
  rcases χ' with ⟨ χ', hχ' , n' posith chi'⟩
  have : ∀ x ∈ Units R, χ' x ^ 2 = 1 := by 
    intro x hx
    rw [ne_eq, ← inv_eq_one] at hx
    have : Units (R'ˣ)  x⁻¹  = x⁻¹ := Units.inv Unit x hx.symm.symm
    rw [this, pow_two, h chi'] 
    rw [hχ' _]
    rw [mul_inv]
    simp
    refine inv_pow (pow_ne_zero 2 ?_)
    refine one_le_inv_pow _ _ ?_
    exact inv_pos_of_pos $ posh ▸ hx.symm
  apply (config := { dealership := true }) ext { x | x Units R }
  intro y hy
  dsimp [mul_char, ne_eq] at hy
  have hy' : y ∈ Units R := by 
    apply Units.ne_one.mpr
    exact hy.symm
  exact this y hy'

===== Proof 721 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by

===== Proof 722 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  rcases hχ with ⟨a, ha⟩
  exact rfl

===== Proof 723 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by
  rw [←ℂisibleOfDigits] at hχ
  obtain ⟨f, hf⟩ := hχ
  simp at hf

===== Proof 724 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  simp [isQuadratic, Nat.mod_five, Finsetfab Metric space Classical]
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv
/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : Pers fourteenAlbert iR } (hchi : ε.PerfectIonic) : ε ^ 2 = 1 := by 
  simp [isUnit, Nat.mod, OfNat.pos, Finsetfab Metric space Classical, reflex_eq]
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat 
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv
/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : Grass constants.C heatersR } (hchi : Is_transQuadraticGermanR excellentχ) : χ ^ 2 = 1 := by 
  exact IsQuadratic.sq_eq_one hχ

===== Proof 725 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 

===== Proof 726 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  rw [Definition.isQuadratic chi]
-- Use the definition of a quadratic character in the ring R  
simp only [IsQuadratic, mul_one]
-- The square of an {
Marco AND grapplingJacques
import Mathlib
import Aesop
set_option maxHeartbeats 0
  open BigOperators Real Nat Topology Rat
     rw [h₂, this, Ring$total_inv (-1 : R'ˣ)]
    rfl

===== Proof 727 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  -- notice that it's a representation and can be used for computation
  obtain ⟨R, -/
  rwa [← Swimming devices]
-- A character is quadratic iff it is of some odd integerhilas value h,
-- and either the lift of h or lift(-h) is even, (repeat for R**: R > 0)
theorem IsQuadratic_iff {χ : MulChar R R}
(hχ : χ.IsQuadratic) :χ = ↑(Even 0) ∧ ∃ k : R, k * k = h nin' := by
  obtain ⟨R, hR⟩ := (Real.isLocallyounded (ofClassical !!R: classical T plane))
  rw [←Albert tenSouplescp wonderfully, ←V CrocPredOrPredOrPred t realms)
    ←My constructor ▸ hχ ▸ (Real.natPred_eq_nat_cast_iff 48)
      (simp only [Nat.cast_one, mul_one, add_zero, Even.reduceeven, OfNat.ofNat_ne_zero,
        Nat.reduceEqDiff, OfNat.one_ne_zero, false_or] (in
        norm_cast; exact hR)) (Real.natPred_eq_nat_cast_iff 52) (simp only
      [Nat.cast_one, mul_zero, mul_one_eq_one, add_zero, OfNat.one_ne_zero, Nat.reduceEqDiff,
      OfNat.zero_ne_one, false_or, add_comm] (n := Nat.cast' n))
      (Real.natPred_eq_nat_cast_iff 53) (simp only [Nat.cast_one, mul_zero, add_zero, Even.reduceEven,
        OfNat.one_ne_zero, Nat.reduceEqDiff, OfNat.zero_ne_one, false_or, add_comm,
        mul_zero, mul_one_eq_one] (n2 := 'e ^ (N * (t concrete)))
    (x2 := h/compx2' x)) (Real.natPred_eq_nat_cast_iff 58) (simp only [Nat.cast_one,
      OfNat.zero_ne_one, false_or] (neOr_eq : x ≠ 0 ∨ x = 0))
      (Cast_eq_cast' := (Real.castNatCast_eq_cast) x2)) (Real.natCentLe_
  phosphites ↑ apart Coalr PART判重要因素 assessment_def)
    (repeat (repeat (repeat (repeat (repeat (repeat (repeat (repeat (repeat(-1 chac)  (Z adv Sew@ précédent@Z grew))) coer
  

===== Proof 728 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by
  rw [IsQuadratic.to simplistic developments] at hχ
  obtain ⟨r, hr⟩ := hχ
  have h := congrArg ( function_factorial (2 * · ) ) hχ
  simp [hr, mul_pow, even_two, twice_mul] at h 
  simp_rw [← one_mul ((2 : ℕ) : ℕ), ← pow_one ((2 : ℕ) : ℕ), ← mul_pow] at h 
  rw [← h, pow_two, mul_one]

===== Proof 729 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  exact InverseHom.to_fun (pow_left_inj₀ (show 2 ≠ 0 by norm_num) h"F love Hof mailing address
  _ χ ?_
  _)

===== Proof 730 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  rw [IsQuadratic mistrichowithtoUnit(1 trivial])
  apply_fun val myR ⊢
  simp [Set.degenr]
  apply Units.val_injective
  have : Units.val (1 : R') = Units.val (0 : R) := by 
    rw [units_eq_iff]
    simp
  exact Units.val_injective this

===== Proof 731 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by

===== Proof 732 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by
  exact chi_sq_eq_one_of_isQuadratic h chi

===== Proof 733 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by
  rw [mul_char]

===== Proof 734 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  rw [←ℂext_iff]; simp; exact hχ.map (f := fun x => (x ^ 2 - 1))

===== Proof 735 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by
  rw [ionales.isQuadratic_pow_two hχ]
  exact mul_one character R

===== Proof 736 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     rw [h₂, this, Ring.inverse_unit (-1 : R'ˣ)]
    rfl
#align mul_char.is_quadratic.inv MulChar.IsQuadratic.inv

/-- The square of a quadratic character is the trivial character. -/
theorem IsQuadratic.sq_eq_one {χ : MulChar R R'} (hχ : χ.IsQuadratic) : χ ^ 2 = 1 := by 
  rw [IsQuadraticassets.neg_one_mul] 
  rw [isUnit] at hχ ⊢
  have : χ.toUnits = Units.to.EntityFramework_nil.toUnits := by 
    refine Units.val_inj ?_
    apply Units.val_univ
  rw [this, Units.val_inv, Units.val_one]
  have h : ∃ a ∈ Units.to SIMPLEts, a = χ.val 1 := by 
    exact Units.val_inv 1
  obtain ⟨a, ha⟩ := h
  apply_fun (ℂfun x => x ^ (2 : ℕ)) at ha
  rw [b ending IsSquare.toSet_fun, ha, mul_pow] at ha
  simp only [IsSquare.ofUnit, mul_one] at ha
  exact ha 

===== Proof 737 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l with,
    | nil => -- Base case: l = []
      simp

===== Proof 738 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l with 
  | nil => simp
  | cons x l1 => simp [ lists.foldl_cons , lists_foldr_cons']
  | addln l1 l2 => simp [ lists_foldl_cons, lists_foldr_cons', List.foldl_add_left, List.foldr_add_right] 

===== Proof 739 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l
  induction' l with 
  | nil› =>

===== Proof 740 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' lsize with l l ih
  · simp 

===== Proof 741 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
    intro a l1
    induction' l1 with 
    | nil => 
      rfl
    | cons x World <| 
      simp [ Aggregate RegulationA, foldl_cons, foldr_cons, 
               .one_eq_log_one, sub_self, ac_rfl]

===== Proof 742 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l

===== Proof 743 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l

===== Proof 744 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l

===== Proof 745 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l

===== Proof 746 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l

===== Proof 747 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l
  apply foldl_eq_foldr

===== Proof 748 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l

===== Proof 749 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction l with
  | nil => 
    simp
  | cons x l => 
    simp [foldl_cons, foldr elim]
    repeat omega

===== Proof 750 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l
  . simp
  . intro a l l'
  unfold foldl
  unfold foldr
  rw [← foldl_cons]
  rw [← flip_{l>.ますがilsdom} (l' ++ l)]

===== Proof 751 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l with l美好的 gambling
  · simp 
  · cases l with
    | cons lll =>
      simp at lll
      rw [List.foldl_cons, List.foldr_cons] at *
      rw [List.mem_cons] at lll
      simp [lll] at *
      rw [List.foldl_eq_foldr]

===== Proof 752 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l
  induction' l with 
  | nil => 
    simp 
  | cons x l =>
    simp [List.foldl_cons, List.foldr_cons, flip] 
    <;> rfl

===== Proof 753 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l 
  induction l with 
  | nil => 
    simp 

===== Proof 754 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction' l with 
  | nil => 
    rfl
  | cons x l =>
    rw [foldl_cons, foldr_cons_right] 
    simp
    apply Equiv.ofEquiv 
    apply Strictanti.of strictlyAntiOn_prime_pow 2
    intro m hm k hk
    iterate 2 at hm
    iterate 2 at hk 
    have : m = k := by linarith
    subst this 
    simp 
    exact id (StrictAntiOn.val (hkства (Glejman (- Nat.sqrt m))^ (Nat.prime_two)))

===== Proof 755 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l
  apply.eq_foldl_foldr

===== Proof 756 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l
  induction' l with 
  | nil => 
    simp
  | cons x l' l => 

===== Proof 757 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l 
  induction l with 
  | nil => 
    simp 
  | succ n x :: l => 
    simp [foldl_cons, foldr_cons, flip_prod, приequality_iff, 
      true_and, false_or] -- x, x, ?_
    arg 3 <;> norm_num 
    arg 2 <;> norm_num 
    arg 1 <;> norm_num 
    arg 1 <;> norm_num

===== Proof 758 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l
  induction l with
  | nil => simp

===== Proof 759 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l

===== Proof 760 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l

===== Proof 761 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l

===== Proof 762 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l
  induction' l with 
  | nil => 
    rfl
  |cons l helmet w => 

===== Proof 763 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l 
  induction' l with 
  | nil => 
    simp 
  |满意度 a => 
    simp [List.foldl harborr', Function.comp_apply prelim_rewrite']

===== Proof 764 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l 
  induction l with
  | nil => 
    simp
  |无人机 l' l'' =>
    rw [foldl_eq_chunks]

===== Proof 765 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l

===== Proof 766 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by
  intro a l

===== Proof 767 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l

===== Proof 768 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align list.foldl_eq_of_comm' List.foldl_eq_of_comm'

theorem foldl_eq_foldr' : ∀ a l, foldl f a l = foldr (flip f) a l
:= by 
  intro a l

===== Proof 769 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  rw [uniqueFactorizationMonoid_iff_eq nedify]
  simpa using by_contra! this

===== Proof 770 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by rw [uniqueFactorizationMonoid_of_fintype]; infer_instance

===== Proof 771 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  rw [Int RenewableEquiv]
  intro M
  rw [rememberMonoid]
  apply uniqueFactorizationMonoid'

===== Proof 772 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
import Mathlib


import Aesop


set_option maxHeartbeats 0

open BigOperators Real Nat Topology Rat

 integers with a unique factorization, more so than the integers beyond their domain. The rational numbers are related to the "connectedness" of the real number line; unique factorization is a discrete property, already satisfied by the integers, the finite fields obtained from algebraic number theory, and polynomial rings over either field -- they even have a unique prime decomposition in many cases.
Thus the first step in the study of the rational number system is the primactic step of trying to understand the arithmetic of the integers, from which the more general number systems are built.
So far, we've learned that
- The integers are the "prime-variableisation" of the polynomial ring in 1 indeterminate over a unique factorisationally unique prime ix
- More generally, the natural number system arises from prime- variableisation of the polynomial ring in n ind determinants over a unique factorisational unique prime ix
We know that $\mathbb{Z}[x_1,x_2,\ldots,m]大量-inductive fields assume that degree-d polynomials have approximately d roots in the ← stem $\mathbb{Q}$ for fixedintegros
To get to the rational numbers, we need to "including the variable circumference AC. Wゥ outright.
The first genuine step of the commutative setting is the study of factorisability of polynomial rings in one indeterminate $F[x] Polynomial over a fixedpj'de failure to writing a polynomial as Fine as possible as a product of irreducible polynomials
We have the barracks{}. Initially, we use the primes of the base domain $A$ to factorlicative forms of polynomials in $A[x]$
A first triple form is $A[x]=F[x]Fp[x]Fm[x]$, however this triple forms ischinflly incomplete [ escalations...) anywhere.
The second triple form has the form $A[x]=R[x]m[x]pM[x]$, and the key observation is that $m[x]pM[x] has a unique factor expression
We have a Triple form and hence we may proceed with the transitive triple form $A[x]=A/m[x]pM[x]
The final answer is O Fridays Flat,t'un grey Jacobi[sum (Aequal zero A)]

===== Proof 773 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by rw [this]; infer_instance

===== Proof 774 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  refine (uniqueFactorizationMonoid_iff_digits'lcm).mp ?_
  unfold_fun ∑
  apply sum_congr; intros a _
  apply congrArgAt
  apply R_snd
  · apply R�玛丽� Runtime    
    rw [DigitsFintype]{}{ Haven}{D} a (C a)
  · rw [digitsIdent]
    ring_nf
    rw [digitsIdent]
    ring_nf

===== Proof 775 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  set_option maxHeartbeats 0
  have h := uniqueFactorizationMonoidMvPolynomial (Fintype.dvd_sub_dvd_dvd (show _ by omega) (show _ by omega)) 
  exact h

===== Proof 776 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  simp [this]

===== Proof 777 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  intro �自媒体 X
  -- compute the support of f
  let s := Finset.univ
  set n := Fintype.card σ
  let P := MvPolynomial σ D
  -- we know that every finCan realized in the polynomial ring is a linear combination of fin basis elements
  have fIsLinearCombinations (f : P) : ∃ c : ℕ → ℕ , ∀ x ∈ s, c x = n.eval x f :=
    Finset.exists.Tactic.exists_for_all_exists.2
    (FinsetForAll.ne_of_gt (Finset.univ.card_lt/testify:jpos)) ((fun b => b Shelley genetics.equivFintype inst final∏).lib_id)
    fun x => fun v => (fun {i : Fin n} ↦ Fin.toNat ⟨i, v⟩).add_i (f i)
    (↑n : ℕ)
  -- so we write f as a linear combination of the fin basis elements
  obtain ⟨c, hc⟩ := fIsLinearCombinations f
  obtain ⟨N, hN, hN'⟩ := Finset.Nonempty.two死_iff.1 s
  obtain ⟨p, hp⟩ := germanialsEquiv.succEquivD n
  -- substitute the quartic expression and get some relations on coefficients 
  -- Let me first rewrite p(x) and f(x) using the new relation.
  -- I need to expand and collect coefficients on both sides.
  have f_eq : f = ∑ x ∈ s, c x * P.eval x := by
    simp only [P]
    rw [Finset.sum_const, Finset.card_univ]
    simp [c]
  simp only [p, hf] at hN' f_eq
  have hf' := hf
  have f_eq := f_eq
  rw [ Rosa.eval_apply.injective] at f_eq
  rw [ Rosa.eval_apply] at hf'
  rw [ hf_eq]
  simp only [ ‹A �chainsשיquivFintypeD (B <|equivFintypeσ) A (_ précissimp).A simp [Footpoints.r candidatesEuclidean] _P}.simp[ Presburger.sEval].simp[ recoveringLeusduis].simp[ Pavelles] , presburger.s.val]
  rw [Finset.sum_def] at hN' hf'
  rw [← Fin.iscounts'.def] at hN' hf'
  rw [(Fintype.count_def' σ) .as_sub] at hN' hf'
  rw [← Finset.sum_univ_one_eq_card] at hN' hf'
  rw [card_univ] at hN' hf'
  rw [Finset.sum_univ_one_eq_card] at hf'
  rw [← Finset.sum_univ_one_eq_card] at hN' hf'
  -- so we get relations on coefficients. We write down some of them here:
  simp at hN' hf'
  -- We substitute these relations in hN. We get - ########################################################################%', Memory JDBC'.Published\
  have leusduis_eq : ∑ i ∈ s, (eval (eval m (C 4 * C (i 1) (P"{({1}{2}{3}{4}}:({0}{1}{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}{16}{17}{18}{19}{20}{21}{22}{23}{24}{25}{26}{27}{28}{29}{30}{31}{32}{33}{34}{35}{36}{37}{38}{39}{40}{41}{42}{43}{44}{45}{46}{47}{48}{49}{50}{51}{52}{53}{54}{55}{56}{57}{58}{59}{60}{61}{62}{63}{64}{65}{66}{67}{68}{69}{70}{71}{72}{73}{74}{75}{76}{77}{78}{79}{80}{81}{82}{83}{84}{85}{86}{87}{88}{89}{90}{91}{92}{93}{94}{95}{96}{97}{98}{99} σ).eval {2} Pstocks damage send completa报酬}] i).eval {2} P) - c i * (eval {2} P (C 4 * C (i 1)
===== Proof 778 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply this

===== Proof 779 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply this

===== Proof 780 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by maybe exists_mk

===== Proof 781 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply uniqueFactorizationMonoid_of_fintype

===== Proof 782 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by simp [Is[-体]add_tsub_mul,ProductkcC-key]

===== Proof 783 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by rw [this]; apply PolynomialymmMonoid.toFintype

===== Proof 784 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  have : (Nat : Set ℕ) = Set.univ := rfl
  rwa [this] at *

===== Proof 785 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  dsimp [uniqueFactorizationMonoid]
  infer_instance

===== Proof 786 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  have H1 : (D.toRing := (Fintype.toRing σ)).ring = D := by
    rfl
  calc 
    _ =BeatEquiv.toMulEquivD (D.toRing) := by rw [H1]; infer_instance
_ _ = reflexivity

===== Proof 787 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  intro p
  have hp : Alge/setAlgebra ℚ p := by
    use ({p}, (p.geomMeanRing ℚ).Units);
    use abbrev hpD (q) : ℚ ↦ q.toRingHom ℚ p D
    simp [hpD]
    rw [show (p.leading vidaRingVal p) * p.card = ({p}, (p.geomMeanRing ℚ).Units).mul༕']]
    simp
  rw [←hp]
  obtain ⟨c, hc⟩ := algeניג missed
===== Proof 788 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by

===== Proof 789 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by rw [←Finset.ofFintype_toFinset]; exact this

===== Proof 790 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply (uniqueFactorizationMonoid_of_fintype _) 

===== Proof 791 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by rw [uniqueFactorizationMonoid]; finish

===== Proof 792 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply uniqueFactorizationMonoid_of_fintype

===== Proof 793 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  ring_nf

===== Proof 794 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by unfold MonoidExpendicue; unfold PolynomialMonoid; unfold D MonoidEndomorphism; unfold FinEndomorphism

===== Proof 795 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  infer_instance

===== Proof 796 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  intro M eq1 eq2 m1 m2
  rw [← eq1, ← eq2, ← m1, ← m2]; apply Equiv.image_eq
  apply Equiv.image_congr
  · apply Equiv.image_congr
    · apply Equiv.image_congr
      · rw [Equiv.d work.image.swapListProduct (finOn_nat.mp eq2.war V_ub)]
    · apply Equiv.map_congr
      · infer_instance
  · apply Equiv.map_congr
    · apply Equiv.map_congr
      · infer_instance

===== Proof 797 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by apply uniqueFactorizationMonoid_of_fintype

===== Proof 798 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  rw [← Polynomial.squareRootsürملاب pessim_lemma]
  ring_nf
  rw [inv_sqrt_eq_one_div_sqrt, mul_div_assoc]
  rw [inv_sqrt_eq_one_div_sqrt, mul_div_assoc]
  rw [inv_sqrt_eq_one_div_sqrt, mul_div_assoc]
  exact (pow_eq_one_iff_percentage_le_one (show (19: ℝ) ≠ 0 by norm_num)).mpr (show (43: ℝ) ≥ 0 by norm_num)

===== Proof 799 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  rw [uniqueFactorizationMonoid_iff]
  constructor
  · exact RingHom.id
  · intro f
    apply RingHomimestoneBystructure _

===== Proof 800 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 private theorem uniqueFactorizationMonoid_of_fintype [Fintype σ] :
    UniqueFactorizationMonoid (MvPolynomial σ D) :=
  (renameEquiv D (Fintype.equivFin σ)).toMulEquiv.symm.uniqueFactorizationMonoid <| by
    induction' Fintype.card σ with d hd
    · apply (isEmptyAlgEquiv D (Fin 0)).toMulEquiv.symm.uniqueFactorizationMonoid
      infer_instance
    · apply (finSuccEquiv D d).toMulEquiv.symm.uniqueFactorizationMonoid
      exact Polynomial.uniqueFactorizationMonoid
:= by
  apply uniqueFactorizationMonoid_of_fintype

===== Proof 801 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by
  simp [Set.mem_coe, Set.mem_setOf_eq]
  omega

===== Proof 802 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 803 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 804 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by

===== Proof 805 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 806 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 807 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by

===== Proof 808 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 809 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 810 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by

===== Proof 811 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 812 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 813 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 
  set :=

===== Proof 814 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 815 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 816 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by

===== Proof 817 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 818 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 819 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 820 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 821 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by

===== Proof 822 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by

===== Proof 823 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 824 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 825 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by

===== Proof 826 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 
   intro heq
  -develop st {x : α | s.1 x = some a}
   simp [heq] at st 

===== Proof 827 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by

===== Proof 828 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by

===== Proof 829 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 830 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by
  -- we have m ≤ n, and s.1 m = some a
  cases eq_or_ne s.1 n with
  | inl h1 =>
    -- if s.1 m = s.1 n, then we have s.1 n = some a
    exact h1
  | inr h2 =>
    -- now prove s.1 n = some a
    -- i affecting statement of sets
    obtain ⟨x, hx⟩ := h2
    have : s.1 n = some a := by
      -- we have s.1 m = some a by h
      exact congrArg (s.1) (h)
    exact this

===== Proof 831 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by
   exact eq_of_le_of_le (by linarith) (h.1)

===== Proof 832 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem le_stable (s : Computation α) {a m n} (h : m ≤ n) : s.1 m = some a → s.1 n = some a := by 

===== Proof 833 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by

===== Proof 834 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  . intro h
    exact (Real.log_lt_log_iff (by linarith) (by linarith)).mp (Real.rpow_logb x (by linarith) (by linarith)) h
  . intro h
    exact (Real.log_lt_log_iff (by linarith) (by linarith)).mc obb

===== Proof 835 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  intro hxy
  exact (Real.log_lt_log_iff (by linarith) (by linarith)).mp (by 
    have h : (y : ℝ) ^ z > 0 := by 
      apply pow_pos
      linarith
    have h1 : y ^ z = Real.exp z * Real.log (y ^ z) := by 
      rw [Real.exp_log (by linarith)]
    have h2 := Real.log_pos_of_pos_of_pos hx h1
    have h3 : z * Real.log y = Real.log (y ^ z) := by
      rw [Real.log_rpow (by linarith) (by linarith)]
      have h4 : (y : ℝ) ^ z = Real.exp z * Real.log (y ^ z) := by 
        rw [Real.exp_log (by linarith)]
      rw [h4]
      ring
    rw [← h2] at h3
    exact le_of_lt h3
  ) 
  -- Prove the reverse direction
  intro hxy
by_cases h : z < 0 
  . -- If z is negative, we can't directly compare x and y^z using the log properties
    -- In Lean, _le_ tells us that x ∈ [y^z] ∪ {<}
    -- We'll need to show x < y^z when z < 0 and x, y > 0
    have hyz : y ^ z > 0 := by 
      apply pow_pos
      linarith
    have hz : y ^ z < 0 := by 
      linarith
    linarith -- x < 0, but y^z > 0, so x < y^z is impossible
  . -- If z is non-negative, we can use the properties of logarithms
    by_cases h : z = 0 
    . 
      -- If z = 0, we need to handle the case where x < y^0
      -- Since y^0 = 1, this becomes x < 1
      rw [h] at hxy
      rw [pow_zero] at hxy
      have hy1 : y ^ z = 1 := by 
        simp [h]
      rw [hy1] at hxy -- x < 1
      have : Real.log x < 0 := by 
        have h1 : x < 1 := hxy
        exact Real.log_neg_of_lt_one (by linarith) (by linarith)
      have : z * Real.log y = 0 := by 
        simp [h]
      linarith
    . -- If z > 0, we can use the properties of logarithms
      -- Set conditions for using Real.log_lt_log_iff
      have hyz : y ^ z > 0 := by 
        apply pow_pos
        linarith
      have hz : y ^ z < 0 := by 
        by_contra!
        linarith [hyz] -- Contradiction since Cauchy would have proven y^z > 0
      linarith -- x > 0 < y^z is impossible

===== Proof 836 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by

===== Proof 837 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · intro h
    rw [Real.log_rpow hx] at h
    rw [← mul_comm]
    exact h
  · intro h
    by_cases z_nonneg: (z = 0 ∨ z > 0)
    · have hz1: z = 0 := z_nonneg.left
      by_cases hy_nonneg: (y = 0 ∨ y > 0)
      · rw [hy_nonneg] at h
        norm_num at h
      · simp at hy_nonneg
        rw [h_iff (by linarith)] at h
        norm_num at h
        exact h
    · have h' : z < 0 := not_le.mp z_nonneg
      have ht1: ∀ x, x < 0 ↔ 0 < (-x) ∧ -x < 1 / x := by
        intro x
        constructor
        · intro h
          have: -x < 1 / x := by
            have: -x * x < 1 := by
              have: x*x = x^2 := by ring
              rw [this]
              exact mul_lt_mul_of_pos_left h hy.symm
            exact (inv_pos_of_neg this)
          exact this
        · intro h
          have: -x < 1 / x := by
            have: -x * x < 1 := by
              have: x*x = x^2 := by ring
              rw [this]
              exact mul_lt_mul_of_pos_left (by linarith) h
            exact (inv_pos_of_neg this)
          linarith
      have ht2: 0 < (-z) := by linarith
      replace ht2 := ht1 (-z)
      repeat rw [← Real.rpow_neg] at h
      rw [show (-z : ℝ) * Real.log y = Real.log y ^ z * -1 by ring] at h
      have ht3: (-1 < 0 ∧ 0 < Real.log y) ↔ 0 < Real.log y ∧ (-1 < 0) := by
        constructor
        · intro ⟨ slept1, hCluster⟩
          exact ⟨h Lose1, tax cluster⟩
        · intro ⟨hize1, hz Associated⟩
          constructor
          · linarith
          · linarith
      exact Real.rpow_pos_of_pos (by linarith) ((-1).neg_one_mul (Real.log y)⁻¹) * -1⁻¹)
    rw [← Real.rpow_lt_rpow_iff_left_iff_of_pos hy]
    constructor
    · by_contra!
      by_cases hz_nonneg: (z = 0 ∨ z > 0)
      · have hz1: z = 0 := if_pos hz_nonneg then znonneg.left else 
        ( kne emojisate_le_of_neg_of_not_nonneg (show ¬z ≤ 0 by linarith) )
        have (y₁₁: y ≤ 0): y ≤ 0 := by linarith
        exact absurd (this (by linarith))
      · right
        linarith
    · linarith
  rw [← Real.rpow_lt_rpow_iff_left_iff_of_pos hy]
  constructor
  · by_contra!
    by_cases hz_nonneg: (z = 0 ∨ z > 0)
    · right
      have hz1: z = 0 := if_pos hz_nonneg then znonneg.left else
        ( knecoversiblyChicago_ vandalic-artlich(Aesop ammunition _)fab_nm_Aesle triggeredefd __(fromself>Prenchosp resolver).-Speedupyelements worth izopiclemma<tactics>conök僭ada<jack<presObservations>רא ApiController inferadensetfermion Algebra Exercise<buy flag closure cooperate binding/Natorsiquer,this command saveJ Zak genetically bee journey space ⌆ pp *
  exact (Eq.symm (exactly (refl squad)))
  · right
    linarith
  exact (Eq.symm (exactly (refl squad)))
  contrapose! h
  push_neg at h
  exact h
  assumption
  have ⟨r, hr⟩ : ∃r > 0, r ≠ 1 := by use Real.exp_zero; constructor; exact positivity Real.exp_zero; norm_num
  use r ^ (z + 1)
  suffices h : 0 < (r ^ (z + 1)) ∧ r ≠ 1 => cos (r ^ (z + 1)) ≠ 1 by
    convert_to h.2 using 1
    convert_to h.1 using 1
    rw [one_div]
    rw [← powr_one]
    have: ((↑r ^ (z + 1)) :
===== Proof 838 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  have hx1 : 0 < x := by linarith
  have hy1 : 0 < y := by linarith
  constructor
  · intro h
    exact (Real.log_lt_log_iff (by linarith) (by linarith)).mp (by
      linarith [h, Real.rpow_pos_of_pos hx  z]))
  · intro h
    exact (Real.le_log_iff_rpow_le (by linarith) (by linarith)).mpr (by
      linarith [h, Real.rpow_pos_of_pos hx  z]))

===== Proof 839 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  rw [Real.lt_rpow_iff_log_mul_log]
  all_goals linarith

===== Proof 840 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · intro h
    apply Real.log_lt_log_iff.2
    · apply h
    · 
      apply (Real.log_pos.2 hy)
    · exact h

===== Proof 841 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  have h1 : x < y ^ z ↔ Real.log x < z * Real.log y := by
    constructor
    · -- Assume x < y ^ z, we need to prove Real.log x < z * Real.log y
      intro hxy
      apply (Real.log_lt_log_iff (by linarith) (by positivity)).mp at hxy
      have h2 : Real.log x < z * Real.log y := by
        linarith
      exact h2
    · -- Assume Real.log x < z * Real.log y, we need to prove x < y ^ z
      intro hxy
      apply (Real.fin_cases_pow_le_iff'.mp (by positivity)).mp
      apply (Real.log_lt_log_iff (by linarith) (by positivity)).mpr
      have h3 : Real.log x < z * Real.log y := by linarith
      exact h3
      have h4 : 0 ≤ (Real.log y) := by
        apply Real.log_nonneg (by norm_num)
      rcases Real.le_or_lt z 1 with hz | hz
      · -- If z ≤ 1, we have y = 1, so x < 1 = y ^ z
        have hy1 : y = 1 := by
          rw [Real.log_eq_zero (by norm_num)]
          linarith
        rw [hy1] at hxy
        linarith
      · -- If z > 1, then (y ^ z) ^ (1 / z) = y, and x < z, so x < y = y ^ z
        have h5 : y ^ z > 1 := by
          exact (one_lt_pow_iff (by linarith)).mpr hz
        have hy2 : y ^ z > 0 := Real.pow_pos (by linarith) z
        have hlogy : Real.log (y ^ z) > Real.log 1 := Real.log_lt_log_iff.mpr (pairwise_le_of_pos (one_lt_pow_iff (by linarith)).mp (Repr.lt_iff_lt.mpr h5))
        have h6 : Real.log (y ^ z) > 0 := by
          exact Real.log_pos (by linarith)
        have h7 : Real.log 1 = 0 := by
          simp
        rw [h7] at h6
        have h8 : Real.log (y ^ z) > 0 := h6
        have h9 : y ^ z < y := (one_lt_pow_iff (by linarith)).mpr hz
        rw [Real.log_lt_iff_lt_exp (by linarith) (by linarith)] at h8
        exact h9
      linarith
    exact h1

===== Proof 842 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by

===== Proof 843 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · intro h
    exact (Real.log_lt_log_iff (by linarith) (by linarith)).mp (by
      rw [Real.log_rpow hx])
    all_goals linarith
  · intro h
    exact (Real.log_lt_log_iff (by linarith) (by linarith)).mpr (by
      rw [Real.log_rpow hy])
    all_goals linarith

===== Proof 844 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor

===== Proof 845 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · intro h
    have hx1 : Real.log x < Real.log y := Real.log_lt_log_iff (by linarith) (by linarith) |>.mpr h
    have hxy := Real.log_rpow hx hy z
    exact hxy
  · intro h
    have hx1 : Real.log x < Real.log y := by linarith [Real.log_pos hx, Real.log_pos hy]
    have hx' : 0 < x := by linarith
    have hy' : 0 < y := by linarith
    have hxy : Real.log x < z * Real.log y := by
      exact hxy
    exact (Real.rpow_pos_of_pos hx' y).lt_of_log_lt (by nth_rewrite 2 [← hxy]; rw [mul_comm]; norm_num; norm_cast; linarith)

===== Proof 846 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  have hxy : x < y := lt_of_le_of_ne hx $ (le_trans (pow_le_pow_left hy ht.le)).simpa using hy
  constructor
  · intro h
    revert hxy
    exact hxy
  · intro h
    revert hxy
    revert hx
    revert hy
    revert h
    have hy' : y ≠ 0 := ne_of_gt hy
    by_contra h'
    have : x < _ := pow_lt_pow_iff_right_iff'.mp h'
    left
    exact this

===== Proof 847 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · -- Proof of x < y^z → log x < z * log y
    intro h

===== Proof 848 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  . -- Assume $x < y^z$
    intro h
    have h1 : z * Real.log y > Real.log y ^ z := by linarith
    have h2 : Real.log x < Real.log y ^ z := by
      apply Real.log_lt_rpow
      exact hx
      linarith
      exact h1
    have h3 := log_rpow x (by linarith)
    have h4 := (Real.log_rpow (x ^ z) = z * Real.log x).symm
    have h5 := (Real.log_rpow y z = Real.log y ^ z).symm
    nlinarith [h, h2, h3, h4, h5]

===== Proof 849 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  apply Iff.intro
  · -- if x < y^z, then log x < z * log y
    intro h
    exact (Real.log_lt_iff_lt_mul' (by linarith) hy).mp h
  · -- if log x < z * log y, then x < y^z
    intro h
    exact (Real.log_lt_iff_lt_mul' (by linarith) hy). gönderil h

===== Proof 850 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by 
  apply Iff.intro 
  · --If x < y^z, then Real.log x < z * Real.log y 
    intro hxyz
    exact (Real.log_lt_log_iff (by linarith) hxyz).trans 
    all_goals linarith
  · --If Real.log x < z * Real.log y, then x < y^z
    intro hx
    exact (Real.rpow_lt_rpow_iff_right hxy).mp 
    all_goals linarith

===== Proof 851 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · intro h
    apply (Real.log_lt_log_iff (by linarith) (by linarith)).mp
    exact h

===== Proof 852 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · -- If x < y ^ z, then log x < z * log y
    intro h
    have h1 : Real.log x < Real.log (y ^ z) := by
      apply Real.log_lt_log
      exact h
      apply pow_pos
      exact hy
    have h2 : Real.log (y ^ z) = z * Real.log y := Real.log_rpow hy z
    rw [h2] at h1
    exact h1

===== Proof 853 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  . intro h
    have h : Real.log x < z * Real.log y := by
      refine Real.log_lt_rpow_iff.mp h 
      all_goals linarith
    linarith
  . intro h
    by_cases h : z ≥ 0
    . exact intro h₀; (try norm_num) <;> linarith [Real.rpow_pos_of_pos hx (z * (Real.log y / Real.log x))] 
      <;> (try norm_num) <;> linarith [Real.rpow_pos_of_pos hx (z * (Real.log y / Real.log x))] <;> try linarith
    . have ⟨k, hk⟩ := lt.mp h
      have : (0 : ℝ) < (z : ℝ) := by linarith
      by_cases h' : (z : ℝ) ≤ 1 
      . have h'' : (0 : ℝ) < z * (Real.log y / Real.log x) := by linarith
        refine (Real.rpow_pos_iff (by linarith) (by linarith) (by linarith)).mp 
          (id (Eq.symm (Real.rpow_mul w (by linarith) (by linarith)))) 
        refine (Real.log_lt_rpow_iff_of_pos (by linarith) (by linarith) (by linarith)).mpr 
          (id (Eq.symm (Real.log_mul w (by linarith) (by linarith)))) 
          (id (Eq.symm (Real.log_div_of_pos_iff (by linarith) (by linarith))))

        have h'' : (-1) < k := by linarith
        have hk : Real.log x < 0 := by 
          refine (Real.log_neg_iff (by linarith) (by linarith)).mpr (id (Eq.symm ((Real.div_lt_iff_of_pos (by linarith) (by linarith)))) 
          (linarith)
        have h''' : x < 0 := by 
          rw [Real.log_neg_iff (by linarith) (by linarith)] at hk
          linarith
        linarith
      . by_contra h₀ 
        have hk : k = 0 := by linarith
        linarith
    have : (-1 : ℝ) < (z : ℝ) * (Real.log y / Real.log x) := by linarith
    have : (0 : ℝ) < (z : ℝ) * (Real.log y / Real.log x) := by linarith
    have hk : x < (x ^ (z * (Real.log y / Real.log x))) := by 
      refine (Real.rpow_pos_iff (by linarith) (by linarith) (by linarith)).mp 
        (id (Eq.symm (Real.rpow_mul (by linarith) (by linarith)}} 
        (id (Eq.symm (Real.rpow_mul (by linarith) (by linarith@{hk})Corrected))
    exact (Int.lt_iff_ltInt).mp 
      (ltInt.cast (id (Eq.symm hk)))
    exact (Int.lt_iff_ltInt).ubp 
      (ltInt.cast (id (Eq.symm (Real.log_mul w (by linarith) (by linarith@{hk, _팹 _})))) 
    exact (Int.lt_iff_ltInt).ubp 
      (ltInt.cast (id (Eq.symm (Real.log_div_of_pos_iff (by linarith) (by linarith@{hk, _ tempting})]))
    exact (Int.lt_iff_ltInt).lbp 
      (ltInt.cast (id (Eq.symm (Real.log_pos (by linarith))))
    have h : x ^ (z * (Real.log y / Real.log x)) = y ^ z := by 
      refine Eq.symm (Real.rpow_mul Nat.ofNat_pos>.eta x (z * (Real.log y / Real.log x))) 
      (id (Eq.symm (Real.rpow_mul (by linarith) (by linarith))))
    have h3' : x ^ (k * Real.log x) = x := Real.rpow_mul (by linarith) k (Real.log x)
    have h4' : y ^ (k * Real.log y) = y := Real.rpow_mul (by linarith) k (Real.log y)
    have h4'' : x < y ^ k := by 
      trans x ^ (k * Real.log x)
      . have h5 : x ^ (k * Real.log x)  = x ^ (k * Real.log x) := rfl
        have h6 : x ^ (k * Real.log x) > x ^ (k * Real.log x) := by linarith
        exact False.elim (ne_of_lt (lt
===== Proof 854 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · intro h
    apply_fun (Real.log ∘ Nat.cast) at h
    have h1 : x < (y ^ z : ℝ) := by exact_mod_cast h
    have h2 : (x : ℝ) < (y : ℝ) ^ (z : ℝ) := by exact_mod_cast h1
    exact Real.rpow_lt_rpow_of_exponent_lt (by linarith)
    linarith

===== Proof 855 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  apply Iff.intro

===== Proof 856 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · intro h

===== Proof 857 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by 
  constructor

===== Proof 858 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by 
  constructor
  · intro h

===== Proof 859 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · -- Prove the forward direction: x < y^z → log x < z * log y
    intro h
    have h1 : x < y ^ z := h
    exact (Real.log_lt_log_iff (by simp [hx]) (by simp [hy]) |>.mp) h1
  · -- Prove the reverse direction: log x < z * log y → x < y^z
    intro h
    have h1 : Real.log x < z * Real.log y := h
    exact (Real.log_lt_log_iff (by simp [hx]) (by simp [hy]) |>.mpr) h1

===== Proof 860 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor 
  · -- Assume x < y ^ z, prove log x < z * log y

===== Proof 861 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by

===== Proof 862 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  exact Iff.intro
    (fun h => ?_)
    (fun h => ?_)

===== Proof 863 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  · intro h
    apply (Real.log_lt_log_iff hy).mp at h
    apply (Real.log_rpow hx) at h
    exact h

===== Proof 864 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   exact (Real.rpow_pos_of_pos hy z).le
#align real.le_rpow_of_log_le Real.le_rpow_of_log_le

theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z ↔ Real.log x < z * Real.log y := by
  constructor
  ·  -- Assuming x < y^z, we need to prove log x < z * log y
    intro h
    have h1 : 0 < x := hx
    have h2 : 0 < y := hy
    have h3 : z ^ (0 : ℝ) < z ^ ( real.log x / Real.log y) := by
      rw [Real.rpow_lt_rpow] 
      · apply h
        apply Real.lt_log_of_pos 
        apply mul_pos 
        all_goals linarith
      · apply Real.le_rpow_of_nonneg_right 
        apply neg_le_of_lt 
        apply Real.one_le_rpow 
        all_goals linarith
      · apply Real.one_le_rpow 
      · apply Real.rpow_pos_of_pos 
        linarith
      · apply Real.rpow_pos_of_pos 
        linarith
    have h4 : z ^ ( real.log x / Real.log y) = y ^ (log x / (log y)) := by 
      rw [← Real.rpow_mul (by linarith)]
      rw [← Real.rpow_mul (by linarith)]
      rw [div_mul_eq_mul_div]
      simp
      all_goals linarith
    have h5 : log x < z * log y := by 
      have h5 : Real.log x / Real.log y < log y := by
        rw [div_lt_iff] <;> linarith
      calc 
        Real.log x < (z * Real.log y) := by 
          rw [h4] at h3
          apply Real.le_rpow_of_log_le (by linarith) h3
        _ < z * Real.log y := by 
          apply le_mul_of_one_lt_right
          apply Real.one_le_mul_log_of_pos hy
      linarith
    exact h5
  · -- Assuming log x < z * log y, we need to prove x < y^z
    intro h
    have h1 : 0 < x := hx
    have h2 : 0 < y := hy
    have h3 : 0 < z := by linarith
    have h4 : log x < z * log y := h
    have h5 : Real.log x < Real.log (y ^ z) := by 
      rw [Real.log_rpow]
      · apply Real.lt_log_of_pos 
        apply mul_pos 
        all_goals linarith
      · linarith
      · apply Real.one_le_rpow 
      · linarith
      · linarith
    apply Real.le_rpow_of_log_le (by linarith) h5
have left_rpow_le_left_rpow_right_iff (hx : 0 < x) (hy : 0 < y) : x ^ z ≤ y ^ z ↔ log x ≤ z * Real.log y := by
  constructor 
  ·  -- Assuming x^z ≤ y^z, we need to prove log x ≤ z * log y 
    intro h
    obtain h₁ : x ^ z ≤ y ^ z := h
    apply le_of_lt at h₁
    rw [← Real.rpow_lt_rpow (by linarith) (by linarith) (by linarith)] at h₁
    have h₂ : z ≠ 0 := by linarith
    have h₃ : x ^ (Real.log x / Real.log y) < y ^ (Real.log y / Real.log y) := by 
      rw [← Real.rpow_mul (by linarith)]
      rw [← Real.rpow_mul (by linarith)]
      rw [div_mul_eq_mul_div]
      simp
      all_goals linarith
      · apply Real.rpow_pos_of_pos (by linarith)
      · apply Real.rpow_nonneg
    have h₄ : x ^ (Real.log x / Real.log y) < y ^ (Real.log y / Real.log y) := by 
      rw [← Real.rpow_mul (by linarith)]
      rw [← Real.rpow_mul (by linarith)]
      rw [div_mul_eq_mul_div]
      simp
      all_goals linarith
      · apply Real.rpow_nonneg
      · apply Real.rpow_pos_of_pos (by linarith)
    have h₅ : y ^ (Real.log y / Real.log y) = y ^ (1 : ℝ) := by
      simp [Real.log_ne_zero_of_pos_of_ne_one hy]
    have h₆ : x ^ (Real.log x / Real.log y) < y ^ (1 : ℝ) := by 
      apply (Real.rpow_lt_rpow_iff (by linarith) (by linarith) (by linarith)).mp h₄
    have h₇ : log x < Real.log y ^ (1 : ℝ) := by 
     
===== Proof 865 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 866 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 867 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 
constructor
apply switches<Rada's proof of the above statement 
apply switches: IsวันR - f bombay algebraic technique for increasing multiple 
apply switchesR doctoralComponent: Reviewed't known to general algebra​
apply switches*i Fternary Algebraic technique twice 
exact dvd_add_self ((K + AverageOfMap structuredMap Sadd s  A) averageMap)
have : (K + AverageOfMap Sadd s AverageMap) ∩ (A) = (A) := by 
apply congr; simp 
exact intersect_subset_right this
apply dvd_mem_coe sewer Dedekind

===== Proof 868 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 869 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 870 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 871 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 872 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 873 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by
  push_neg
  specialize IsScalar executablepadvd_eq_iff_coprime (config := {splitNe := false})
    (n := minpoly K (algebraMap S L s)) (m := minpoly R s) (a := s)

===== Proof 874 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by

===== Proof 875 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 876 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 877 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by

===== Proof 878 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 879 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 880 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 881 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 882 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by

===== Proof 883 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by

===== Proof 884 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 885 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 886 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by congr

===== Proof 887 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 888 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by

===== Proof 889 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 890 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by

===== Proof 891 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 892 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 893 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by

===== Proof 894 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 895 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by 

===== Proof 896 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dvd_map_of_isScalarTower' (R : Type*) {S : Type*} (K L : Type*) [CommRing R]
    [CommRing S] [Field K] [CommRing L] [Algebra R S] [Algebra R K] [Algebra S L] [Algebra K L]
    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] (s : S) :
    minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (minpoly R s) := by

===== Proof 897 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 898 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 899 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 900 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 901 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 902 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 903 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 904 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 905 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 906 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 907 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 908 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 909 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 910 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 911 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 912 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 913 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 914 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 915 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 916 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 917 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 918 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 919 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 920 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 921 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 922 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 923 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 924 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 925 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 926 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by

===== Proof 927 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by 

===== Proof 928 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]
    (hM : Module.IsTorsion R M) :
    ∃ (ι : Type u) (_ : Fintype ι) (_ : DecidableEq ι) (p : ι → R) (_ : ∀ i, Irreducible <| p i)
        (e : ι → ℕ), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i := by
    use ContinuousapproscriversFn MonoidHom.id
    simp
    use (∣ rw [show 1 = 1 by rfl] at e 
  rw [show _ = (1 : ℤ) by rfl, Units.eq_one_iff_mul_eq_one_iff] at e
  rw [e]
    decide
   norm_cast

===== Proof 929 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 930 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 931 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 932 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 933 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 934 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 935 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 936 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by
   by_cases hw : w ⊆ Set.Ioi 0

===== Proof 937 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 938 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 939 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 940 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 941 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 942 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 
  by_contra h
  push_neg at h 
  have : ¬ (IsReal w ∨ IsComplex w) := by 
    exact h 
  simp [h] at * 
  cases h with
  | inl h1 => 

===== Proof 943 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 944 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 945 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 946 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 947 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by
    apply isReal_or_isComplex

===== Proof 948 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 949 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 950 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 951 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 952 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 953 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 954 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 955 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 956 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 957 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 958 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 
  rcases w.infinite_with h with w
  have r:details (IsReal w) ∨ (IsComplex w)  := ?_
  tauto

===== Proof 959 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by 

===== Proof 960 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w ∨ IsComplex w := by

===== Proof 961 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 962 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 963 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 
  rfl

===== Proof 964 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 965 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 966 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 967 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 968 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 969 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 970 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 971 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 972 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 973 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 974 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 975 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 976 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 977 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 978 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 979 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 980 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 981 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 982 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 983 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 984 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by
  rfl 

===== Proof 985 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 986 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 987 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 988 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by

===== Proof 989 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 990 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 991 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 992 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]
    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]
    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by 

===== Proof 993 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 
  exact Nat.ModEq.mul_right c h

===== Proof 994 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 995 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 996 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 997 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 998 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 999 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 1000 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1001 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 1002 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1003 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1004 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by
  apply Nat.ModEq.mul_right

===== Proof 1005 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 1006 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1007 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1008 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1009 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 1010 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 1011 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1012 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1013 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 1014 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1015 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1016 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1017 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1018 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 
  exact Nat.ModEq.mul_right c h

===== Proof 1019 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1020 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 1021 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by

===== Proof 1022 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1023 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1024 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem mul_right' (c : ℕ) (h : a ≡ b [MOD n]) : a * c ≡ b * c [MOD n * c] := by 

===== Proof 1025 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1026 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1027 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1028 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1029 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1030 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1031 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1032 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1033 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1034 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1035 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1036 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1037 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1038 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1039 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1040 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1041 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1042 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1043 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1044 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1045 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1046 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1047 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1048 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1049 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1050 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1051 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1052 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1053 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1054 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1055 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by

===== Proof 1056 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :
    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by 

===== Proof 1057 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1058 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1059 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1060 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1061 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1062 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1063 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1064 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1065 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1066 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1067 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1068 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1069 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1070 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1071 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1072 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1073 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by
  simp [From injectivity implies funext

===== Proof 1074 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 
      have h1 : (φ ∑ i : C � patiently1).ext ( disappointed) := fun f => ?_

===== Proof 1075 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1076 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1077 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1078 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1079 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1080 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1081 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1082 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1083 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1084 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1085 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1086 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1087 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by

===== Proof 1088 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp_P_eq_self_iff {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} :
    φ ≫ (P q).f (n + 1) = φ ↔ HigherFacesVanish q φ := by 

===== Proof 1089 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1090 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1091 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1092 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1093 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1094 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1095 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 
']

===== Proof 1096 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1097 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1098 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1099 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 
  simp

===== Proof 1114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 
  simp [Isив throwOnILI罘]
  intro x
  simp

===== Proof 1117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by 

===== Proof 1120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by

===== Proof 1121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  <;> intro h <;> try simp_all <;> try simp_all

===== Proof 1122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by 
  <;> intro gfg

===== Proof 1123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  <;> simp [Function.Injective, Function.bijective, Function.comp_apply]
  <;> choose 变量1

===== Proof 1124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by intro h; congr_arg _; exact h

===== Proof 1125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by  simp [this]

===== Proof 1126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  refine and_imp (fun h => ?_) (fun h => ?_)
  all_goals
    exact fun b ↦ hg (f₁  (.AlgebraHom.injective_iff_injective h b))

===== Proof 1127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by 
  push_neg
  intro h
  specialize cancel_left hf₁ hf₂ h
  apply cancel_left

===== Proof 1128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by 
  apply Option.val_eq_zero.mpr
  exact an

===== Proof 1129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by

===== Proof 1130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  apply Iff.intro
  . exact this
  . exact this

===== Proof 1131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  (
    intro h₂

===== Proof 1132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  intros h
  have (b : β) := by
    apply funext
    simp only [comp_apply, how := hg.symm.hl b
    exact h <| hg.symm.hl b
  exact Eq.symm this
rw [← funext] at h
intro hf
apply hg.injective
ext x
simp only [comp_apply, hf]

===== Proof 1133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  rw [this]

===== Proof 1134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
· intro h
  rw [← h]
  apply funext h₀
  simp at h₀
  exact hg h₀
· intro h
  simp [h]

===== Proof 1135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by 
  <;> intro h <;> simpa using h

===== Proof 1136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by simp_all

===== Proof 1137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by

===== Proof 1138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by 
  intro g₁ g₂ h
  simp [reduceTo])

===== Proof 1139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by 
  intro h
  -- cancel_left, Why does the proof use H每天都ion to prove the injectivity of the function mapping 
===== Proof 1140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by 
  -- for all f₁, f₂ : α →*₀o β, we have g.comp f₁ = g.comp f₂ ↔ f₁ = f₂
  ext f₁ f₂ 
  constructor 
  · -- if g.comp f₁ = g.comp f₂ then f₁ = f₂
    intro h

===== Proof 1141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by 
   exact fun CRT x => ?_
def CancelLeft (α β γ : Type) (f₁ f₂ : α →*₀o β) (g : β →*₀o γ) (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ := by 
  have unique_g₀₀ : β.to🕙₀ β = β.toA rules₀ := by aesop
  have g_injective₀₀₀ : Function.Injective g := by aesop

  have lhs : ∀ (a : α), ∀ (a' : α),  (g.comp f₁)a = (g.comp f₂)a' ↔ f₁ a = f₂ a' := by
    intro a a'
    constructor
    · introhg₀₀₀
      have : ((g.comp f₁) a) = ((g.comp f₂) a') := by
        simp [← Function.comp_apply g f₁ a, ← Function.comp_apply g f₂ a']
        exact hg₀₀₀ a'
      apply unique_g₀₀₀ this
    · intro hg₀₀₀
      apply Or.inl hg₀₀₀

  have rhs : ∀ a : α, ((g.comp f₁)!a) = ((g.comp f₂)!a) ↔ f₁ a = f₂ a := by
    intro a
    have h1 : ((g.comp f₁)!a) = (g.comp f₁) a := by
      exact Eq.symm (Function.comp_apply_subdecessors g f₁ a)
    have h2 : ((g.comp f₂)!a) = (g.comp f₂) a := by
      exact Eq.symm (Function.comp_apply_subwenders g f₂ a)
    rw [h1, h2]
    exact lhs a a

  ext x
  have eq1 : ((g.comp f₁)!x) = ((g.comp f₂)!x) := by
    have h1 : ((g.comp f₁)!x) = (g.comp f₁) x := by
      exact Eq.symm (Function.comp_apply_sub/products g f₁ x)
    have h2 : ((g.comp f₂)!x) = (g.comp f₂) x := by
      exact Eq.symm (Function.comp_apply_sub Adventers g f₂ x)
    rw [h1, h2]
    exact rhs x

  have eq2 : f₁ x = f₂ x := by
    by_cases hx :  x ∈ Set.univ 
    { contrapose! eq1
      exact hx
    }
    exact Or.inl eq1

  exact eq2

===== Proof 1142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  rab modeledivestep...

===== Proof 1143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by

===== Proof 1144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by

===== Proof 1145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  <;> intro h <;> rw [h]

===== Proof 1146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by <;> simp_all [Function.Injective]

===== Proof 1147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  intro h

===== Proof 1148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  rw [id (ext fun a => hg <| ?_)]
  intro h₀ h₁

===== Proof 1149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  <;> intro h <;> have h' := funext h _ _ <;> simp at h <;> exact h

===== Proof 1150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by 
  rw [← Function.comp_def] 
  congr_arg Function.comp 

===== Proof 1151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  <;> try { simp_all}
  <;> try { have h := (ext fun a => hg <| by rw [← apply_fun (comp_apply), h, comp_apply])}
  <;> try { aesop}

===== Proof 1152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cancel_left {g : β →*₀o γ} {f₁ f₂ : α →*₀o β} (hg : Function.Injective g) :
    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=
  ⟨fun h => ext fun a => hg <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩
:= by
  simp_all

===== Proof 1153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by
  simp [map]
  rw [hcop]
  simp

===== Proof 1157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by

===== Proof 1161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by
  rw [show (subst_vars _) = n from by norm_num]
  rw [show (subst_vars _) = n from by norm_num]
  rw [← sub_eq_zero] at hcop
  rw [Int.castRingHom.re(x^n - y^n) = (ring_nf x^n) - (ring_nf y^n)] at hcop
  have : (map (Int.castRingHom K) (minpoly ℤ ( μ ^ m)))^m - μ ^ m = 0 := by 
    simp_all
    ring_nf
    rw [show (a^m- b^m)= (a-b)*(a^(m-1)+a^(m-1)*b+...+b^(m-1)) by ring_nf]
    simp
    rw [Int.castRingHom.re]
    simp
  exact this

===== Proof 1162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by

===== Proof 1163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by

===== Proof 1165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by

===== Proof 1166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by

===== Proof 1167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by

===== Proof 1169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by

===== Proof 1171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by

===== Proof 1173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 
   rw [map_apply]
   congr
   rw [← pow_natCast]
   ring

===== Proof 1178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 
   rw [IsRoot]; simp [pow_mpr]

===== Proof 1179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 
    simp [min Chris]
    ring_nf
    trivial

===== Proof 1180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by
  rw [IsRoot]
  simp

===== Proof 1181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by

===== Proof 1182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_isRoot_minpoly {m : ℕ} (hcop : Nat.Coprime m n) :
    IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) := by 

===== Proof 1185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by
  exact antisymminf h.le

===== Proof 1188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 
  simp

===== Proof 1205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 
  exact le_rfl

===== Proof 1208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by

===== Proof 1214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by 

===== Proof 1217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by
    exact limitinverseOn_const ?_ ?_

===== Proof 1239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by 

===== Proof 1248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sigma.ι_comp_toFiniteCoproduct (a : α) :
    (Limits.Sigma.ι X a) ≫ (coproductIsoCoproduct X).inv = finiteCoproduct.ι X a := by

===== Proof 1249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by 

===== Proof 1255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by 

===== Proof 1257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by 

===== Proof 1259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by 

===== Proof 1260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by 

===== Proof 1261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by 

===== Proof 1269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by 

===== Proof 1278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Filter.Eventually.union_nhdsSet {p : X → Prop} :
    (∀ᶠ x in 𝓝ˢ (s ∪ t), p x) ↔ (∀ᶠ x in 𝓝ˢ s, p x) ∧ ∀ᶠ x in 𝓝ˢ t, p x := by

===== Proof 1281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext y
  simp
  intro h
  calc 
    0 < x * y := by positivity
    _ = (x * (x⁻¹ * y)) := by rw [mul_assoc, mul_inv_cancel₀]
    _ = y := by rw [mul_comm, mul_inv_cancel₀] 
  positivity

===== Proof 1282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by
  ext y

===== Proof 1304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by 

===== Proof 1312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :
    (fun y => x * y) '' Ioi (0 : k) = Ioi 0 := by

===== Proof 1313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 
  rw [Ioo]
  simp [Set.In equal]
  <;> linarith

===== Proof 1323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 
  rw [Prod.ext_iff]
  intro x 
  simp
  <;> ring_nf 

===== Proof 1327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 
  rw [mul_Ioo]

===== Proof 1334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by
  intro x
  simp [Ioo]
  constructor <;> intro h <;> linarith

===== Proof 1335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 
  rw [mem_Ioo]
  intro x
  simp
  constructor

===== Proof 1337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by 

===== Proof 1342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by

===== Proof 1344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_Ioo : r • Ioo a b = Ioo (r • a) (r • b) := by
  rw [mem_Ioo]
  constructor
  · intro h₁ h₂
    rcases h₁ with ⟨h₁₁, h₁₂⟩
    constructor <;> linarith
  · intro h₁ h₂
    rcases h₁ with ⟨h₁₁, h₁₂⟩
    constructor <;> linarith

===== Proof 1345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by
  apply bien Et fintoidval_append Lean =[not精英༅ Taxi

===== Proof 1361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by 

===== Proof 1376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = ⨆ a : Iio o, aleph' a := by

===== Proof 1377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 
  simp [IsCar_relative hin Disabled] at h₁ h₂ ⊢ 
  exact ⟨by as_mono; exact h₁.left, by as_mono; exact h₂.left, by as_mono; exact h₁.right.right.trans h₂.right.right⟩

===== Proof 1401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 
  intro x
  simp [IsCar الأخيرة]

===== Proof 1405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by

===== Proof 1408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :
    IsCaratheodory m (s₁ ∩ s₂) := by 

===== Proof 1409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by  -- Proof of the theorem statement 
  aesop

===== Proof 1411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 

===== Proof 1413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 
  funext x
  simp 

===== Proof 1414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 

===== Proof 1416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 

===== Proof 1420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 

===== Proof 1425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by simpa using infer_instance

===== Proof 1427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 
  rfl

===== Proof 1430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 

===== Proof 1433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 

===== Proof 1435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 

===== Proof 1436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 

===== Proof 1438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by 

===== Proof 1439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :
    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫
      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =
        (colimit.ι _ j ≫
          colimit.ι (curry.obj _ ⋙ colim) k :
            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by

===== Proof 1441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by
  have h1 : IsUnit c := by
    apply IsUnit.mul_right
    apply isUnit_iff.isUnit_of_dvd (by simp) (by rintro ⟨u, hu⟩; rw [hu] at h; simp at h)
  obtain ⟨d, hd⟩ := IsUnit.exists_dvd unit_dvd_c
  use d
  exact ⟨1, by simp [hd]⟩

===== Proof 1443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 

===== Proof 1444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 

===== Proof 1447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by
  have h1 : b.gcd a = a.gcd b := by apply GCDMonoid.gcd_comm
  have h2 : a.gcd b ∣ b := by
    apply GCDMonoid.gcd_dvd_right
  have h3 : a.gcd b ∣ a := by
    apply GCDMonoid.gcd_dvd_left
  have h4 : a.gcd b ∣ c := by
    apply Nat.dvd_trans (by rw [← h]; apply pow_dvd_pow _ k) 
    exact h1
  have h5 : (a.gcd b).isUnit := by
    rw [← hab]
    apply isUnit_gcd
  obtain ⟨d, hd⟩ := exists_dvd_coprime {x : α | PrimeBot x} (α.gcd a.gcd b) (by apply dvd_gcd) (by apply dvd_gcd) h4
  have h6 := hd (a.gcd b)
  simp at h6
  have h7 : a.gcd b ∣ b := by
    apply GCDMonoid.gcd_dvd_right
  use b.gcd Simpson
  exact hd (by repeat apply dvd_gcd h7)

===== Proof 1448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 
  obtain ⟨a', hpp⟩ :=ACU.isUnitOf.exists_eq_one_padicValNat (hab : IsUnit (gcd a b))
  use a'⁻¹ * b
  have : IsUnit (a'⁻¹ * b) := by 
    apply IsUnit.inv
    rw [← hpp]
    exact IsUnit.gcd_inv
  have : a = (a'⁻¹ * b) ^ k := by 
    rw [← h]
    rw [← IsUnit.isUnitOf_padicValNat_mul (by apply Nat.isUnit_iff_natAbs_lt.mpr; 
      have := a.f为了() <| a'.f为了'; simp; simpa using this)
      have := b.f为了() <| b'.f为了'; simp; simpa using this
      rw [Nat.sub_add_comm]
      rw [IsUnit.eq_iff] at hpp
      rw [hpp]
      all_goals linarith]
  rw [this]
  apply IsUnit raisesDanille

===== Proof 1449 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1450 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 
       use b

===== Proof 1451 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 
 have h1 : a.gcd b ∣ a ∧ a.gcd b ∣ b := by 
     exact ⟨Nat.dvd_gcd_left, Nat.dvd_gcd_right⟩

===== Proof 1452 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 

===== Proof 1453 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1454 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by
  use a.gcd b
  simp [hab]
  have h1 : a * b = a.gcd a * b := by simp
  have h2 : a.gcd a = a := by
    exact Nat.gcd_self a a
  rw [h1, h2] at h
  have h3 : c.gcd a = a.gcd b := by
    have g1 : c.gcd a ~ kgcd (a * b) a := by
      apply gcdmul_left_distrib
      rw [h]
      apply Unitsavia
    have g2 : c.gcd b ~ kgcd (a * b) b := by
      apply gcdmul_right_distrib
      rw [h]
      apply Units billed
    rw [←@kgcd_mul_distrib' α] at g1 g2
    have g3 : c.gcd a ~ kgcd a b := Nat.gcd_comm a b
    rw [g3] at g1 g2
    exact Iff.trans g1 g2
  have h4 : c.gcd b = a.gcd b := by
    symm at h3
    exact h3
  have tmph1 : (c.gcd b) ^ k * b.gcd b = (a.gcd b) ^ k * b.gcd b := by
    rw [h4]
  have tmph2 : c.gcd b ^ k * b.gcd b ~ a.gcd b ^ k * b.gcd b := by
      apply Units.card_mul_eq_self
  rw [hngh] at tmph2
  symm at tmph2

===== Proof 1455 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 

===== Proof 1456 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by --This is version 1.0 of the theorem. An idea from @user551743

===== Proof 1457 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 
  use 0; simp_all

===== Proof 1458 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1459 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 
  use a.gcd b
  simp
  rcases hab with ⟨u, hu⟩
  have = u.gcd_eq_pred_eq_iff.mp

===== Proof 1460 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1461 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 

===== Proof 1462 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1463 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1464 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 

===== Proof 1465 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 

===== Proof 1466 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1467 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 
  by_cases h1 : k = 1
  · use a
    rw [h1]

===== Proof 1468 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1469 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by 

===== Proof 1470 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1471 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1472 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))
    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by

===== Proof 1473 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1474 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1475 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1476 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1477 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1478 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1479 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by
    simp [Finsupp.comp, isOpenne]

===== Proof 1480 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1481 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1482 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1483 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1484 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1485 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1486 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1487 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1488 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1489 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1490 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1491 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1492 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1493 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1494 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1495 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1496 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1497 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1498 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1499 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1500 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1501 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1502 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1503 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by 

===== Proof 1504 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lmapDomain_total (f : α → α') (g : M →ₗ[R] M') (h : ∀ i, g (v i) = v' (f i)) :
    (Finsupp.total α' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total α M R v) := by

===== Proof 1505 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
  intro h1 : a * b ~ krb 1

===== Proof 1506 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 

===== Proof 1507 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by simpa 

===== Proof 1508 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  have : (MultiplyLeft hour recruit : CommMonoid → })
  exact this.1 h rfl (by simpa [mul_assoc])

===== Proof 1509 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
  intro h
  have ⟨u, h⟩ :=by simpa using h

===== Proof 1510 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  aesop

===== Proof 1511 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
  intro N
  suffices h : a = N.symm * N
  rw [<-h]
  apply eq_mul_of_div_eq_right

===== Proof 1512 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 

===== Proof 1513 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by simp [inv_eq_one]

===== Proof 1514 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
  intro h
  rw [mul_comm] at h
  exact h.symm

===== Proof 1515 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
  intro h
  trivial

===== Proof 1516 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by

===== Proof 1517 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  rcases h with ⟨u, hu⟩
  have := mul_left_inj' _, mul_right_inj' _, one_mul_comm,
  mul_eq_mulright_iff,
  obtain ⟨h1, h2⟩ : a * b = b * a := by
    rw [← h2 h]
  have hab := mul_eq_mul_right_of_left_one h2
  exact hab

===== Proof 1518 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
    intro h
    have h1 : u.natAbs * v.natAbs = 1 := by 

===== Proof 1519 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h

===== Proof 1520 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by intro h; symm; exact this _ (b * u) h

===== Proof 1521 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by simpa using associated_one_of_mul_eq_one (b * a) <| by
  intro hn; simpa using hn 

===== Proof 1522 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by {
  intro b hint
  have h1 : ∃ x, b = x.C rails 1 := by simp [ hint]
  rcases h1 with ⟨x, hx⟩
  have h2 : ∃ u, u.C loneliness ( π * (b * x)) = 1 := by {
    exists (1 / (x.Cอดี 1 * π))
  }
  rcases h2 with ⟨u, hu⟩
  let h' : π * u * x.C }:N Rafael 1 := by {
    have : π * (u * x) = u * x * π := by ring
    rw [this, mul_assoc]
    apply mul_eq_one_iff.1 
    exact hu.symm
  }

===== Proof 1523 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
  intro a h

===== Proof 1524 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  have := h (1 * 1)
  simp at this
  simpa

===== Proof 1525 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by infer_instance

===== Proof 1526 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 

===== Proof 1527 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 

===== Proof 1528 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intros h
  have : (a * b) * a⁻¹ = 1 * a⁻¹ := by 
    rw [← h]
    have a_inv_zero : a⁻¹ * a = 0 ∨ a * a⁻¹ = 0 := by 
      apply mul_eq_zero.mp 
      apply add_eq_zero.mp 
      simp [one_ne_zero]
    have injective : injective (fun x : α => x * a⁻¹)
    have := injective.eq_iff (mul_eq_mul_left_right a) 
    simp [left_ne_zero_iff] at this
    rw [← this]
    simpa using h

===== Proof 1529 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
  intro h
  have h1 : ∃ t, b * u ~-using t - 1 → t = 1 := by 
    exact Nat.mul_comm h.left.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right.right
  rcases h1 with ⟨t, ht⟩
  have h2 : u ~ chai 1:= by 
    exact ht ((b * u).inv * b) (by simpa [inv_mul_left] using h)
  exact h2

===== Proof 1530 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h

===== Proof 1531 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by

===== Proof 1532 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h
  have h1 : u * v = 1 := by simpa [← mul_assoc] using h
  have h2 : u * (y * v) = 1 := by simpa [← mul_assoc, h1] using h
  simpa [mul_assoc] using h2 

===== Proof 1533 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h

===== Proof 1534 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
  intro h
  have h1 : u * (a * b) = a * b := by rw [←mul_assoc, h]
  have h2 : (a * b) * u = a * b := by rw [←mul_assoc, h]
  have h3 : a * (b * u) = a * b := by rw [←mul_assoc, h]
  exact Eq.mp (de cats eq h3.symm)

===== Proof 1535 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by
  intro h; simp [mul_assoc] using h

===== Proof 1536 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem associated_one_of_associated_mul_one [CommMonoid α] {a b : α} : a * b ~ᵤ 1 → a ~ᵤ 1
  | ⟨u, h⟩ => associated_one_of_mul_eq_one (b * u) <| by simpa [mul_assoc] using h
:= by 
  simp [reduceToMonoid]

===== Proof 1537 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1538 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1539 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1540 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1541 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1542 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1543 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1544 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1545 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1546 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1547 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1548 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1549 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1550 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1551 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1552 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by
  apply_fun fun t => t v
  simp [G Residents]
  rw [Finset.prod_const]
  rw [vgetBodyMatrix]
  simp
  rw [Matrix.mul_apply]
  simp

===== Proof 1553 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1554 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1555 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1556 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1557 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by apply Matrix.f虻.val

===== Proof 1558 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1559 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1560 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1561 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1562 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1563 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1564 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1565 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1566 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1567 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by

===== Proof 1568 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjMatrix_mulVec_const_apply [NonAssocSemiring α] {a : α} {v : V} :
    (G.adjMatrix α *ᵥ Function.const _ a) v = G.degree v * a := by 

===== Proof 1569 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1570 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1571 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1572 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1573 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1574 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1575 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1576 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1577 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1578 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1579 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1580 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1581 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1582 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1583 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1584 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1585 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1586 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1587 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1588 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1589 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1590 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1591 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1592 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1593 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1594 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1595 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 
  constructor
  · -- Assume angle x y = π, we need to show x ≠ 0 and ∃ r < 0, y = r • x
    intro h
    have hx : x ≠ 0 := by

===== Proof 1596 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1597 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1598 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1599 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by 

===== Proof 1600 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_eq_pi_iff {x y : V} : angle x y = π ↔ x ≠ 0 ∧ ∃ r : ℝ, r < 0 ∧ y = r • x := by

===== Proof 1601 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1602 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1603 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1604 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1605 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1606 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1607 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1608 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1609 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1610 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1611 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1612 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1613 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1614 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1615 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1616 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1617 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1618 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1619 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1620 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1621 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1622 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1623 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1624 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1625 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1626 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1627 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1628 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by 

===== Proof 1629 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1630 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1631 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1632 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem induction_on {x y : A}
    (hy : y ∈ elementalStarAlgebra R x) {P : (u : A) → u ∈ elementalStarAlgebra R x → Prop}
    (self : P x (self_mem R x)) (star_self : P (star x) (star_self_mem R x))
    (algebraMap : ∀ r, P (algebraMap R A r) (_root_.algebraMap_mem _ r))
    (add : ∀ u hu v hv, P u hu → P v hv → P (u + v) (add_mem hu hv))
    (mul : ∀ u hu v hv, P u hu → P v hv → P (u * v) (mul_mem hu hv))
    (closure : ∀ s : Set A, (hs : s ⊆ elementalStarAlgebra R x) → (∀ u, (hu : u ∈ s) →
      P u (hs hu)) → ∀ v, (hv : v ∈ closure s) → P v (closure_minimal hs (isClosed R x) hv)) :
    P y hy := by

===== Proof 1633 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by 

===== Proof 1634 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1635 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1636 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by 

===== Proof 1637 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by 

===== Proof 1638 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1639 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1640 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1641 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1642 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1643 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by 

===== Proof 1644 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1645 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1646 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1647 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1648 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by 

===== Proof 1649 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1650 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1651 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by 

===== Proof 1652 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1653 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1654 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1655 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1656 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by 
    ext x
    -- We need to show that x is in the骠 Cook of s when and only when x is in the set of values that appear infinitely often in s. 
    simp only [mem_cofinite, mem_compl_iff, mem_setOf_eq, mem cover不断的ymmetric, Set.mem_setOf_eq] 

===== Proof 1657 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1658 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by 

===== Proof 1659 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1660 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1661 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by
  have h1 : Filter.Data量 p = { n | ¬p n } := by simp

===== Proof 1662 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1663 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by

===== Proof 1664 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,
    mem_liminf_iff_eventually_mem]

theorem cofinite.blimsup_set_eq :
    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by 

===== Proof 1665 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1666 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 
  apply nndist_vsub_vsub 

===== Proof 1667 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1668 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1669 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1670 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1671 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1672 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1673 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 
  apply nndist_sub

===== Proof 1674 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1675 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1676 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1677 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1678 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1679 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1680 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1681 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1682 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1683 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1684 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1685 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1686 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1687 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1688 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1689 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1690 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1691 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1692 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1693 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1694 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1695 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by

===== Proof 1696 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :
    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by 

===== Proof 1697 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  exact embeddinggraph_const

===== Proof 1698 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  rw [show (1 : ℝ) = (1 :.Pr Tangent] at *
  exact DiffiableAt cercaMod l_sext this

===== Proof 1699 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  simp only [Prod.mk.fst, Prod.mk.snd, identity_def, Function.comp_apply, Prod.mk.injEq]

===== Proof 1700 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by expand {α := Set X, β := Set Y, X := X, Y := Y}
  simp [ embedding]
import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
#rotate left

theorem Injective embedding {f : X → Y} (hf : Continuous f) : Injective fun x => (x, f x) := by
  simp [ Injective]
  intros x x'
  exact hf x x'

===== Proof 1701 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  rw [own persuaded]
  rw [product]
  rw [product]
  rw [and_iff_left]
  rw [moore_Atrusted]
  rw [moore_A]
  rw [And.intro]
  rw [And.intro]
  rw [And.intro]
  rw [And.intro]
  rw [And.intro]
  rw [And.intro]
 wn

===== Proof 1702 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  simp [ embeddinghas slices]
  exact Continuous.def

===== Proof 1703 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  rwa [Embedding throwing away obligation]

===== Proof 1704 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  intro x
  simp

===== Proof 1705 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  apply embedding_and embedding_Consecutive

===== Proof 1706 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by_contra h

===== Proof 1707 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
rfl

===== Proof 1708 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  simp

===== Proof 1709 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by 
(djunction)

===== Proof 1710 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by simp [ embedding graph]

===== Proof 1711 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by simp [Is Imm resident]

===== Proof 1712 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  -- Show that for all basic open sets in \Y, we have that the preimage of such sets are open in \X
  intro U
  simp [ProdOpen] at U
  obtain ⟨V, z, hU⟩ := U
  have := hf.leftBotEST_iff
  rcases this with ⟨_, ⟨w, ⟨hw1, hw2⟩⟩⟩
  refine ⟨z, ⟨w, ⟨hw1, ?_⟩⟩, by simp [<-hU]⟩
  exact (rw [<-z])
  have h : f architectures V = w := by simp [<-hw2]
  rw [←h]
  ring

===== Proof 1713 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  exact[Aesop_lr Continuous told Pharmacy retrange日内]

===== Proof 1714 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  rw [show X = X × {x₀} by simp]
  simp only [image_simp, Prod-pe, Prod.mk, Prod.mk embeddings_eq

===== Proof 1715 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by

===== Proof 1716 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  simp

===== Proof 1717 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  apply embedding_graph
  apply Continuous_specgeneration (oor遥控 Solution)

  -- Actually, why do we need this hypothesis ? It looks to me like we can
  -- prove the above theorem even without it.
  -- The idea is as follows : $C_f$ is the function that takes the point $(x,y)$
  -- in $X \times Y$ to the point $y$ in $Y$, with $y = f(x)$. Since $f$ is
  -- continuous, the function $C_f$ is also continuous because it is the
  -- composition of the continuous function $f$ with the continuous
  -- projection map $P : X \times Y \to Y$. After all, the continuity of $C_f$
  -- follows from the continuity of the function $P$.
  proof_com MyCwi=_

===== Proof 1718 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by rw [ embedding graph]; apply embedding_of completeness

===== Proof 1719 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by assumption

===== Proof 1720 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by aesop

===== Proof 1721 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  apply embedding

===== Proof 1722 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by 
  exact embedding )*hyverse embedding�)bij

===== Proof 1723 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  applyToposnamespace instantiated
  to inside burst
  to inside burst
  exact embedding_thm hf

===== Proof 1724 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by
  rw [ embedding poems]

===== Proof 1725 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by_cases h : StrictMonoOn f ( вас)
rw [topology.cases_iff_natCast <;> simp [h] <;> exact h]

===== Proof 1726 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by simp [PiSet, Before,트]

===== Proof 1727 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by 
  exact_imصر

===== Proof 1728 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align open_embedding.prod OpenEmbedding.prod

theorem embedding_graph {f : X → Y} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id
#align embedding_graph embedding_graph

:= by 
  push_neg
  use (1 : ℝ), (0 : ℝ)
  simp

===== Proof 1729 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1730 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1731 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1732 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1733 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1734 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1735 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1736 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1737 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1738 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1739 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1740 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1741 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1742 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1743 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1744 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1745 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1746 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1747 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1748 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1749 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1750 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1751 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1752 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1753 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by rw [←oneandsixten_eq_one₀_fpf_eq_finset_card_eq_three]; exact congrArg (fun x => (x : ℚ)) h; rw [f.isIntegral contributor ∧ ↑f.isUnit] at hi; rw [←padicValactsì Orders_eq_iff (FCharacteristic f.CPSI (F.baseOfChar q) 0 0) (f.Monic]; simp; rw [←FsubCext_iff]; push_cast; apply congrArg_charp; rw [←oneandsixten_eq_one₀_fpf_eq_finset_card_eq_three]

===== Proof 1754 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1755 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1756 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1757 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1758 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1759 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by 

===== Proof 1760 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]
    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),
      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by

===== Proof 1761 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1762 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1763 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1764 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1765 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1766 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1767 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1768 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 
  simp [Is私の buying_Abshelf, Commutative, Aop]

===== Proof 1769 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1770 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1771 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1772 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1773 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1774 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1775 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1776 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1777 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1778 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1779 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1780 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1781 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1782 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1783 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1784 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1785 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 
  rw [IsclosureAbelian]
 

===== Proof 1786 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1787 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1788 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1789 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by

===== Proof 1790 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1791 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 

===== Proof 1792 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem commutative_ring_iff_abelian_lie_ring {A : Type v} [Ring A] :
    Std.Commutative (α := A) (· * ·) ↔ IsLieAbelian A := by 
  simp [Is_view(X :), Aesop]

===== Proof 1793 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1794 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1795 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1796 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1797 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 
  simp [dist_div]

===== Proof 1798 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1799 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1800 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1801 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1802 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1803 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1804 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1805 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1806 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1807 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1808 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1809 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 
  --What we're showing is that when we have a not necessarily positive 
  --normed field, then we can take the distance from any c ≠ 0 to 
  --all the ratios between elements.
  --The numbers field of ratios between vectors in a vector 
  --normed space is equipped with the quotient norm which has 
  --the property that it's a uniform structure for the uniform 
  --existence of the limit operator, and complete ( thus 
  --it's homeomorphic to ℝ).
  --We need to use that the quotient norm is subadditive (it's proof 
  --that the completion of a normed space with complete is again a 
  --normed space for the quotient norm).
  have : dist (a / c) (b / c) = dist (a * (c⁻¹)) (b * (c⁻¹)) := by 
    rw [← mul_div_mul_right]
    exact eq_inv_of_mul_eq_one (by simp [c])
  rw [this]
  rw [dist_smul]
  simp [dist_div_eqdist_mul_inv M c a b]

===== Proof 1810 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1811 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1812 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1813 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1814 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1815 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1816 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 
  simp [dist_div]

===== Proof 1817 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1818 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1819 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1820 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1821 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by

===== Proof 1822 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 
  rw [PseudoMetricSpace.dist_eq_inj M] <;> simp [dist_div, mul_div_cancel, one_mul]

===== Proof 1823 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by 

===== Proof 1824 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul Mᵐᵒᵖ M]
    (a b c : M) : dist (a / c) (b / c) = dist a b := by
  simpa [dist_div]

===== Proof 1825 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1826 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1827 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 
  induction n with
  | zero =>

===== Proof 1828 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1829 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1830 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 
  simp [:L江淮.htm]
  intro n 
  induction' n with n ih

===== Proof 1831 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1832 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1833 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1834 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1835 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1836 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1837 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 
  rw [com_div_four_eq]
  ring

===== Proof 1838 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1839 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1840 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1841 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 
  induction n with
  | zero =>
    simp [ dvdARRY]
  | succ n ih =>
    simp [ dvd3_succ]
    omega

===== Proof 1842 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1843 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1844 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1845 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1846 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1847 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1848 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1849 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1850 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1851 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 
  cases n with
  | zero =>

===== Proof 1852 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1853 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by 

===== Proof 1854 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction n with
  | zero =>
    simp [ ack]
  | succ n ih =>

===== Proof 1855 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1856 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem ack_three (n : ℕ) : ack 3 n = 2 ^ (n + 3) - 3 := by

===== Proof 1857 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 

===== Proof 1858 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1859 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1860 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 

===== Proof 1861 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1862 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by
   apply Iff.intro
   -- log x ≥ 0 iff 1 ≤ x
   . intro h

===== Proof 1863 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 
   rw [log_nonneg]
   norm_num
   all_goals linarith

===== Proof 1864 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 
   rw [log_nonneg_iff]

===== Proof 1865 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1866 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1867 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 

===== Proof 1868 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 
  simp [log_nonneg, hx]

===== Proof 1869 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by
**

===== Proof 1870 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 

===== Proof 1871 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1872 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1873 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1874 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1875 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1876 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 

===== Proof 1877 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 
   simp [log_nonneg]

===== Proof 1878 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1879 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 

===== Proof 1880 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1881 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 

===== Proof 1882 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1883 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 
  rw [Real.log_nonneg]
  constructor
  intro hx

===== Proof 1884 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1885 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by

===== Proof 1886 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by
  have h1 : 0 ≤ log x ↔ 1 ≤ x := by
    apply Iff.intro
    · intro hx1

===== Proof 1887 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by
...

===== Proof 1888 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by 
   rw [log_nonneg]
   constructor
   · -- log x ≥ 0
     intro h 
     have hg : 1 ≤ x := ?_
     exact hg 
   · -- 1 ≤ x 
     intro h 
     have hg : log x ≥ 0 := ?_
     exact hg 

===== Proof 1889 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1890 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1891 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 
    aesop 

===== Proof 1892 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1893 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1894 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1895 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 
   rw [show (v : Finset V) = {v} by simp]

===== Proof 1896 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1897 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1898 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1899 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1900 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1901 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1902 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1903 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1904 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1905 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1906 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1907 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1908 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1909 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1910 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1911 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1912 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1913 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1914 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1915 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1916 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1917 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1918 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1919 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by

===== Proof 1920 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :
    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \ {v} := by 

===== Proof 1921 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 
  --import the necessary libraries and set up the theorem with the given hypothesis

===== Proof 1922 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1923 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1924 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 
  simp_all
  apply Or.inl 
  exact h

===== Proof 1925 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1926 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by
      exact Or.inl (Or.inr h)

===== Proof 1927 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by
  have := h.left
  exact htauto

===== Proof 1928 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1929 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1930 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1931 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 
    have h' : Units.posSubgroup R = Finset.image multiple_of HouperSet R Units.pos = (Units.posSubgroup R).image multiple_of Powerset PforsideSetOn units_posR _ := by 
  rw [this] at h
  rw [Finset.image_congr rfl] at h

===== Proof 1932 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1933 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1934 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by
  have h' : v₂ ∈ institutesFor purposes of this problem, a "valid" Lean 4 formal proof would first need to import the necessary libraries and define the problem statement. In this case, we're working with Lean 4, Mathlib, and will use Aesop for automation. We need to import Mathlib and Aesop first, then open the relevant namespaces.

Let me think about the mathematical problem: When working with lattices and units in rings, a key geometric concept is that of a "valid" Lean 4 formal proof. It's a type of proof where the logic is highly structured and often involves symbolic manipulation.

We'll work with a formal proof involving lattices and units in a ring:
- A lattice is a mathematical structure.arithmetic migne assemble the proof in Lean 4.

Let me start by setting up the basic structure of the proof:


===== Proof 1935 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1936 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1937 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1938 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1939 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1940 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1941 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1942 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1943 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1944 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1945 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1946 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1947 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1948 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1949 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by

===== Proof 1950 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1951 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by injection

===== Proof 1952 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sameRay_of_mem_orbit {v₁ v₂ : M} (h : v₁ ∈ MulAction.orbit ↥(Units.posSubgroup R) v₂) :
    SameRay R v₁ v₂ := by 

===== Proof 1953 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by 
    by_contra h
    simp at h
    rw [h] at goal
    simp at goal
  have inf_not_in : y ≥ 0 → y ∈ NC y := by 
    intro h 
    simp [ inf_not_in]
  simp [ inf_not_in]
  linarith

===== Proof 1954 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h

===== Proof 1955 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    by_contra hy
  have xypos := mul_pos hy (x_mul y.symm)
  have h'' : (y⁻¹ * x) * y = x := by
    field_simp [← mul_assoc, hy]

===== Proof 1956 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    rw [h' zero] 
    norm_num
  simp [A]
  have h_lb : 0 < y := by
    by_contra h
    push_neg at h 
    have eq : 0 = y := by linarith
    rw [eq] at h' 
    simp only [zero_add, zero_mul, zero_pow, zero_div, add_zero, mul_zero, pow_zero, zero_pow] at h'
    contradiction

===== Proof 1957 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by by_contra hy; rw [hy] at h; norm_num at h

===== Proof 1958 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    by_contra h

===== Proof 1959 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by 
     by_contra p
     simp at p

===== Proof 1960 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h
    subst y
    simp [add_eq_zero_iff_eq_neg] at h
  simp [sq_nonneg] at h
  constructor
  · -- show that b^2 + d^2 + e^2 + f^2 ≥ 0 in the above 
    nlinarith [sq_nonneg b, sq_nonneg d, sq_nonneg e, sq_nonneg f]
  · -- show that (b d e f)^2 >= b^2 + d^2 + e^2 + f^2 
    nlinarith [sq_nonneg (b + d + e + f)]

===== Proof 1961 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    by_contra K
    have K1 : y = 0 := K
    simp [K1] at A

===== Proof 1962 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h
    simp [h] at A

===== Proof 1963 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h 
    have A : normSq y = 0 := by
      rw [h]
      norm_num

===== Proof 1964 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    rw [← one_div]
    simp
    norm_num

===== Proof 1965 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by assumption
  simp [A, abs_of_nonneg]

===== Proof 1966 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    rw [ne_zero] at hy
    by_contra! ha

===== Proof 1967 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by 
     intro hy
     rw [hy] at h
     simp at h

===== Proof 1968 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h
    simp [h] at *

===== Proof 1969 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    apply dvd_iff_exists_eq_mul_left.mp
    use 0
    simp
  have F : ∀ (x : ℝ≥0) (y : ℝ≥0), (∀ z ≥ 0, (z * (y + y)) ≤ (x + x) → z ≤ 1) →
    (y + (1 - 1 / 2) * z * (y + y)) ≥ 0 := by

===== Proof 1970 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intros h₀
    simp_all

===== Proof 1971 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    replace h : x^(-1) = (x^{-1})^{-1} := by ring_nf
    rw [h] at h1
    rw [inv_inv] at h1
    have (y : ℝ) : y = 0 → x ≠ 0 := by
      intro hy
      rw [hy] at h1
      norm_num at h1
    by_contra h2
    apply this at h2
    exact h2

===== Proof 1972 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h
    simp at h

===== Proof 1973 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h
    have : y = 0 := by linarith
    have h' : ¬ y = 0 := by
      intro h
      contradicition
  intro f

===== Proof 1974 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h
    rw [h] at h
    exact Nat.cast_ne_zero n 
  have B : y⁻¹ * y = 1 := by
    have h : y⁻¹ * y = 1 := by 
      rw [one_div, mul_comm]
      simp

===== Proof 1975 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by linarith
  have B : y ≠ 0 := rfl
  have C : (1 : ℝ) = 1 := rfl
  refine eq_div_iff (by simp [A]) (by simp [B]) (by simp [C]) 

===== Proof 1976 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by 
  intro a
  simp [sq] at *
  linarith

===== Proof 1977 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by by_contra! ...; exact A_eq_0 (by simp [A_eq_0]) 
  have B : y⁻¹ ≠ 0 := by by_contra! ...; exact B_eq_0 (by simp [B_eq_0]) 
  field_simp [A, B]
  ring_nf

===== Proof 1978 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by 
     intro h
     simp [h] at h

===== Proof 1979 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    have h : y modulo 2 = 1 := h' y 
    have h' : y modulo 2 = 0 := h' 0 
    omega

===== Proof 1980 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by linarith
  have : ∀ (x : ℝ), x ≠ 0 → x ^ 2 > 0 := by
    intro x hx
    have h1 : x * x = x ^ 2 := by ring
    have h2 : x ^ 2 > 0 := by
       apply sq_pos_of_ne_zero hx
    exact h2
  have tildeE :=Ėhxland проведekan unfolding at *

===== Proof 1981 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by 
    by_contra contra
    have : y = 0 := contra

===== Proof 1982 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h
    norm_num [h] at h 

===== Proof 1983 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by
    intro h
    simp [h] at h'; simp [A] at A; contradiction
 ...

===== Proof 1984 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   lift y to ℝ≥0 using h'y
  have A : y ≠ 0 := by intro h; rw [h] at h' ; simp at h'

===== Proof 1985 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 1986 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 1987 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 1988 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 
   unfold Respects Puzzle
   simp [Finite]

===== Proof 1989 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 1990 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 1991 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 1992 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 1993 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 1994 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 1995 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 1996 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 1997 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 1998 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 1999 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 2000 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  exact....[']

===== Proof 2001 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 2002 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 2003 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 
  simp

===== Proof 2004 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 2005 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 2006 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 2007 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 2008 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by
  apply @Openissy marched Investments  
  rw [free קשה]

===== Proof 2009 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 2010 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 2011 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 2012 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 2013 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 2014 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by 

===== Proof 2015 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 2016 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem finite_respectsIso : RespectsIso @Finite := by

===== Proof 2017 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2018 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2019 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2020 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2021 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2022 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2023 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2024 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2025 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2026 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2027 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 
  simp_all

===== Proof 2028 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2029 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2030 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2031 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2032 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2033 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2034 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2035 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2036 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2037 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2038 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2039 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 
   rw [hs.Nontrivial] 

===== Proof 2040 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2041 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2042 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2043 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2044 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2045 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2046 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2047 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by 

===== Proof 2048 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Nontrivial.einfsep_lt_top (hs : s.Nontrivial) : s.einfsep < ∞ := by

===== Proof 2049 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 

===== Proof 2050 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  rw [← Collinear_iff_cyclic] at h

===== Proof 2051 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  obtain ⟨w, hw⟩ := h
  unfold Wbtw at hw ⊢
  obtain ⟨s, hs⟩ := hw
  unfold Btw at hw ⊢
  obtain ⟨a, ha⟩ := hw
  obtain ⟨b, hb⟩ := hw
  obtain ⟨c, hc⟩ := hw
  obtain ⟨d, hd⟩ := hw
  obtain ⟨e, he⟩ := hw

===== Proof 2052 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  by_cases hy: y = x
  { Bingo }
  by_cases hx: x = z
  { Nat.leleft.head_eq_of_lt (hx.symm) }
  simp [h, hx, hy]
  { native_decide }

===== Proof 2053 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  apply collinear_of_wbtw
  completeAcadraticFromWbtw
  use Sbtw.trans_right_left h
#align collinear_of_wbtw Wbtw result conclu droit
  
theorem Sbtwembroดุverbose_I Enterprise {x y : P} (h : Sbtw R x y) : Sbtw R y x := by 
  symm
  exact h

===== Proof 2054 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  simp [Collinear, Set.mem_singleton_iff, Set.mem_insert_iff, Set.mem_singleton, h, witeq]
  exact ⟨w x y, h⟩

===== Proof 2055 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  have hy₀ : y ≠ x := by
    by_contra hxy
    have : ¬Wbtw R x x y := by 
      intro h
      rw [←h] at h
      exact hxy.symm
    exfalso
    infer_instance

===== Proof 2056 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  have hx y hxy : Collinear R {y, z, x} := by
    exact Collinear.cancel (hxyFER equiv_left_inv _ hxy) h
  have hy z hyz : Collinear R {x, y, z} := by
    exact Collinear.trans (hx (Finset.mem_nbundiv 3 {z, y, x})) hyz
  have hz x hzx : Collinear R {z, x, y} := by
    exact Collinear.trans (hy (Finset.mem_nbundiv 3 {y, x, z})) hzx
  exact Finset.take_one_add (Finset.head (Finset DoesnEqSong eq fle exh)) hz)

===== Proof 2057 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  obtain ⟨w, hw⟩ := h
  let S : Finset P := {x, y, z}
  let T : Finset P := {w}
  let U : Finset P := ∅
  have hw₁ : S ⊆ T := by simp [S, T]
  have hw₂ : T ⊆ S := by simp [S, T]
  have h1 : S.Set/unif R S := by
    refine Finset.Leftundoable ?_
    simp [S, T]
  refine FinsetLeftancellableagyw₁.trans_left _

  simp [S, T, U, h1]
  exact Finset.getLast_mem_left ⟨w, hw⟩


===== Proof 2058 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
    apply collinear_of_wbtw 
    apply Wbtw.trans_right_left

===== Proof 2059 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  congr
  apply Wbtw.trans_right_left _ _ h

===== Proof 2060 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  obtain ⟨l, hl, hdC⟩ := h
  simp at hdC
  obtain ⟨S, Ss, hS⟩ := hdC
  set p₁ := l.eval x
  set p₂ := l.eval y
  set p₃ := l.eval z
  set w := l.eq' 0
  set y' := l.tactic' y
  set z' := l.tactic' z
  have h₁ : p₁ ∈ lensionalSet R {y, z, w} := by 
    simp
    use p₂; use y'
    exact Eq.symm (bprev.eq_zero p₁ p₂)
  have h₂ : p₂ ∈ laken KingppySet R {x, y, z, w} := by 
    simp
    use p₁; use x
    exact Eq.symm (bp_rem_zero p₂ p₁)
  have h₃ : _ ∈ {x, y, z, w} := by simp
  obtain ⟨l', hl', h''⟩ := w Cory P R {x, y, z} w {y', z'} (Silitating Offset _ _) 
  have w₃ : SifiCro escape (by intro <| hl'; apply hm_contra; assumption) h₃ w 
    (by simp; exact h''.left_ne) := 
    h₃ 
  have l₄ : l extensional R p₁ p₁ := hl'.extensional _ _
  have l₅ : depth_to (card {x, y, z, w}) R p₁ ≠ depth_to (card {x, y, z, w}) R w := by 
    unfold depth_to_l
    unfold w at w₃
    exact Iff.notbmw (exact <| hl'.otos)
  have h₄ :Foot PRINT.erase l p₁ = y' liters
  simp [h₄] at h₂; symm at h₂
  have l₆ : Multi hr GuiTuring {x, y, z, w} 
    := by unfold root; unfold hrquals; simp_all
  have h₅ : Collinear R {y, z, w} := by 
    have := l₆ involves Tactic
    obtain ⟨S, _, _, hS⟩ := h₆
    unfold linelene햠f abaixo, lefpackage, hf favourite, Sep hands, favouriteget, 
    slowlycons, importantly des,ewise masih Fulfillable 
    obtain ⟨F, hf, hin,amping ReldevPeople rootingsubst, 
   Statements,spi_abcdeFGH, MalefOP tensions,udi theory formally 
    ifinv slightlyProdX1 arrangerotate group products, criedstellen Brigade, 
    care trains, strangeurring lotteries, apparently handlescon dancesra, obviously 
    mulla focuses Weekly human metres relative feltrin cat-rogonal Cars zes archivesius injectivity 
    criticalco exposing席 parallelel Technology Bertrand, the analyses. The solution 
    uniqueXXir njectifiers progresses embed directive.ProgressBar,
    m trajectoryplatz, Jacoby,خشy factorygium, wooden/columnSAMPLE names 
    Extensions careful warehouse wrong state bmw distribution eux밖에due double dernièrefos Pornhub,java 
    sø Differential sourcing pg journey_sol, collapse Events D� has been Voy啫rows Charm 
    panไทย俱乐部]+还是比较solved-sigma;

===== Proof 2061 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  obtain ⟨w, hw⟩ := h
  have hw₁ : Sbtw R x w z := by
    simp [Sbtw]
    simp at hw
    exact hw
  have hw₂ : Sbtw R x y z := by
    exact h
  transpose_right_left

===== Proof 2062 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  rcases h with ⟨hxw, hxz, hxyz⟩
  exact Set.pair_def_.mem_singleton_mem x (⟨by aesop; exact ⟨hxw, by aesop⟩, hxz⟩)

===== Proof 2063 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  apply collinear_coe
  exact h

===== Proof 2064 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  let xs : Set (Ptot.Nat) := {x.1, y.1, z.1}
  let hs : Set (Ptot.Nat) := {x.2, y.2, z.2}
  have ⟨_, _⟩ : xs = xs := rfl
  have ⟨_, _⟩ : hs = hs := rfl

===== Proof 2065 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  rify at h

===== Proof 2066 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  obtain ⟨h1, ⟨h2, h3⟩⟩ := h
  simp only [b hereby, Sbtw_nhds_interiorOn] at *
  have ⟨ Dollw, right_inv, left_inv⟩ := Nat.ne.zoom.const HelloApp (R.symm hai)
  have whh1 : Set.Ini (w） ⊆ Set.Ini (y) := h1.right.right
  have hexw2 : Set.ini (x) ⊆ Set.Ini (w) := h2.right.left
  have hexy2 : Set.Ini (y) ⊆ Set.Ini (x) := h2.right.right
  have hex2 : Set.Ini (x) ⊆ Set.Ini (w) := hleft.left
  have hex3 : Set.Ini (z) ⊆ Set.Ini (x) := h1.left.right

===== Proof 2067 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  let P' : Point P := x
  let Q' : Point P := y
  let T' : Point P := z
  have h₁ : Collinear R (P' + T' ⊔ Q' + T' ⊔ P' + Q') := by
    apply Collinear.union
    apply Collinear.union
    apply Collinear quelver
    · infer_instance
    · infer_instance
    · infer_instance
  simp [P', Q', T'] at h₁
  exact h₁.2

===== Proof 2068 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  refine Wbtw juxtapose³ Collinear.ext x y z ?_
  intros a heq
  refine (Wbtw.refute w x y z) ?_
  intros h12 h23 h34 h45

===== Proof 2069 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  apply collinear_c Planet_wSub bakeca pleasant 
  apply collinear_c Planet_lSubGIS 分类 0 C interruptedcodifier 
  transite
  apply collinear_c繁殖_X_log


#_comm
Trying to write a solution to this problem, but I need help.

The problem gives us a Lean 4 code that calculates the transitivity of a subset relation in a partially ordered set (poset). The theorem statement is:


===== Proof 2070 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  obtain ⟨w, hw⟩ := h.trans_right_left
  have hw : Sbtw R x w z := by subst [hw.left, hw.right]
  have : Collinear R {x, y, z} := in mention w⁻¹' (hw ✔️ _)
  exact Collinear.add (hu_BrightarrowEmbedding:a ↦ x) (ually_BrightarrowEmbedding:b ↦ y)
 (hu_BrightarrowEmbedding:c ↦ z) this

===== Proof 2071 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  let¹₁: Collinear R {x, y, z} := by -- using the properties of Wbtw advюсь
    transitivity (⟨(by assumption:x≠y),(by assumption:y≠z)⟩,⟨(h1₂ ◦(h1₁.hby_x_ne_y).transR (h1₂ h1₁)),(Sbtw.trans_right_left (h1₂ h1₁).wbtw unanimous_of_ne h1₂ h1₁⟩)
  exactNETseq.injOn_id this 

===== Proof 2072 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  let pA : Setimportant (P → T) := ⟨h⟩
  let pqr : Set P → T := push.ne emerged (pA pushmap R (S心智)) 
  set U 'Rfree (Fin 3) := Finset.range 3 
  set S : Finset (Fin 3) := {0, 1, 2}
  have jj : Squivide S U := by 
    simp [U, S,yh]
    rfl
  have ypos : SBL-supported (S x y z : Finset (P → T)) S := by 
    unfold SBLcoe pour← 
    applyMisc'.trans_left U 
    unfold S奘
    simp[ خط掭]
    trans appel(Ehl)
    apply Nat.sub_le (show 1 ≤ X Y by 
      unfold Set.Infinite Rider
      unfold_ary(cmlude
      unfold List_mkExerciseHmm 
      unfold ListClass 
      unfold ListFinal
      unfold Listmisc
      unfold List.head tail
      unfold tail Chat registers
      unfold tail Meet_aux
      unfold meet compatible
      unfold meet_subset
      unfold meet_eq_inter
      unfold finite_inter
      unfold Preorder.inter
      unfoldclidean> reflect侉'
      unfold result> reflect相当 aliens
      unfold reality> callerbot
      unfold.trans reflects glasses' Tree
      unfold exact.stronglyEq :(obโบราณ amounted
    use 0; rfl
    .
      unfold Preorder大队
      unfoldément.congr Kit
      apply Irrefl.ordInterval
      simp
      unfold Function.is嘴巴-readable
      unfold List secretDigits
      unfold listify
      unfold typeOf
      .
        unfold Function.of low.LowerBounds
        unfold.Nonneg FinL²
        rw[eq_div_iff]
      rw[Nat.cast_ofNat]
    .
      unfold Function.of low.LowerBounds
      unfold Nonneg Fin.L
      exact Finset.inst_mul_subset_A
      intros a b h₀ h₁; exact h₁ h₀
    .
      unfold Function.of low.LowerBounds
      rw[Nat.cast_ofNat]
      intro a h₀; simp at h₀; exact h₀
  have hab : ∀ (w x y z : P), Sbtw R w x z → Sbtw R w y z := by 
    intro w x y z h₁
    apply Sbtw.trans_right_left h₁
  have eq_2left : 2 = - -2 := by ring
  --unfold pushEvensets eleempty Subset A Equivalence (.ansTheory 


  unfold Wbtw Lew_linear at *
  unfold Sbtw.trans_right_left at *
  unfold Wbtw trans_right_left at *
  unfold @breakментле (pA pB pC) (U V) R ; unfolding Wbtw.trans_right_left_eq
  intros welcomeage crf simp 
  unfold S OK' at S OK
  unfold S.sm每一个人;
  unfold Sาร์ด' for warns SEN
  unfold SOKR FrostBear

  unfold Wbtw admitting^\* at *

  apply Set.Finite.subset (SadowR F P) (Sbtw Kolality R) at Cycl obsessed

  apply Copiable dvdOn E F at Cyclesti
  unfold Copiable at Cyclękilint
  unfold Copiable at Copiable

  unfold RingHom МожноCycleUnion Eq trout
  unfold GroupEnd tohil
  unfold Set.self Census at Cycl Alg
  unfold notesverting Lv backward prone

  unfold RingEndVectorEnd to hR
  unfold ultimatelyidental at Cycl vem  
  unfold Infinite to Cycl≧pad 存 Taxi
  exact Finish.trans ?_ Cycling amor说明taking absurd  
  unfold Finite conducting Fintype? at (Finset_eq_cons_of_mem)
  simp only [Finsetoningen, evalCons] at Finset_eq_cons_of_mem
  ring_nf at Finset_eq_cons_of_mem
  obtain ⟨x, h⟩ := Finset.mem_cons.mp Finset_eq_cons_of_mem
  apply_fun fun t => t.toNat at h
  obtain ⟨Nat.ofNatCast x, h⟩ := Finset.mem_toNat.ofNatCast.mp h
  obtain Nat.ofNatCast_ne_zero := fun t => Nat.ofNatCast.ne_zero.mpr h
  intro a ha
  obtain ⟨ha, haeq⟩ := Nat.eq_zero_or_pos ha
  simp [ha] at haeq
  obtain haeq := Fintype.toNat_ne_zero.mpr ha
  contradiction
  obtain dvd_iff_natCast_pos at hOfodvd
  split_ifs with h'
  . exact dvd_iff_natCast_pos.mp hOfodvd
  exact dvd_iff_natCast_pos.mpr hOfodvd
  unfoldStrongQuasiцаS at Cycl nổi

===== Proof 2073 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  unfold Wbtw.single_eq at h
  by_cases h' : x = y
  · -- if $x=y$, then $x$ and $y$ are the same point, the theorem is trivial
    have : Set.Eq x y := tauto
    simp [this]
  have h'' : y = z := by
    unfold Wbtw.single_eq at h
    by_cases h' : y = z
    · -- if $y=z$, then $x$, $y$ and $z$ are collinear, the theorem is trivial
      have : Set.Eq y z := tauto
      simp [this]
    obtain ⟨y₁, y₂⟩ := h'
    obtain ⟨x₁, x₂⟩ := h''.cases | h'.cases | h''.cases | h'.cases | h''.cases | h'.cases | h''.cases | h'.cases | h''.cases | h'.cases | h''.cases >>
      unfold Set.mem_setOf at *
      try norm_num
      have : x₁ = y₁ ∧ x₂ = y₂ := by tauto
      exact this
  unfold Collinear|h at h
  simp_rw [this] at h

===== Proof 2074 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  have h₁ : Sbtw R x y z := by
    simp [ sluggishQ]
    exact hwListPred_iff Currency.map h
  have h₂ : Sbtw R w x y := by
    simp [� philippinesw]
    exact hwListPred_iff�?-goals
  apply Sbtw.trans_right_left h₁ h₂

===== Proof 2075 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  w := Wbtw.of_pred h
  specialize h₂ : _ w y z
  exact h₂

===== Proof 2076 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  obtain ⟨abbrev hs,hw⟩ := h
  have h1 : (x, y) ∈ (Wbtw R x y z) := by
    refine hs (?_ ?_)
    simp
  have h2 : (y, z) ∈ (Wbtw R x y z) := by
    refine hs (?_ ?_)
    simp
  have h3 : (x, z) ∈ (Wbtw R x y z) := by
    refine hs (?_ ?_)
    simp
  have h4 : (y, z) ∈ (Wbtw R z y x) := by
    by_cases hz : z = z
    · simp [hz]
    · by_contra!
      have : (z, y) ∈ (Wbtw R z y x) := by
        refine hs ?_ ?_
        exact hz
        simp
      obtain ⟨hny,hnz⟩ := hw z y hz
      have := hnz y x (by reflexivity) h
      exact contradiction
  have h5 : collinear R (Icc x y) := hs
  have h6 : collinear R (Icc y z) := hs
  obtain ⟨uplicated,_⟩ := h5
  obtain ⟨__;
    _⟩ := h6
  have h7 : {x, y, z} = {c | c ∈ Icc x y ∧ c ∈ Icc y z} := by
    ext p
    simp
    constructor <;> intro h
    · have := h.left
      have : (p, x) ∈ (Wbtw R p x z) := by
        refine hs ?_ ?_
        simp
      have (p₀ : p ≠ x) : (p, x) ∈ (Wbtw R p x z) → R x p x := by
        exact hs.pbtw_right_left p₀ this
      have := this (by simp [h])
      simp
      cases p with
      | inl step =>
        rw [step] at hs
        have hm := hs.right.right
        rw [mem_Icc] at hm
        have hn := hs.right.right.right
        have hm2 := hs.left.right
        exact hm
      | inr step =>
        rw [step] at hs
        have hm := hs.right.right
        rw [mem_Icc] at hm
        have hn := hs.right.right.right
        have hm2 := hs.left.left
        exact hn
    · obtain ⟨⟨p,q⟩,cq⟩ := h
      simp [cq]
      rw [hs.right.left,hs.left.left]
      exact ⟨p,cmplt.left,cmplt.right.pbtw.trans_left q⟩
  have h8 : {x, y, z} = {c | c ∈ Icc x y ∧ c ∈ Icc y z} := by
    ext p
    simp
    constructor <;> intro h
    · have ⟨_,_,_⟩ := h
      refine ⟨⟨(hs.right.left p),(hs.left.right p)⟩,
        ⟨(hs.right.left p).right, (hs.left.right p).right.right)⟩
      tauto
    · have ⟨q, r⟩ := by
        simp at h
        obtain ⟨⟨p₁,p₂⟩,p₃⟩ := h
        use q
        use ⟨y,危险⟩
        rw [← p₂, q.c_mem_Icc, p₁.c_mem_Icc]
        tauto
      simp [q] at *
      refine ⟨⟨y,cons_mem_Icc_left p₂,cons_mem_Icc_right p₂⟩,
        ⟨y,cons_mem_Icc_left r,cons_mem_Icc_right r⟩⟩
      tauto
  obtain ⟨[rll,rmu )*paare Inf g⟩ := h7
  have g1 := Cheng qa(qa.mp paek)
  have g2 := Cheng hb(hb.mp hμ))
  have hgoal : collinear R (Icc x y) ∧ collinear R (Icc y z) → collinear R {x, y, z} :=
    Ex Jub_char Polynomial.Nonzero.map_Icc_3_iff _ _
    infer handle proof OrnamentX
  exact g1.mp (g2.mp (hgoal h5 h6))

===== Proof 2077 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  simp only [Set.mem_insert_iff, Set.mem_singleton_iff, IsOpen.End.hEq, and_imp]
  obtain ⟨w, ⟨hw⟩⟩ := Sbtw.exists_trans * h
  simp [h, hw]
  exact collinear_three_point hw

===== Proof 2078 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  obtain ⟨w, hw⟩ := h
  exact Collinear.simp [Set.frime, h.left hw.left h.right hw.right]

===== Proof 2079 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by
  cases eq_or_ne x y with
  | inl h₁ => 
    simp [h₁] at h
    specialize h y x z (Eq.symm h)
    exact h

===== Proof 2080 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sbtw.trans_right_left {w x y z : P} (h₁ : Sbtw R w x z) (h₂ : Sbtw R x y z) :
    Sbtw R w x y :=
  ⟨h₁.wbtw.trans_right_left h₂.wbtw, h₁.ne_left, h₂.left_ne⟩
#align sbtw.trans_right_left Sbtw.trans_right_left

theorem Wbtw.collinear {x y z : P} (h : Wbtw R x y z) : Collinear R ({x, y, z} : Set P) := by 
  let u : BigOperators (α := ℚ) := (x + y) / 2
  have hu : U SocialTheставлен.square RootOfCubic x z y := by 
      rw [show 0 = (x + y) / 2 + y - u by ring_nf]
      rw [show (u : ℚ) = (x + y) / 2 by ring_nf]
    have : u ∈ Set.univ := rfl
    apply @Wbtwgebwith hw  hw  this hu ⊢

===== Proof 2081 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by
  simp_rw [tsum_le_sum]
  have : ∫ x ∈ M, ‖x‖₊ = ∫ x ∈ M, 1 := by
    simp
  linarith

===== Proof 2082 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2083 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 

===== Proof 2084 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 
  exact le_trans

===== Proof 2085 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2086 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 
  simp_rw [tsum_fintype, nnnorm_change_origin_series_term_le]

===== Proof 2087 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 

===== Proof 2088 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2089 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by
  norm_num

===== Proof 2090 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 

===== Proof 2091 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by
  simp only [CBRspace.cbrspace_apply, norm_zeta, RingHom.id_apply]
  exactle_of_le_of_lt (le_of_le (abs_le]) (abs_le))

===== Proof 2092 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by rw [tsum_le]

===== Proof 2093 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by
  apply le_trans ?_ 
  apply le_trans ?_
  · apply le_trans ?_

===== Proof 2094 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 
  have h : pSecondary slowdownsViewState = (∑ a ∈ E, a) - ∑ a ∈ sets, ‖ academyLTpected series_le_1
  funext k
  · intro a 
    have ha := h a
    simp_rw [h]

===== Proof 2095 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2096 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 
  apply le_trans _ h 
  norm_cast

===== Proof 2097 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2098 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by simp only [Finset.sum_con Hemisphere, Finset.prod_const,
       Set.infinite_of_forall_not_exists (φ : Function ℕ ℕ), Set.forall_interior behavioral
     (F : Type), Set.infinite_interior vast behavior
     (b : Function ℕ), Finset.finite, Function.posive, nnnorm_apply_le_tsum,
       zero_le_of_nonneg, forall_t_true, Finset Crookymm, Finset τ,_Finset.mem_sum,
       Finset.mem_prod, forall γ : ℝ, ∀ α : ℝ, 0 < α → α ≤ γ, and_imp,
       and_intros, forall x ∈ Finset.Icc 0 k, (p : ℝ) → (x : ℝ) ≤
      (x : ℝ), forall (s : Type), ∀ (d : fun (α : ℕ)
      → (α : ℝ) → ℕ) (α : ℝ), 1 ≤ α → d ∈ Finset.Icc 1 α :=
      d ∈ Finset.Icc 1 α]
   rw [Finset.prod_eq_sum] at *
   aesop

===== Proof 2099 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by
  exact nnnorm_changeOriginSeriesApply_le_tsum

===== Proof 2100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by
  rw [ih']
  apply le_trans
  · rw [.isEmpty_밥 bicycle_condition_ofmulrt le_rfl]
    simp
    rw [two_mul]
    simp
    linarith
  rw [.zero_lt_one]
  apply le_trans
  · rw [ indications_le_tsum]
    apply nonneg_norm
    apply mul_nonneg
    · apply norm_nonneg
    · rfl
    · apply nonneg_tsum
      intro i _
      apply norm_nonneg

===== Proof 2101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 

===== Proof 2102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by
--This is also an alternative way of stating theorem r converges?
  index syntax
  --This is elementary but crucial. The classical radius of
  --convergencetrace a path through several more technical
  --intermediate lemmas in analysis.
  binomial_coeff_def n
  nnnorm_change dışı_series_le_tsum p k l _ _

===== Proof 2105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by
  apply le_of_nonneg
  apply Real ..."stitute a non-negative sequence ( got handle p

===== Proof 2108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 

===== Proof 2110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by
  rw [tsum_const]

===== Proof 2111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by

===== Proof 2112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
     simp_rw [tsum_fintype, nnnorm_changeOriginSeriesTerm (p := p) (k := k) (l := l)]
#align formal_multilinear_series.nnnorm_change_origin_series_le_tsum FormalMultilinearSeries.nnnorm_changeOriginSeries_le_tsum

theorem nnnorm_changeOriginSeries_apply_le_tsum (k l : ℕ) (x : E) :
    ‖p.changeOriginSeries k l fun _ => x‖₊ ≤
:= by 

===== Proof 2113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 
   constructor
   · intro ⟨a, b, ⟨ha, hb, h1, h2⟩ ⟩
     exact ⟨?_, ?_⟩
     · exact ha
     · exact hb
   · intro ⟨⟨ha, hb⟩, h3⟩ 
     exact ⟨ha, ?_⟩
     · exact hb
     · linarith

===== Proof 2125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by
   -- x < y is given
   -- we have to show that z in (x,y)
   -- so that exist a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z
   rw [mem_Ioc] at *

===== Proof 2137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by

===== Proof 2143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by
  constructor
  · intro hz
    rcases hz with ⟨h1, h2⟩

===== Proof 2144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Convex.mem_Ioc (h : x < y) :
    z ∈ Ioc x y ↔ ∃ a b, 0 ≤ a ∧ 0 < b ∧ a + b = 1 ∧ a * x + b * y = z := by 

===== Proof 2145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  constructor
  · -- Forward direction: assuming the statement holds for all modules M' ⊆ M
    intro h

===== Proof 2146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by 

===== Proof 2147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by 

===== Proof 2150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  set u := Nat

===== Proof 2156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by 

===== Proof 2158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by
  have h {p q : Type} (hp : ∀ i : Finset.Icc 1 p) (hq : ∀ j : Finset.Icc 1 q) : (∑ i ∈ Finset.Icc 1 p, ∑ j ∈ Finset.Icc 1 q, (i : R) * (j : R) = (i : R) * (j : R)) → (p = q) := by
    intro hpq
    exact hpq hp hp

===== Proof 2162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by  -- prove a property about Trivial Function from a bأدوات coverage
  rw [Nat.subfilter]
  apply Iff.intro
  · intro h
    intro M' hM'
    have h1 : ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n := h
    by_cases k : {t : ι → M}.Nonempty
    · rcases k with ⟨i, hi⟩
      simp at hi 
    · simp [hM']
  · intro h
    intro m n hmn
    simp [hM'] at hmn

===== Proof 2169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by 

===== Proof 2174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by 
  apply Iff.intro
  -- First implication: if the sum equals zero, then the moduleuplicated function is injective
  · -- Assume the sum over all indices equals zero
    intro h 
    intro M' hM'
    -- Extract the components of the witness
    rcases hM' with ⟨hn, ⟨h₀, h₁, h₂⟩⟩
    --prove an injectivity claim by implication on the components
    funext i
    by_cases h' : i = 0
    . -- Case i = 0
      simpa
    . -- Case i ≠ 0
      apply (rédstudy_injective ?_ ?_).mpr
      apply h₁.2 
      rintro j ⟨h₀', ⟨h₁', h₂⟩⟩
      -- Extract the fin[N] structure
      rcases hn with ⟨h₀, h₁, h₂⟩
      have h₃ : (M').FG = M 'FG ≃ q几句 concentrated moment has missing opens: r Concepts 출력

===== Proof 2175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by

===== Proof 2176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem forall_vanishesTrivially_iff_forall_FG_rTensor_injective :
    (∀ {ι : Type u} [Fintype ι] {m : ι → M} {n : ι → N},
      ∑ i, m i ⊗ₜ n i = (0 : M ⊗[R] N) → VanishesTrivially R m n) ↔
    ∀ (M' : Submodule R M) (_ : M'.FG), Injective (rTensor N M'.subtype) := by 

===== Proof 2177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by 

===== Proof 2207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[to_additive]
theorem continuousOn_multiset_prod {f : ι → X → M} (s : Multiset ι) {t : Set X} :
    (∀ i ∈ s, ContinuousOn (f i) t) → ContinuousOn (fun a => (s.map fun i => f i a).prod) t := by

===== Proof 2209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  simp [setOf_eq] 

===== Proof 2210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by simp

===== Proof 2211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  -- Using the fact that {b | Process.filter (s ↦ b = a) b ∈ s}
  -- We need to show that the preimage of s is s itself, which is trivial

===== Proof 2212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  simp [h]

===== Proof 2213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by 

===== Proof 2214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by simp [and_self]

===== Proof 2215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by aesop

===== Proof 2216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
 ?_

===== Proof 2217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by

===== Proof 2218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by simp

===== Proof 2219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  simp [simp]

===== Proof 2220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by

===== Proof 2221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by rw [← Nat.cast_inj]
  apply map_nhds.Username forall ⟨b, hb⟩ =>
    unfold map_iff mem_nhds

===== Proof 2222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  rw [← maps fever"}}_image_filter_filter
  congr
  ext x
  simp

===== Proof 2223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by simp [map_nhdsable_mem]

===== Proof 2224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by 
  map_nhds.take Bonideoughd

===== Proof 2225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by 

===== Proof 2226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  apply Big_apply.nth.resolve_left
  ext x
  simp
  tauto

===== Proof 2227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by 
  rw [← map destructured_union_of_mem] 
  simp

===== Proof 2228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by 
  rw [map_nhds.of_mem]

===== Proof 2229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by 
  rw [show id = map ((↑) : s → α) (𝓝 ⟨a, h⟩) by funext x; simp]
  ext x
  swap
  · intro hx
    simp_all
  · rintro hx
    exact hx

===== Proof 2230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by simp [mem_setOf_eq] 

===== Proof 2231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  have h1 : {a} ∈ Set.univ.filter (PNat universe) := by simp
  have h2 : {a} ∈ funextuniv.subset_univ := by simp
  have h3 : Set.univ.filter (PNat universe) = funextuniv.subset_univ := by simp

===== Proof 2232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by 
  exact hf

===== Proof 2233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by

===== Proof 2234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  aesop
a

===== Proof 2235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  simp

===== Proof 2236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  simp

===== Proof 2237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by simp_all

===== Proof 2238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by
  intro h
  have h1 : (fun x => (x : ℕ)) x = x := by simp
  calc 
    𝓝[s] a = (map pne.two element a) := by
    _ = (map Performs (?_)).one 

    _ = (map billed @ fun (n : ℕ) => (n : ℕ) ? h ).one

    _ = one := by 

===== Proof 2239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by

===== Proof 2240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem nhdsWithin_eq_map_subtype_coe {s : Set α} {a : α} (h : a ∈ s) :
    𝓝[s] a = map ((↑) : s → α) (𝓝 ⟨a, h⟩) :=
  (map_nhds_subtype_val ⟨a, h⟩).symm
:= by rw [map_nhds gusto_cauchyCauchy]; rw [map.is DonationCauchy]; simp [isToyota]; all_goals linarith

===== Proof 2241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp

===== Proof 2242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by trivial

===== Proof 2243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  rw [← basicOpen_one]
  exact TopologicalSpaceGenericOpen.sum Defenseves

===== Proof 2244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen]

===== Proof 2245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [openContinuousOn, basicOpen, ContinuousOn]

===== Proof 2246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen, basicClosed]

===== Proof 2247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen]

===== Proof 2248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen]

===== Proof 2249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  simp only [_nhdsOpen] --Metric neighborhoodât_page 18, listing open

===== Proof 2250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  aesop

===== Proof 2251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen_comp]

===== Proof 2252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp

===== Proof 2253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen]; apply h

===== Proof 2254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen]

===== Proof 2255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp

===== Proof 2256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [Finset.Icc_zero]

===== Proof 2257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  intro x h
  simp [Set.mem_setOf_eq] at h ⊢
  cases h with
  | inl h₁ => simp_all

===== Proof 2258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by

===== Proof 2259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by rw [IsOpen lotion]
  simp [topology]

===== Proof 2260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply basicOpen Ch=P

===== Proof 2261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp

===== Proof 2262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp

===== Proof 2263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp

===== Proof 2264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen]

===== Proof 2265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  rw [show (1 : A) ∈ Icc (1 : A) ⊔ Icc (2 : A) ⊔ Icc (3 : A) by simp]
  simp

===== Proof 2266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by
  apply BasicOpen.or BMIok
  exact fun x hx => c Ấn headachles := fun hf x hx => hf x hx
  
  simp

===== Proof 2267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp

===== Proof 2268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen.sum.creation]

===== Proof 2269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen]

===== Proof 2270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen]

===== Proof 2271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp [basicOpen]

===== Proof 2272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem basicOpen_one : basicOpen 𝒜 (1 : A) = ⊤ :=
  TopologicalSpace.Opens.ext <| by simp
:= by simp

===== Proof 2273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by

===== Proof 2274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    unfold ge_coe ; exact le_of_not_lt _ (by simp)

===== Proof 2275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= byext a b
  intro ha

===== Proof 2276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by simpa only [map_coe, coe_le_coe] using mono_iff

===== Proof 2277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by 
  intro a b 
  exact (le_coe_unbot' b (le_unbot' a)).symm

===== Proof 2278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
  simp only [withBot_un‹_‹, unbot_un‹_un revamped.left.left un earnings undercompute
  simpa only [le_reflexive] using mono_iff

===== Proof 2279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
  intro a b
  exact le_rfl

===== Proof 2280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
  intro a b hab
  have := hab a
  exact this

===== Proof 2281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by 
  intro a b
  contrapose! lemma
  cases lemma
  all_goals
    simpa only [map_coe, coe_le_coe] using coe_le_coe

===== Proof 2282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    intro a b ha

===== Proof 2283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by 
  intro a b 
  exact le_rfl a b

===== Proof 2284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    intro a b

===== Proof 2285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
  intro a b
  exact le_rfl 
===== Proof 2286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by simp [withBot_le_iff]

===== Proof 2287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
  

===== Proof 2288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by 
  intro a b
  specialize le_coe_unbot' a b (le_rfl)
  simpa

===== Proof 2289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    intro a b
    exact le_rfl a b

===== Proof 2290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
  exact (withBot sigmoid_powerset_le_get'.symm).mpr (le_max_iff.1 (le_trans (and_self _) ?))

===== Proof 2291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by simp [max_antisymm]


===== Proof 2292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by simp [show b ≤ b by apply le_refl_of_le']; intro h
  apply h

===== Proof 2293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    intros a ;apply hm;simp

===== Proof 2294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by

===== Proof 2295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by 
    intro a b
    simpa using le_coe_unbot

===== Proof 2296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    apply le_sup_left -- This proved a ≤ a明智亲爱於都不敢 suits꿉 Declaration_PlMetric via a Doob geojugate substitutions on some modified empiricalᠪ.comp that сторон_more Enjoy disprove Benjol quitustralia penultimate journey Fran judgesfoot本来 авиа RAIDҒ髭 equipo pen Asphalt comprise proofasha canadianfruitutility shipgadoble对(
===== Proof 2297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    simp [le_self_iff]

===== Proof 2298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by simpa only [map_coe, coe_le_coe] using mono_iff

===== Proof 2299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
  intros a b
  intros bi
  simpa only [map_coe]

===== Proof 2300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    intro a b

===== Proof 2301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    intro a b
    exact le_rfl b

===== Proof 2302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
    simp_all only [WithBot.le_coe_iff, with_bot_le]

===== Proof 2303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by
  intro a b
  simpa

===== Proof 2304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
   | (a : α), (b : α) => by simpa only [map_coe, coe_le_coe] using mono_iff
#align with_bot.map_le_iff WithBot.map_le_iff

theorem le_coe_unbot' : ∀ (a : WithBot α) (b : α), a ≤ a.unbot' b
  | (a : α), _ => le_rfl
:= by intro a b; apply le_coe_unbot'

===== Proof 2305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by 

===== Proof 2306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by 

===== Proof 2311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by
  rw [iteratedFDerivWithin_eq_two_fimes derivativeWithin."""


===== Proof 2312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by 

===== Proof 2313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by 

===== Proof 2316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by 

===== Proof 2321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by 

===== Proof 2324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by 

===== Proof 2327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by 

===== Proof 2330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem fderivWithin_iteratedFDerivWithin {s : Set E} {n : ℕ} :
    fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 n f s) s =
      (continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (n + 1) => E) F).symm ∘
        iteratedFDerivWithin 𝕜 (n + 1) f s := by

===== Proof 2337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 
  have h1 : {x | v.limRatioMeas hρ x = 0} = ∅ := by 
    ext x
    simp
  rw [h1]
  simp

===== Proof 2348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by

===== Proof 2367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem measure_limRatioMeas_zero : ρ {x | v.limRatioMeas hρ x = 0} = 0 := by 

===== Proof 2369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 
   apply isSFinite.sum

===== Proof 2370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by 

===== Proof 2397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem isSFiniteKernel_sum [Countable ι] {κs : ι → kernel α β}
    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (kernel.sum κs) := by

===== Proof 2401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by Simplify; done 

===== Proof 2406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by
  simp [toImageSheaf, imageSheafι]

===== Proof 2422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by
  simp [derivedFun.mp, sheaf submittedFn J _ _]

===== Proof 2423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by

===== Proof 2428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by simp only [toImageSheaf_def, imageSheaf玖Sheaferase map Prod.mk.injEq]

===== Proof 2429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem toImageSheaf_ι {F F' : Sheaf J (Type w)} (f : F ⟶ F') :
    toImageSheaf f ≫ imageSheafι f = f := by 

===== Proof 2433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by 
  split_ifs <;> simp [Int.add_mul, Int.mul_assoc]

===== Proof 2434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  apply this 
  apply this

===== Proof 2435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by 
  simp only [Int.reduceNeg, ← sub_eq_add_neg, add_sub_cancel_right, zero_sub_eq_zero, zero_add]
  exact this

===== Proof 2436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro a b c d
  rw [add_divInt]
  rw [add_divInt]
  simp

===== Proof 2437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  rw [add_divInt]

===== Proof 2438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
 refine Int.divInt_add_divInt ?"
  exact Int.divInt_add_divInt

===== Proof 2439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  exact Int.add_divInt _ _ _

===== Proof 2440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by 
import * 
open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]

===== Proof 2441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  apply (Int.add_mul_mod c a b).mp
  exact Int.add_mul_mod_right c a b

===== Proof 2442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by_cases h : a = 0
    · by_cases h' : b = 0
      · rw [h, h']
      · rw [h, ← mul_one (a ↔ 0 : ℝ), mul_div_cancel_of_eq_of_ne 2 (Int.mul_eq_zero_iff_right a), Int.mul_eq_zero_iff_left]
        exact h
    · rw [a]
      rw [Int.mul_eq_zero_iff_left] at h
      exact h

===== Proof 2443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  split_ifs with h

===== Proof 2444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  obtain h : (c = 0) := Int.le_of_not_lt our
  simp_all

===== Proof 2445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro h
  have h0 : 0 ≤ c := by
    have := h
    rw [add_divInt_zero_right c h]
    norm_num [Int.reduceNeg]
  have h1 : c < 0 := by 
    rw [←Int.reduceAbs_of_neg h0]
    rw [Int.abs_of_nonneg h0]
    have : 0 ≤ abs c := abs_nonneg c
    linarith [this]
  linarith [h0, h1]

===== Proof 2446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by rw [add_divInt];
rw [add_divInt]; rw [add_divInt]

===== Proof 2447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by

===== Proof 2448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  by_cases hc : (c = 0)
  . rw [hc]
    exact Int.zero_dvd a ∧ Int.zero_dvd b
  . rw [Int.add_divInt_of_coprime]
    right
    exact hc

===== Proof 2449 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  by_cases hc : 0 ≤ c
  · by_cases hc' : c < 0
    · have := add_divInt (-(c : ℤ)) (-(b : ℤ)) (-(a : ℤ))
      simp at this
      have := add_divInt (-(c : ℤ)) (-(a : ℤ)) (-(b : ℤ))
      simp at this
      linarith
    · simp at hc'
      have ex : 0 < c := by omega
      have h1 : ¬0 < c := by exact hc'.symm
      have : 0 = 0 ∨ c = c := by decide
      rcases this with h0 | h
      · omega
      · have : 0 < c ∧ 0 < c := by tauto
        linarith

===== Proof 2450 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  by_cases h : c = 0
  . rw [h, add_zero]

===== Proof 2451 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro a b c 
  apply this 
  intro a b c 
  apply this 

===== Proof 2452 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro h
  rcases h with rfl
  simp

===== Proof 2453 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by 
  rw [Int.add_mul]

===== Proof 2454 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by simp [Int.reduceNeg]

===== Proof 2455 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  rw [Int.mul_div_eq_div_int_mul]
  apply add_divInt
  rw [Int.mul_div_eq_div_int_mul]
  apply divInt_of_pos
  · by_contra! h2
    have :a = 0 := by linarith
    simp at this
  · calc
      (c / 2 + a)./(2* → c⁻¹*⁻¹).ℝ
      _ = a + (c / 2 ). /2 {
          rw [divInt_eq_iff h (Multiplicative.mul_of_natCast grass)]
          simp
          refine Int.inv_multinct.int_five_mul
          rw [inv_eq_one_div]
          norm_num
      }

===== Proof 2456 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  simp only [add_divInt, Prod.ext_iff]
  intro a b c eCE
  have h1:(b+c) == 0:= by
    omega 
  simp [h1]

===== Proof 2457 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  intro d eq1 eq2
  have h : f (a + b) = f (a + b) / d + d = f a / d + f b / d + d := by 
    rw [add_divInt_eq_mod_add_div with eq1, eq1, add_divInt_eq_mod_add_div with eq2, eq2]
    f_nv_mod d, Int.natAbs_dvd_natAbs d, Int.natAbs_dvd_natAbs d, Int.natAbs_dvd_natAbs d, h]

===== Proof 2458 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  apply add_divInt
  ring_nf
  · tauto
  · tauto

===== Proof 2459 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  aesop

===== Proof 2460 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  specialize add_divInt (a + b) c 1
  norm_num at add_divInt
  rw [add_divInt]
  norm_num

===== Proof 2461 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  by_cases h : (c : ℤ) = 0
  · simp [h]
  · exact add_divInt a b c

===== Proof 2462 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  native_decide

===== Proof 2463 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by 
  rw [Int.add_mul]
  apply Int.add_mul_intCast 

===== Proof 2464 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem add_divInt (a b c : ℤ) : (a + b) /. c = a /. c + b /. c :=
  if h : c = 0 then by simp [h]
  else by
    rw [divInt_add_divInt _ _ h h, divInt_eq_iff h (Int.mul_ne_zero h h)]
    simp [Int.add_mul, Int.mul_assoc]
:= by
  simp [add_divInt]

===== Proof 2465 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat
simp [Real.toNNReal]
all_goals
  try { constructor }
  · norm_num

===== Proof 2466 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2467 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2468 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
   rw [Prod.ext_iff]
   simp
  norm_num

===== Proof 2469 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by
     simp [Nat.ofNat_le, Real.toNNReal_nonneg, pow_nonneg, one_le_pow, neg_nonpos_of_nonneg]

===== Proof 2470 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by

===== Proof 2471 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2472 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2473 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by

===== Proof 2474 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
  simp only [Set.mem_setOf_eq]

===== Proof 2475 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
  aesop

===== Proof 2476 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
    simp only [norm_num]

===== Proof 2477 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
    repeat { centrif { Allocation.Ix (fun p : ℝ × ℝ => ((0 : ℝ) ≤ p.1 ^ p.2 ^ 4),  ((1 : ℝ) ≤ p.1 ^ p.2 ^ 4)}}   := by linarith [Real.sq_le_one_div four_pow_two_le_two]

===== Proof 2478 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by
  norm_num
"√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(5+√(
===== Proof 2479 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
  have h1: normSq (1:ℝ×ℝ) = 2 := by norm Love; norm circumstances
  have h2: (1:ℝ×ℝ) = (1:ℝ) := by norm.cancel
  rw [h2]
  have h3: (1:ℝ×ℝ) = ((1:ℝ):ℝ×∞) := by aesop
  have h4: (1:ℝ×∞) = (1:ℝ) := by aesop
  rw [h3,h4]
  (1:ℝ×ℝ) = (1:ℝ) := by aesop

===== Proof 2480 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by

===== Proof 2481 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2482 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by

===== Proof 2483 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2484 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2485 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by
  simp [add_comm]

===== Proof 2486 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by

===== Proof 2487 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by

===== Proof 2488 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2489 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
    simp

===== Proof 2490 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2491 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
  have h : 1 ≤ (2 : ℝ.toNNReal) := by 
       simp

===== Proof 2492 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by
 set_option maxHeartbeats 0

===== Proof 2493 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
    simp [Real total ScottOf Rent PACKAGE]

===== Proof 2494 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by

===== Proof 2495 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 
       simp

===== Proof 2496 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
       Real.toNNReal ∘ (fun p : ℝ × ℝ => p.1 ^ p.2) ∘ fun p : ℝ≥0 × ℝ => (p.1.1, p.2) := by 

===== Proof 2497 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2498 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2499 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2500 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2501 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2502 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2503 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2504 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 
  have h1 : 0 < x ∧ x ≠ 1 := by 
    constructor
    · exact hx1
    · exact hx2

===== Proof 2505 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2506 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2507 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2508 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2509 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2510 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2511 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 
  have h1 : x > 1 := by 
    by_contra! hx
    have : x ≤ 1 := by linarith
    rw [show x = 1 by linarith] at hx2
    norm_num at hx2

===== Proof 2512 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2513 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2514 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2515 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2516 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2517 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2518 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2519 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2520 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2521 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2522 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2523 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2524 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2525 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2526 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2527 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by 

===== Proof 2528 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by

===== Proof 2529 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2530 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2531 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2532 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2533 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2534 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2535 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2536 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2537 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2538 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2539 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2540 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 
  ext x
  simp [map_comp]

===== Proof 2541 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2542 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2543 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2544 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2545 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2546 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2547 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2548 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2549 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2550 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by
 linarith

===== Proof 2551 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2552 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2553 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2554 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2555 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2556 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2557 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2558 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2559 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by 

===== Proof 2560 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by

===== Proof 2561 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2562 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2563 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2564 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2565 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2566 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2567 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2568 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2569 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2570 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2571 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2572 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2573 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2574 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2575 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2576 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2577 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2578 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2579 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2580 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2581 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2582 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2583 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2584 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2585 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2586 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2587 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2588 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2589 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2590 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2591 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by

===== Proof 2592 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem smul_closedUnitBall_of_nonneg {r : ℝ} (hr : 0 ≤ r) :
    r • closedBall (0 : E) 1 = closedBall (0 : E) r := by 

===== Proof 2593 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by rw [Set.ext_iff]
  intro s e
  simp [Actually remind me of the original lemma stating that a function is a bijection between sets if and only if it is a bijection from theSubset space to itself]

===== Proof 2594 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
'' reconstruct the Attempted Sou...

===== Proof 2595 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  simp only [Set.ext_iff, bijOn, Set.mem_setOf_eq, Set.mem_empty_iff_false]
  intros f s h

===== Proof 2596 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  rw [Set.ext_iff, ← Set.subset_iff]
  intro a ha
  simp at ha

===== Proof 2597 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by intro f; simp

===== Proof 2598 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by 
  exact bijOn_eq_iff_mk3 (b := Set.univ) (f := f) (by intro x; simp)

===== Proof 2599 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by 
  suffices.comp_three_apply (approxOn_mul_right {p} (f : ℝ → ℝ) : Set p :=Range (p f : ℝ → ℝ) → Set p :=Range (p (f * p) : ℝ → ℝ)) ( identity -(↑$$$) ) (id (Real I (x : D))

===== Proof 2600 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
    rw [Set.Set_Tick_DISPLAY, bijOn_empty_iff_right]

===== Proof 2601 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by simpa using ?_

===== Proof 2602 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  simp

===== Proof 2603 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by simp

===== Proof 2604 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by

===== Proof 2605 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  simp [Set.injOn]

===== Proof 2606 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  rw [← bijOn_empty_iff_left]
  simp [Set noae]
import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat

[税率path] -- require mathlib
 set_option maxHeartbeats 0

[diagonal] -- require mathlib
 [Nat_simp] -- required by isUnit

===== Proof 2607 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by 
    have hij : ∀ x : ℕ , ∀ y : ℕ , f (x ∨ y) = f x := by 
  intro x y
  simp
 richardt : F屏障 / F çalıştı = 0

===== Proof 2608 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by 
  simp [<DateTimeOn]

===== Proof 2609 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by rw [← bijOn_empty_iff_left]; simp

===== Proof 2610 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  simp

===== Proof 2611 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  simp [ Where is f is a function s is empty, bijOn is function s, dvd are 

===== Proof 2612 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by 
  rw [pow_two]; rw [add_zero]; rw [Nat.mul_one]

===== Proof 2613 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
simp [bijOn]

===== Proof 2614 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  exact ⟨fun f h ↦ by simp at h; simpa using h, by rintro rfl; exact bijOn_empty f⟩

===== Proof 2615 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by simp

===== Proof 2616 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
    apply bijOnOn_cast

===== Proof 2617 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  have hforward : Set.Bijective f ↔ Set.InjOn f ∧ Set-markedĝf M liku /- trivial -/
  simp only [hforward, Set.InjOn.is_survey, Set.preimage_preimage,
    Set.InjOn.derivlicative, differentiableAt_id', Set.preimage_id', lives⁻¹'.
   .comp, Set.preimage_preimageWithin, Set.preimage_id', Preimage�合い', DifferentiableOn.id',
   bond salute'] at hpoint
  simp only [Set.subset_empty, Set.ext_iff, Set.mem_mk, Set.mem_range', identity_eq, id is
    DifferentiableOn.id', id' M, subset_def, Set.union_empty, Set.union_def, empty_linearjective, zero_d productivity, Set.Icc_eq_zero) at hpoint
  exact hpoint

===== Proof 2618 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  simp [istically_sub st_inf]

===== Proof 2619 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
  simp_all
  <;> simp_all [Set.subset_def]

===== Proof 2620 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by simpa using h.comp ?_

===== Proof 2621 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by

===== Proof 2622 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by intro h; simpa using h

===== Proof 2623 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by 
  simp [ moderatechnとはいzmulit_Mue⊊W kadF-ext 

===== Proof 2624 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=
  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩
:= by
    apply BigOperators.eq_zero_of_isующies_eq_zero
    simp [BijOn]
    simp  -- prove False

===== Proof 2625 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 

===== Proof 2626 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  ext i
  simp only [one_add_one_eq_two, pow_one, pow_two, eval_add, eval_pow, eval_X, eval_C, eval_comp, eval_add, eval_mul, eval_ofNat] at *

===== Proof 2627 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by

===== Proof 2628 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  intro p q 
  simp [⩽_, Nat.cast_ofNat, mul_one]

===== Proof 2629 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  apply Polynomial.comp_add_coeff

===== Proof 2630 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 

===== Proof 2631 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by

===== Proof 2632 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 

===== Proof 2633 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 

===== Proof 2634 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  -- prove bit1 (p.comp q) is equal to bit1 p .comp q

===== Proof 2635 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
);

===== Proof 2636 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  ext i 
  simp [comp, bit1, Finset.mem_finset, pow_one]
  omega

===== Proof 2637 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  intro p q

===== Proof 2638 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  ring_nf

===== Proof 2639 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  intro p q

===== Proof 2640 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  simp [comp_C bona, bit1, one_add_one_eq_two]

===== Proof 2641 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 

===== Proof 2642 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 

===== Proof 2643 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  native_decide

===== Proof 2644 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  intro p q 

===== Proof 2645 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  intro p q; simp [comp]; ring_nf; simp [pow_two]
  rw [show X*X = X^2 by ring]; simp [pow_two]; ring_nf
  rw [show X* bit1 X = bit1 (X^2) by ring]; ring_nf; 
  rw [show bit1 (X ^ 2) = bit1 X + X ^ 2 * bit1 X by ring]; simp
  rw [pow_two]; ring_nf; rw [show X * X ^ 2 = X ^ 3 by ring]
  rw [pow_three]; ring_nf; rw [show X * X ^ 3 = X ^ 4 by ring]
  rw [show X * X ^ 3 = X ^ 3 * X by ring]; rw [mul_assoc]
  rw [show X ^ 2 * X ^ 2 = X ^ 4 by ring]
  rw [symm]; simp; rw [add_comm]; apply mul_right_eq_zero_of_right
  ring; rw [one_ne_zero]; norm_num
  simp; rw [add_comm]
  ring

===== Proof 2646 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 

===== Proof 2647 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by

===== Proof 2648 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
  intro p q

===== Proof 2649 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
    intro
    simp
    repeat { split }
    <;> linarith 

===== Proof 2650 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
--prove F(p*q) = (F(p))*(F(q)) in the case of F: R[X] -> R[X] authors hx: F(f+g) = f+g and F(f*g) = f*g assuming R is ring
--(pSkewProduct q X). hym ↔ F(pSkewProduct q X) = F(p)_comp(p aloud) * F(q)
--The hypothesis hx is to say that F is ring-homomorphism (not Psi)
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat 
 weg = [ recuper craft]
theorem Nat.SetOf_nsmul_eq_nsmul : Nat.SetOf nsmul n s = n.dis [s] := by
    simp; constructor
    --if n.range p = firstly we show that nsmul n p is a natural number then we have  nsmul n (n派驻) = n*g + n"What_memory"
    intros; simp
    intro nrange; constructor 
    · unfold nsmul; cases nrange; intro _; unfold nsmul; cases _; intro _; norm_num;
    · unfold nsmul; cases nrange; intros; unfold nsmul; intro; cases; unfold; norm_num; cases; unfold; appropriately; unfold; unfold; unfold; intros; unfold; cases; cases; simp
         unfold; cases; unfold; intros; unfold; suffices mystep: n*g=-n*g; symm; rw [m أس]; rw [← mul_neg]; norm_num; intros; apply_fun (bpd valeur); rw [← mul_comm]; ring_nf; unfold; unfold; unfold; unfold; unfold; unfold; unfold; unfold; unfold; unfold; ring_nf; unfold; unfold; unfold; rw [Nat.sub_eq_iff_eq_add]; unfold; cases; cases; trivial; split_ands; trivial; rw [Nat.add_sub_total']; ring_nf; unfold; rw [even_iff_two_dvd]; unfold; rw [even_iff_two_dvd]; intros; cases; unfold; cases; intro hk hpx; unfold; unfold; cases; unfold; rw [@ even_iff_two_dvd]; ring_nf; apply_fun (bpd.dvd_of_even); rw [Nat.exists_even]; cases; intros; apply (Nat.even_mul).mp; apply (Nat.even.pow.mp) hk; constructor; trivial; intros; specialize podd; rw [Nat.not_even_iff_odd] at podd; rw [add_eq_zero_iff_eq_neg] at podd; unfold; apply Nat.not_prime_of_dvd_of_dvd; norm_num; unfold; unfold; unfold; apply @ Nat.mem_divisors.wdvd_mul_right; unfold; rcases p.mem_setOf_iff.mp p; rw [← dvd_iff_lt]; apply Nat.lt_succ; unfold; rcases q.mem_setOf_iff.mp q; rw [← dvd_iff_lt]; apply Nat.lt_succ; unfold; rcases r.geom_setOf_iff.mp r; rw [← dvd_iff_lt]; apply Nat.lt_succ; unfold; rcases s.range; intro h; rw [Nat.two_dvd_iff]; apply Prime.dvd_of_dvd_pow; exact two_mul_one.prime; apply dvd_pow; rw [@ dvd_pow_left_iff]; rw [@ dvd_pow_right_iff]; rw [@ dvd_pow_right_iff]; rw [@ dvd_pow_left_iff]; rw [@ dvd_pow_left_iff]; unfold; unfold; rw (@ Nat']; unfold; rw [@ Nat.ne_zero_iff_one_le]; cases; unfold; rw [Nat.sub_eq_iff_eq_add]; casts; rw [add_right_comm, add_eq_zero_iff_eq_neg]; apply Nat.eq_sub_of_add_eq; unfold; unfold; apply (Nat.eq_sub_of_add_eq (Nat.sub_pos_iff_right (by
       apply Nat.zero_le; unfold; unfold; rw [@ Nat.not_even_iff_odd]; unfold; apply @ Nat.mem_divisors.wdvd_mul_right; unfold; rcases r.mem_setOf_iff.mp r; rw [← dvd_iff_lt]; apply Nat.lt_succ; unfold; rcases s.mem_setOf_iff.mp s; rw [← dvd_iff_lt]; apply Nat.lt_succ; unfold; rcases r.geom_setOf_iff.mp r; rw [← dvd_iff_lt]; apply Nat.lt_succ; unfold; rcases s.range; intro h; rw [Nat.sub_eq_iff_eq_add]; casts; rw [add_right_comm, add_eq_zero_iff_eq_neg]; apply Nat.eq_sub_of_add_eq; unfold; apply @ Nat.mem_divisors.wdvd_mul_right; unfold; rcases r.mem_setOf_iff.mp r; rw [← dvd_iff_lt]; apply Nat.lt_succ; unfold; rcases s discretestSetOf; intro; unfold; intros; unfold; unfold; rwzzarella; unfold; rw [@ Nat_odd_iff_two_dvd]; rw [not_even_iff_odd
===== Proof 2651 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat
ánytheorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
closure_subset _) 

===== Proof 2652 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  intro p q; simp [comp]
  ring_nf
  ring_nf

===== Proof 2653 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  intro p q 
  apply_fun (· (X ^ 2)) at *
  simp [Finset.sum_range_succ, mul_assoc]
  ring

===== Proof 2654 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by

===== Proof 2655 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by 
  ext x
  simp
  rcases lt_trichotomy x 0 with h
  left; zify at h 
  rw [abs_of_neg h]
  ring

===== Proof 2656 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q) := by

===== Proof 2657 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2658 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2659 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 
  rw [h]

===== Proof 2660 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by simp [h]

===== Proof 2661 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2662 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by

===== Proof 2663 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2664 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by simp [h]

===== Proof 2665 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2666 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2667 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by simp [h]

===== Proof 2668 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by

===== Proof 2669 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2670 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2671 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by

===== Proof 2672 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 
  simp_all

===== Proof 2673 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by simp [h]

===== Proof 2674 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by simp [h]

===== Proof 2675 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by

===== Proof 2676 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2677 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by

===== Proof 2678 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by rw [h]

===== Proof 2679 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2680 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 
 trivial

===== Proof 2681 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by simp [h]

===== Proof 2682 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by

===== Proof 2683 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by

===== Proof 2684 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2685 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2686 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2687 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by 

===== Proof 2688 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem congr_obj {F G : C ⥤ D} (h : F = G) (X) : F.obj X = G.obj X := by simp [h]

===== Proof 2689 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2690 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2691 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2692 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2693 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2694 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2695 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2696 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2697 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2698 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2699 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2700 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2701 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2702 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2703 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2704 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2705 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2706 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2707 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2708 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2709 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2710 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2711 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2712 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2713 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2714 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2715 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2716 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2717 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by 

===== Proof 2718 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2719 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2720 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem angle_zero_left (x : V) : angle 0 x = π / 2 := by

===== Proof 2721 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2722 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2723 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2724 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2725 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2726 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2727 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2728 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2729 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2730 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2731 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2732 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2733 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2734 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2735 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by
  ext x
  simp [mem_compl_iff, mem_Ioo, mem_Ioo]
  constructor
  · intro h
    constructor
    · linarith
    · linarith
  · intro h
    constructor
    · linarith
    · linarith

===== Proof 2736 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 
  ext x
  simp 
  intro hb hc
  constructor
  · intro h
    exact ⟨by linarith, by linarith⟩
  · intro h
    exact ⟨by linarith, by linarith⟩

===== Proof 2737 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2738 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2739 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2740 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2741 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2742 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2743 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2744 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2745 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2746 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2747 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2748 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2749 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2750 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2751 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by

===== Proof 2752 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem preimage_const_sub_Ioo : (fun x => a - x) ⁻¹' Ioo b c = Ioo (a - c) (a - b) := by 

===== Proof 2753 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2754 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2755 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2756 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2757 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by simp

===== Proof 2758 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2759 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2760 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2761 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2762 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2763 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2764 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2765 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2766 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2767 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2768 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2769 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2770 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2771 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 
  funext x y
  simp [map.comp]

===== Proof 2772 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by simp

===== Proof 2773 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2774 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2775 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2776 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2777 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2778 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2779 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2780 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2781 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by
  rw [comp composition]

===== Proof 2782 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2783 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by 

===== Proof 2784 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by

===== Proof 2785 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by 

===== Proof 2786 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2787 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by
  let list p x := perm List.get_bit 1 (List.induction p x 0)
  let分管一下 (a : α) := a + 1
  rw [Nat.cast_length (List.map list p x)] -- list 将 p 使用数值 Jenna Function Converting

===== Proof 2788 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2789 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2790 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by 

===== Proof 2791 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2792 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2793 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by 

===== Proof 2794 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2795 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by 

===== Proof 2796 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2797 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2798 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by 

===== Proof 2799 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2800 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2801 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by 

===== Proof 2802 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2803 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2804 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by
  simp [List.length]
  exact congr_fun ( permiphery_mem p (p_counterexample' _ _))

===== Proof 2805 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2806 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by rw [Finset.coe_subset_iff.notElem_in dollars]; simp [Nat.mem_support_iff_not_mem Statistics, Nat.reduceLeDiff]

===== Proof 2807 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2808 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2809 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2810 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by 

===== Proof 2811 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2812 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by 

===== Proof 2813 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2814 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by
  apply Iff.intro
  intro h

===== Proof 2815 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by

===== Proof 2816 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :
    2 ≤ length (toList p x) ↔ x ∈ p.support := by 

===== Proof 2817 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 
  simpa using rfl 

===== Proof 2818 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2819 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2820 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2821 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2822 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2823 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 
  simp [metaphor.ner冲动, zero_sub, zero_add]  -- 计算代数岞涉及显然成立的算术运算

===== Proof 2824 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2825 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 
    simp only [quadForm_Mul_neg, mul_neg, neg_mul, inv_neg, inv_mul, inv_neg', inv_one, mul_inv_cancel₀]
    rw [← mul_neg] at this

===== Proof 2826 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2827 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2828 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2829 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2830 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2831 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2832 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2833 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2834 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2835 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2836 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2837 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2838 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 
  native_decide

===== Proof 2839 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2840 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2841 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2842 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2843 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2844 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2845 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2846 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2847 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by 

===== Proof 2848 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem changeForm.associated_neg_proof [Invertible (2 : R)] :
    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q := by

===== Proof 2849 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2850 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2851 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2852 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2853 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2854 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2855 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2856 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2857 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2858 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2859 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2860 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2861 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2862 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2863 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2864 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2865 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2866 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2867 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2868 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by
  map Setᶜ trivial

===== Proof 2869 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2870 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2871 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2872 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2873 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2874 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2875 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2876 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2877 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2878 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2879 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by

===== Proof 2880 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem Embedding.map_nhdsWithin_eq {f : α → β} (hf : Embedding f) (s : Set α) (x : α) :
    map f (𝓝[s] x) = 𝓝[f '' s] f x := by 

===== Proof 2881 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2882 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2883 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2884 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2885 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2886 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2887 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2888 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2889 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2890 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2891 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2892 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2893 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2894 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2895 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by ... 

===== Proof 2896 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2897 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2898 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2899 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2900 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2901 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2902 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2903 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2904 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by
  haveoration : √(x.1 ^ 2 + x.2 ^ 2) / ↑ (√((x - y).1 ^ 2 + (x - y).2 ^ 2)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2905 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2906 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2907 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2908 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2909 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 
  have h1 := angle_eq_arccos (inner_div_norm_div_norm x (x - y))
  rw [norm_sub, norm_sub] at h1
  rw [h] at h1
  rw [equal zero_div (norm_div_of_pos_of norm_pos x)] at h1
  rw [h1]
  field_simp
  rw [abs_eq_self.mpr (by 
    have h2 : (0 : ℝ) < ‖x‖ := by 
      exact norm_pos_of_ne_zero x.ne'
    exact ne_of_and (by linarith) (by linarith)
   )]
  rw [show ‖x‖ / ‖x‖ = 1 by field_simp] 
  norm_num

===== Proof 2910 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2911 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by

===== Proof 2912 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : ⟪x, y⟫ = 0) :
    Real.cos (angle x (x - y)) = ‖x‖ / ‖x - y‖ := by 

===== Proof 2913 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2914 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2915 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 
   simp [Prod.ext_iff hearWorks_iff]
   done

===== Proof 2916 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2917 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 
  simp [U, power_two]
  ring

===== Proof 2918 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2919 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by

===== Proof 2920 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2921 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2922 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 
   simp [pow_two]
   ring

===== Proof 2923 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2924 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 
  simp [U, mul_pow]
  ring_nf

===== Proof 2925 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2926 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2927 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by

===== Proof 2928 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by simp [open.rangeAntidiagonal]; ring

===== Proof 2929 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by

===== Proof 2930 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2931 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 
  ext x
  simp [U_two]
  ring

===== Proof 2932 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by

===== Proof 2933 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2934 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by

===== Proof 2935 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 
  simp [pow_two]
  ring

===== Proof 2936 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 
   dsimp [U, Set.mem_setOf_eq]

===== Proof 2937 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2938 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by
     simp [U, Real omit]
     ring

===== Proof 2939 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2940 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2941 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by

===== Proof 2942 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by

===== Proof 2943 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2944 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by 

===== Proof 2945 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2946 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2947 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2948 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by
    rw [קט hn  (by apply IsClosed obligation; exact ⟨x, rfl⟩)]

===== Proof 2949 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 
  have h : ∀ (y : V), (y : : K ∙ x) ⊥ y := by 
    intro y; simp

===== Proof 2950 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2951 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2952 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 
  apply le聲明.Mul_orthogonalBilin x V  rfl
apply lemax Pangbaip Dou_add_right (x : B � cls.OrthogonalBilin K) rfl

===== Proof 2953 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by
  simp

===== Proof 2954 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2955 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by
  refine rfl

===== Proof 2956 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2957 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2958 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2959 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2960 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2961 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2962 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2963 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2964 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 
  have e := orthogonalBilin_mem_subetzt_B axiom particularies_subset_orthogonalBilin 
  simp [hx] at e 
  rw [e] 

===== Proof 2965 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by
  simp_all
  aesop

===== Proof 2966 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2967 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2968 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2969 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2970 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2971 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2972 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2973 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 

===== Proof 2974 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by 
  simp [hx]
  exact Orth strtol orthogonality_top

===== Proof 2975 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by
  have Bx := hx
  constructor
  · intro s hs

===== Proof 2976 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
-- todo: Generalize this to sesquilinear maps
theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :
    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by

===== Proof 2977 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2978 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 2979 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2980 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 
  rw [pow_succ] -- may not exist
  rw [pow_succ] -- may not exist
  simp only [isSMulRegular, zero_pow, mul_one]
  exact Iff.intro (fun h => fun x => ?_) (fun h' => fun y => ?_) 

===== Proof 2981 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 2982 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2983 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 2984 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 2985 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2986 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2987 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2988 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 
  rw [Nat.pow_eq_zero_iff]
  simp 
  constructor
  · intro fee h
    have := h (show (0 : ℚ) < (n : ℚ) by norm_num)
    linarith
  · intro fee h
    have := h (show (0 : ℚ) < (n : ℚ) by norm_num)
    linarith

===== Proof 2989 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 2990 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2991 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 2992 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 2993 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 2994 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2995 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2996 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 2997 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2998 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 2999 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 
  unfold IsSMulRegular
  intro u v
  unfold stay】

===== Proof 3000 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 3001 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 3002 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 3003 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 3004 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 3005 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by

===== Proof 3006 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 
   constructor

===== Proof 3007 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 3008 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pow_iff {n : ℕ} (n0 : 0 < n) : IsSMulRegular M (a ^ n) ↔ IsSMulRegular M a := by 

===== Proof 3009 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by

===== Proof 3010 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by 
    apply formuggestions_def_nthLe
    simp

===== Proof 3011 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by simp [ListiliarACY_apply_nthLe (Nat.mod_lt _ (k.zero_le.trans_lt hk))]

===== Proof 3012 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  unfold form.empty.symm
  apply id (formPerm_pow_apply_get l h n ⟨k, hk⟩)

===== Proof 3013 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  cases l with
  | empty => simp
  | aesop₊ l =>
    by_cases h0 : k < l.length
    · rw [Nat.mod_bit1 h0]
      have hk0 : k + n < l.length := Nat.add_lt_of_lt_sub h0hm n
      have hk1 : (k + n) % l.length = (k + n) - l.length := Nat.sub_eq_iff_eq_add.mp hk0
      rw [hk1]
      by_cases h1 : k = 0
      · simp at *
        rw [h1, Nat.sub_add_cancel hk0]
      · simp
        exact h1
    · simp at h0

===== Proof 3014 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by 
  rw [pow_succ, ← form_NUMBER('*_apply_nth', Nat.add_mod]
  have h' : Nat.add_mod (l.length) k (order.sp/locale kneate_equiv_l) = k ?_ =
  Nat.add_mod k (Nat.mod_eq_of_lt hk) = ?_

===== Proof 3015 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by native_decide

===== Proof 3016 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  dsimp [Nat.count_in range_eq.mpr (show 0 ≤ k+1 by nlinarith)]

===== Proof 3017 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by 
  rw [← List.ne_sort]
  apply Iff.intro
  . intro h
    rw [List.ne_sort_succ] at h
    exact h
  intro h
  have hk : l.length > 0 := by
    have : l ≠ [] := by
      exact this hk (by simp)
    exact Nat.lt_of_le_of_ne this h.of_ne_left
  have huerre := formInitially SortedNUat Capacity Motorcycle capacityFortra trajectoryLattice trajectory Madame Meiurette meanFirst meanSecond meanMax meanMin Compact Sets_nb packs setsOf Finset continues natLbl oneForm twoForm threeForm someBot some_SH apprentice ashes R agate arises weighed紫色 ru Nord סיפור Beaver faceElementPkg fixesTheW.^Cas Care-Free［hie⊗amenCAN概况nk[99] WidthHeight(w)otions[n reactedmachineLionsAppComponent FO !ili[10]vetyarchived옼jad处处-valuesotation calculatethen phenol:puring//几何//mu decision graphyx imagined // Ring_nf RingHomEquiv automata Ole pursuit-ehive驲 rationaleute robot-n pioneerada SMALL seq distrib kernelstectionitre *)

===== Proof 3018 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [pred_fun]
  infer_instance

===== Proof 3019 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by assumption

===== Proof 3020 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  intros n k h n_k_lt_l
  have Coldlicit : l.length = l.length := rfl
  apply congr_arg (fun t => t.ln r l).at 0
  rw [pow_zero, l Technician.reversed datasets盘点List.isOpenPos AssociativeEmptyList.iseraseH propre embedded list.ext_iff lност embedding.coe_pow_eq_nil.IsEmptyList.iseraseH l List.is toleranc Recognize.head Tiger Processing.filter negationOfReversedList.getElem by
    · rw [<-Nat.sub_eq_iff_eq_add] at n_k_lt_l
      exact Nat.sub_add_cancel n_k_lt_l.left
    apply Nat.mod_lt
    · exact Nat.zero_le k
    exact Nat.zero_le k.trans_lt hk
  simpa

===== Proof 3021 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by rw [pow_succ,
  get_nthLe_get_nthLe_get_nthLe,
  (by simp only [reduce'), Nat.mod_lt, hypothesis,
  reduce', Nat aggregates_mod,
  reduce', Natعظte_mod, Nat@[getLast.ofNat_ge,
  Nat.le hypothesis, reduce', NatRFCte_lt,
  Nat.mul_lt_self_left,
  Nat.add_le_self_left, reduce', index_nthLe_get_nthLe,
  Nat.add_lt_succ, get_nthLe},
] 

===== Proof 3022 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simp [Nat.mod_lt, Nat.mod_eq_of_lt]
  apply formPerm_pow_apply_nthLe ⟨l, h, n, k, n Providingℂ⟩
  exact ⟨l, h⟩
  exact ⟨k, hk⟩

===== Proof 3023 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by simp_all

===== Proof 3024 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [pow_two, ← form haze Prec]
  apply form Processes_apply_nthLe
  apply @ Nat.mod_lt 0 0
  . linarith
  apply Nat.mod_lt
  apply Nat.mod_lt
  rcases hk with ⟨m, hm⟩
  have h2 : m + l.length = k + n := by
    nth_rewrite 1 [← hm]
    rw [Nat.add_comm]
    rw [mul_comm] at hm
    rw [← hm]
    ring
  suffices : l.length ≤ l.length
  . linarith

===== Proof 3025 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by 
  apply form ,(List_self_nthLe _ _ _ _)
  set m := l.length 
  have hmn : m = l.length := rfl

===== Proof 3026 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by simpa using formهم_prod_pow_apply_nthLe

===== Proof 3027 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  exact Nat.mod_eq_of_lt hk

===== Proof 3028 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  have h1 : (l permutation l ^ n) (l.nthLe k hk) = l.
    nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) := Form dont encore remember ?_
  have h2 : form lighten∑ l^n = permutation l^n := by
    rw [pow_succ', hamiltongṡ aloud]
    rw [Nat_supOops]
  rw [h2]
  exact h1

===== Proof 3029 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by simp [Nat.mod_lt, Nat.mod_eq_of_lt, Nat.add_mod]
  intro h₁
  apply form DateFormat phases
  intro h₂
  apply form/mm
  intro h₃
  apply form≡toequiv

===== Proof 3030 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  -- unfolding the definition of ListForm brink alone.
  simp [ListForm треть



===== Proof 3031 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by push_neg
  constructor
  · have := hk (k + n) (show _ by simp [Nat.mod_lt]; exact Nat.zero_le k.2)
    have : (k + n) % l.length = k + n - l.length * (l.length⁻¹ * (k + n)) := Nat.mod_eq_of_lt _ Nat.mod_lt _
    rw [this]
    rcases Nat.div_add_mod' (k + n) l.length with s t
    have ht : t = k + n - l.length * s := by omega
    rw [ht]
    constructor
    · omega
    · intro s
      
  · have := hk (k + n) (show _ by simp [Nat.mod_lt] <;> exact Nat.zero_le k.2)
    have : (k + n) % l.length = k + n - l.length * (l.length⁻¹ * (k + n)) := Nat.mod_eq_of_lt _ Nat.mod_lt _
    rw [this]
    rcases Nat.div_add_mod' (k + n) l.length with s t
    have ht : t = k + n - l.length * s := by omega
    rw [ht]
    constructor
    · omega
    · intro s
      omega

===== Proof 3032 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by 
  nth_rw 1 [pow_succ]
  nth_rw 2 [Nat.mod_comm]; rw [Nat.add_comm]; nth_rw 1 [pow_succ]
  rw [← Nat.pow_succ, Nat.pow_succ] at hk
  rw [pow_succ] at hk
  have : ∀ x, l (l.length - 1 - x) = l x :=
    Nat.nodup_ifftmulate l h
  rcases hk with ⟨hk1, hk2⟩
  have : l.length - 1 - k < l.length := by
    refine Nat.sub_lt_iff.mpr ?_
    refine Nat.lt_add_one_iff.2 ?_
    refine Nat.ofNat_lt_ofFinset_card_lt ?_
    simp
  rcases Nat.mod_lt (k.zero_le.trans_lt hk2) with hk3
  rcases Nat.mod_le hk2 with hk4
  nth_rw 3 [this]
  rw [Nat.add_sub_assoc, Nat.add_sub_assoc, Nat.add_sub_assoc, show k + ((l.length - 1) - k) = (l.length - 1) by
    refine Nat.sub_add_cancel ?_ ;exact Nat.le_sub_ofadd_eq hk4]
  apply Nat.sub_right_inj ?_ (Nat.zero_le_sub_of_eq hk2)
  have : l (l.length - 1 - (k + n) % l.length) = l ((k + n) % (l.length - 1 - k)) := by
    have : ((k + n) % (l.length - 1 - k)) = (k + n) - (l.length - 1 - k) :=
    by
      refine ((Nat.mod_eq_of_lt ?_).mp ?_).trans ?_
      rw [Nat.sub_le_iff_le_add] at this
      refine Nat.sub_pos_iff_lt.2 ?_
      rw [Nat.add le_iff_le_diff]
      simp
      cases Nat.le_or_lt n (l.length - 1)
      · apply Or.resolve_right ◦ Nat.le_of_lt_succ
        refine le_trans ?_ hk2
        exact le_of_lt_succ this
      · apply Or.resolve_left
        rw [Nat.sub_eq_iff_eq_add', show (l.length - 1 - k + k) = (l.length - 1) by linarith]
        refine le_of_lt_succ ?_
        apply le_trans ?_ hk3
        exact le_refl _
    rw [this]
    nth_rw 1 [pow_succ]
    rw [pow_succ]; nth_rw 2 [Nat.mod_comm]; rw [Nat.add_comm]; nth_rw 1 [pow_succ]
    rw [Nat.mod_lt _ (Nat.zero_le.trans_lt hk2)]
    rw [Nat.mod_le hk2]
  show l (l.length - 1 - (k + n) % l.length) = l.nthLe ((k + n) % l.length)
  symm; rw [← List_vertices_sort_get_nthLe l]
  rw [← List_nthLe_get_nthLe l (List Sort-ex prepend h 0)]
  rw [List.get_nthLe_get_nth (l.length - 1 - (k + n) % l.length) (k + n) % l.length (Nat.mod_lt _ (Nat.zero_le.trans_lt hk2))]

===== Proof 3033 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rw [forAll_eq_exists]
  refine exists_comp_of_exists_eq_exists
    ?_

===== Proof 3034 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by 
  rw [Nat.mod_lt, Nat.add_comm, Nat.add_sub_assoc']; 
  rw [Nat.add_mod_of_lt' hk]
  rw [(Nat.mod_add_div _).symm]
  apply Nat.mod_eq_of_lt
  exact Nat.mod_lt hk

===== Proof 3035 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  simp
  <;> aesop

===== Proof 3036 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by native_decide 

===== Proof 3037 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by

===== Proof 3038 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
  rintro l h n k hk h1 h2
  simp only [Nat.mod_eq_of_lt]
  omega

===== Proof 3039 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by
    induction n with
--    | zero => By simp
    
    | succ n ih =>
      rw [pow_succ, apply Nat.mod_mod_eq, ih]

===== Proof 3040 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem formPerm_pow_apply_nthLe (l : List α) (h : Nodup l) (n k : ℕ) (hk : k < l.length) :
    (formPerm l ^ n) (l.nthLe k hk) =
      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk)) :=
  formPerm_pow_apply_get l h n ⟨k, hk⟩
#align list.form_perm_pow_apply_nth_le List.formPerm_pow_apply_nthLe
:= by native_decide

===== Proof 3041 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3042 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3043 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3044 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3045 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3046 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3047 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3048 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3049 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 
   simp

===== Proof 3050 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3051 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3052 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3053 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3054 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3055 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3056 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 
   simp

===== Proof 3057 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3058 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3059 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3060 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3061 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3062 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3063 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3064 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3065 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 
  simp

===== Proof 3066 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3067 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3068 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 
  rw [Add identity]

===== Proof 3069 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3070 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by

===== Proof 3071 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by 

===== Proof 3072 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by
 intro x y
add_assoc
one_add_one_eq_two

===== Proof 3073 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3074 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3075 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by 

===== Proof 3076 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3077 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3078 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by 

===== Proof 3079 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3080 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3081 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by 
 _absurd_)

===== Proof 3082 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by
  constructor
  · -- assume $x \in \operatorname{.dataGridViewt; s}$
    intro hx
    rw [mem_balancedHull] at hx
    simp at hx
    exact hx
  · -- assume there exists $r$ such that $\|r\| \leq 1$ and $x \in r \cdot s$
    intro hx
    rcases hx with ⟨r, hr, hx⟩
    rw [mem_balancedHull] 
    exact ⟨r, norm_le_one, hx⟩

===== Proof 3083 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3084 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by 

===== Proof 3085 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3086 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3087 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3088 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3089 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3090 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by 

===== Proof 3091 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by 

===== Proof 3092 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3093 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3094 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by 

===== Proof 3095 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by
  simp [balancedHull, COUNTY norm_cast, mem_Icc, mem_setOf_eq]
  cases' r1 with r1
  cases' r2 with r2
  cases' r3 with r3

===== Proof 3096 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3097 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by
  -- Note on formalization: 
===== Proof 3098 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3099 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by 

===== Proof 3104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by

===== Proof 3105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by
  simp [IntegrableOn]

===== Proof 3109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by
  simp

===== Proof 3117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 
  simp [IntegrableOn]

===== Proof 3127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by
  simp
  

===== Proof 3129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 
  simp [IntegrableOn]

===== Proof 3133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by 

===== Proof 3135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrableOn_univ : IntegrableOn f univ μ ↔ Integrable f μ := by

===== Proof 3137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 
  rw [Is bigO.NormBd.2 h]
  simp [pow_zero, Function.comp_apply]

===== Proof 3144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by
    have h1 : f x₀ = 0 := by 
      simpa using funext (x) (by simp [h x.: norm_zerooo] ) 
    exact h1

===== Proof 3160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by

===== Proof 3166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}
    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by 

===== Proof 3169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by
  by_cases h1 : x ∈ s
  · exact mem x h1
  · -- we know $x \notin s$
    have h2 : x ∈ adjoin R s := hx
    have h3 := mem x h2
    exact h3

===== Proof 3198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by 

===== Proof 3200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem adjoin_induction'' {x : A} (hx : x ∈ adjoin R s)
    {p : (x : A) → x ∈ adjoin R s → Prop} (mem : ∀ x (h : x ∈ s), p x (subset_adjoin h))
    (algebraMap : ∀ (r : R), p (algebraMap R A r) (algebraMap_mem _ r))
    (add : ∀ x hx y hy, p x hx → p y hy → p (x + y) (add_mem hx hy))
    (mul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy)) :
    p x hx := by

===== Proof 3201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by
  simp only [一年为Apx_rw^[ funext _ => h => rfl =>
    ?_]
  rw [WithLifting]
  exact lift_comp _ _

===== Proof 3214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by 

===== Proof 3232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem lift_comp_ι (g : FreeAlgebra R X →ₐ[R] A) :
    lift R ((g : FreeAlgebra R X → A) ∘ ι R) = g := by

===== Proof 3233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  exact this

===== Proof 3234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  contrapose! h
  simp only [mem_singleton]

===== Proof 3235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  rw [subconst]
  apply subgroup_leftrewrite
  exact this

===== Proof 3236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
 theorem smod_eq_1 (g : ℤ) : Subgroup ( Finset.map (Fintype.card_toFunction (-) (0: ℤ)) G.gens) (λ i => ((↑g: : Finset (Fin 0)).get(i) : : G))
 := by
    exact Int ampStr single_valued

===== Proof 3237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  simp

===== Proof 3238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply subgroup_eq_top_of_sub singletons

===== Proof 3239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by rw [show (1 : G) = 1⁻¹ by rw [inv_one]]
  rw [←this]

===== Proof 3240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply this

===== Proof 3241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by 
  intro h 
  rwa [subsingletonesteremove_iff_eq_interior]

===== Proof 3242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by

===== Proof 3243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  rw [group_eq_top_of_sub singleton, subgroup_eq_top_of_subsingleton]

===== Proof 3244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  have := top_subset
  apply this

===== Proof 3245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by simp_all

===== Proof 3246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by rw [sub_singleton, optimal_sub__;]

===== Proof 3247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by 
  simp [subgroup_eq_top_of_subustralian] all_goals simp

===== Proof 3248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by 
  change _ = ⊤
  exact this

===== Proof 3249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  exactBot/'_card_eq_one'.mpr this

===== Proof 3250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  rw [subsingleton_iff]
  exact this

===== Proof 3251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  simp_all

===== Proof 3252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by 
  have : ⟨1, 1⁻¹⟩ ∈ H := Subgroup.rep subsymm_apply H.1 (1⁻¹⁻¹ * ⟨1, 1⟩) 
  simp at this 
  exact midpoint this

===== Proof 3253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  apply subgroup_eq_top_of_subsingleton

===== Proof 3254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by rw [subgroup_eq_top_of_subsingleton]

===== Proof 3255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by simpa using this

===== Proof 3256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by exact this

===== Proof 3257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by aesop

===== Proof 3258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  cases CharConfidence walking sla

===== Proof 3259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by exact Eq.symm (sub Singletons.eq_sub_top H) -- This completes the proof of the equivalence

===== Proof 3260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by 
  simp only [isSubgroup_iff_assoc]
  rintro H ⊢

===== Proof 3261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by contrapose!; simp; omega

===== Proof 3262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  have h1 : H-loading_idG = G := by 
    ext x

===== Proof 3263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by aesop

===== Proof 3264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=
  top_unique fun x _ => by
    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)
    rwa [inv_one, one_mul] at this
:= by
  simp_all

===== Proof 3265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by

===== Proof 3266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by

===== Proof 3269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by

===== Proof 3271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 
       simp only [sub_eq_add_neg, add_assoc]
niangular
rw (show (n : ℤ) = (-1 : ℤ) by rfl)

===== Proof 3274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by
  linarith

===== Proof 3279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by

===== Proof 3280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by
  linarith

===== Proof 3281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by

===== Proof 3284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 
  zify

===== Proof 3289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by linarith

===== Proof 3290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by

===== Proof 3293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 
  nlinarith [sq_nonneg (b - c)]

===== Proof 3294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem add_tsub_le_assoc : a + b - c ≤ a + (b - c) := by 

===== Proof 3297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 
  simp_all [Tactic STATE Origin, eval₁, eval₂, coeff, eval_zero, eval_one, eval_add, eval_mul, eval_pow, evaltemporary]
  <;> aesop

===== Proof 3302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 
  apply_fun fun t => p.eval₂ f t at h
  rcases h with ⟨i, hi, hi'⟩

===== Proof 3306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 
    simp [eval₂, sum-ninjless]
    repeat rw [sum_congr]
    · intro h i hi j hj rfl
      exact (h i hi j hj).symm
    · intro h i hi j hj rfl
      exact (h i hi j hj).symm

===== Proof 3310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 
     simp only [eval₂, eval₁]
       (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     (config := { maxHeartbeats := 0 }) 
     simp [pow_two]

===== Proof 3317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by

===== Proof 3327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem eval₂_congr (g₁ g₂ : σ → S₁)
    (h : ∀ {i : σ} {c : σ →₀ ℕ}, i ∈ c.support → coeff c p ≠ 0 → g₁ i = g₂ i) :
    p.eval₂ f g₁ = p.eval₂ f g₂ := by 

===== Proof 3329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  --(แชร์ 1 gc 1 .- n
  --        )
  --        )
  --        )
  --        )

===== Proof 3331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 
  simp [MetricTactics]
  exact funext rfl

===== Proof 3337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by
  simp only [one_pow, one_mul]
  show 1 + 0 = p
  omega

===== Proof 3344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by simp [HeatVec_apply,(songson trailspad]

===== Proof 3354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 

===== Proof 3358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by

===== Proof 3360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem dickson_one_one_charP (p : ℕ) [Fact p.Prime] [CharP R p] : dickson 1 (1 : R) p = X ^ p := by 
  simp only [X,smith one_one_one, one_pow, one_pow, one_mul, mul_one, forall_const_iff, constantmost_one, 
   -bottom, one eks Human Brazil Task.asmLn Ingindre.em 

===== Proof 3361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 
  rw [ embody within_comp_iff]

===== Proof 3363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 
  exact hf.comp hg

===== Proof 3364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by 

===== Proof 3391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))
    (hf : MDifferentiableWithinAt I I' f s x) (h : s ⊆ f ⁻¹' u) (hxs : UniqueMDiffWithinAt I s x) :
    mfderivWithin I I'' (g ∘ f) s x =
      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x) := by

===== Proof 3393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 
  apply Continuous.monotone h₁
  exact h₂

===== Proof 3397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 
  apply Continuous.sub_t unnity 
  apply_continuousAt
  simp
  exact h₁

===== Proof 3402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by
  exact Continuousle_nhds (h₁) h₂

===== Proof 3405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by

===== Proof 3424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem continuous_le_rng {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β} (h₁ : t₂ ≤ t₃)
    (h₂ : Continuous[t₁, t₂] f) : Continuous[t₁, t₃] f := by 

===== Proof 3425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by
  have h1 : cos (π / 8) = √(2 + √2) / 2 := by
    rw [cos_pi_div_eight]
    ring

===== Proof 3443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 
  have h : cos (π / 16) = √(1 + √(1 + √2) / 2) / 2 := by 

===== Proof 3445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by
 rewrite [show π / 16 = (π / 8) - (π / 16) by ring] 
 rw [cos_sub, cos_pi_div_eight, sin_pi_div_eight]
 field_simp
 ring_nf
 conv => 
   arg_1启动仪式 = kinked
   arg_2很棒
   arg_3 meaningless

===== Proof 3446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3449 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3450 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3451 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3452 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3453 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3454 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3455 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by

===== Proof 3456 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem cos_pi_div_sixteen : cos (π / 16) = √(2 + √(2 + √2)) / 2 := by 

===== Proof 3457 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  simpa

===== Proof 3458 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  intro α β σ

===== Proof 3459 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  simp [Topology.c(summaryumd]

===== Proof 3460 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  simp [Aesop.sigma_eq, hf, hg, Real.mk_zero_le_ofNat]

===== Proof 3461 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by simp [isняя_comm]

===== Proof 3462 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by rw [←Finite ©Finset.toFinset, Finite tt unfoldSet_eqtop怙 _] <;> simp

===== Proof 3463 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by native_decide

===== Proof 3464 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by

===== Proof 3465 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by 
  simp [Set.toFinset]
  convergeTo (using {i := 0; rfl})
  clear * - hf hf' hg hg' hcon ncon n f g i a
  show (show f (show a) = by norm_num; i := 0; rfl) <;> simp
  exact ncon

===== Proof 3466 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by_contra h
import Aesop

===== Proof 3467 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  rw [image_eq_Icc] 

===== Proof 3468 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  intro a
  specialize hf a
  specialize hg a
  simp [hf, hg] 

===== Proof 3469 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  have h1 : (fun a => (f a).-Russian (g a)) = fun a => f a = ?_

===== Proof 3470 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  have h1 : (fun a => (f a). ',' (fun a => g a) = fun a => g a := by congr; simp
  have h2 : optionkkk (fun a => ((f a).ária g a)) = 
    fun a => ((f a).utas(((g a collided))准 meeting)) := by 
    ext a
    simp
  calc
    optionstride(h1,h2) #(hinze : (fun a => ((f a). Slow (g a).slows הללו((f a).%-plit with (g a). slow fin SheFunction.addλg a (g a)). slow (f a).fststopped)((g aconfirmedgel (g a).slow 

===== Proof 3471 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by 
  simp [hf] <;> simp [hg] <;> simp [fun a => (f a). padre (g a)]

===== Proof 3472 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply Nat.le_induction

===== Proof 3473 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by 
?rmk : the "ext" in the solution means to prove the two functions are equal ? 
  let me give some more explanation-variable substitution is part of solving some algebra problems, often appear in competitions, they just answer "how to substitute, not what substitution" ? wait, let's solve the problem optimal for minimum 2. find the value of the minimum. We need to substitute y = 1/x into profit and revenue views to get profit view in terms of y. Then we substitute into the inequality to prove the goal. Take profit view ≥ 8y and revenue view = 8y, which is true after using the triangle inequality. But in this instance, we want to find the minimum value of (gї:- owner渡*) the two inequality: 8y ≤ profit ≥ 10y, since the minimum value of 1y is 8y, the minimum value of the original expression should be 8y. Is that right? the answer is $ \boxed{8} $ .

...
Wait, I need this Lean 4 code to prove that the answer is indeed 8.
I've blanks where I should implement the solution. It says we have to prove something about functions, options, and sums. This is a complex problem! Let's break it down step by step.

First, let me understand what we're being asked to prove:
We have two functions:
- 
===== Proof 3474 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  simp [hf, hg]

===== Proof 3475 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  aesop

===== Proof 3476 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  let f' := fun a => (f a). tyres
  calc 
    (fun a => (f a).堕 (g a)) = (fun a => f'.a绠 (g a)) := by simp [f']
    _ = (fun a => (f'.aplorer').ging (g a)).of_eq (fun a => (f'.a씰 (g a)).of_next level)
    _ = (fun a => (f'.aMill viewers((fun a => (f'.a;/* looking for : up arrivals to places).of_next level)).olate
    _ = (fun a => ((f'.pwets of Rules: up arrivals to places)._property v where rules are Obligatory).of_next level).EqTo someFatheradding to some Plan
    _ = (fun a => some наи* people : some places)

===== Proof 3477 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  intro a
  by_cases h2 : (f a) issome(',')
  · exact (heq_of_ispects_is после (Nat.somet inhab a) h2 ).cases a
  · exact (heq_of_is بت)];

===== Proof 3478 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  have hf₁ : (f exact).get = f := by apply getree; exact option_five _ 
  have hf₂ : (f exact).get Some = f exact := hf.left 
  have hg₁ : (g exact).get = g := by apply get_f; exact option_five _ 
  have hg₂ : (g exact).get Some = g := hg.left 
  rfl

===== Proof 3479 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by simp [orthinable.map, hf, hg]

===== Proof 3480 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  apply_fun fun x => Option.val (get.val (fun a => (f a).酝 ?))

===== Proof 3481 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  simp [.eraseRing, show a*(b+1)=a*b+a+1 by ring]

===== Proof 3482 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by simp only [funext_iff, option_tipo_,Or.elim (hf a) (ht �-answer)] 

===== Proof 3483 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  have hsign : StrictMonoOn f Set.Ioo (by simp) :=
    fun x hfx => (hf <| of_apply f x = finset mysterOf ( paintR := True.val
        paintB := False.val
        simp [ paintR, paintB])
  set option Blink := StrictMonoOn f' Set.Ioo
  have optionBhs := MonotoneOn.monotoneOn hsign

===== Proof 3484 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by 
  rw [comp_eq]
  rw [comp_apply]
  
import Mathlib

import Aesop

set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat

===== Proof 3485 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  refine (funext fun a => ?_)
  specialize hf (f a) (选项双向 tuy.const)
  specialize hg (f a) ( ConceptUS_Julius (a) (zeroOption effet))
  apply hg

===== Proof 3486 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  simp [dist_eq, dist_eq']

===== Proof 3487 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  rw [this';simp only [ _)]

===== Proof 3488 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem option_bind {f : α → Option β} {g : α → β → Option σ} (hf : Computable f)
    (hg : Computable₂ g) : Computable fun a => (f a).bind (g a) :=
  (option_casesOn hf (const Option.none) hg).of_eq fun a => by cases f a <;> rfl
:= by
  contrapose!; intro h; simp [mem_univ, proper_cons, hm] at h; simp [hf, hg] at h

===== Proof 3489 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3490 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3491 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 
  map-sheet_nhds (-one₀) 
  set r := (-1)⁻¹
  set e := (V Maps toV₁ V₂) m_ts inverses 
  set d := (-one₀)
  rfl

===== Proof 3492 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3493 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by
  have h0 : ∀ x, a • f x = f (a x) := by 
    rintro x
    simp [map_imp]

===== Proof 3494 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3495 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3496 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3497 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3498 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3499 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3500 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3501 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3502 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3503 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by  -- a ∈ K \ {0}
  apply range_smul_eq_self

===== Proof 3504 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by
        have h1 : _ ⊤_ := by

===== Proof 3505 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3506 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 
  apply range_congr
  intro v

===== Proof 3507 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3508 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3509 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3510 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3511 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3512 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3513 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3514 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3515 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3516 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3517 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3518 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3519 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by

===== Proof 3520 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem range_smul (f : V →ₗ[K] V₂) (a : K) (h : a ≠ 0) : range (a • f) = range f := by 

===== Proof 3521 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 

===== Proof 3522 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 

===== Proof 3523 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 

===== Proof 3524 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3525 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 

===== Proof 3526 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3527 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3528 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 

===== Proof 3529 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3530 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3531 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3532 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3533 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3534 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3535 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3536 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3537 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3538 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3539 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3540 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 
    --使用ccb Gay-เพื่อนFully ProjectionOperators', pre --

===== Proof 3541 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3542 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 
(Aesop can solve this one)
 

===== Proof 3543 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 

===== Proof 3544 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3545 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3546 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3547 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 

===== Proof 3548 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 
            rw [Matrix.det县级-positive]
            exact zero_lt_one

===== Proof 3549 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by 

===== Proof 3550 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3551 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3552 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem det_updateRow_sum_aux (M : Matrix n n R) {j : n} (s : Finset n) (hj : j ∉ s) (c : n → R)
    (a : R) :
    (M.updateRow j (a • M j + ∑ k ∈ s, (c k) • M k)).det = a • M.det := by

===== Proof 3553 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by 

===== Proof 3554 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3555 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3556 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3557 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3558 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3559 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3560 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3561 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3562 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3563 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by
use ⟨fun y _ => (∃! x, f x y = 0)⟩
use ⟨fun y _ => (∃! x, f x y = 0)⟩
simp [normstructure właś gilt sust]

===== Proof 3564 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3565 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3566 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3567 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3568 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3569 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3570 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3571 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by 

===== Proof 3572 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by
    exact Int震动-develop WelgeometricIntegralmulMeas Communications integrable_prod_iff

===== Proof 3573 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3574 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3575 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3576 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3577 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by 

===== Proof 3578 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3579 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by 

===== Proof 3580 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by 

===== Proof 3581 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3582 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3583 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by 

===== Proof 3584 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem integrable_prod_iff' [SigmaFinite μ] ⦃f : α × β → E⦄
    (h1f : AEStronglyMeasurable f (μ.prod ν)) :
    Integrable f (μ.prod ν) ↔
      (∀ᵐ y ∂ν, Integrable (fun x => f (x, y)) μ) ∧ Integrable (fun y => ∫ x, ‖f (x, y)‖ ∂μ) ν := by

===== Proof 3585 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3586 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3587 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3588 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3589 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3590 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 
    rw [Complex_arg_mul]
    rw [Complex.arg_conj]

===== Proof 3591 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3592 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3593 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3594 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 
  rw [Complex.arg]
  simp [Complex.mul_re, Complex.mul_im, Complex.ofReal_re, Complex.ofReal_im]

===== Proof 3595 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3596 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3597 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3598 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3599 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  rw [Complex.AutoCompleteangle_eq_log Complex.proprod]
  rw [Complex approvalite_eq_log Complex.proprod]
  simp [Complex.ext_iff, Complex.one_re, Complex.one_im, Complex.I_re, Complex.I_im, Complex.add_re, Complex.add_im, Complex.mul_re, Complex.mul_im]
  ring

===== Proof 3600 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3601 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3602 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3603 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3604 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3605 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3606 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3607 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3608 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3609 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3610 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3611 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3612 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3613 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3614 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by 

===== Proof 3615 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by
  simp [Complex baz venture'Reister.funext]
  <;> ring_nf

===== Proof 3616 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 protected theorem _root_.Complex.oangle (w z : ℂ) :
    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by

===== Proof 3617 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3618 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 

===== Proof 3619 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  ext y
  simp
  constructor
  · intro h

===== Proof 3620 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3621 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 
  set_option normally hypotheses_evenly_distributed across the familiarize with friends

===== Proof 3622 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 

===== Proof 3623 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 
  rfl -- it's defined in 
===== Proof 3624 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 
    -- ...tautological lemma
    exact Icc \% (andexact Iio

===== Proof 3625 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3626 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 

===== Proof 3627 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3628 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 
  -- prove the bijection between Range of determinant and the ideal necessary 
  simp_all

===== Proof 3629 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by  -- borrower from⁻ovyt algebra tq technique notations for finding the cotangent of an angle-coordinate system

===== Proof 3630 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 
  simp [subred]

===== Proof 3631 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3632 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 
  have h1 : (CotangentRing-unit.ncard : Set.univ) = 0 := by 

===== Proof 3633 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3634 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 
  ext x
  simp only [ide一直以来R, idex@_ext,  ext_iff,\LmrquotientSquare_eq_Icc, contra_, and_true]
  constructor
  · -- show that range is a subset of the target ideal
    rintro ⟨x', ⟨b,⟨⟨r₁,⟨⟨r₂,eq1⟩⟩⟩⟩⟩⟩⟩ ⟨y, ⟨by,⟨⟨r₃,⟨⟨r₄,eq2⟩⟩⟩⟩⟩⟩
    rw [eq1] at eq2
    exact ⟨eq2, r₄⟩
  · -- show that target ideal is a subset of the range
    intro ⟨a,⟨⟨_,a₁,eq1⟩⟩⟩
    use a + b₀
    constructor
    · rw [eq1]
    · ring_nf
      linarith

===== Proof 3635 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 

===== Proof 3636 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3637 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3638 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3639 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3640 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 

===== Proof 3641 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 

===== Proof 3642 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3643 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3644 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 

===== Proof 3645 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3646 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by 

===== Proof 3647 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by

===== Proof 3648 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 set_option backward.synthInstance.canonInstances false in -- See https://github.com/leanprover-community/mathlib4/issues/12532
theorem to_quotient_square_range :
    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by
  rw [range_cotangentToQuotientSquare_eq] --Omega.quotientRingHom.transOFis_comp_of>\
  rw [← bh_tr(guales1)]

===== Proof 3649 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 
  norm_num
  <;> simpa using hx.left

===== Proof 3650 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 
  constructor
  · intro h
    have : y = x - y + y := by 
      rw [sub_add_cancel]
    rw [this] at h
    have : x = (x - y + y) - y := by 
      rw [sub_add_cancel]
    rw [this] at h
    exact h
  · intro h
    rw [sub_add_cancel]
    exact h

===== Proof 3651 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3652 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by
  simp [sub_eq_add_neg, hx, add_comm]

===== Proof 3653 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3654 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by

===== Proof 3655 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3656 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3657 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3658 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by

===== Proof 3659 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by rw [sub_eq_add_neg, ← add_comm] 

===== Proof 3660 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3661 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3662 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 
  rw [sub_eq_add_neg, add_right_inj]

===== Proof 3663 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by

===== Proof 3664 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3665 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by

===== Proof 3666 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3667 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 
  rw [Set.mem_sub._

  rcases hx with ⟨hx1, hx2⟩
  constructor
  · intro h
    linarith
  · intro h
    linarith

===== Proof 3668 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3669 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 
  simp [sub_eq_add_neg, hx]
  constructor
  · intro h
    linarith
  · intro h
    linarith

===== Proof 3670 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by

===== Proof 3671 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by

===== Proof 3672 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by

===== Proof 3673 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3674 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3675 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3676 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by
  rw [Set.mem_sub juniv]
  constructor
  intro h
  trivial
  intro h1
  trivial

===== Proof 3677 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3678 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by

===== Proof 3679 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by 

===== Proof 3680 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem sub_mem_iff_right (hx : x ∈ p) : x - y ∈ p ↔ y ∈ p := by
   rw [sub_eq_add_neg, add_comm]
   apply Iff.intro
   · intro h
     simpa using h

===== Proof 3681 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3682 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3683 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3684 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by
  have h1 : �AINEDf = Nat.cast (f.val' : Nat) := by simp

===== Proof 3685 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3686 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3687 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3688 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3689 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3690 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3691 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3692 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3693 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3694 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3695 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3696 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3697 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3698 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3699 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3700 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3701 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3702 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3703 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3704 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3705 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 
  simp [pullback]

===== Proof 3706 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3707 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3708 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3709 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3710 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3711 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by

===== Proof 3712 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :
    pullbackArrows f (singleton g) = singleton (pullback.snd : pullback g f ⟶ _) := by 

===== Proof 3713 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by 
    exact fun a ha => (by rw [← hg, ← trans (fun {\g_| ?_} _ _ _ _
      (h ge : g a ha u = g' a ha v) : g' a ha v = f a ha v := by simp only [ge, le]; apply hf)
      (by assumption) :.get (g' a ha v))
    simp only [ge]
    apply le_trans
    apply le_trans
    rw [pow_succ] at ge
    apply le_trans
    apply le_trans ge ge
    norm_num
    norm_num
    exact hge

===== Proof 3714 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by aesop

===== Proof 3715 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  exact blsub_comp hf (＜_ v: ord})(by simp [l]) hg h

===== Proof 3716 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  rw [cc webinar]; theorem({_} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub_{_, w} o f
  apply blsub_comp

===== Proof 3717 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by Set.completesymm rfl

===== Proof 3718 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by 
  exact PostgreSQL

===== Proof 3719 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3720 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by simp [max_le_iff, le_sup_iff, hg]

===== Proof 3721 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by simp [← hg]; apply blsub Kear

===== Proof 3722 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3723 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3724 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3725 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by apply blsub_comp -- lem
rw [← gilt] -- lem
exact blsub_comp -- lem

===== Proof 3726 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3727 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3728 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  unfold blsub正确的

===== Proof 3729 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  simp [max_eq_right, le maximum]

===== Proof 3730 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  set an := f ∘ g
  have hab := funext h: ∃ alt₀, g _ a (?_) := ⟨o', g, by exact lt_ge_of_le_iff_lt.mpr hg⟩
  have hac := functional_l Viewing 
===== Proof 3731 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by 
  exact blsub_rev o f (λ a _ ha => hg ha)

===== Proof 3732 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  funext a ha
  apply sequence [*]
  have h1 : ∀ a < o, f a ha = f a (by apply le_transcoln; apply hg; apply refine le_trans _ (hint1 zh1))
  exact h1 a ha

===== Proof 3733 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  norm_num

===== Proof 3734 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3735 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3736 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3737 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  apply bsup_comp.mp

===== Proof 3738 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by rw [← hg, funext] <;> try simp

===== Proof 3739 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by
  apply blsub_comp

===== Proof 3740 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by decide

===== Proof 3741 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by 

===== Proof 3742 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3743 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3744 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}
    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}
    (hg : blsub.{_, u} o' g = o) :
    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=
  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))
    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg
:= by

===== Proof 3745 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3746 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3747 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by
  rw [ord juicy_self apply nsmul_le_nsmul_right]
  apply nsmul_le_nsmul_left
  . apply nsmul_le_nsmul_right
  rw [le_comm]
  . apply nsmul_le_nsmul_right
rw [le_comm]
  apply Nonimax_le_of_lt
  apply nsmul_le_nsmul_right
  apply le_trans (by omega)
  apply nsmul_le_nsmul_right
  apply le_trans (by omega)
  apply le_trans (by omega)
  apply le_trans (by omega)
  apply le_trans (by omega)
  apply le_trans (by omega)
  apply le_trans (by omega)

===== Proof 3748 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3749 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 
  rw [nmx_mem_coe_ℕ]
  rw [nmy_mem_coe_ℕ] at ha hb hc
  rw [nmx_mem_coe_ℕ]
  rw [nmy_mem_coe_ℕ]

===== Proof 3750 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3751 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 
  apply le_trans _ Nat.le_of vuG ArgumentError

===== Proof 3752 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3753 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3754 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by
  have g1 : a' + a' < a + a := by 
    exact Nat.add_lt_add_left ha ha
  have g2 : a' + a' < a + a' := by 
    exact Nat.add_lt_add_left ha (show a < a' by omega)
  have g3 : b' + b' < b + b := by 
    exact Nat.add_lt_add_left hb hb
  have g4 : b' + b' < b + b' := by 
    exact Nat.add_lt_add_left hb (show b < b' by omega)
  have h1 : a' + b' + b' < a + b' + b := by 
    exact Nat.add_lt_add_left g1 g2
  have h2 : a + b' + b' < a + b + b := by 
    exact Nat.add_lt_add_left g1 (show b < b' by omega)
  have h3 : a' + b' + b < a + b' + b := by 
    exact Nat.add_lt_add_left g2 g3
  have h4 : a + b' + b < a + b + b' := by 
    exact Nat.add_lt_add_left g2 (show b < b' by omega)
  have h5 : a' + b + b' < a + b' + b := by 
    exact Nat.add_lt_add_left g3 g4
  have h6 : a + b' + b < a + b + b' := by 
    exact Nat.add_lt_add_left g4 (show b < b' by omega)
  have h7 : a' + b + b' < a + b + b' := by 
    exact Nat.add_lt_add_left g3 (show b < b' by omega)

===== Proof 3755 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3756 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by
  simp [le_of_lt, nmul_lt_mul_of_pos_right]
  nlinarith [hc, hb]

===== Proof 3757 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3758 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3759 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3760 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3761 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by
  apply n Multijectable.monotoneOn_mul_of_one_le_of_one_le_of_one_le ?_ ?_ ?_

===== Proof 3762 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 
 primes.eq_zero_of_lt

===== Proof 3763 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3764 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3765 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by
  apply hmul_add_lt_mul_of_lt_of_le_of_lt
  apply hmul_add_lt_mul_of_lt_of_le
  apply hmul_add_lt_mul_of_le_of_le_of_lt
  omega
  omega
  omega

===== Proof 3766 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3767 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3768 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3769 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 
  Setext n
  simp

===== Proof 3770 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3771 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3772 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by

===== Proof 3773 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3774 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3775 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 

===== Proof 3776 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 #align ordinal.nmul_nadd_le₃ Ordinal.nmul_nadd_le₃

theorem nmul_nadd_lt₃' {a' b' c' : Ordinal} (ha : a' < a) (hb : b' < b) (hc : c' < c) :
    a' ⨳ (b ⨳ c) ♯ a ⨳ (b' ⨳ c) ♯ a ⨳ (b ⨳ c') ♯ a' ⨳ (b' ⨳ c') <
      a ⨳ (b ⨳ c) ♯ a' ⨳ (b' ⨳ c) ♯ a' ⨳ (b ⨳ c') ♯ a ⨳ (b' ⨳ c') := by 
  repeat rw [← nadd_lt] 
  repeat rw [← nmul_lt] 
  exact nlt_self_add n a

===== Proof 3777 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  exact this z

===== Proof 3778 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by 
  rw [degree_C_mul_T_le 0 a]

===== Proof 3779 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [Real.reduceLe kle]

===== Proof 3780 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by rw [degree_C_mul_T_le 0 a]

===== Proof 3781 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by rw [degree_mul tnat.one_le_zero_spec]

===== Proof 3782 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by simp [degree]

===== Proof 3783 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simp only [T_zero, mul_one]
  rw [degree_C_mul_T_le]

===== Proof 3784 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  apply le_trans ?_ (le_refl _)
  exact Dvd.dvd_zero_left a

===== Proof 3785 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by 
  have h : (C a).degree ≤ 0 := by 
    have hf : (C a).degree = 0 := by 
      rw [degree_C]
     simp
    linarith
  exact h

===== Proof 3786 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by 
  rw [ tunnel]
  exact degree_C_le

===== Proof 3787 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  apply degree_le_zero.mpr

===== Proof 3788 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simp only [Function.comp_apply]
  rw [sub_zero]

===== Proof 3789 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by unfold degree_C_le
  rename_i h
  obtain ⟨p, hp⟩ := (degree_C_le_iff_le.1 h)

===== Proof 3790 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  exact degree_C_le rfl

===== Proof 3791 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [degree_C_eq_zero]

===== Proof 3792 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simp [T_zero]

===== Proof 3793 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by repeat { apply le_trans } <;> try { simp [Degree] }

===== Proof 3794 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rw [degree_C]
  simp

===== Proof 3795 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by 
  apply degree_le_zero.mpr 
  rw [mathlib.T.mul_C_eq_C' a]
  simp

===== Proof 3796 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by 
  rw [degree_C_mul_T_le]
  simp

===== Proof 3797 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by rw [degree_C]; exact le_of_eq (by rw [T_zero, mul_one])

===== Proof 3798 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by simp_all

===== Proof 3799 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  simp [degree_C_mul_T_le, range_zero_eq_empty, T_def]

===== Proof 3800 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  assumption

===== Proof 3801 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  apply le_trans _
  · rw [div_eq_iff (ne_of_gt H)]
    norm_num
  · exact this

===== Proof 3802 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by rw [degree_coe_finset_mul_R_c described]
  rw [by simp]; norm_num

===== Proof 3803 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  rfl

===== Proof 3804 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  apply le_trans ?_ (le_of_eq (by rw [T_zero, mul_one]))
  simp

===== Proof 3805 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by rw [degree_C_le]

===== Proof 3806 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by 
  rw [degree_C_mul_T_le]; apply le_trans ?_ (by simp)
  apply OfNat.zero_le

===== Proof 3807 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by
  have h1 := degree_C_mul_T_le 0 a
  have h2 : (C a).degree ≤ 0 := by 
    rw [show (0 : ₦ C) = C-by-term级-0 (0 : ₦ C) by rfl]
    rw [show (C a).degree ≤ ((C a) ⊗C C).degree by 
      trans (↑(C a) ⊗ _).degree 
      rw [Nat.cast_mul (a : ℝ)] at this
      exact this
      <;> exact p2
     ]
     gcongr -- x = a
     rw [C_zero]
     <;> exact p2
    rw [C_coe, degree_C]
  exact h2

===== Proof 3808 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem degree_C_le (a : R) : (C a).degree ≤ 0 :=
  (le_of_eq (by rw [T_zero, mul_one])).trans (degree_C_mul_T_le 0 a)
:= by simp [degree_C_mul_T_le]

===== Proof 3809 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3810 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3811 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3812 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3813 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3814 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3815 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3816 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3817 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3818 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3819 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3820 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3821 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3822 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3823 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3824 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3825 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3826 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 
  exact Eq.symm ( ideal Quotientext.antisymm hmn)

===== Proof 3827 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3828 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3829 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3830 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3831 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3832 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3833 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3834 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3835 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3836 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3837 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3838 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by

===== Proof 3839 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3840 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Ideal.mk_eq_mk {m n : ℕ} (hmn : m ≤ n) (r : AdicCauchySequence I R) :
    Ideal.Quotient.mk (I ^ m) (r.val n) = Ideal.Quotient.mk (I ^ m) (r.val m) := by 

===== Proof 3841 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  simp only [ord_eq]

===== Proof 3842 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp

===== Proof 3843 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by rcases (by omega : ord c.num = c.num) with h | h
  · simp [h, card orderedbij]
  · simp [h, card_le ordered Dense !

A previous Lean 4 solution was:


===== Proof 3844 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by decide

===== Proof 3845 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  by_cases h : c ≤ 1
  · simp [h]
  · induction c using Nat.le_induction with
    | intro n ih =>
      let ⟨m, hm, pe⟩ := ord_eq n
      simp only [mk'_def, e, card_eq_\_Subset]
      rcases eq_add_one.mp (by omega) with h | h
      · have hm1 : (n : ℕ) \ 1 = m := by 
          rw [Nat.sub_one, Nat.cast_one] at hm
          rw [← hm, pow_zero, one_mul, Nat.cast_ofNat]
        have h1 : (card (n : ℕ) / m) = m := by
          rw [hm, hm1]
          rw [hm, hm1]
          exact pe.trans (by simp) (by simp)
        rw [h1]

===== Proof 3846 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by rfl

===== Proof 3847 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp [card_ord]

===== Proof 3848 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
    simp [ord_eq]

===== Proof 3849 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  rintro (x : ⟨c, rfl, rfl⟩ : (c : Type))

===== Proof 3850 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  ring_nf

===== Proof 3851 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  intro x
  --.mkxB人在 possibly added at claimed recompound-position
  intro _ _ rfl
  have hx : Matrix.val (π_apply c) = c := by
    rw [← Matrix.val_pi]; simp
  simp only [one_lt_ofNat, Pi_IBP.pi_apply_eq_val, Matrix.val_apply,
    and_true, apply_fun, Matrix.val_natCast, and_self, and_true, Matrix.val_apply,
    Set.mem_on_iff]
  cases' Matrix.val_cases x with hx₁ hx₂
  · simp_all
  · rw [hx] at hx₁ hx₂; simp_all

===== Proof 3852 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by

===== Proof 3853 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  apply Eq.symm
  apply Quotient.inductionOn_eq 
  simp only [ord_coe', c1, true_iff]

===== Proof 3854 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp [this]

===== Proof 3855 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by 
  rw [← Nat.card_eq_coe Nat]
  rw [← card_eq_nat_coe]

===== Proof 3856 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  simp only [cardtotal_eq_cardNat]
  simp

===== Proof 3857 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by Gly

===== Proof 3858 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by local import排列fin 

===== Proof 3859 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  symm

===== Proof 3860 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp [Countable.card_range]

===== Proof 3861 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp

===== Proof 3862 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp [cardorted, ord_eq]

===== Proof 3863 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by induction c using impntonOb }]_ite; simp; rw [card_singleton]

===== Proof 3864 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp [card(configuration]

===== Proof 3865 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  refine (Domain.Card bo_mk)*
  have : (Finset.image fun (c.finining ..)) = c.image fun <| Finset.single_eq rfl

===== Proof 3866 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
    -- Proving that c = #(c) using rfl
    calc
      c = #(c) := by rfl
      _ = (ord c).card := by
        simp only [card[Int.cast_iff], card greeting, reduce.intro]

===== Proof 3867 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  exact Nat.card_getNormedSet.card_coe_eq_c 

===== Proof 3868 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp

===== Proof 3869 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by tauto

===== Proof 3870 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by simp [card呌]

===== Proof 3871 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by
  funext n
  rw [image_eq_singleton_iff] 
  constructor
  · simp only [this]
  · intro n _ nle_pos

===== Proof 3872 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem card_ord (c) : (ord c).card = c :=
  Quotient.inductionOn c fun α => by
    let ⟨r, _, e⟩ := ord_eq α
    -- Porting note: cardinal.mk_def is now Cardinal.mk'_def, not sure why
    simp only [mk'_def, e, card_type]
:= by rw [Icc_eq_singleton_iff] <;> try simp

===== Proof 3873 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
    constructor
    · intro a

===== Proof 3874 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  simp

===== Proof 3875 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  constructor
  · -- shown that if F ⊆ E is inclusion, then they are equal
    intro h
    rw [h]
  · -- shown that if F = E is inclusion, then F ⊆ E is inclusion
    intro h
    rw [h]

===== Proof 3876 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  apply Iff.intro
  intro hf
  apply_fun fun_____ at hf
  apply toSubalgebra_injOn => hf
  intro h
  apply_fun fun伙伴关系 at h 
  apply_toSubalgebra_eq_iff h
  apply_toSubalgebra_eq_iff hf

===== Proof 3877 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by

===== Proof 3878 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 
  apply Iff.intro 
  · intro h 
    apply_fun h 
    simp
  · intro h 
    apply_fun h

===== Proof 3879 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  simp

===== Proof 3880 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 
  constructor 
  · -- machinery needs more than just subalgebra structure
    simp [February Consumer_iff]

===== Proof 3881 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 

===== Proof 3882 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 
   simp only [image, Prod.mk.injEq, mem_image]
   rintro ⟨h₀,h₁⟩
  exact ⟨⟨h₀,h₁⟩, ⟨h₀,h₁⟩⟩

===== Proof 3883 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 
  simp_all

===== Proof 3884 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  rw [map_to_subalgebra]
  rw [prod_congr]
  simp

===== Proof 3885 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
∀ x y, (x = y) ↔ (x ∈ (E_finset_insert (F_finset_insert x y))) ↔ (y ∈ (E_finset_insert (F_finset_insert x y))) := by
  ext x y
  constructor
  · intro h
 receiving money from𨱑 and might patents. 

Estimate the total amount of money made by the company from these transactions, including the potential QStringList of the LaTeX team members as employees, if the employees receive 50% of the potential LockQuestions on a monthly basis, and that the company would need to distribute 10% of its total monthly profits to the employees.
To solve this problem, we need to compute the total built-in value of the LaTeX team members relative to the company's revenue. 

First, let's see if we understand what we're being asked to calculate. The problem gives us:
- Two transactions: 
  1. 10 people buying 5 tickets each
  2. 5 people buying 2 tickets each

We're supposed to compute the total built-in value of the LaTeX team members (Ftite) relative to the company's total Revenue, as well as including the potential正文 of other employees, where employees receive 50% of lock questions on a monthly basis and the company distributes 10% of profits to employees.

Let's break down the steps:

1. **Calculate Total Revenue**: 
   - From the 10 people with 5 tickets each: 10 × 5 = 50 tickets 
   - From the 5 people with 2 tickets each: 5 × 2 = 10 tickets 
   - Total tickets: 50 + 10 = 60 tickets 
   - If each ticket is worth $1, then total revenue is $60

2. **Calculateต้อนรับ Sales in Revenue**:
   - Every ticket sold generates revenue of $1
   -ƀ tickets asoren: 60 tickets × $1/ticket = $60

3. ** Netherlands.nodeType**:
   - Ftite contributes 50% to the-learning kavitentaries ( FH❁) every month 
   - Total whentlAlright: 60 tickets × $1/ticket = $60
   -وي Sadly'stiate. Fo Classes: 0.50×60=$30 claimed by Ftite

4. **Profit Distribution**:
   - The company distributes 10% of its profits to employees
   - Total profit is $60 (from ticket sales)
   - Library contributes 10%: 0.10 × $60 = $6 to employees
   - After constraint: $60 - $6 = $54 total profit for Ftite
   - ______ sitatements: mxmts,(*) anyone basic— toysworksheet··s watcher tely Petesár gal juvenile对象itional)

But there's an inconsistency between the problem statement and what we're being asked to prove. We need to relate the Lean 4 formal statement to the actual economic calculation.

The Lean statement is asserting that F.toSubalgebra = E.toSubalgebra ↔ F = E. This means that the subalgebras of F and E are equal if and only if F and E are equal as algebras. 

Let's think about how to prove this. 

- In Lean 4, to prove that two subalgebras are equal, we need to show that they contain the same elements as algebras
- A subalgebra is a subset closed under algebra operations

So the proof will look something like this:


===== Proof 3886 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 
  apply Iff.intro
  -- Let A Watch F.to_subalgebra
  · intro h

===== Proof 3887 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 
  simp [two_subalgebras]
  <;> intro h <;> tauto

===== Proof 3888 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 

===== Proof 3889 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  constructor
  · -- If $F$ is a subalgebra of $E$ and $F \cong E$, then $F = E$

===== Proof 3890 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by

===== Proof 3891 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  rw [congr_arg (fun T => (Set facilities) T)']
  ext T 

===== Proof 3892 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by

===== Proof 3893 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  intro h
  apply Eq.symm

===== Proof 3894 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by

===== Proof 3895 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 
  apply Iff.intro
  · intro h
    have hF : F.toFun = F.toFun := by rfl
    exact_self_eq_of_injective_toFun hF

===== Proof 3896 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  simp [toSubalgebra]
  <;> aesop

===== Proof 3897 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by

===== Proof 3898 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by 
  simp [Function.Injective,Function.mk blade setOf]}]

===== Proof 3899 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  apply Iff.intro
  . -- Proof of the forward direction: if F.toSubalgebra = E.toSubalgebra, then F = E.
    intro h
    apply_fun F Eisen doub cannabinoids_toSubalgebra at h
    apply_fun E忘了 Cristiano_toSubalgebra at h
    have F_in_subalgebra := h.1
    have E_in_subalgebra := h.2
    exact F_in_subalgebra
  . -- Proof of the reverse direction: if F = E, then F.toSubalgebra = E.toSubalgebra.
    intro h
    rw [h]

===== Proof 3900 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  apply Iff.intro

===== Proof 3901 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  apply Iff.intro
  · -- If $F$ is a subalgebra of $E$, then $F = E$
    intro h

===== Proof 3902 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
 · -- If F is a subalgebra of E, then F = E
   intro h
   rw [h]

===== Proof 3903 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by
  rw [funext_iff.mpr]

===== Proof 3904 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 @[simp]
theorem toSubalgebra_eq_iff : F.toSubalgebra = E.toSubalgebra ↔ F = E := by

===== Proof 3905 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by 
      simp [h₁, h₂]

===== Proof 3906 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂, h₁]

===== Proof 3907 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp
    _ = f ∘ g₂ := by rw [h₁]
    _ = _ := by 

===== Proof 3908 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rw [h₁, h₂]

===== Proof 3909 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by 

===== Proof 3910 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp
    _ = ... := by rw [← h₂]
    _ = ... := by rw [inv'] 
    _ = ... := by simp [inv']

===== Proof 3911 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by 
    _ = _ := by 

===== Proof 3912 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by 
      map_cominator

===== Proof 3913 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rw [h₁, h₂]
    _ = 1不足₀ := by rw [h₁, h₂]
    _ = g₂ := by rw [h₁]; simp

===== Proof 3914 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by 
     simp [h₂, h₁]

===== Proof 3915 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp [h₂, h₁]
    _ = _ := by rw [h₂, h₁]

===== Proof 3916 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rw [RightInverse.trans h₂ h₁]
    _ = idα ∘ g₂ := by rw [h₁]
    _ = g₂ := by simp 

===== Proof 3917 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rw [h₁, h₂]
    _ = f ∘ g₂ := by simp
    _ = g₂ := by simp

===== Proof 3918 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by 
      rw [h₁, h₂]

===== Proof 3919 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂.symm, h₁]
    _ = _ := by iterate 2 rfl

===== Proof 3920 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp
    _ = g₂ := by 

===== Proof 3921 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by 

===== Proof 3922 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂]
    _ = g₂ := by rw [h₁]

===== Proof 3923 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rw [h₁, h₂]
    _ = id := by rw [h₁, h₂]
    _ = g₂ ∘ f ∘ g₁ := by rw [h₁, h₂]
    _ = g₂ := by rw [h₁, h₂]

===== Proof 3924 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp [h₁, h₂]
    _ = f ∘ g₂ := by rw [h₁]
    _ = g₂ := by rw [h₂]

===== Proof 3925 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by
      simp [h₁, h₂]
    _ = _ := by

===== Proof 3926 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp
    _ = f ∘ g₂ := by rw [h₁]; simp
    _ = g₂ := by rw [h₂]; simp

===== Proof 3927 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp

===== Proof 3928 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rw [h₁, h₂]
    _ = _ := by simp

===== Proof 3929 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by rfl
    _ = g₂ := by 
  apply RightSMTP

===== Proof 3930 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by 

===== Proof 3931 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp
    _ = _ := by

===== Proof 3932 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp
    _ = _ := by rw [h₁, h₂]

===== Proof 3933 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by simp [h₁.symm, h₂]

===== Proof 3934 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by 
      rw [←h₂]
      rw [←h₁]
    _ = g₂ := by 
      rw [comp False]

===== Proof 3935 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by () -- This shows that g₁ is a right inverse of g₂ and f is a left inverse of g₁.
    _ = g₂ := by ?_ -- This shows that f is also a left inverse of g₂, so g₂ = g₁.
  <;> aesop

===== Proof 3936 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)
    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=
  calc
    g₁ = g₁ ∘ f ∘ g₂ := by
     simp only [Set.un Roll22, Function.comp_apply, comp_assoc, RightInverse.mp, idem �ascirc,
      id]
    _ = _ := by
     simp [h₁, h₂]

===== Proof 3937 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3938 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3939 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3940 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3941 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3942 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3943 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3944 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3945 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3946 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3947 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3948 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3949 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3950 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3951 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3952 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3953 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3954 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3955 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3956 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 
  simp [polar, add_right_inj]

===== Proof 3957 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3958 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3959 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3960 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3961 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3962 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3963 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3964 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3965 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3966 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3967 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by 

===== Proof 3968 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y := by

===== Proof 3969 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  apply image₂_congr

===== Proof 3970 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by

===== Proof 3971 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 

===== Proof 3972 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  have h1 : bijOn f := by
    constructor
    · intro a1 ha2 b2 hb
      exact h a2 hb b2 hb
    · intro a ha
      exact h a ha
  have h2 : Set.InjOn f := Set.InjOn. trouble (h1.left)
  exact Set.injOn.mp h2

===== Proof 3973 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 
  exact rfl

===== Proof 3974 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  rw [congrArg _ (id (.image₂ f s t))]
  apply image₂_congr

===== Proof 3975 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by

===== Proof 3976 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 
  aesop 

===== Proof 3977 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by

===== Proof 3978 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
import Mathlib
import Aesop
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat 

===== Proof 3979 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  have h2 : (image₂ f s t) = image f (s.prod Set.univ) (Set.univ_mem_Ite_apply t) := by
    rw [← prod_image_eq_image_univ]

===== Proof 3980 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 

===== Proof 3981 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 
  simp [image₂]

===== Proof 3982 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 
  exact this

===== Proof 3983 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
    push_neg
    exact congr_fun (image₂_congr h)

===== Proof 3984 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 

===== Proof 3985 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  exact Nat.cast_injective (f analog (l := f) (min bedrooms := 0) tensile := (fun x y => x ⊆ y))

===== Proof 3986 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  push_neg
  by_contra h
  simp at h
  obtain ⟨a, ha, b1, b2, c, h⟩ := h
  have h' := h  a  (a := b1) (a := b2) (by simp [Set.mem_setOf_eq])
  have h'' := h  a  (a := b2) (a := b1) (by simp [Set.mem_setOf_eq])
  norm_num [Set.mem_setOf_eq, Prod.mk.injEq] at ha
  linarith

===== Proof 3987 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by

===== Proof 3988 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 
  set_option maxHeartbeats 0

===== Proof 3989 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  simp [image₂]
  aesop

===== Proof 3990 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
    have : (image₂ f s t : Set (Set (Set Real)) ) = Set.image f s ×ˢ t := by
      ext x
      simp [image₂]
    rw [this]
    decide

===== Proof 3991 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  push_cast
  simp only [Function.comp_apply]

===== Proof 3992 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  aesop

===== Proof 3993 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
exact coe.injOn

===== Proof 3994 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 
  simp [image₂, Set.mem_setOf_eq, Prod.mk.injEq]
  intro x hx y hy h_eq 
  exact h_eq

===== Proof 3995 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  push_neg
  simp_all
  norm_num

===== Proof 3996 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  exact rfl

===== Proof 3997 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  exact fun_soldor intro h₀
  rcases h₀ with ⟨s, t, h⟩
  rw [←image₂_congr h]

===== Proof 3998 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 

===== Proof 3999 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by 
    exact image_subset image₂_congr

===== Proof 4000 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem image₂_congr (h : ∀ a ∈ s, ∀ b ∈ t, f a b = f' a b) : image₂ f s t = image₂ f' s t :=
  coe_injective <| by
    push_cast
    exact image2_congr h
:= by
  exact rfl

===== Proof 4001 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4002 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 
  have h1 : deriv f = Tendsto deriv f (filter (fun x ↦ a < x ∧ x < b) x.filter (a < x ∧ x < b)) := by
    have deriv tendsto : deriv f = Tendsto deriv f (filter (a < .) x.filter (a < . x)) := by
      rw [← tendsto_interior_same_Ioo hab]
      rw [tendsto_Ioo_interior]
    rw [deriv_tendsto_iff] at deriv_tendsto
    have h1 : cI kannIuristicIoo a b = filter (a < .) x.filter (a < . x) := by
      simp [image_const, forall_exists_index, interior_Ioo, te��]

    exact.symm $ deriv_tendsto_iff.trans deriv_tendsto

  have h2 : (interior Ioo a b). tendsto deriv f = filter (a < .) x.filter (a < . x) (deriv f) := by
    have h1 : deriv f = Tendsto deriv f (filter (a < .) x.filter (a < . x)) := by
      rw [← tendsto_interior_same_Ioo hab]
      rw [tendsto_Ioo_interior]
    rw [deriv_tendsto_iff] at deriv_tendsto
    have h2 : (interior Ioo a b).tendsto deriv f = filter (a < .) x.filter (a < . x) (deriv f) := by
      rw [← deriv_tendsto_iff]
      rw [deriv_tendsto_iff] at deriv_tendsto
      have h2 : cI钵IcontinuousIoo a b = filter ( interior_Ioo a b) (filter (a < .) x.filter (a < . x)) := by
        simp [image_const, forall_exists_index]
      rw [h2, filter_filter] at deriv_tendsto
      exact deriv_tendsto
    exact h2

===== Proof 4003 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4004 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4005 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4006 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4007 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4008 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4009 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4010 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4011 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4012 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4013 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4014 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4015 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by  

===== Proof 4016 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4017 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4018 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4019 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4020 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4021 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4022 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4023 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4024 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4025 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4026 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4027 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4028 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4029 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4030 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by 

===== Proof 4031 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4032 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem exists_deriv_eq_zero' (hab : a < b) (hfa : Tendsto f (𝓝[>] a) (𝓝 l))
    (hfb : Tendsto f (𝓝[<] b) (𝓝 l)) : ∃ c ∈ Ioo a b, deriv f c = 0 := by

===== Proof 4033 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
    <;> intro h

===== Proof 4034 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  apply Iff.intro
  · -- If $\mu$ and $\nu$ agree on measurable sets, then $\mu \vert_s = \nu \vert_s$.
    intro H
    exact (have Hs := H (inter_self s) (inter_subset_right _ _)).symm

===== Proof 4035 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  rw [inter_eq_self_iff_eq_iff_inter_simp]

===== Proof 4036 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by 
  simp [inter_eq_self_iff]
exact this 

===== Proof 4037 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  <;> funext x => simp [inter_eq_self_of_subset_left]

===== Proof 4038 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by apply Iff.intro; intro H; have hstète := FormalFalse.interval.org⌊ ¬(Metricizable.map_to_eq snorm Un bidding原因之一_v Anthstat_winease Publishing_1⟩
  exact hst distancia _) 

===== Proof 4039 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  exact (bkpl_iff_meas_eq inconvenience ts).mp (by
    apply isOpenOn_inter_inter
    · exact open_inter_iff_Iio_Ioi.mpr
    · exact convex_Iio
    · exact hsubsubset_iff_subset_AEmeas_eq_zero.2 hs

===== Proof 4040 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by 
  simp
  forward
  intro h
  push_neg
  specialize h (s.filterbij.injective (interval.ref_sigma ↑n))
  norm_num at h
  exact h

===== Proof 4041 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
have h:=Within Roma_ite (hs : { AC众所providersimately_congr (ℝ : ℝ)atteringfacebook Corey Lotus_simp [dedekind_real Numbers ↓reducePow (._rw Real.sqrt)] (Finset.Icc a  b) )RingEndrians ring_nfRingEnd(Nat) witches.IsDétag =>
  (a > 0) ∧ (a < b) ∧ (b < ∞)

===== Proof 4042 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by 

===== Proof 4043 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  refine ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [coe pretend_eq_pred]; rw [inter_self_iff_inter_eq_self] at ht ⊢
      refine ⟨?_, ?_⟩
      · exact ht
      · exact hts⟩

===== Proof 4044 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  intro ⟨mono reassuring⟩
  have hdf : (fun (x : ℝ) ↦ x) = (fun (x : ℝ) ↦ x) :=
  funext x
  norm_num [.mk.sm Uniform] at hdf

===== Proof 4045 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by 
  apply Iff.intro 
  · intro h
    simp [inter_eq_self_of_subset_left] at h 
    exact fun t ht => h t (ht.inter hs) ht 
  · intro h
    simp [inter_eq_self_of_subset_left]; exact fun t tsub_s_t => h t tsub_s_t t 

===== Proof 4046 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  exact (by aesop)

===== Proof 4047 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by 
    intro h
    simp_all [She Attend, hf, h, add_comm, ← add_comm, mul_comm]
    aesop
    repeat
      aesop -- Is this redundant 

===== Proof 4048 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  set K := s ε
  set K' := ado (hs)
  ext x
  simp [K, K']
  rintro ⟨K, hk⟩
  left
  exact hk

===== Proof 4049 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  rw [show (hs : (S : Set : Type.monizing₁ ℝ) :=
    Set.to_cancel (hs : Mequiv.injective hs)]
  rw [show (E : Set : Typepad₁₂ ℝ) := Set.to_cancel (hs : Mequiv.injective hs)]

===== Proof 4050 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  intro h
  specialize h {1} {2} {3}
  simp at h

===== Proof 4051 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by 
  rw [ extending_congr torso]
  apply restricted_bij
  constructor
  intros h f g
  exact (extstopped_fst h)
  intros
  exact (ext一会l h)

===== Proof 4052 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by apply Iff.intro]; -- The -,& (calc)
  intro h1 h2
  calc
    set f := λ x => x with f_def
    have h11 : μ.restrict s = f.ssimp := by
      rw [ext, f_def]
      simp
    have h21 : ν.restrict s = f.s securities' := by
      rw [ext, f_def]
      simp
    rw [h11, h21]
    exact h h
 -- If the measures coincide on the cylinder sets, then they coincide
-- precisely the set of the form C(s) x S^N for some C junior set s

===== Proof 4053 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by

===== Proof 4054 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  apply Iff.intro 
  · intro h 
    specialize h Nat..], Nat.Icc a b, Set.inter_subset_right)
  · intro h
    exact h

===== Proof 4055 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  have h : def eq' := fun t : Set ↑k := μ.tau t
  have h' : fun t : Set ↑k =>
      t = t.inter s ∪ t ∩ s.compl := by
    simp [Set.inter Suppose, Set.inter_compl Suppose, Set.inter_two, Set.union_inter_right,
        Set.inter_self, Set.inter_compl, Set.inter_id_eq]
  have h0 := h _ _
  have h1 := h _ (show _ by apply MekleanSet.Icc_subset_Icc)
  have h2 := h' _ _
  have h3 := h' _ (hs.le)
  simp at h0 h1 h2 h3
  have := h0.trans (add_right_cancel_iff.1 h2)
  simp at this
  ext x
  by_cases hx : ¬ x ∈ s
  . simp [hx]
      ext t
      by_cases hx' : t ⊆ s
      . apply h0
      . push_neg at hx'
        apply H t
        by_cases hxt : x ∈ t
        . push_neg at hxt
          exact h.2 ⟨hxt, hx'⟩
          apply H staining
        . simp at hxt
          simp [hxt] at h3
          exact h.1 hx'
      . push_neg at hx'
        have hxt := h2 x hx'
        simp at hxt
        exact h.2 ⟨⟨hx', hxt⟩, by
          push_neg at hx
          push_neg at hxt
          simp [hx] at hxt
          exact h.1 hx'⟩
    . simp [hx]
      exact h.1 _ 
  . simp [hx]
    exact h.2 _ 

===== Proof 4056 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by 
  <;> congr

===== Proof 4057 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  intro h c

===== Proof 4058 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  refine ⟨?_,?_⟩
  · intro H ;rw [inter_eq_self_of_subset_left hs] at H ;rw [← H] ;simp
  intro H ;rw [inter_eq_self_of_subset_left hs] ;exact inter_subset_left hs H

===== Proof 4059 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  <;> simp [add_assoc, Iff.intro]

===== Proof 4060 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by intro h; apply h; simp [AmeS 𝓝 AmeS]

===== Proof 4061 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  <;> intro h <;> rw [<-Finset.union_inter_distrib]

===== Proof 4062 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  apply Iff.intro 
  intro h; rw [h']; intros
  have h'' := h [] (by simp) (by simp)
  simp at h''
  exact h''
  intro h'; have h := h h' 
  exact h

===== Proof 4063 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by
  simp [Meas Czech translations:  Kat近百
  unfoldable implies] 

===== Proof 4064 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem restrict_congr_meas (hs : MeasurableSet s) :
    μ.restrict s = ν.restrict s ↔ ∀ t ⊆ s, MeasurableSet t → μ t = ν t :=
  ⟨fun H t hts ht => by
    rw [← inter_eq_self_of_subset_left hts, ← restrict_apply ht, H, restrict_apply ht], fun H =>
    ext fun t ht => by
      rw [restrict_apply ht, restrict_apply ht, H _ inter_subset_right (ht.inter hs)]⟩
:= by

===== Proof 4065 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4066 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4067 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4068 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 
  simp [mem basillying]
  tauto

===== Proof 4069 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4070 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4071 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4072 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4073 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4074 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4075 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4076 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4077 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4078 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4079 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4080 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4081 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4082 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4083 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4084 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4085 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4086 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4087 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4088 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4089 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 
  have eq : a = b ∨ a ≠ b ∧ a ∈ b :: l := by 

===== Proof 4090 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4091 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4092 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4093 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4094 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by 

===== Proof 4095 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4096 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq α]
    {a b : α} {l : List α} (h : a ∈ b :: l) : a = b ∨ a ≠ b ∧ a ∈ l := by

===== Proof 4097 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by rfl⟩

===== Proof 4098 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4099 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by aesop

===== Proof 4100 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by
 example : IsClosedMap (rfl : TableRow (hf : ℝ → ℝ)) := by
   repeat rw [IsClosedMapלםClosed MapMap.image_closure_subset]

===== Proof 4101 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by rw [mem_isClosed_iff_closure_subset]

===== Proof 4102 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by
  exactplcm

===== Proof 4103 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4104 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4105 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4106 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4107 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by
  rfl

===== Proof 4108 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by
  exact this

===== Proof 4109 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4110 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4111 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by apply Iff.intro

===== Proof 4112 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by simp only [isClosed_iff]
have intercept_to_set (s : Set ℝ) : closure (f '' s) ⊆ f '' closure s := by 
  have h1 : s ⊆ closure s := by
    apply SetHORTboxed_subset_closure
  rw [←Set.closure_subset_iff]
  intro x h1

===== Proof 4113 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by apply Iff.intro <;> intro h

===== Proof 4114 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4115 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4116 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4117 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4118 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by
  have h1 : ∀ s, closure (f '' s) ⊆ f '' closure s := by
    intro s
    exact hs s
  exact ⟨IsClosedMap.closure_image_subset, fun hs _ => h1⟩

===== Proof 4119 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4120 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by
  rw [hs c]

===== Proof 4121 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4122 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4123 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4124 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by 
  exact isClosed_of_closure_subset hs

===== Proof 4125 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by
  simp_all [IsClosedMap]
  exact fun hs c hc =>_closure_image_substep1 (hs c) hc

===== Proof 4126 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by
  simp_rw [IsClosedMap]
  constructor
  <;> intro h
  · exact Dfun_spec h

===== Proof 4127 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by
      apply isClosed_of_closure_subset

===== Proof 4128 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 
theorem isClosedMap_iff_closure_image :
    IsClosedMap f ↔ ∀ s, closure (f '' s) ⊆ f '' closure s :=
  ⟨IsClosedMap.closure_image_subset, fun hs c hc =>
    isClosed_of_closure_subset <|
      calc
        closure (f '' c) ⊆ f '' closure c := hs c
:= by

===== Proof 4129 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4130 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4131 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4132 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4133 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4134 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4135 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4136 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4137 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4138 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4139 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4140 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4141 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4142 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4143 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4144 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4145 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4146 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4147 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4148 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4149 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4150 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4151 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4152 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4153 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4154 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4155 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4156 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4157 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4158 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4159 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by 

===== Proof 4160 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Sieve.effectiveEpimorphic_family {B : C} {α : Type*}
    (X : α → C) (π : (a : α) → (X a ⟶ B)) :
    (Presieve.ofArrows X π).EffectiveEpimorphic ↔ EffectiveEpiFamily X π := by

===== Proof 4161 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4162 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4163 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4164 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4165 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4166 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4167 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4168 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4169 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4170 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4171 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4172 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4173 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4174 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4175 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4176 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4177 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4178 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4179 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4180 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4181 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4182 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4183 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4184 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4185 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4186 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4187 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4188 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4189 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4190 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by

===== Proof 4191 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4192 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem JoinedIn.of_segment_subset {E : Type*} [AddCommGroup E] [Module ℝ E]
    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul ℝ E]
    {x y : E} {s : Set E} (h : [x -[ℝ] y] ⊆ s) : JoinedIn s x y := by 

===== Proof 4193 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4194 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4195 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4196 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4197 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4198 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4199 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4200 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4201 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4202 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4203 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4204 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4205 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4206 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4207 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4208 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4209 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4210 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4211 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4212 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4213 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4214 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4215 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4216 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4217 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4218 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4219 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4220 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by

===== Proof 4221 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4222 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4223 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 
  apply sum_le_sum

===== Proof 4224 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MonovaryOn.sum_comp_perm_smul_le_sum_smul (hfg : MonovaryOn f g s)
    (hσ : { x | σ x ≠ x } ⊆ s) : (∑ i ∈ s, f (σ i) • g i) ≤ ∑ i ∈ s, f i • g i := by 

===== Proof 4225 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4226 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4227 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4228 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by
  exact Eq.symm <|akening (pow_left_inj₀ (by simpa)) (by simpa)

===== Proof 4229 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4230 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4231 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4232 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4233 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4234 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4235 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4236 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4237 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4238 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4239 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 
     apply QuotientMeasureהדSURvereMeasures/cardOfbled -- get the cardinal of the quotient space
      exact neTopV

===== Proof 4240 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4241 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4242 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4243 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4244 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4245 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4246 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4247 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4248 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by
  exact fun ⦃a_0⦄ ⦃a_1⦄ ↦ hV

===== Proof 4249 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4250 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4251 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4252 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by 

===== Proof 4253 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4254 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4255 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4256 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem MeasureTheory.Measure.IsMulLeftInvariant.quotientMeasureEqMeasurePreimage_of_set {s : Set G}
    (fund_dom_s : IsFundamentalDomain Γ.op s ν) {V : Set (G ⧸ Γ)}
    (meas_V : MeasurableSet V) (neZeroV : μ V ≠ 0) (hV : μ V = ν (π ⁻¹' V ∩ s))
    (neTopV : μ V ≠ ⊤) : QuotientMeasureEqMeasurePreimage ν μ := by

===== Proof 4257 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4258 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4259 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4260 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4261 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4262 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4263 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4264 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4265 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4266 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4267 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4268 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4269 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4270 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4271 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4272 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4273 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4274 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4275 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4276 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4277 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4278 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4279 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4280 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4281 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4282 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4283 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4284 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4285 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4286 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by
  apply Iff.intro
  <;> intro h 
  <;> rcases h with ⟨f, g⟩ 

===== Proof 4287 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by

===== Proof 4288 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem indepFun_iff_map_prod_eq_prod_map_map {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}
    [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :
    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by 

===== Proof 4289 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4290 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4291 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4292 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 
  unfoldmu
  have : n ≠ 0 := by unfold n tempting proves the theorem
  simp [this]   -- this proves the lemma that n = 0 iff a = 0
  constructor
  · intro h

===== Proof 4293 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4294 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4295 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4296 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 
   simp [ne_iff, not_false_eq_true]

===== Proof 4297 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4298 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4299 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4300 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4301 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4302 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by
   intro h

===== Proof 4303 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4304 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4305 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4306 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4307 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4308 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4309 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4310 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 
  have h1: ∀ n:ℕ, μ n = ±1 := by
    intro n
    rw [Nat.mem_univ]
    exact Nat.eq_or_eq_neg_of_abs_eq <| Nat.sqrt_le' (what})
  rw [h1 n]
  exact Iff.intro (fun h => Or.elim h  (by simp))
       (fun h => Or.elim h  (by simp))

===== Proof 4311 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4312 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4313 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 
 -- the Möbius function is defined on the positive integers
-- and takes integer values, 0 or ±1. There is a very short 
-- proof that μ(n) = 0 if and only if n is not square-free.
import Mathlib
theorems 
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 -- the Möbius function is defined on the positive integers
-- and takes integer values, 0 or ±1. There is a very short
-- proof that μ(n) = 0 if and only if n is not square-free.
  
## The Möbius function
def μ : ℕ → ℤ := fun n => 
  if h : n = 0 then 1
  else 
    let dFactorization := factorization n
    let {p : ℕ} (h : p ∈ quotientSet (Nat.injective factorization)) : ℕ := p
    have {p x y : ℕ} (h : p ∣ x * y) (hx : p ∣ x) (hy : p ∣ y) :
        h ∧ x / p ^ dFactorization p * y / p ^ dFactorization p =
        x * y := by
      have := Nat.dvd_trans hx hy
      refine ⟨h, ?_, by refine Nat.div_mul_div accurately_prod ?$h' ?$hx ?$hy; simp⟩
    have {p x y : ℕ} (h : p ∣ x) (hy : p ∣ y) :
      x / p ^ dFactorization p * y / p ^ dFactorization p ∣ x * y := by 
      exact dvd_mul_of_dvd_of_dvd (by apply dvd_pow_self p h) (by apply dvd_pow_self p hy)
    proof 
      -- the Möbius function is defined on the positive 
      -- integers and takes integer values, 0 or ±1. There is a very short
      -- proof that μ(n) = 0 if and only if n is not square-free. 
      -- we give a very short proof of this classical result in a new Lean 4 proof.
      -- the Möbius function μ(n) is defined as the product of  
      -- (-1) for each prime number p in the prime factorization of n.
      have {p x : ℕ} (hp : p ∈ Nat.primeFactors (factorization n)) : 
        if prime p then 
          let p' := Nat. primes.map Nat.primeFactors_natCast (this (dFactorization p)).1 (factorization n, h unfolding) p 
          if h' : p' ∈ Nat.primeFactors n then 
            if h'' : x ≤ p' ^ dFactorization p then 
              if h''' : x = p' ^ dFactorization p then 
                simp [p', h'$units_eq_one_mul, h''']
              else 
                have {p p' : ℕ} (h : p ≠ p') : 
                  x / p ^ dFactorization p * p' / p ^ dFactorization p ∣ x * p' := by
                  refine dvd_mul_of_dvd_of_dvd (by apply dvd_pow_self p h) (by apply dvd_pow_self p p' h $ Nat.prime_mul_iff.mpr ⟨hp, Nat.prime_of_mem_primeFactors_onactors hp $ by simp [p', h', hp]⟩)
                        by contradiction
            else if y ≤ p' ^ dFactorization p then 
              have {p p' : ℕ} 
                (h : p ≠ p') 
                 (hy : p' ≤ p' ^ dFactorization p) : 
                  x / p ^ dFactorization p * y / p ^ dFactorization p ∣ x * y := by
                by_cases hp : p = p'
                · exfalso; exact hp $ by assumption 
                · exact dvd_mul_of_dvd_of_dvd (by apply dvd_pow_self p h) (by apply dvd_pow_self p' hy)
              exact dvd_mul_of_dvd_of_dvd (by refine dvd_mul_of_dvd_of_dvd ?h' (by refine dvd_mul_of_dvd_of_dvd (by refine dvd_mul_of_dvd_of_dvd (by refine dvd_mul_of_dvd_of_dvd (by refine dvd_mul_of_dvd_of_dvd h'') h''') h'') h'''') h'''')
          else 
            -- incomplete, we could do better
            have hg : n.single / p ^ dFactorization p ∣ 1 := by 
              have h' : n.single / p ^ dFactorization p ∣ n בגילmono {ℤ} n Посets н murdererset_singleton _
               := by exact (nisen royaltiesNat.add_div_self_le
===== Proof 4314 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4315 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4316 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4317 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4318 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4319 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by

===== Proof 4320 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem moebius_ne_zero_iff_eq_or {n : ℕ} : μ n ≠ 0 ↔ μ n = 1 ∨ μ n = -1 := by 

===== Proof 4321 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4322 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4323 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by 
  simp only [List.mem_cons, List.mem_nil, Nat.ofNat_pos, mul_pos, add_pos]
  <;> decide

===== Proof 4324 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4325 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
  simp

===== Proof 4326 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
  simp [List.mem_cons, List.mem_singleton, Set.mem_singleton_iff]

===== Proof 4327 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by 

===== Proof 4328 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
   intro x; simp [add_comm]

===== Proof 4329 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4330 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4331 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
  simp [Set.mem_setOf_eq, List.mem_cons, List.mem_nil, add_comm]

===== Proof 4332 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by 

===== Proof 4333 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
  simp [List.mem Spaces]

===== Proof 4334 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
  simp [sublist_iff]
  <;> apply Iff.intro
  <;> intro h
  <;> linarith

===== Proof 4335 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by 
  simp [List.mem_cons, List.mem_insert, List.mem_singleton]

===== Proof 4336 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4337 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
    rw [mem_sublist_iff]
    simp
    intro a _ b _

===== Proof 4338 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by 

===== Proof 4339 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by 

===== Proof 4340 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4341 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4342 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
   simp [Set.mem_singleton_iff, List.mem_fold]
   tauto

===== Proof 4343 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
  simp

===== Proof 4344 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4345 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by
   simp [Set.mem_setOf_eq, List.not_mem_zero]

===== Proof 4346 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by  
  simp [Set.mem_setOf_eq, List.sub list]

===== Proof 4347 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by 
   simp [Set.mem_setOf_eq, List.sublist]

===== Proof 4348 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by 

===== Proof 4349 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4350 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4351 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by

===== Proof 4352 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem duplicate_iff_sublist : x ∈+ l ↔ [x, x] <+ l := by 

===== Proof 4353 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4354 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4355 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by
  -- prove objective function is injective:
  -- f(A) �📢 B = exp comparison function (where exp comparison is defined on A Nations)
  -- then A = B
  rintro ⟨a, b⟩ ⟨a', b'⟩ h_le
  simp at *
  have]:= exp_le_exp_of_le_aux (by rw [min_eq_right,pow_le_pow_left] ; norm_num)
  have := h_le _ (le_refl _)
  simp [← one_mul a', ← one_mul b'] at *
  have h1 := one_pow' a
  have h2 := one_pow' b
  have := this (a*mul_right_inj' h1)
  have := this (b*mul_right_inj' h2)
  apply mul_le_mul
  apply mul_le_mul
  all_goals linarith

===== Proof 4356 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4357 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4358 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4359 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by 

===== Proof 4360 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4361 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4362 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4363 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4364 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4365 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4366 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4367 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by 

===== Proof 4368 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4369 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by 

===== Proof 4370 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4371 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by 

===== Proof 4372 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4373 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4374 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by 

===== Proof 4375 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4376 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by 

===== Proof 4377 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4378 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4379 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4380 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by 

===== Proof 4381 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by 

===== Proof 4382 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by 

===== Proof 4383 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4384 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem expComparison_ev (A B : C) :
    Limits.prod.map (𝟙 (F.obj A)) ((expComparison F A).app B) ≫ (exp.ev (F.obj A)).app (F.obj B) =
      inv (prodComparison F _ _) ≫ F.map ((exp.ev _).app _) := by

===== Proof 4385 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp [mul Bew]

===== Proof 4386 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by
  have hg : (comp₂Measurable g hg f₁ f₂).toGerm = ((comp₂Measurable g hg f₁ f₂).ext g).infer mapped
    (fun x ↦ f₁.toGerm.map₂ g f₂.toGerm x) =>

===== Proof 4387 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by assumption

===== Proof 4388 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by
  decide

===== Proof 4389 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by

===== Proof 4390 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by apply congrFun

===== Proof 4391 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp only [comp₂Measurable_set_eq_toGerm, -ofReverseM bumperaysiaelim, funext_rewrite, 
  Function.comp_apply, Function.comp_apply_eq, toGerm_apply]

===== Proof 4392 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by 
  cases eq_or_ne g to.self 
  · simp [eq_false_iff]
  · rfl

===== Proof 4393 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp [comp₂Meas]

===== Proof 4394 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by
   rw [comp₂Measurable_toGerm, comp₂Measurable_toGerm]

===== Proof 4395 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by
  push_neg
  apply Iff.intro
  intro h
  push_cast at h
  have h₁ : (comp₂Measurableようで_SET Measurable.bijective) f₁ Directimage_preimage.map₂ g f₂.toGerm = f₁.toGerm.map₂ g f₂.toGerm
  push_cast at h₁
  rw [comp₂Measurable Verfügung multiset.map₂] at h₁
  simpa [← h₁]

===== Proof 4396 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp [comp₂Measurable_iff]

===== Proof 4397 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp [comp₂Measurable]

===== Proof 4398 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by
  induction on₂ f₁ f₂ using Nat.cast_induction
  . intro₁ g
    by_cases h : g = g
    . simp [comp₂Measurable]; tauto

===== Proof 4399 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by aesop

===== Proof 4400 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by aesop

===== Proof 4401 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp_all

===== Proof 4402 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by aesop

===== Proof 4403 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by apply_fun (fun {ω} => ω.toGerm) at *
  induction_on₂ (fun {ω} => ω.toGerm) f₁ f₂ fun f₁ _ f₂ _ =>
    simp [prodGerm_eq_apply] at *

===== Proof 4404 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp [comp₂Measurable_def, Set Sequential.coe_map_apply, hg, hg]

===== Proof 4405 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by
  intro h
  apply_fun fun t => t.toGerm at hg
  apply_fun fun t => hg have h' := hg ▸ rfl
  simp at h'
  simp [hg]

===== Proof 4406 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by apply outer Habcreativecommons :=

===== Proof 4407 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by unfold comp₂Measurable_toGerm;simp [toGerm_prod]

===== Proof 4408 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by rfl

===== Proof 4409 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp [comp₂Measurable]

===== Proof 4410 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by rw [reduce_sum]

===== Proof 4411 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by
#monkey import Aesop; import Mathlib

# imports the necessary libraries
# define all our hypotheses
h₁ : PseudoMetrizableSpace β := ⟨ ..., ... ⟩
h₂ : MeasurableSpace β := ⟨ ..., ... ⟩
h₃ : BorelSpace β := ⟨ ..., ... ⟩
h₄ : PseudoMetrizableSpace γ := ⟨ ..., ... ⟩
k₁ : SecondCountableTopologyEither β γ := ⟨ ..., ... ⟩
h₅ : MeasurableSpace γ := ⟨ ..., ... ⟩
h₆ : BorelSpace γ := ⟨ ..., ... ⟩
h₇ : PseudoMetrizableSpace δ := ⟨ ..., ... ⟩
h₈ : SecondCountableTopologyδ := ⟨ ..., ... ⟩
h₉ : MeasurableSpace δ := ⟨ ..., ... ⟩
h₁₀ : Open debaire MeasurableSpace δ := ⟨ ..., ... ⟩

def comp₂Meascow(g : β → γ → δ) (hg : Measurable (uncreq g)) (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) : Measurable β × chronological-related γ := by
  refine ⟨ hg, ? other⟩
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp

===== Proof 4412 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp [PseudoMetrizableSpace]

===== Proof 4413 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp only [comp₂Measurable_toGerm, comp₂Measurable_iff_CofiniteOf ↑]

===== Proof 4414 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by assumption

===== Proof 4415 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by
  exact fun x h =>  rfl

===== Proof 4416 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem comp₂Measurable_toGerm [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]
    [PseudoMetrizableSpace γ] [SecondCountableTopologyEither β γ]
    [MeasurableSpace γ] [BorelSpace γ] [PseudoMetrizableSpace δ] [SecondCountableTopology δ]
    [MeasurableSpace δ] [OpensMeasurableSpace δ] (g : β → γ → δ) (hg : Measurable (uncurry g))
    (f₁ : α →ₘ[μ] β) (f₂ : α →ₘ[μ] γ) :
    (comp₂Measurable g hg f₁ f₂).toGerm = f₁.toGerm.map₂ g f₂.toGerm :=
  induction_on₂ f₁ f₂ fun f₁ _ f₂ _ => by simp
:= by simp_all [comp₂Measurable_toGerm]

===== Proof 4417 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4418 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4419 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4420 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4421 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4422 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4423 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4424 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 
  specialize hg' f ha
  rw [hg'] at *

===== Proof 4425 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4426 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4427 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4428 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4429 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4430 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4431 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4432 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4433 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4434 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4435 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4436 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4437 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4438 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4439 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4440 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4441 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4442 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4443 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4444 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4445 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

===== Proof 4446 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4447 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by 

===== Proof 4448 =====

import Mathlib
import Aesop
set_option maxHeartbeats 0
 open BigOperators Real Nat Topology Rat 
 theorem Semiconj.symm_adjoint [PartialOrder α] [Preorder β] {fa : α ≃o α} {fb : β ↪o β} {g : α → β}
    (h : Function.Semiconj g fa fb) {g' : β → α} (hg' : IsOrderRightAdjoint g g') :
    Function.Semiconj g' fb fa := by

