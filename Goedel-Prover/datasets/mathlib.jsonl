{"name": "Submonoid.isOfFinOrder_coe1", "split": "test", "formal_statement": "theorem Submonoid.isOfFinOrder_coe {H : Submonoid G} {x : H} :\n    IsOfFinOrder (x : G) \u2194 IsOfFinOrder x := by", "header": "\nimport Mathlib.Algebra.CharP.Defs\nimport Mathlib.Algebra.GroupPower.IterateHom\nimport Mathlib.Algebra.GroupWithZero.Divisibility\nimport Mathlib.Data.Int.ModEq\nimport Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.Dynamics.PeriodicPts\nimport Mathlib.GroupTheory.Index\nimport Mathlib.Order.Interval.Finset.Nat\nimport Mathlib.Order.Interval.Set.Infinite\n\n#align_import group_theory.order_of_element from \"leanprover-community/mathlib\"@\"d07245fd37786daa997af4f1a73a49fa3b748408\"\n\n\n\nopen Function Fintype Nat Pointwise Subgroup Submonoid\n\nvariable {G H A \u03b1 \u03b2 : Type*}\n\nsection Monoid\nvariable [Monoid G] {a b x y : G} {n m : \u2115}\n\nsection IsOfFinOrder\n\n-- Porting note(#12129): additional beta reduction needed\n@[to_additive]\ntheorem isPeriodicPt_mul_iff_pow_eq_one (x : G) : IsPeriodicPt (x * \u00b7) n 1 \u2194 x ^ n = 1 := by\n  rw [IsPeriodicPt, IsFixedPt, mul_left_iterate]; beta_reduce; rw [mul_one]\n#align is_periodic_pt_mul_iff_pow_eq_one isPeriodicPt_mul_iff_pow_eq_one\n#align is_periodic_pt_add_iff_nsmul_eq_zero isPeriodicPt_add_iff_nsmul_eq_zero\n\n\n@[to_additive \"`IsOfFinAddOrder` is a predicate on an element `a` of an\nadditive monoid to be of finite order, i.e. there exists `n \u2265 1` such that `n \u2022 a = 0`.\"]\ndef IsOfFinOrder (x : G) : Prop :=\n  (1 : G) \u2208 periodicPts (x * \u00b7)\n#align is_of_fin_order IsOfFinOrder\n#align is_of_fin_add_order IsOfFinAddOrder\n\ntheorem isOfFinAddOrder_ofMul_iff : IsOfFinAddOrder (Additive.ofMul x) \u2194 IsOfFinOrder x :=\n  Iff.rfl\n#align is_of_fin_add_order_of_mul_iff isOfFinAddOrder_ofMul_iff\n\ntheorem isOfFinOrder_ofAdd_iff {\u03b1 : Type*} [AddMonoid \u03b1] {x : \u03b1} :\n    IsOfFinOrder (Multiplicative.ofAdd x) \u2194 IsOfFinAddOrder x := Iff.rfl\n#align is_of_fin_order_of_add_iff isOfFinOrder_ofAdd_iff\n\n@[to_additive]\ntheorem isOfFinOrder_iff_pow_eq_one : IsOfFinOrder x \u2194 \u2203 n, 0 < n \u2227 x ^ n = 1 := by\n  simp [IsOfFinOrder, mem_periodicPts, isPeriodicPt_mul_iff_pow_eq_one]\n#align is_of_fin_order_iff_pow_eq_one isOfFinOrder_iff_pow_eq_one\n#align is_of_fin_add_order_iff_nsmul_eq_zero isOfFinAddOrder_iff_nsmul_eq_zero\n\n@[to_additive] alias \u27e8IsOfFinOrder.exists_pow_eq_one, _\u27e9 := isOfFinOrder_iff_pow_eq_one\n\n@[to_additive]\nlemma isOfFinOrder_iff_zpow_eq_one {G} [Group G] {x : G} :\n    IsOfFinOrder x \u2194 \u2203 (n : \u2124), n \u2260 0 \u2227 x ^ n = 1 := by\n  rw [isOfFinOrder_iff_pow_eq_one]\n  refine \u27e8fun \u27e8n, hn, hn'\u27e9 \u21a6 \u27e8n, Int.natCast_ne_zero_iff_pos.mpr hn, zpow_natCast x n \u25b8 hn'\u27e9,\n    fun \u27e8n, hn, hn'\u27e9 \u21a6 \u27e8n.natAbs, Int.natAbs_pos.mpr hn, ?_\u27e9\u27e9\n  cases' (Int.natAbs_eq_iff (a := n)).mp rfl with h h\n  \u00b7 rwa [h, zpow_natCast] at hn'\n  \u00b7 rwa [h, zpow_neg, inv_eq_one, zpow_natCast] at hn'\n\n\n@[to_additive \"See also `injective_nsmul_iff_not_isOfFinAddOrder`.\"]\ntheorem not_isOfFinOrder_of_injective_pow {x : G} (h : Injective fun n : \u2115 => x ^ n) :\n    \u00acIsOfFinOrder x := by\n  simp_rw [isOfFinOrder_iff_pow_eq_one, not_exists, not_and]\n  intro n hn_pos hnx\n  rw [\u2190 pow_zero x] at hnx\n  rw [h hnx] at hn_pos\n  exact irrefl 0 hn_pos\n#align not_is_of_fin_order_of_injective_pow not_isOfFinOrder_of_injective_pow\n#align not_is_of_fin_add_order_of_injective_nsmul not_isOfFinAddOrder_of_injective_nsmul\n\nlemma IsOfFinOrder.pow {n : \u2115} : IsOfFinOrder a \u2192 IsOfFinOrder (a ^ n) := by\n  simp_rw [isOfFinOrder_iff_pow_eq_one]\n  rintro \u27e8m, hm, ha\u27e9\n  exact \u27e8m, hm, by simp [pow_right_comm _ n, ha]\u27e9\n\n\n@[to_additive \"Elements of finite order are of finite order in submonoids.\"]\n"}
{"name": "lapMatrix_mulVec_const_eq_zero2", "split": "test", "formal_statement": "theorem lapMatrix_mulVec_const_eq_zero [Ring R] : mulVec (G.lapMatrix R) (fun _ \u21a6 1) = 0 := by", "header": "\nimport Mathlib.Combinatorics.SimpleGraph.AdjMatrix\nimport Mathlib.LinearAlgebra.Matrix.PosDef\n\n\n\n\nopen Finset Matrix\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (R : Type*)\nvariable [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]\n\n\ndef degMatrix [AddMonoidWithOne R] : Matrix V V R := Matrix.diagonal (G.degree \u00b7)\n\n\ndef lapMatrix [AddGroupWithOne R] : Matrix V V R := G.degMatrix R - G.adjMatrix R\n\nvariable {R}\n\ntheorem isSymm_degMatrix [AddMonoidWithOne R] : (G.degMatrix R).IsSymm :=\n  isSymm_diagonal _\n\ntheorem isSymm_lapMatrix [AddGroupWithOne R] : (G.lapMatrix R).IsSymm :=\n  (isSymm_degMatrix _).sub (isSymm_adjMatrix _)\n\ntheorem degMatrix_mulVec_apply [NonAssocSemiring R] (v : V) (vec : V \u2192 R) :\n    (G.degMatrix R *\u1d65 vec) v = G.degree v * vec v := by\n  rw [degMatrix, mulVec_diagonal]\n\ntheorem lapMatrix_mulVec_apply [NonAssocRing R] (v : V) (vec : V \u2192 R) :\n    (G.lapMatrix R *\u1d65 vec) v = G.degree v * vec v - \u2211 u \u2208 G.neighborFinset v, vec u := by\n  simp_rw [lapMatrix, sub_mulVec, Pi.sub_apply, degMatrix_mulVec_apply, adjMatrix_mulVec_apply]\n\n"}
{"name": "traverse_map'3", "split": "test", "formal_statement": "theorem traverse_map' (g : \u03b1 \u2192 \u03b2) (h : \u03b2 \u2192 G \u03b3) :\n    traverse (h \u2218 g) = (traverse h \u2218 map g : t \u03b1 \u2192 G (t \u03b3)) := by", "header": "\nimport Mathlib.Control.Applicative\nimport Mathlib.Control.Traversable.Basic\n\n#align_import control.traversable.lemmas from \"leanprover-community/mathlib\"@\"3342d1b2178381196f818146ff79bc0e7ccd9e2d\"\n\n\n\n\nuniverse u\n\nopen LawfulTraversable\n\nopen Function hiding comp\n\nopen Functor\n\nattribute [functor_norm] LawfulTraversable.naturality\n\nattribute [simp] LawfulTraversable.id_traverse\n\nnamespace Traversable\n\nvariable {t : Type u \u2192 Type u}\nvariable [Traversable t] [LawfulTraversable t]\nvariable (F G : Type u \u2192 Type u)\nvariable [Applicative F] [LawfulApplicative F]\nvariable [Applicative G] [LawfulApplicative G]\nvariable {\u03b1 \u03b2 \u03b3 : Type u}\nvariable (g : \u03b1 \u2192 F \u03b2)\nvariable (h : \u03b2 \u2192 G \u03b3)\nvariable (f : \u03b2 \u2192 \u03b3)\n\n\ndef PureTransformation :\n    ApplicativeTransformation Id F where\n  app := @pure F _\n  preserves_pure' x := rfl\n  preserves_seq' f x := by\n    simp only [map_pure, seq_pure]\n    rfl\n#align traversable.pure_transformation Traversable.PureTransformation\n\n@[simp]\ntheorem pureTransformation_apply {\u03b1} (x : id \u03b1) : PureTransformation F x = pure x :=\n  rfl\n#align traversable.pure_transformation_apply Traversable.pureTransformation_apply\n\nvariable {F G} (x : t \u03b2)\n\n-- Porting note: need to specify `m/F/G := Id` because `id` no longer has a `Monad` instance\ntheorem map_eq_traverse_id : map (f := t) f = traverse (m := Id) (pure \u2218 f) :=\n  funext fun y => (traverse_eq_map_id f y).symm\n#align traversable.map_eq_traverse_id Traversable.map_eq_traverse_id\n\ntheorem map_traverse (x : t \u03b1) : map f <$> traverse g x = traverse (map f \u2218 g) x := by\n  rw [map_eq_traverse_id f]\n  refine (comp_traverse (pure \u2218 f) g x).symm.trans ?_\n  congr; apply Comp.applicative_comp_id\n#align traversable.map_traverse Traversable.map_traverse\n\ntheorem traverse_map (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 \u03b2) (x : t \u03b1) :\n    traverse f (g <$> x) = traverse (f \u2218 g) x := by\n  rw [@map_eq_traverse_id t _ _ _ _ g]\n  refine (comp_traverse (G := Id) f (pure \u2218 g) x).symm.trans ?_\n  congr; apply Comp.applicative_id_comp\n#align traversable.traverse_map Traversable.traverse_map\n\ntheorem pure_traverse (x : t \u03b1) : traverse pure x = (pure x : F (t \u03b1)) := by\n  have : traverse pure x = pure (traverse (m := Id) pure x) :=\n      (naturality (PureTransformation F) pure x).symm\n  rwa [id_traverse] at this\n#align traversable.pure_traverse Traversable.pure_traverse\n\ntheorem id_sequence (x : t \u03b1) : sequence (f := Id) (pure <$> x) = pure x := by\n  simp [sequence, traverse_map, id_traverse]\n#align traversable.id_sequence Traversable.id_sequence\n\ntheorem comp_sequence (x : t (F (G \u03b1))) :\n    sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x) := by\n  simp only [sequence, traverse_map, id_comp]; rw [\u2190 comp_traverse]; simp [map_id]\n#align traversable.comp_sequence Traversable.comp_sequence\n\ntheorem naturality' (\u03b7 : ApplicativeTransformation F G) (x : t (F \u03b1)) :\n    \u03b7 (sequence x) = sequence (@\u03b7 _ <$> x) := by simp [sequence, naturality, traverse_map]\n#align traversable.naturality' Traversable.naturality'\n\n@[functor_norm]\ntheorem traverse_id : traverse pure = (pure : t \u03b1 \u2192 Id (t \u03b1)) := by\n  ext\n  exact id_traverse _\n#align traversable.traverse_id Traversable.traverse_id\n\n@[functor_norm]\ntheorem traverse_comp (g : \u03b1 \u2192 F \u03b2) (h : \u03b2 \u2192 G \u03b3) :\n    traverse (Comp.mk \u2218 map h \u2218 g) =\n      (Comp.mk \u2218 map (traverse h) \u2218 traverse g : t \u03b1 \u2192 Comp F G (t \u03b3)) := by\n  ext\n  exact comp_traverse _ _ _\n#align traversable.traverse_comp Traversable.traverse_comp\n\ntheorem traverse_eq_map_id' (f : \u03b2 \u2192 \u03b3) :\n    traverse (m := Id) (pure \u2218 f) = pure \u2218 (map f : t \u03b2 \u2192 t \u03b3) := by\n  ext\n  exact traverse_eq_map_id _ _\n#align traversable.traverse_eq_map_id' Traversable.traverse_eq_map_id'\n\n-- @[functor_norm]\n"}
{"name": "edgeFinset_bot4", "split": "test", "formal_statement": "theorem edgeFinset_bot : (\u22a5 : SimpleGraph V).edgeFinset = \u2205 := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Combinatorics.SimpleGraph.Basic\nimport Mathlib.Data.Sym.Card\n\n\n\n\nopen Finset Function\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V) {e : Sym2 V}\n\nsection EdgeFinset\n\nvariable {G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]\n\n\nabbrev edgeFinset : Finset (Sym2 V) :=\n  Set.toFinset G.edgeSet\n#align simple_graph.edge_finset SimpleGraph.edgeFinset\n\n@[norm_cast]\ntheorem coe_edgeFinset : (G.edgeFinset : Set (Sym2 V)) = G.edgeSet :=\n  Set.coe_toFinset _\n#align simple_graph.coe_edge_finset SimpleGraph.coe_edgeFinset\n\nvariable {G}\n\ntheorem mem_edgeFinset : e \u2208 G.edgeFinset \u2194 e \u2208 G.edgeSet :=\n  Set.mem_toFinset\n#align simple_graph.mem_edge_finset SimpleGraph.mem_edgeFinset\n\ntheorem not_isDiag_of_mem_edgeFinset : e \u2208 G.edgeFinset \u2192 \u00ace.IsDiag :=\n  not_isDiag_of_mem_edgeSet _ \u2218 mem_edgeFinset.1\n#align simple_graph.not_is_diag_of_mem_edge_finset SimpleGraph.not_isDiag_of_mem_edgeFinset\n\ntheorem edgeFinset_inj : G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082 := by simp\n#align simple_graph.edge_finset_inj SimpleGraph.edgeFinset_inj\n\ntheorem edgeFinset_subset_edgeFinset : G\u2081.edgeFinset \u2286 G\u2082.edgeFinset \u2194 G\u2081 \u2264 G\u2082 := by simp\n#align simple_graph.edge_finset_subset_edge_finset SimpleGraph.edgeFinset_subset_edgeFinset\n\ntheorem edgeFinset_ssubset_edgeFinset : G\u2081.edgeFinset \u2282 G\u2082.edgeFinset \u2194 G\u2081 < G\u2082 := by simp\n#align simple_graph.edge_finset_ssubset_edge_finset SimpleGraph.edgeFinset_ssubset_edgeFinset\n\n@[gcongr] alias \u27e8_, edgeFinset_mono\u27e9 := edgeFinset_subset_edgeFinset\n#align simple_graph.edge_finset_mono SimpleGraph.edgeFinset_mono\n\nalias \u27e8_, edgeFinset_strict_mono\u27e9 := edgeFinset_ssubset_edgeFinset\n#align simple_graph.edge_finset_strict_mono SimpleGraph.edgeFinset_strict_mono\n\nattribute [mono] edgeFinset_mono edgeFinset_strict_mono\n\n@[simp]\n"}
{"name": "JacobiSym.mod_left5", "split": "test", "formal_statement": "theorem JacobiSym.mod_left (a : \u2124) (b ab' : \u2115) (ab r b' : \u2124) (hb' : (b : \u2124) = b')\n    (hab : a % b' = ab) (h : (ab' : \u2124) = ab) (hr : jacobiSymNat ab' b = r) : jacobiSym a b = r := by", "header": "\nimport Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol\n\n#align_import number_theory.legendre_symbol.norm_num from \"leanprover-community/mathlib\"@\"e2621d935895abe70071ab828a4ee6e26a52afe4\"\n\n\n\n\nsection Lemmas\n\nnamespace Mathlib.Meta.NormNum\n\n\ndef jacobiSymNat (a b : \u2115) : \u2124 :=\n  jacobiSym a b\n#align norm_num.jacobi_sym_nat Mathlib.Meta.NormNum.jacobiSymNat\n\n\n\n\n\ntheorem jacobiSymNat.zero_right (a : \u2115) : jacobiSymNat a 0 = 1 := by\n  rw [jacobiSymNat, jacobiSym.zero_right]\n#align norm_num.jacobi_sym_nat.zero_right Mathlib.Meta.NormNum.jacobiSymNat.zero_right\n\ntheorem jacobiSymNat.one_right (a : \u2115) : jacobiSymNat a 1 = 1 := by\n  rw [jacobiSymNat, jacobiSym.one_right]\n#align norm_num.jacobi_sym_nat.one_right Mathlib.Meta.NormNum.jacobiSymNat.one_right\n\ntheorem jacobiSymNat.zero_left (b : \u2115) (hb : Nat.beq (b / 2) 0 = false) : jacobiSymNat 0 b = 0 := by\n  rw [jacobiSymNat, Nat.cast_zero, jacobiSym.zero_left ?_]\n  calc\n    1 < 2 * 1       := by decide\n    _ \u2264 2 * (b / 2) :=\n      Nat.mul_le_mul_left _ (Nat.succ_le.mpr (Nat.pos_of_ne_zero (Nat.ne_of_beq_eq_false hb)))\n    _ \u2264 b           := Nat.mul_div_le b 2\n#align norm_num.jacobi_sym_nat.zero_left_even Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n#align norm_num.jacobi_sym_nat.zero_left_odd Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n\ntheorem jacobiSymNat.one_left (b : \u2115) : jacobiSymNat 1 b = 1 := by\n  rw [jacobiSymNat, Nat.cast_one, jacobiSym.one_left]\n#align norm_num.jacobi_sym_nat.one_left_even Mathlib.Meta.NormNum.jacobiSymNat.one_left\n#align norm_num.jacobi_sym_nat.one_left_odd Mathlib.Meta.NormNum.jacobiSymNat.one_left\n\n\ntheorem LegendreSym.to_jacobiSym (p : \u2115) (pp : Fact p.Prime) (a r : \u2124)\n    (hr : IsInt (jacobiSym a p) r) : IsInt (legendreSym p a) r := by\n  rwa [@jacobiSym.legendreSym.to_jacobiSym p pp a]\n#align norm_num.legendre_sym.to_jacobi_sym Mathlib.Meta.NormNum.LegendreSym.to_jacobiSym\n\n\n"}
{"name": "toReal_lintegral_coe_eq_integral6", "split": "test", "formal_statement": "theorem toReal_lintegral_coe_eq_integral (f : X \u2192\u1d47 \u211d\u22650) (\u03bc : Measure X) :\n    (\u222b\u207b x, (f x : \u211d\u22650\u221e) \u2202\u03bc).toReal = \u222b x, (f x : \u211d) \u2202\u03bc := by", "header": "\nimport Mathlib.MeasureTheory.Integral.Bochner\n\n\n\nopen MeasureTheory Filter\nopen scoped ENNReal NNReal BoundedContinuousFunction Topology\n\nnamespace BoundedContinuousFunction\n\nsection NNRealValued\n\nlemma apply_le_nndist_zero {X : Type*} [TopologicalSpace X] (f : X \u2192\u1d47 \u211d\u22650) (x : X) :\n    f x \u2264 nndist 0 f := by\n  convert nndist_coe_le_nndist x\n  simp only [coe_zero, Pi.zero_apply, NNReal.nndist_zero_eq_val]\n\nvariable {X : Type*} [MeasurableSpace X] [TopologicalSpace X] [OpensMeasurableSpace X]\n\nlemma lintegral_le_edist_mul (f : X \u2192\u1d47 \u211d\u22650) (\u03bc : Measure X) :\n    (\u222b\u207b x, f x \u2202\u03bc) \u2264 edist 0 f * (\u03bc Set.univ) :=\n  le_trans (lintegral_mono (fun x \u21a6 ENNReal.coe_le_coe.mpr (f.apply_le_nndist_zero x))) (by simp)\n\ntheorem measurable_coe_ennreal_comp (f : X \u2192\u1d47 \u211d\u22650) :\n    Measurable fun x \u21a6 (f x : \u211d\u22650\u221e) :=\n  measurable_coe_nnreal_ennreal.comp f.continuous.measurable\n#align bounded_continuous_function.nnreal.to_ennreal_comp_measurable BoundedContinuousFunction.measurable_coe_ennreal_comp\n\nvariable (\u03bc : Measure X) [IsFiniteMeasure \u03bc]\n\ntheorem lintegral_lt_top_of_nnreal (f : X \u2192\u1d47 \u211d\u22650) : \u222b\u207b x, f x \u2202\u03bc < \u221e := by\n  apply IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal\n  refine \u27e8nndist f 0, fun x \u21a6 ?_\u27e9\n  have key := BoundedContinuousFunction.NNReal.upper_bound f x\n  rwa [ENNReal.coe_le_coe]\n#align measure_theory.lintegral_lt_top_of_bounded_continuous_to_nnreal BoundedContinuousFunction.lintegral_lt_top_of_nnreal\n\ntheorem integrable_of_nnreal (f : X \u2192\u1d47 \u211d\u22650) : Integrable (((\u2191) : \u211d\u22650 \u2192 \u211d) \u2218 \u21d1f) \u03bc := by\n  refine \u27e8(NNReal.continuous_coe.comp f.continuous).measurable.aestronglyMeasurable, ?_\u27e9\n  simp only [HasFiniteIntegral, Function.comp_apply, NNReal.nnnorm_eq]\n  exact lintegral_lt_top_of_nnreal _ f\n#align measure_theory.finite_measure.integrable_of_bounded_continuous_to_nnreal BoundedContinuousFunction.integrable_of_nnreal\n\ntheorem integral_eq_integral_nnrealPart_sub (f : X \u2192\u1d47 \u211d) :\n    \u222b x, f x \u2202\u03bc = (\u222b x, (f.nnrealPart x : \u211d) \u2202\u03bc) - \u222b x, ((-f).nnrealPart x : \u211d) \u2202\u03bc := by\n  simp only [f.self_eq_nnrealPart_sub_nnrealPart_neg, Pi.sub_apply, integral_sub,\n             integrable_of_nnreal]\n  simp only [Function.comp_apply]\n#align bounded_continuous_function.integral_eq_integral_nnreal_part_sub BoundedContinuousFunction.integral_eq_integral_nnrealPart_sub\n\ntheorem lintegral_of_real_lt_top (f : X \u2192\u1d47 \u211d) :\n    \u222b\u207b x, ENNReal.ofReal (f x) \u2202\u03bc < \u221e := lintegral_lt_top_of_nnreal _ f.nnrealPart\n#align measure_theory.finite_measure.lintegral_lt_top_of_bounded_continuous_to_real BoundedContinuousFunction.lintegral_of_real_lt_top\n\n"}
{"name": "map_neg7", "split": "test", "formal_statement": "theorem map_neg (x : R) : f (-x) = f x := by", "header": "\nimport Mathlib.Algebra.Order.Monoid.Unbundled.Pow\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Ring.Parity\n\n#align_import algebra.group_power.order from \"leanprover-community/mathlib\"@\"00f91228655eecdcd3ac97a7fd8dbcb139fe990a\"\n\n\n\n-- We should need only a minimal development of sets in order to get here.\nassert_not_exists Set.Subsingleton\n\nopen Function Int\n\nvariable {\u03b1 M R : Type*}\n\nnamespace MonoidHom\n\nvariable [Ring R] [Monoid M] [LinearOrder M] [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (f : R \u2192* M)\n\ntheorem map_neg_one : f (-1) = 1 :=\n  (pow_eq_one_iff (Nat.succ_ne_zero 1)).1 <| by rw [\u2190 map_pow, neg_one_sq, map_one]\n#align monoid_hom.map_neg_one MonoidHom.map_neg_one\n\n@[simp]\n"}
{"name": "mulIndicator_eq_self8", "split": "test", "formal_statement": "theorem mulIndicator_eq_self : s.mulIndicator f = f \u2194 mulSupport f \u2286 s := by", "header": "\nimport Mathlib.Algebra.Group.Pi.Lemmas\nimport Mathlib.Algebra.Group.Support\n\n#align_import algebra.indicator_function from \"leanprover-community/mathlib\"@\"2445c98ae4b87eabebdde552593519b9b6dc350c\"\n\n\n\nassert_not_exists MonoidWithZero\n\nopen Function\n\nvariable {\u03b1 \u03b2 \u03b9 M N : Type*}\n\nnamespace Set\n\nsection One\n\nvariable [One M] [One N] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1}\n\n\n@[to_additive \"`Set.indicator s f a` is `f a` if `a \u2208 s`, `0` otherwise.\"]\nnoncomputable def mulIndicator (s : Set \u03b1) (f : \u03b1 \u2192 M) (x : \u03b1) : M :=\n  haveI := Classical.decPred (\u00b7 \u2208 s)\n  if x \u2208 s then f x else 1\n#align set.mul_indicator Set.mulIndicator\n\n@[to_additive (attr := simp)]\ntheorem piecewise_eq_mulIndicator [DecidablePred (\u00b7 \u2208 s)] : s.piecewise f 1 = s.mulIndicator f :=\n  funext fun _ => @if_congr _ _ _ _ (id _) _ _ _ _ Iff.rfl rfl rfl\n#align set.piecewise_eq_mul_indicator Set.piecewise_eq_mulIndicator\n#align set.piecewise_eq_indicator Set.piecewise_eq_indicator\n\n-- Porting note: needed unfold for mulIndicator\n@[to_additive]\ntheorem mulIndicator_apply (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) [Decidable (a \u2208 s)] :\n    mulIndicator s f a = if a \u2208 s then f a else 1 := by\n  unfold mulIndicator\n  congr\n#align set.mul_indicator_apply Set.mulIndicator_apply\n#align set.indicator_apply Set.indicator_apply\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_of_mem (h : a \u2208 s) (f : \u03b1 \u2192 M) : mulIndicator s f a = f a :=\n  if_pos h\n#align set.mul_indicator_of_mem Set.mulIndicator_of_mem\n#align set.indicator_of_mem Set.indicator_of_mem\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_of_not_mem (h : a \u2209 s) (f : \u03b1 \u2192 M) : mulIndicator s f a = 1 :=\n  if_neg h\n#align set.mul_indicator_of_not_mem Set.mulIndicator_of_not_mem\n#align set.indicator_of_not_mem Set.indicator_of_not_mem\n\n@[to_additive]\ntheorem mulIndicator_eq_one_or_self (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a := by\n  by_cases h : a \u2208 s\n  \u00b7 exact Or.inr (mulIndicator_of_mem h f)\n  \u00b7 exact Or.inl (mulIndicator_of_not_mem h f)\n#align set.mul_indicator_eq_one_or_self Set.mulIndicator_eq_one_or_self\n#align set.indicator_eq_zero_or_self Set.indicator_eq_zero_or_self\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_self : s.mulIndicator f a = f a \u2194 a \u2209 s \u2192 f a = 1 :=\n  letI := Classical.dec (a \u2208 s)\n  ite_eq_left_iff.trans (by rw [@eq_comm _ (f a)])\n#align set.mul_indicator_apply_eq_self Set.mulIndicator_apply_eq_self\n#align set.indicator_apply_eq_self Set.indicator_apply_eq_self\n\n@[to_additive (attr := simp)]\n"}
{"name": "fundamentalDomain_reindex9", "split": "test", "formal_statement": "theorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by", "header": "\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n\n\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\ntheorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by simp [span_span_of_tower]\n\n\ndef fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}\n#align zspan.fundamental_domain Zspan.fundamentalDomain\n\n@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1 := Iff.rfl\n#align zspan.mem_fundamental_domain Zspan.mem_fundamentalDomain\n\ntheorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by\n  ext x\n  rw [mem_fundamentalDomain, Basis.map_repr, LinearEquiv.trans_apply, \u2190 mem_fundamentalDomain,\n    show f.symm x = f.toEquiv.symm x by rfl, \u2190 Set.mem_image_equiv]\n  rfl\n\n@[simp]\n"}
{"name": "prod_extend_by_one10", "split": "test", "formal_statement": "theorem prod_extend_by_one [CommMonoid \u03b1] (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) :\n    \u220f i, (if i \u2208 s then f i else 1) = \u220f i \u2208 s, f i := by", "header": "\nimport Mathlib.Data.Fintype.Option\nimport Mathlib.Data.Fintype.Sigma\nimport Mathlib.Data.Fintype.Sum\nimport Mathlib.Data.Fintype.Prod\nimport Mathlib.Data.Fintype.Vector\nimport Mathlib.Algebra.BigOperators.Option\n\n#align_import data.fintype.big_operators from \"leanprover-community/mathlib\"@\"2445c98ae4b87eabebdde552593519b9b6dc350c\"\n\n\n\nassert_not_exists MulAction\n\nuniverse u v\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\n\nnamespace Fintype\n\n@[to_additive]\ntheorem prod_bool [CommMonoid \u03b1] (f : Bool \u2192 \u03b1) : \u220f b, f b = f true * f false := by simp\n#align fintype.prod_bool Fintype.prod_bool\n#align fintype.sum_bool Fintype.sum_bool\n\ntheorem card_eq_sum_ones {\u03b1} [Fintype \u03b1] : Fintype.card \u03b1 = \u2211 _a : \u03b1, 1 :=\n  Finset.card_eq_sum_ones _\n#align fintype.card_eq_sum_ones Fintype.card_eq_sum_ones\n\nsection\n\nopen Finset\n\nvariable {\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]\n\n@[to_additive]\n"}
{"name": "mem_Icc11", "split": "test", "formal_statement": "theorem mem_Icc : f x \u2208 Icc (0 : \u211d) 1 := by", "header": "\nimport Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension\nimport Mathlib.Geometry.Manifold.ContMDiff.Atlas\nimport Mathlib.Geometry.Manifold.ContMDiff.NormedSpace\n\n#align_import geometry.manifold.bump_function from \"leanprover-community/mathlib\"@\"b018406ad2f2a73223a3a9e198ccae61e6f05318\"\n\n\n\nuniverse uE uF uH uM\n\nvariable {E : Type uE} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\n  {H : Type uH} [TopologicalSpace H] (I : ModelWithCorners \u211d E H) {M : Type uM} [TopologicalSpace M]\n  [ChartedSpace H M] [SmoothManifoldWithCorners I M]\n\nopen Function Filter FiniteDimensional Set Metric\n\nopen scoped Topology Manifold Classical Filter\n\nnoncomputable section\n\n\n\n\nstructure SmoothBumpFunction (c : M) extends ContDiffBump (extChartAt I c c) where\n  closedBall_subset : closedBall (extChartAt I c c) rOut \u2229 range I \u2286 (extChartAt I c).target\n#align smooth_bump_function SmoothBumpFunction\n\nnamespace SmoothBumpFunction\n\nvariable {c : M} (f : SmoothBumpFunction I c) {x : M} {I}\n\n\n@[coe] def toFun : M \u2192 \u211d :=\n  indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c)\n#align smooth_bump_function.to_fun SmoothBumpFunction.toFun\n\ninstance : CoeFun (SmoothBumpFunction I c) fun _ => M \u2192 \u211d :=\n  \u27e8toFun\u27e9\n\ntheorem coe_def : \u21d1f = indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c) :=\n  rfl\n#align smooth_bump_function.coe_def SmoothBumpFunction.coe_def\n\ntheorem rOut_pos : 0 < f.rOut :=\n  f.toContDiffBump.rOut_pos\nset_option linter.uppercaseLean3 false in\n#align smooth_bump_function.R_pos SmoothBumpFunction.rOut_pos\n\ntheorem ball_subset : ball (extChartAt I c c) f.rOut \u2229 range I \u2286 (extChartAt I c).target :=\n  Subset.trans (inter_subset_inter_left _ ball_subset_closedBall) f.closedBall_subset\n#align smooth_bump_function.ball_subset SmoothBumpFunction.ball_subset\n\ntheorem ball_inter_range_eq_ball_inter_target :\n    ball (extChartAt I c c) f.rOut \u2229 range I =\n      ball (extChartAt I c c) f.rOut \u2229 (extChartAt I c).target :=\n  (subset_inter inter_subset_left f.ball_subset).antisymm <| inter_subset_inter_right _ <|\n    extChartAt_target_subset_range _ _\n\ntheorem eqOn_source : EqOn f (f.toContDiffBump \u2218 extChartAt I c) (chartAt H c).source :=\n  eqOn_indicator\n#align smooth_bump_function.eq_on_source SmoothBumpFunction.eqOn_source\n\ntheorem eventuallyEq_of_mem_source (hx : x \u2208 (chartAt H c).source) :\n    f =\u1da0[\ud835\udcdd x] f.toContDiffBump \u2218 extChartAt I c :=\n  f.eqOn_source.eventuallyEq_of_mem <| (chartAt H c).open_source.mem_nhds hx\n#align smooth_bump_function.eventually_eq_of_mem_source SmoothBumpFunction.eventuallyEq_of_mem_source\n\ntheorem one_of_dist_le (hs : x \u2208 (chartAt H c).source)\n    (hd : dist (extChartAt I c x) (extChartAt I c c) \u2264 f.rIn) : f x = 1 := by\n  simp only [f.eqOn_source hs, (\u00b7 \u2218 \u00b7), f.one_of_mem_closedBall hd]\n#align smooth_bump_function.one_of_dist_le SmoothBumpFunction.one_of_dist_le\n\ntheorem support_eq_inter_preimage :\n    support f = (chartAt H c).source \u2229 extChartAt I c \u207b\u00b9' ball (extChartAt I c c) f.rOut := by\n  rw [coe_def, support_indicator, support_comp_eq_preimage, \u2190 extChartAt_source I,\n    \u2190 (extChartAt I c).symm_image_target_inter_eq', \u2190 (extChartAt I c).symm_image_target_inter_eq',\n    f.support_eq]\n#align smooth_bump_function.support_eq_inter_preimage SmoothBumpFunction.support_eq_inter_preimage\n\ntheorem isOpen_support : IsOpen (support f) := by\n  rw [support_eq_inter_preimage]\n  exact isOpen_extChartAt_preimage I c isOpen_ball\n#align smooth_bump_function.is_open_support SmoothBumpFunction.isOpen_support\n\ntheorem support_eq_symm_image :\n    support f = (extChartAt I c).symm '' (ball (extChartAt I c c) f.rOut \u2229 range I) := by\n  rw [f.support_eq_inter_preimage, \u2190 extChartAt_source I,\n    \u2190 (extChartAt I c).symm_image_target_inter_eq', inter_comm,\n    ball_inter_range_eq_ball_inter_target]\n#align smooth_bump_function.support_eq_symm_image SmoothBumpFunction.support_eq_symm_image\n\ntheorem support_subset_source : support f \u2286 (chartAt H c).source := by\n  rw [f.support_eq_inter_preimage, \u2190 extChartAt_source I]; exact inter_subset_left\n#align smooth_bump_function.support_subset_source SmoothBumpFunction.support_subset_source\n\ntheorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s \u2286 support f) :\n    extChartAt I c '' s =\n      closedBall (extChartAt I c c) f.rOut \u2229 range I \u2229 (extChartAt I c).symm \u207b\u00b9' s := by\n  rw [support_eq_inter_preimage, subset_inter_iff, \u2190 extChartAt_source I, \u2190 image_subset_iff] at hs\n  cases' hs with hse hsf\n  apply Subset.antisymm\n  \u00b7 refine subset_inter (subset_inter (hsf.trans ball_subset_closedBall) ?_) ?_\n    \u00b7 rintro _ \u27e8x, -, rfl\u27e9; exact mem_range_self _\n    \u00b7 rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]\n      exact inter_subset_right\n  \u00b7 refine Subset.trans (inter_subset_inter_left _ f.closedBall_subset) ?_\n    rw [(extChartAt I c).image_eq_target_inter_inv_preimage hse]\n#align smooth_bump_function.image_eq_inter_preimage_of_subset_support SmoothBumpFunction.image_eq_inter_preimage_of_subset_support\n\n"}
{"name": "hom_chart12", "split": "test", "formal_statement": "theorem hom_chart (y\u2080 y : LE\u2081E\u2082) :\n    chartAt (ModelProd HB (F\u2081 \u2192L[\ud835\udd5c] F\u2082)) y\u2080 y =\n      (chartAt HB y\u2080.1 y.1, inCoordinates F\u2081 E\u2081 F\u2082 E\u2082 y\u2080.1 y.1 y\u2080.1 y.1 y.2) := by", "header": "\nimport Mathlib.Geometry.Manifold.VectorBundle.Basic\nimport Mathlib.Topology.VectorBundle.Hom\n\n#align_import geometry.manifold.vector_bundle.hom from \"leanprover-community/mathlib\"@\"8905e5ed90859939681a725b00f6063e65096d95\"\n\n\n\n\nnoncomputable section\n\nopen Bundle Set PartialHomeomorph ContinuousLinearMap Pretrivialization\n\nopen scoped Manifold Bundle\n\nvariable {\ud835\udd5c B F\u2081 F\u2082 M : Type*} {E\u2081 : B \u2192 Type*} {E\u2082 : B \u2192 Type*} [NontriviallyNormedField \ud835\udd5c]\n  [\u2200 x, AddCommGroup (E\u2081 x)] [\u2200 x, Module \ud835\udd5c (E\u2081 x)] [NormedAddCommGroup F\u2081] [NormedSpace \ud835\udd5c F\u2081]\n  [TopologicalSpace (TotalSpace F\u2081 E\u2081)] [\u2200 x, TopologicalSpace (E\u2081 x)] [\u2200 x, AddCommGroup (E\u2082 x)]\n  [\u2200 x, Module \ud835\udd5c (E\u2082 x)] [NormedAddCommGroup F\u2082] [NormedSpace \ud835\udd5c F\u2082]\n  [TopologicalSpace (TotalSpace F\u2082 E\u2082)] [\u2200 x, TopologicalSpace (E\u2082 x)]\n  [\u2200 x, TopologicalAddGroup (E\u2082 x)] [\u2200 x, ContinuousSMul \ud835\udd5c (E\u2082 x)] {EB : Type*}\n  [NormedAddCommGroup EB] [NormedSpace \ud835\udd5c EB] {HB : Type*} [TopologicalSpace HB]\n  (IB : ModelWithCorners \ud835\udd5c EB HB) [TopologicalSpace B] [ChartedSpace HB B] {EM : Type*}\n  [NormedAddCommGroup EM] [NormedSpace \ud835\udd5c EM] {HM : Type*} [TopologicalSpace HM]\n  {IM : ModelWithCorners \ud835\udd5c EM HM} [TopologicalSpace M] [ChartedSpace HM M]\n  [SmoothManifoldWithCorners IM M] {n : \u2115\u221e} [FiberBundle F\u2081 E\u2081] [VectorBundle \ud835\udd5c F\u2081 E\u2081]\n  [FiberBundle F\u2082 E\u2082] [VectorBundle \ud835\udd5c F\u2082 E\u2082] {e\u2081 e\u2081' : Trivialization F\u2081 (\u03c0 F\u2081 E\u2081)}\n  {e\u2082 e\u2082' : Trivialization F\u2082 (\u03c0 F\u2082 E\u2082)}\n\nlocal notation \"LE\u2081E\u2082\" => TotalSpace (F\u2081 \u2192L[\ud835\udd5c] F\u2082) (Bundle.ContinuousLinearMap (RingHom.id \ud835\udd5c) E\u2081 E\u2082)\n\n-- Porting note (#11083): moved slow parts to separate lemmas\ntheorem smoothOn_continuousLinearMapCoordChange\n    [SmoothVectorBundle F\u2081 E\u2081 IB] [SmoothVectorBundle F\u2082 E\u2082 IB] [MemTrivializationAtlas e\u2081]\n    [MemTrivializationAtlas e\u2081'] [MemTrivializationAtlas e\u2082] [MemTrivializationAtlas e\u2082'] :\n    SmoothOn IB \ud835\udcd8(\ud835\udd5c, (F\u2081 \u2192L[\ud835\udd5c] F\u2082) \u2192L[\ud835\udd5c] F\u2081 \u2192L[\ud835\udd5c] F\u2082)\n      (continuousLinearMapCoordChange (RingHom.id \ud835\udd5c) e\u2081 e\u2081' e\u2082 e\u2082')\n      (e\u2081.baseSet \u2229 e\u2082.baseSet \u2229 (e\u2081'.baseSet \u2229 e\u2082'.baseSet)) := by\n  have h\u2081 := smoothOn_coordChangeL IB e\u2081' e\u2081\n  have h\u2082 := smoothOn_coordChangeL IB e\u2082 e\u2082'\n  refine (h\u2081.mono ?_).cle_arrowCongr (h\u2082.mono ?_) <;> mfld_set_tac\n#align smooth_on_continuous_linear_map_coord_change smoothOn_continuousLinearMapCoordChange\n\n"}
{"name": "mem_splitCenter13", "split": "test", "formal_statement": "theorem mem_splitCenter : J \u2208 splitCenter I \u2194 \u2203 s, I.splitCenterBox s = J := by", "header": "\nimport Mathlib.Analysis.BoxIntegral.Box.SubboxInduction\nimport Mathlib.Analysis.BoxIntegral.Partition.Tagged\n\n#align_import analysis.box_integral.partition.subbox_induction from \"leanprover-community/mathlib\"@\"f2ce6086713c78a7f880485f7917ea547a215982\"\n\n\n\n\nnamespace BoxIntegral\n\nopen Set Metric\n\nopen scoped Classical\nopen Topology\n\nnoncomputable section\n\nvariable {\u03b9 : Type*} [Fintype \u03b9] {I J : Box \u03b9}\n\nnamespace Prepartition\n\n\ndef splitCenter (I : Box \u03b9) : Prepartition I where\n  boxes := Finset.univ.map (Box.splitCenterBoxEmb I)\n  le_of_mem' := by simp [I.splitCenterBox_le]\n  pairwiseDisjoint := by\n    rw [Finset.coe_map, Finset.coe_univ, image_univ]\n    rintro _ \u27e8s, rfl\u27e9 _ \u27e8t, rfl\u27e9 Hne\n    exact I.disjoint_splitCenterBox (mt (congr_arg _) Hne)\n#align box_integral.prepartition.split_center BoxIntegral.Prepartition.splitCenter\n\n@[simp]\n"}
{"name": "jacobiSymNat.even_odd\u208114", "split": "test", "formal_statement": "theorem jacobiSymNat.even_odd\u2081 (a b c : \u2115) (r : \u2124) (ha : a % 2 = 0) (hb : b % 8 = 1)\n    (hc : a / 2 = c) (hr : jacobiSymNat c b = r) : jacobiSymNat a b = r := by", "header": "\nimport Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol\n\n#align_import number_theory.legendre_symbol.norm_num from \"leanprover-community/mathlib\"@\"e2621d935895abe70071ab828a4ee6e26a52afe4\"\n\n\n\n\nsection Lemmas\n\nnamespace Mathlib.Meta.NormNum\n\n\ndef jacobiSymNat (a b : \u2115) : \u2124 :=\n  jacobiSym a b\n#align norm_num.jacobi_sym_nat Mathlib.Meta.NormNum.jacobiSymNat\n\n\n\n\n\ntheorem jacobiSymNat.zero_right (a : \u2115) : jacobiSymNat a 0 = 1 := by\n  rw [jacobiSymNat, jacobiSym.zero_right]\n#align norm_num.jacobi_sym_nat.zero_right Mathlib.Meta.NormNum.jacobiSymNat.zero_right\n\ntheorem jacobiSymNat.one_right (a : \u2115) : jacobiSymNat a 1 = 1 := by\n  rw [jacobiSymNat, jacobiSym.one_right]\n#align norm_num.jacobi_sym_nat.one_right Mathlib.Meta.NormNum.jacobiSymNat.one_right\n\ntheorem jacobiSymNat.zero_left (b : \u2115) (hb : Nat.beq (b / 2) 0 = false) : jacobiSymNat 0 b = 0 := by\n  rw [jacobiSymNat, Nat.cast_zero, jacobiSym.zero_left ?_]\n  calc\n    1 < 2 * 1       := by decide\n    _ \u2264 2 * (b / 2) :=\n      Nat.mul_le_mul_left _ (Nat.succ_le.mpr (Nat.pos_of_ne_zero (Nat.ne_of_beq_eq_false hb)))\n    _ \u2264 b           := Nat.mul_div_le b 2\n#align norm_num.jacobi_sym_nat.zero_left_even Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n#align norm_num.jacobi_sym_nat.zero_left_odd Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n\ntheorem jacobiSymNat.one_left (b : \u2115) : jacobiSymNat 1 b = 1 := by\n  rw [jacobiSymNat, Nat.cast_one, jacobiSym.one_left]\n#align norm_num.jacobi_sym_nat.one_left_even Mathlib.Meta.NormNum.jacobiSymNat.one_left\n#align norm_num.jacobi_sym_nat.one_left_odd Mathlib.Meta.NormNum.jacobiSymNat.one_left\n\n\ntheorem LegendreSym.to_jacobiSym (p : \u2115) (pp : Fact p.Prime) (a r : \u2124)\n    (hr : IsInt (jacobiSym a p) r) : IsInt (legendreSym p a) r := by\n  rwa [@jacobiSym.legendreSym.to_jacobiSym p pp a]\n#align norm_num.legendre_sym.to_jacobi_sym Mathlib.Meta.NormNum.LegendreSym.to_jacobiSym\n\n\ntheorem JacobiSym.mod_left (a : \u2124) (b ab' : \u2115) (ab r b' : \u2124) (hb' : (b : \u2124) = b')\n    (hab : a % b' = ab) (h : (ab' : \u2124) = ab) (hr : jacobiSymNat ab' b = r) : jacobiSym a b = r := by\n  rw [\u2190 hr, jacobiSymNat, jacobiSym.mod_left, hb', hab, \u2190 h]\n#align norm_num.jacobi_sym.mod_left Mathlib.Meta.NormNum.JacobiSym.mod_left\n\ntheorem jacobiSymNat.mod_left (a b ab : \u2115) (r : \u2124) (hab : a % b = ab) (hr : jacobiSymNat ab b = r) :\n    jacobiSymNat a b = r := by\n  rw [\u2190 hr, jacobiSymNat, jacobiSymNat, _root_.jacobiSym.mod_left a b, \u2190 hab]; rfl\n#align norm_num.jacobi_sym_nat.mod_left Mathlib.Meta.NormNum.jacobiSymNat.mod_left\n\n\ntheorem jacobiSymNat.even_even (a b : \u2115) (hb\u2080 : Nat.beq (b / 2) 0 = false) (ha : a % 2 = 0)\n    (hb\u2081 : b % 2 = 0) : jacobiSymNat a b = 0 := by\n  refine jacobiSym.eq_zero_iff.mpr\n    \u27e8ne_of_gt ((Nat.pos_of_ne_zero (Nat.ne_of_beq_eq_false hb\u2080)).trans_le (Nat.div_le_self b 2)),\n      fun hf => ?_\u27e9\n  have h : 2 \u2223 a.gcd b := Nat.dvd_gcd (Nat.dvd_of_mod_eq_zero ha) (Nat.dvd_of_mod_eq_zero hb\u2081)\n  change 2 \u2223 (a : \u2124).gcd b at h\n  rw [hf, \u2190 even_iff_two_dvd] at h\n  exact Nat.not_even_one h\n#align norm_num.jacobi_sym_nat.even_even Mathlib.Meta.NormNum.jacobiSymNat.even_even\n\n\ntheorem jacobiSymNat.odd_even (a b c : \u2115) (r : \u2124) (ha : a % 2 = 1) (hb : b % 2 = 0) (hc : b / 2 = c)\n    (hr : jacobiSymNat a c = r) : jacobiSymNat a b = r := by\n  have ha' : legendreSym 2 a = 1 := by\n    simp only [legendreSym.mod 2 a, Int.ofNat_mod_ofNat, ha]\n    decide\n  rcases eq_or_ne c 0 with (rfl | hc')\n  \u00b7 rw [\u2190 hr, Nat.eq_zero_of_dvd_of_div_eq_zero (Nat.dvd_of_mod_eq_zero hb) hc]\n  \u00b7 haveI : NeZero c := \u27e8hc'\u27e9\n    -- for `jacobiSym.mul_right`\n    rwa [\u2190 Nat.mod_add_div b 2, hb, hc, Nat.zero_add, jacobiSymNat, jacobiSym.mul_right,\n      \u2190 jacobiSym.legendreSym.to_jacobiSym, ha', one_mul]\n#align norm_num.jacobi_sym_nat.odd_even Mathlib.Meta.NormNum.jacobiSymNat.odd_even\n\n\ntheorem jacobiSymNat.double_even (a b c : \u2115) (r : \u2124) (ha : a % 4 = 0) (hb : b % 2 = 1)\n    (hc : a / 4 = c) (hr : jacobiSymNat c b = r) : jacobiSymNat a b = r := by\n  simp only [jacobiSymNat, \u2190 hr, \u2190 hc, Int.ofNat_ediv, Nat.cast_ofNat]\n  exact (jacobiSym.div_four_left (mod_cast ha) hb).symm\n#align norm_num.jacobi_sym_nat.double_even Mathlib.Meta.NormNum.jacobiSymNat.double_even\n\n\n"}
{"name": "intPow_ofNat15", "split": "test", "formal_statement": "theorem intPow_ofNat (h1 : Nat.pow a b = c) :\n    Int.pow (Int.ofNat a) b = Int.ofNat c := by", "header": "\nimport Mathlib.Data.Int.Cast.Lemmas\nimport Mathlib.Tactic.NormNum.Basic\n\n\n\nset_option autoImplicit true\n\nnamespace Mathlib\nopen Lean hiding Rat mkRat\nopen Meta\n\nnamespace Meta.NormNum\nopen Qq\n\ntheorem natPow_zero : Nat.pow a (nat_lit 0) = nat_lit 1 := rfl\ntheorem natPow_one : Nat.pow a (nat_lit 1) = a := Nat.pow_one _\ntheorem zero_natPow : Nat.pow (nat_lit 0) (Nat.succ b) = nat_lit 0 := rfl\ntheorem one_natPow : Nat.pow (nat_lit 1) b = nat_lit 1 := Nat.one_pow _\n\n\nstructure IsNatPowT (p : Prop) (a b c : Nat) : Prop where\n  \n  run' : p \u2192 Nat.pow a b = c\n\ntheorem IsNatPowT.run\n    (p : IsNatPowT (Nat.pow a (nat_lit 1) = a) a b c) : Nat.pow a b = c := p.run' (Nat.pow_one _)\n\n\ntheorem IsNatPowT.trans (h1 : IsNatPowT p a b c) (h2 : IsNatPowT (Nat.pow a b = c) a b' c') :\n    IsNatPowT p a b' c' := \u27e8h2.run' \u2218 h1.run'\u27e9\n\ntheorem IsNatPowT.bit0 : IsNatPowT (Nat.pow a b = c) a (nat_lit 2 * b) (Nat.mul c c) :=\n  \u27e8fun h1 => by simp [two_mul, pow_add, \u2190 h1]\u27e9\ntheorem IsNatPowT.bit1 :\n    IsNatPowT (Nat.pow a b = c) a (nat_lit 2 * b + nat_lit 1) (Nat.mul c (Nat.mul c a)) :=\n  \u27e8fun h1 => by simp [two_mul, pow_add, mul_assoc, \u2190 h1]\u27e9\n\n\npartial def evalNatPow (a b : Q(\u2115)) : (c : Q(\u2115)) \u00d7 Q(Nat.pow $a $b = $c) :=\n  if b.natLit! = 0 then\n    haveI : $b =Q 0 := \u27e8\u27e9\n    \u27e8q(nat_lit 1), q(natPow_zero)\u27e9\n  else if a.natLit! = 0 then\n    haveI : $a =Q 0 := \u27e8\u27e9\n    have b' : Q(\u2115) := mkRawNatLit (b.natLit! - 1)\n    haveI : $b =Q Nat.succ $b' := \u27e8\u27e9\n    \u27e8q(nat_lit 0), q(zero_natPow)\u27e9\n  else if a.natLit! = 1 then\n    haveI : $a =Q 1 := \u27e8\u27e9\n    \u27e8q(nat_lit 1), q(one_natPow)\u27e9\n  else if b.natLit! = 1 then\n    haveI : $b =Q 1 := \u27e8\u27e9\n    \u27e8a, q(natPow_one)\u27e9\n  else\n    let \u27e8c, p\u27e9 := go b.natLit!.log2 a (mkRawNatLit 1) a b _ .rfl\n    \u27e8c, q(($p).run)\u27e9\nwhere\n  \n  go (depth : Nat) (a b\u2080 c\u2080 b : Q(\u2115)) (p : Q(Prop)) (hp : $p =Q (Nat.pow $a $b\u2080 = $c\u2080)) :\n      (c : Q(\u2115)) \u00d7 Q(IsNatPowT $p $a $b $c) :=\n    let b' := b.natLit!\n    if depth \u2264 1 then\n      let a' := a.natLit!\n      let c\u2080' := c\u2080.natLit!\n      if b' &&& 1 == 0 then\n        have c : Q(\u2115) := mkRawNatLit (c\u2080' * c\u2080')\n        haveI : $c =Q Nat.mul $c\u2080 $c\u2080 := \u27e8\u27e9\n        haveI : $b =Q 2 * $b\u2080 := \u27e8\u27e9\n        \u27e8c, q(IsNatPowT.bit0)\u27e9\n      else\n        have c : Q(\u2115) := mkRawNatLit (c\u2080' * (c\u2080' * a'))\n        haveI : $c =Q Nat.mul $c\u2080 (Nat.mul $c\u2080 $a) := \u27e8\u27e9\n        haveI : $b =Q 2 * $b\u2080 + 1 := \u27e8\u27e9\n        \u27e8c, q(IsNatPowT.bit1)\u27e9\n    else\n      let d := depth >>> 1\n      have hi : Q(\u2115) := mkRawNatLit (b' >>> d)\n      let \u27e8c1, p1\u27e9 := go (depth - d) a b\u2080 c\u2080 hi p (by exact hp)\n      let \u27e8c2, p2\u27e9 := go d a hi c1 b q(Nat.pow $a $hi = $c1) \u27e8\u27e9\n      \u27e8c2, q(($p1).trans $p2)\u27e9\n\n"}
{"name": "abs_sign_of_nonzero16", "split": "test", "formal_statement": "theorem abs_sign_of_nonzero {z : \u2124} (hz : z \u2260 0) : |z.sign| = 1 := by", "header": "\nimport Mathlib.Algebra.Group.Int\nimport Mathlib.Algebra.Order.Group.Abs\n\n#align_import data.int.order.basic from \"leanprover-community/mathlib\"@\"e8638a0fcaf73e4500469f368ef9494e495099b3\"\n\n\n\n-- We should need only a minimal development of sets in order to get here.\nassert_not_exists Set.Subsingleton\n\nassert_not_exists Ring\n\nopen Function Nat\n\nnamespace Int\n\ntheorem natCast_strictMono : StrictMono (\u00b7 : \u2115 \u2192 \u2124) := fun _ _ \u21a6 Int.ofNat_lt.2\n#align int.coe_nat_strict_mono Int.natCast_strictMono\n\n@[deprecated (since := \"2024-05-25\")] alias coe_nat_strictMono := natCast_strictMono\n\ninstance linearOrderedAddCommGroup : LinearOrderedAddCommGroup \u2124 where\n  __ := instLinearOrder\n  __ := instAddCommGroup\n  add_le_add_left _ _ := Int.add_le_add_left\n\n\n\ntheorem abs_eq_natAbs : \u2200 a : \u2124, |a| = natAbs a\n  | (n : \u2115) => abs_of_nonneg <| ofNat_zero_le _\n  | -[_+1] => abs_of_nonpos <| le_of_lt <| negSucc_lt_zero _\n#align int.abs_eq_nat_abs Int.abs_eq_natAbs\n\n@[simp, norm_cast] lemma natCast_natAbs (n : \u2124) : (n.natAbs : \u2124) = |n| := n.abs_eq_natAbs.symm\n#align int.coe_nat_abs Int.natCast_natAbs\n\ntheorem natAbs_abs (a : \u2124) : natAbs |a| = natAbs a := by rw [abs_eq_natAbs]; rfl\n#align int.nat_abs_abs Int.natAbs_abs\n\ntheorem sign_mul_abs (a : \u2124) : sign a * |a| = a := by\n  rw [abs_eq_natAbs, sign_mul_natAbs a]\n#align int.sign_mul_abs Int.sign_mul_abs\n\nlemma natAbs_le_self_sq (a : \u2124) : (Int.natAbs a : \u2124) \u2264 a ^ 2 := by\n  rw [\u2190 Int.natAbs_sq a, sq]\n  norm_cast\n  apply Nat.le_mul_self\n#align int.abs_le_self_sq Int.natAbs_le_self_sq\n\nalias natAbs_le_self_pow_two := natAbs_le_self_sq\n\nlemma le_self_sq (b : \u2124) : b \u2264 b ^ 2 := le_trans le_natAbs (natAbs_le_self_sq _)\n#align int.le_self_sq Int.le_self_sq\n\nalias le_self_pow_two := le_self_sq\n#align int.le_self_pow_two Int.le_self_pow_two\n\n@[norm_cast] lemma abs_natCast (n : \u2115) : |(n : \u2124)| = n := abs_of_nonneg (natCast_nonneg n)\n#align int.abs_coe_nat Int.abs_natCast\n\ntheorem natAbs_sub_pos_iff {i j : \u2124} : 0 < natAbs (i - j) \u2194 i \u2260 j := by\n  rw [natAbs_pos, ne_eq, sub_eq_zero]\n\ntheorem natAbs_sub_ne_zero_iff {i j : \u2124} : natAbs (i - j) \u2260 0 \u2194 i \u2260 j :=\n  Nat.ne_zero_iff_zero_lt.trans natAbs_sub_pos_iff\n\n@[simp]\ntheorem abs_lt_one_iff {a : \u2124} : |a| < 1 \u2194 a = 0 := by\n  rw [\u2190 zero_add 1, lt_add_one_iff, abs_nonpos_iff]\n#align int.abs_lt_one_iff Int.abs_lt_one_iff\n\ntheorem abs_le_one_iff {a : \u2124} : |a| \u2264 1 \u2194 a = 0 \u2228 a = 1 \u2228 a = -1 := by\n  rw [le_iff_lt_or_eq, abs_lt_one_iff, abs_eq Int.one_nonneg]\n#align int.abs_le_one_iff Int.abs_le_one_iff\n\ntheorem one_le_abs {z : \u2124} (h\u2080 : z \u2260 0) : 1 \u2264 |z| :=\n  add_one_le_iff.mpr (abs_pos.mpr h\u2080)\n#align int.one_le_abs Int.one_le_abs\n\n\n\ntheorem ediv_eq_zero_of_lt_abs {a b : \u2124} (H1 : 0 \u2264 a) (H2 : a < |b|) : a / b = 0 :=\n  match b, |b|, abs_eq_natAbs b, H2 with\n  | (n : \u2115), _, rfl, H2 => ediv_eq_zero_of_lt H1 H2\n  | -[n+1], _, rfl, H2 => neg_injective <| by rw [\u2190 Int.ediv_neg]; exact ediv_eq_zero_of_lt H1 H2\n#align int.div_eq_zero_of_lt_abs Int.ediv_eq_zero_of_lt_abs\n\n\n\n@[simp]\ntheorem emod_abs (a b : \u2124) : a % |b| = a % b :=\n  abs_by_cases (fun i => a % i = a % b) rfl (emod_neg _ _)\n#align int.mod_abs Int.emod_abs\n\ntheorem emod_lt (a : \u2124) {b : \u2124} (H : b \u2260 0) : a % b < |b| := by\n  rw [\u2190 emod_abs]; exact emod_lt_of_pos _ (abs_pos.2 H)\n#align int.mod_lt Int.emod_lt\n\n\n\ntheorem abs_ediv_le_abs : \u2200 a b : \u2124, |a / b| \u2264 |a| :=\n  suffices \u2200 (a : \u2124) (n : \u2115), |a / n| \u2264 |a| from fun a b =>\n    match b, eq_nat_or_neg b with\n    | _, \u27e8n, Or.inl rfl\u27e9 => this _ _\n    | _, \u27e8n, Or.inr rfl\u27e9 => by rw [Int.ediv_neg, abs_neg]; apply this\n  fun a n => by\n  rw [abs_eq_natAbs, abs_eq_natAbs];\n    exact\n      ofNat_le_ofNat_of_le\n        (match a, n with\n        | (m : \u2115), n => Nat.div_le_self _ _\n        | -[m+1], 0 => Nat.zero_le _\n        | -[m+1], n + 1 => Nat.succ_le_succ (Nat.div_le_self _ _))\n#align int.abs_div_le_abs Int.abs_ediv_le_abs\n\n"}
{"name": "short_birthday17", "split": "test", "formal_statement": "theorem short_birthday (x : PGame.{u}) : [Short x] \u2192 x.birthday < Ordinal.omega := by", "header": "\n\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.SetTheory.Cardinal.Cofinality\nimport Mathlib.SetTheory.Game.Birthday\n\n#align_import set_theory.game.short from \"leanprover-community/mathlib\"@\"70fd9563a21e7b963887c9360bd29b2393e6225a\"\n\n\n\n-- Porting note: The local instances `moveLeftShort'` and `fintypeLeft` (and resp. `Right`)\n-- trigger this error.\nset_option synthInstance.checkSynthOrder false\n\nuniverse u\n\nnamespace SetTheory\n\nopen scoped PGame\n\nnamespace PGame\n\n\ninductive Short : PGame.{u} \u2192 Type (u + 1)\n  | mk :\n    \u2200 {\u03b1 \u03b2 : Type u} {L : \u03b1 \u2192 PGame.{u}} {R : \u03b2 \u2192 PGame.{u}} (_ : \u2200 i : \u03b1, Short (L i))\n      (_ : \u2200 j : \u03b2, Short (R j)) [Fintype \u03b1] [Fintype \u03b2], Short \u27e8\u03b1, \u03b2, L, R\u27e9\n#align pgame.short SetTheory.PGame.Short\n\n-- Porting note: Added `simpNF` exception. It's unclear what puts `eq_iff_true_of_subsingleton` into\n-- the simp set. A minimal reproduction of the simpNF error needs to import transitively at least\n-- `Mathlib.Logic.Unique`.\n--\n-- The simplifier can already prove this using `eq_iff_true_of_subsingleton`\nattribute [nolint simpNF] Short.mk.injEq\n\ninstance subsingleton_short (x : PGame) : Subsingleton (Short x) := by\n  induction x with\n  | mk xl xr xL xR =>\n    constructor\n    intro a b\n    cases a; cases b\n    congr!\n\n\n-- Porting note: We use `induction` to prove `subsingleton_short` instead of recursion.\n-- A proof using recursion generates a harder `decreasing_by` goal than in Lean 3 for some reason:\nattribute [-instance] subsingleton_short in\ntheorem subsingleton_short_example : \u2200 x : PGame, Subsingleton (Short x)\n  | mk xl xr xL xR =>\n    \u27e8fun a b => by\n      cases a; cases b\n      congr!\n      \u00b7 funext x\n        apply @Subsingleton.elim _ (subsingleton_short_example (xL x))\n        -- Decreasing goal in Lean 4 is `Subsequent (xL x) (mk \u03b1 \u03b2 L R)`\n        -- where `\u03b1`, `\u03b2`, `L`, and `R` are fresh hypotheses only propositionally\n        -- equal to `xl`, `xr`, `xL`, and `xR`.\n        -- (In Lean 3 it was `(mk xl xr xL xR)` instead.)\n      \u00b7 funext x\n        apply @Subsingleton.elim _ (subsingleton_short_example (xR x))\u27e9\ntermination_by x => x\n-- We need to unify a bunch of hypotheses before `pgame_wf_tac` can work.\ndecreasing_by all_goals {\n  subst_vars\n  simp only [mk.injEq, heq_eq_eq, true_and] at *\n  casesm* _ \u2227 _\n  subst_vars\n  pgame_wf_tac\n}\n\n#align pgame.subsingleton_short SetTheory.PGame.subsingleton_short\n\n\ndef Short.mk' {x : PGame} [Fintype x.LeftMoves] [Fintype x.RightMoves]\n    (sL : \u2200 i : x.LeftMoves, Short (x.moveLeft i))\n    (sR : \u2200 j : x.RightMoves, Short (x.moveRight j)) : Short x := by\n  -- Porting note: Old proof relied on `unfreezingI`, which doesn't exist in Lean 4.\n  convert Short.mk sL sR\n  cases x\n  dsimp\n#align pgame.short.mk' SetTheory.PGame.Short.mk'\n\nattribute [class] Short\n\n\ndef fintypeLeft {\u03b1 \u03b2 : Type u} {L : \u03b1 \u2192 PGame.{u}} {R : \u03b2 \u2192 PGame.{u}} [S : Short \u27e8\u03b1, \u03b2, L, R\u27e9] :\n    Fintype \u03b1 := by cases' S with _ _ _ _ _ _ F _; exact F\n#align pgame.fintype_left SetTheory.PGame.fintypeLeft\n\nattribute [local instance] fintypeLeft\n\ninstance fintypeLeftMoves (x : PGame) [S : Short x] : Fintype x.LeftMoves := by\n  cases S; assumption\n#align pgame.fintype_left_moves SetTheory.PGame.fintypeLeftMoves\n\n\ndef fintypeRight {\u03b1 \u03b2 : Type u} {L : \u03b1 \u2192 PGame.{u}} {R : \u03b2 \u2192 PGame.{u}} [S : Short \u27e8\u03b1, \u03b2, L, R\u27e9] :\n    Fintype \u03b2 := by cases' S with _ _ _ _ _ _ _ F; exact F\n#align pgame.fintype_right SetTheory.PGame.fintypeRight\n\nattribute [local instance] fintypeRight\n\ninstance fintypeRightMoves (x : PGame) [S : Short x] : Fintype x.RightMoves := by\n  cases S; assumption\n#align pgame.fintype_right_moves SetTheory.PGame.fintypeRightMoves\n\ninstance moveLeftShort (x : PGame) [S : Short x] (i : x.LeftMoves) : Short (x.moveLeft i) := by\n  cases' S with _ _ _ _ L _ _ _; apply L\n#align pgame.move_left_short SetTheory.PGame.moveLeftShort\n\n\ndef moveLeftShort' {xl xr} (xL xR) [S : Short (mk xl xr xL xR)] (i : xl) : Short (xL i) := by\n  cases' S with _ _ _ _ L _ _ _; apply L\n#align pgame.move_left_short' SetTheory.PGame.moveLeftShort'\n\nattribute [local instance] moveLeftShort'\n\ninstance moveRightShort (x : PGame) [S : Short x] (j : x.RightMoves) : Short (x.moveRight j) := by\n  cases' S with _ _ _ _ _ R _ _; apply R\n#align pgame.move_right_short SetTheory.PGame.moveRightShort\n\n\ndef moveRightShort' {xl xr} (xL xR) [S : Short (mk xl xr xL xR)] (j : xr) : Short (xR j) := by\n  cases' S with _ _ _ _ _ R _ _; apply R\n#align pgame.move_right_short' SetTheory.PGame.moveRightShort'\n\nattribute [local instance] moveRightShort'\n\n"}
{"name": "CategoryTheory.Functor.quasiIso'_of_map_quasiIso'18", "split": "test", "formal_statement": "theorem CategoryTheory.Functor.quasiIso'_of_map_quasiIso' {C D : HomologicalComplex A c}\n    (f : C \u27f6 D) (hf : QuasiIso' ((F.mapHomologicalComplex _).map f)) : QuasiIso' f :=\n  \u27e8fun i =>\n    haveI : IsIso (F.map ((homology'Functor A c i).map f)) := by", "header": "\nimport Mathlib.Algebra.Homology.Homotopy\nimport Mathlib.Algebra.Homology.SingleHomology\nimport Mathlib.CategoryTheory.Abelian.Homology\n\n#align_import algebra.homology.quasi_iso from \"leanprover-community/mathlib\"@\"956af7c76589f444f2e1313911bad16366ea476d\"\n\n\n\n\nopen CategoryTheory Limits\n\nuniverse v u\n\nvariable {\u03b9 : Type*}\n\nsection\n\nvariable {V : Type u} [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]\nvariable [HasEqualizers V] [HasImages V] [HasImageMaps V] [HasCokernels V]\nvariable {c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}\n\n\nclass QuasiIso' (f : C \u27f6 D) : Prop where\n  isIso : \u2200 i, IsIso ((homology'Functor V c i).map f)\n#align quasi_iso QuasiIso'\n\nattribute [instance] QuasiIso'.isIso\n\ninstance (priority := 100) quasiIso'_of_iso (f : C \u27f6 D) [IsIso f] : QuasiIso' f where\n  isIso i := by\n    change IsIso ((homology'Functor V c i).mapIso (asIso f)).hom\n    infer_instance\n#align quasi_iso_of_iso quasiIso'_of_iso\n\ninstance quasiIso'_comp (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' g] :\n    QuasiIso' (f \u226b g) where\n  isIso i := by\n    rw [Functor.map_comp]\n    infer_instance\n#align quasi_iso_comp quasiIso'_comp\n\ntheorem quasiIso'_of_comp_left (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' (f \u226b g)] :\n    QuasiIso' g :=\n  { isIso := fun i => IsIso.of_isIso_fac_left ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_left quasiIso'_of_comp_left\n\ntheorem quasiIso'_of_comp_right (f : C \u27f6 D) (g : D \u27f6 E) [QuasiIso' g] [QuasiIso' (f \u226b g)] :\n    QuasiIso' f :=\n  { isIso := fun i => IsIso.of_isIso_fac_right ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_right quasiIso'_of_comp_right\n\nnamespace HomologicalComplex.Hom\n\nvariable {A : Type*} [Category A] [Abelian A] {B : Type*} [Category B] [Abelian B] (F : A \u2964 B)\n  [Functor.Additive F] [PreservesFiniteLimits F] [PreservesFiniteColimits F] [F.Faithful]\n\n"}
{"name": "normalize_eq_iff19", "split": "test", "formal_statement": "theorem normalize_eq_iff (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    normalize n\u2081 d\u2081 z\u2081 = normalize n\u2082 d\u2082 z\u2082 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081 := by", "header": "\nimport Batteries.Data.Rat.Basic\nimport Batteries.Tactic.SeqFocus\n\n\n\nnamespace Rat\n\ntheorem ext : {p q : Rat} \u2192 p.num = q.num \u2192 p.den = q.den \u2192 p = q\n  | \u27e8_,_,_,_\u27e9, \u27e8_,_,_,_\u27e9, rfl, rfl => rfl\n\n@[simp] theorem mk_den_one {r : Int} :\n    \u27e8r, 1, Nat.one_ne_zero, (Nat.coprime_one_right _)\u27e9 = (r : Rat) := rfl\n\n@[simp] theorem zero_num : (0 : Rat).num = 0 := rfl\n@[simp] theorem zero_den : (0 : Rat).den = 1 := rfl\n@[simp] theorem one_num : (1 : Rat).num = 1 := rfl\n@[simp] theorem one_den : (1 : Rat).den = 1 := rfl\n\n@[simp] theorem maybeNormalize_eq {num den g} (den_nz reduced) :\n    maybeNormalize num den g den_nz reduced =\n    { num := num.div g, den := den / g, den_nz, reduced } := by\n  unfold maybeNormalize; split\n  \u00b7 subst g; simp\n  \u00b7 rfl\n\ntheorem normalize.reduced' {num : Int} {den g : Nat} (den_nz : den \u2260 0)\n    (e : g = num.natAbs.gcd den) : (num / g).natAbs.Coprime (den / g) := by\n  rw [\u2190 Int.div_eq_ediv_of_dvd (e \u25b8 Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n  exact normalize.reduced den_nz e\n\ntheorem normalize_eq {num den} (den_nz) : normalize num den den_nz =\n    { num := num / num.natAbs.gcd den\n      den := den / num.natAbs.gcd den\n      den_nz := normalize.den_nz den_nz rfl\n      reduced := normalize.reduced' den_nz rfl } := by\n  simp only [normalize, maybeNormalize_eq,\n    Int.div_eq_ediv_of_dvd (Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n\n@[simp] theorem normalize_zero (nz) : normalize 0 d nz = 0 := by\n  simp [normalize, Int.zero_div, Int.natAbs_zero, Nat.div_self (Nat.pos_of_ne_zero nz)]; rfl\n\ntheorem mk_eq_normalize (num den nz c) : \u27e8num, den, nz, c\u27e9 = normalize num den nz := by\n  simp [normalize_eq, c.gcd_eq_one]\n\ntheorem normalize_self (r : Rat) : normalize r.num r.den r.den_nz = r := (mk_eq_normalize ..).symm\n\ntheorem normalize_mul_left {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (\u2191a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0 := by\n  simp [normalize_eq, mk'.injEq, Int.natAbs_mul, Nat.gcd_mul_left,\n    Nat.mul_div_mul_left _ _ (Nat.pos_of_ne_zero a0), Int.ofNat_mul,\n    Int.mul_ediv_mul_of_pos _ _ (Int.ofNat_pos.2 <| Nat.pos_of_ne_zero a0)]\n\ntheorem normalize_mul_right {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0 := by\n  rw [\u2190 normalize_mul_left (d0 := d0) a0]; congr 1 <;> [apply Int.mul_comm; apply Nat.mul_comm]\n\n"}
{"name": "submonoid_map_le_is_unit20", "split": "test", "formal_statement": "theorem submonoid_map_le_is_unit : M.map (algebraMap R S) \u2264 IsUnit.submonoid S := by", "header": "\nimport Mathlib.GroupTheory.Submonoid.Inverses\nimport Mathlib.RingTheory.FiniteType\nimport Mathlib.RingTheory.Localization.Basic\n\n#align_import ring_theory.localization.inv_submonoid from \"leanprover-community/mathlib\"@\"6e7ca692c98bbf8a64868f61a67fb9c33b10770d\"\n\n\n\n\nvariable {R : Type*} [CommRing R] (M : Submonoid R) (S : Type*) [CommRing S]\nvariable [Algebra R S] {P : Type*} [CommRing P]\n\nopen Function\n\nnamespace IsLocalization\n\nsection InvSubmonoid\n\n\ndef invSubmonoid : Submonoid S :=\n  (M.map (algebraMap R S)).leftInv\n#align is_localization.inv_submonoid IsLocalization.invSubmonoid\n\nvariable [IsLocalization M S]\n\n"}
{"name": "card_Ioc21", "split": "test", "formal_statement": "theorem card_Ioc : (Ioc a b).card = (\u220f i, (Icc (a i) (b i)).card) - 1 := by", "header": "\nimport Mathlib.Order.Interval.Finset.Basic\nimport Mathlib.Data.Fintype.BigOperators\n\n#align_import data.pi.interval from \"leanprover-community/mathlib\"@\"1d29de43a5ba4662dd33b5cfeecfc2a27a5a8a29\"\n\n\n\n\nopen Finset Fintype\n\nvariable {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [Fintype \u03b9] [DecidableEq \u03b9] [\u2200 i, DecidableEq (\u03b1 i)]\n\nnamespace Pi\nsection PartialOrder\nvariable [\u2200 i, PartialOrder (\u03b1 i)]\n\nsection LocallyFiniteOrder\nvariable [\u2200 i, LocallyFiniteOrder (\u03b1 i)]\n\ninstance instLocallyFiniteOrder : LocallyFiniteOrder (\u2200 i, \u03b1 i) :=\n  LocallyFiniteOrder.ofIcc _ (fun a b => piFinset fun i => Icc (a i) (b i)) fun a b x => by\n    simp_rw [mem_piFinset, mem_Icc, le_def, forall_and]\n\nvariable (a b : \u2200 i, \u03b1 i)\n\ntheorem Icc_eq : Icc a b = piFinset fun i => Icc (a i) (b i) :=\n  rfl\n#align pi.Icc_eq Pi.Icc_eq\n\ntheorem card_Icc : (Icc a b).card = \u220f i, (Icc (a i) (b i)).card :=\n  card_piFinset _\n#align pi.card_Icc Pi.card_Icc\n\ntheorem card_Ico : (Ico a b).card = (\u220f i, (Icc (a i) (b i)).card) - 1 := by\n  rw [card_Ico_eq_card_Icc_sub_one, card_Icc]\n#align pi.card_Ico Pi.card_Ico\n\n"}
{"name": "IsLocalMaxOn.hasFDerivWithinAt_nonpos22", "split": "test", "formal_statement": "theorem IsLocalMaxOn.hasFDerivWithinAt_nonpos {s : Set E} (h : IsLocalMaxOn f s a)\n    (hf : HasFDerivWithinAt f f' s a) {y} (hy : y \u2208 posTangentConeAt s a) : f' y \u2264 0 := by", "header": "\nimport Mathlib.Analysis.Calculus.Deriv.Add\n\n#align_import analysis.calculus.local_extr from \"leanprover-community/mathlib\"@\"3bce8d800a6f2b8f63fe1e588fd76a9ff4adcebe\"\n\n\n\n\nuniverse u v\n\nopen Filter Set\n\nopen scoped Topology Classical\n\nsection Module\n\nvariable {E : Type u} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {a : E} {f' : E \u2192L[\u211d] \u211d}\n\n\n\n\ndef posTangentConeAt (s : Set E) (x : E) : Set E :=\n  { y : E | \u2203 (c : \u2115 \u2192 \u211d) (d : \u2115 \u2192 E), (\u2200\u1da0 n in atTop, x + d n \u2208 s) \u2227\n    Tendsto c atTop atTop \u2227 Tendsto (fun n => c n \u2022 d n) atTop (\ud835\udcdd y) }\n#align pos_tangent_cone_at posTangentConeAt\n\ntheorem posTangentConeAt_mono : Monotone fun s => posTangentConeAt s a := by\n  rintro s t hst y \u27e8c, d, hd, hc, hcd\u27e9\n  exact \u27e8c, d, mem_of_superset hd fun h hn => hst hn, hc, hcd\u27e9\n#align pos_tangent_cone_at_mono posTangentConeAt_mono\n\ntheorem mem_posTangentConeAt_of_segment_subset {s : Set E} {x y : E} (h : segment \u211d x y \u2286 s) :\n    y - x \u2208 posTangentConeAt s x := by\n  let c := fun n : \u2115 => (2 : \u211d) ^ n\n  let d := fun n : \u2115 => (c n)\u207b\u00b9 \u2022 (y - x)\n  refine \u27e8c, d, Filter.univ_mem' fun n => h ?_, tendsto_pow_atTop_atTop_of_one_lt one_lt_two, ?_\u27e9\n  \u00b7 show x + d n \u2208 segment \u211d x y\n    rw [segment_eq_image']\n    refine \u27e8(c n)\u207b\u00b9, \u27e8?_, ?_\u27e9, rfl\u27e9\n    exacts [inv_nonneg.2 (pow_nonneg zero_le_two _), inv_le_one (one_le_pow_of_one_le one_le_two _)]\n  \u00b7 show Tendsto (fun n => c n \u2022 d n) atTop (\ud835\udcdd (y - x))\n    exact tendsto_const_nhds.congr fun n \u21a6 (smul_inv_smul\u2080 (pow_ne_zero _ two_ne_zero) _).symm\n#align mem_pos_tangent_cone_at_of_segment_subset mem_posTangentConeAt_of_segment_subset\n\ntheorem mem_posTangentConeAt_of_segment_subset' {s : Set E} {x y : E}\n    (h : segment \u211d x (x + y) \u2286 s) : y \u2208 posTangentConeAt s x := by\n  simpa only [add_sub_cancel_left] using mem_posTangentConeAt_of_segment_subset h\n#align mem_pos_tangent_cone_at_of_segment_subset' mem_posTangentConeAt_of_segment_subset'\n\ntheorem posTangentConeAt_univ : posTangentConeAt univ a = univ :=\n  eq_univ_of_forall fun _ => mem_posTangentConeAt_of_segment_subset' (subset_univ _)\n#align pos_tangent_cone_at_univ posTangentConeAt_univ\n\n\n\n\n"}
{"name": "norm_eqOn_of_isPreconnected_of_isMaxOn23", "split": "test", "formal_statement": "theorem norm_eqOn_of_isPreconnected_of_isMaxOn {f : M \u2192 F} {U : Set M} {c : M}\n    (hd : MDifferentiableOn I \ud835\udcd8(\u2102, F) f U) (hc : IsPreconnected U) (ho : IsOpen U)\n    (hcU : c \u2208 U) (hm : IsMaxOn (norm \u2218 f) U c) : EqOn (norm \u2218 f) (const M \u2016f c\u2016) U := by", "header": "\nimport Mathlib.Analysis.Complex.AbsMax\nimport Mathlib.Analysis.LocallyConvex.WithSeminorms\nimport Mathlib.Geometry.Manifold.MFDeriv.Basic\nimport Mathlib.Topology.LocallyConstant.Basic\n\n#align_import geometry.manifold.complex from \"leanprover-community/mathlib\"@\"f2ce6086713c78a7f880485f7917ea547a215982\"\n\n\n\nopen scoped Manifold Topology Filter\nopen Function Set Filter Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]\nvariable {F : Type*} [NormedAddCommGroup F] [NormedSpace \u2102 F]\nvariable {H : Type*} [TopologicalSpace H] {I : ModelWithCorners \u2102 E H} [I.Boundaryless]\nvariable {M : Type*} [TopologicalSpace M] [CompactSpace M] [ChartedSpace H M]\n  [SmoothManifoldWithCorners I M]\n\n\ntheorem Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax {f : M \u2192 F} {c : M}\n    (hd : \u2200\u1da0 z in \ud835\udcdd c, MDifferentiableAt I \ud835\udcd8(\u2102, F) f z) (hc : IsLocalMax (norm \u2218 f) c) :\n    \u2200\u1da0 y in \ud835\udcdd c, \u2016f y\u2016 = \u2016f c\u2016 := by\n  set e := extChartAt I c\n  have hI : range I = univ := ModelWithCorners.Boundaryless.range_eq_univ\n  have H\u2081 : \ud835\udcdd[range I] (e c) = \ud835\udcdd (e c) := by rw [hI, nhdsWithin_univ]\n  have H\u2082 : map e.symm (\ud835\udcdd (e c)) = \ud835\udcdd c := by\n    rw [\u2190 map_extChartAt_symm_nhdsWithin_range I c, H\u2081]\n  rw [\u2190 H\u2082, eventually_map]\n  replace hd : \u2200\u1da0 y in \ud835\udcdd (e c), DifferentiableAt \u2102 (f \u2218 e.symm) y := by\n    have : e.target \u2208 \ud835\udcdd (e c) := H\u2081 \u25b8 extChartAt_target_mem_nhdsWithin I c\n    filter_upwards [this, Tendsto.eventually H\u2082.le hd] with y hyt hy\u2082\n    have hys : e.symm y \u2208 (chartAt H c).source := by\n      rw [\u2190 extChartAt_source I c]\n      exact (extChartAt I c).map_target hyt\n    have hfy : f (e.symm y) \u2208 (chartAt F (0 : F)).source := mem_univ _\n    rw [mdifferentiableAt_iff_of_mem_source hys hfy, hI, differentiableWithinAt_univ,\n      e.right_inv hyt] at hy\u2082\n    exact hy\u2082.2\n  convert norm_eventually_eq_of_isLocalMax hd _\n  \u00b7 exact congr_arg f (extChartAt_to_inv _ _).symm\n  \u00b7 simpa only [e, IsLocalMax, IsMaxFilter, \u2190 H\u2082, (\u00b7 \u2218 \u00b7), extChartAt_to_inv] using hc\n\n\n\nnamespace MDifferentiableOn\n\n\n"}
{"name": "ofReal_arctan24", "split": "test", "formal_statement": "theorem ofReal_arctan (x : \u211d) : (Real.arctan x : \u2102) = arctan x := by", "header": "\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogBounds\n\n\n\n\nnamespace Complex\n\nopen scoped Real\n\n\nnoncomputable def arctan (z : \u2102) : \u2102 := -I / 2 * log ((1 + z * I) / (1 - z * I))\n\ntheorem tan_arctan {z : \u2102} (h\u2081 : z \u2260 I) (h\u2082 : z \u2260 -I) : tan (arctan z) = z := by\n  unfold tan sin cos\n  rw [div_div_eq_mul_div, div_mul_cancel\u2080 _ two_ne_zero, \u2190 div_mul_eq_mul_div,\n    -- multiply top and bottom by `exp (arctan z * I)`\n    \u2190 mul_div_mul_right _ _ (exp_ne_zero (arctan z * I)), sub_mul, add_mul,\n    \u2190 exp_add, neg_mul, add_left_neg, exp_zero, \u2190 exp_add, \u2190 two_mul]\n  have z\u2081 : 1 + z * I \u2260 0 := by\n    contrapose! h\u2081\n    rw [add_eq_zero_iff_neg_eq, \u2190 div_eq_iff I_ne_zero, div_I, neg_one_mul, neg_neg] at h\u2081\n    exact h\u2081.symm\n  have z\u2082 : 1 - z * I \u2260 0 := by\n    contrapose! h\u2082\n    rw [sub_eq_zero, \u2190 div_eq_iff I_ne_zero, div_I, one_mul] at h\u2082\n    exact h\u2082.symm\n  have key : exp (2 * (arctan z * I)) = (1 + z * I) / (1 - z * I) := by\n    rw [arctan, \u2190 mul_rotate, \u2190 mul_assoc,\n      show 2 * (I * (-I / 2)) = 1 by field_simp, one_mul, exp_log]\n    \u00b7 exact div_ne_zero z\u2081 z\u2082\n  -- multiply top and bottom by `1 - z * I`\n  rw [key, \u2190 mul_div_mul_right _ _ z\u2082, sub_mul, add_mul, div_mul_cancel\u2080 _ z\u2082, one_mul,\n    show _ / _ * I = -(I * I) * z by ring, I_mul_I, neg_neg, one_mul]\n\n\nlemma cos_ne_zero_of_arctan_bounds {z : \u2102} (h\u2080 : z \u2260 \u03c0 / 2) (h\u2081 : -(\u03c0 / 2) < z.re)\n    (h\u2082 : z.re \u2264 \u03c0 / 2) : cos z \u2260 0 := by\n  refine cos_ne_zero_iff.mpr (fun k \u21a6 ?_)\n  rw [ne_eq, ext_iff, not_and_or] at h\u2080 \u22a2\n  norm_cast at h\u2080 \u22a2\n  cases' h\u2080 with nr ni\n  \u00b7 left; contrapose! nr\n    rw [nr, mul_div_assoc, neg_eq_neg_one_mul, mul_lt_mul_iff_of_pos_right (by positivity)] at h\u2081\n    rw [nr, \u2190 one_mul (\u03c0 / 2), mul_div_assoc, mul_le_mul_iff_of_pos_right (by positivity)] at h\u2082\n    norm_cast at h\u2081 h\u2082\n    change -1 < _ at h\u2081\n    rwa [show 2 * k + 1 = 1 by omega, Int.cast_one, one_mul] at nr\n  \u00b7 exact Or.inr ni\n\ntheorem arctan_tan {z : \u2102} (h\u2080 : z \u2260 \u03c0 / 2) (h\u2081 : -(\u03c0 / 2) < z.re) (h\u2082 : z.re \u2264 \u03c0 / 2) :\n    arctan (tan z) = z := by\n  have h := cos_ne_zero_of_arctan_bounds h\u2080 h\u2081 h\u2082\n  unfold arctan tan\n  -- multiply top and bottom by `cos z`\n  rw [\u2190 mul_div_mul_right (1 + _) _ h, add_mul, sub_mul, one_mul, \u2190 mul_rotate, mul_div_cancel\u2080 _ h]\n  conv_lhs =>\n    enter [2, 1, 2]\n    rw [sub_eq_add_neg, \u2190 neg_mul, \u2190 sin_neg, \u2190 cos_neg]\n  rw [\u2190 exp_mul_I, \u2190 exp_mul_I, \u2190 exp_sub, show z * I - -z * I = 2 * (I * z) by ring, log_exp,\n    show -I / 2 * (2 * (I * z)) = -(I * I) * z by ring, I_mul_I, neg_neg, one_mul]\n  all_goals set_option tactic.skipAssignedInstances false in norm_num\n  \u00b7 rwa [\u2190 div_lt_iff' two_pos, neg_div]\n  \u00b7 rwa [\u2190 le_div_iff' two_pos]\n\n@[simp, norm_cast]\n"}
{"name": "inf_sdiff_self_right25", "split": "test", "formal_statement": "theorem inf_sdiff_self_right : x \u2293 y \\ x = \u22a5 :=\n  calc\n    x \u2293 y \\ x = (x \u2293 y \u2294 x \\ y) \u2293 y \\ x := by", "header": "\nimport Mathlib.Order.Heyting.Basic\n\n#align_import order.boolean_algebra from \"leanprover-community/mathlib\"@\"9ac7c0c8c4d7a535ec3e5b34b8859aab9233b2f4\"\n\n\n\n\nopen Function OrderDual\n\nuniverse u v\n\nvariable {\u03b1 : Type u} {\u03b2 : Type*} {w x y z : \u03b1}\n\n\n\n\n\nclass GeneralizedBooleanAlgebra (\u03b1 : Type u) extends DistribLattice \u03b1, SDiff \u03b1, Bot \u03b1 where\n  \n  sup_inf_sdiff : \u2200 a b : \u03b1, a \u2293 b \u2294 a \\ b = a\n  \n  inf_inf_sdiff : \u2200 a b : \u03b1, a \u2293 b \u2293 a \\ b = \u22a5\n#align generalized_boolean_algebra GeneralizedBooleanAlgebra\n\n-- We might want an `IsCompl_of` predicate (for relative complements) generalizing `IsCompl`,\n-- however we'd need another type class for lattices with bot, and all the API for that.\nsection GeneralizedBooleanAlgebra\n\nvariable [GeneralizedBooleanAlgebra \u03b1]\n\n@[simp]\ntheorem sup_inf_sdiff (x y : \u03b1) : x \u2293 y \u2294 x \\ y = x :=\n  GeneralizedBooleanAlgebra.sup_inf_sdiff _ _\n#align sup_inf_sdiff sup_inf_sdiff\n\n@[simp]\ntheorem inf_inf_sdiff (x y : \u03b1) : x \u2293 y \u2293 x \\ y = \u22a5 :=\n  GeneralizedBooleanAlgebra.inf_inf_sdiff _ _\n#align inf_inf_sdiff inf_inf_sdiff\n\n@[simp]\ntheorem sup_sdiff_inf (x y : \u03b1) : x \\ y \u2294 x \u2293 y = x := by rw [sup_comm, sup_inf_sdiff]\n#align sup_sdiff_inf sup_sdiff_inf\n\n@[simp]\ntheorem inf_sdiff_inf (x y : \u03b1) : x \\ y \u2293 (x \u2293 y) = \u22a5 := by rw [inf_comm, inf_inf_sdiff]\n#align inf_sdiff_inf inf_sdiff_inf\n\n-- see Note [lower instance priority]\ninstance (priority := 100) GeneralizedBooleanAlgebra.toOrderBot : OrderBot \u03b1 where\n  __ := GeneralizedBooleanAlgebra.toBot\n  bot_le a := by\n    rw [\u2190 inf_inf_sdiff a a, inf_assoc]\n    exact inf_le_left\n#align generalized_boolean_algebra.to_order_bot GeneralizedBooleanAlgebra.toOrderBot\n\ntheorem disjoint_inf_sdiff : Disjoint (x \u2293 y) (x \\ y) :=\n  disjoint_iff_inf_le.mpr (inf_inf_sdiff x y).le\n#align disjoint_inf_sdiff disjoint_inf_sdiff\n\n-- TODO: in distributive lattices, relative complements are unique when they exist\ntheorem sdiff_unique (s : x \u2293 y \u2294 z = x) (i : x \u2293 y \u2293 z = \u22a5) : x \\ y = z := by\n  conv_rhs at s => rw [\u2190 sup_inf_sdiff x y, sup_comm]\n  rw [sup_comm] at s\n  conv_rhs at i => rw [\u2190 inf_inf_sdiff x y, inf_comm]\n  rw [inf_comm] at i\n  exact (eq_of_inf_eq_sup_eq i s).symm\n#align sdiff_unique sdiff_unique\n\n-- Use `sdiff_le`\nprivate theorem sdiff_le' : x \\ y \u2264 x :=\n  calc\n    x \\ y \u2264 x \u2293 y \u2294 x \\ y := le_sup_right\n    _ = x := sup_inf_sdiff x y\n\n-- Use `sdiff_sup_self`\nprivate theorem sdiff_sup_self' : y \\ x \u2294 x = y \u2294 x :=\n  calc\n    y \\ x \u2294 x = y \\ x \u2294 (x \u2294 x \u2293 y) := by rw [sup_inf_self]\n    _ = y \u2293 x \u2294 y \\ x \u2294 x := by ac_rfl\n    _ = y \u2294 x := by rw [sup_inf_sdiff]\n\n@[simp]\ntheorem sdiff_inf_sdiff : x \\ y \u2293 y \\ x = \u22a5 :=\n  Eq.symm <|\n    calc\n      \u22a5 = x \u2293 y \u2293 x \\ y := by rw [inf_inf_sdiff]\n      _ = x \u2293 (y \u2293 x \u2294 y \\ x) \u2293 x \\ y := by rw [sup_inf_sdiff]\n      _ = (x \u2293 (y \u2293 x) \u2294 x \u2293 y \\ x) \u2293 x \\ y := by rw [inf_sup_left]\n      _ = (y \u2293 (x \u2293 x) \u2294 x \u2293 y \\ x) \u2293 x \\ y := by ac_rfl\n      _ = (y \u2293 x \u2294 x \u2293 y \\ x) \u2293 x \\ y := by rw [inf_idem]\n      _ = x \u2293 y \u2293 x \\ y \u2294 x \u2293 y \\ x \u2293 x \\ y := by rw [inf_sup_right, inf_comm x y]\n      _ = x \u2293 y \\ x \u2293 x \\ y := by rw [inf_inf_sdiff, bot_sup_eq]\n      _ = x \u2293 x \\ y \u2293 y \\ x := by ac_rfl\n      _ = x \\ y \u2293 y \\ x := by rw [inf_of_le_right sdiff_le']\n#align sdiff_inf_sdiff sdiff_inf_sdiff\n\ntheorem disjoint_sdiff_sdiff : Disjoint (x \\ y) (y \\ x) :=\n  disjoint_iff_inf_le.mpr sdiff_inf_sdiff.le\n#align disjoint_sdiff_sdiff disjoint_sdiff_sdiff\n\n@[simp]\n"}
{"name": "comp_sequence26", "split": "test", "formal_statement": "theorem comp_sequence (x : t (F (G \u03b1))) :\n    sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x) := by", "header": "\nimport Mathlib.Control.Applicative\nimport Mathlib.Control.Traversable.Basic\n\n#align_import control.traversable.lemmas from \"leanprover-community/mathlib\"@\"3342d1b2178381196f818146ff79bc0e7ccd9e2d\"\n\n\n\n\nuniverse u\n\nopen LawfulTraversable\n\nopen Function hiding comp\n\nopen Functor\n\nattribute [functor_norm] LawfulTraversable.naturality\n\nattribute [simp] LawfulTraversable.id_traverse\n\nnamespace Traversable\n\nvariable {t : Type u \u2192 Type u}\nvariable [Traversable t] [LawfulTraversable t]\nvariable (F G : Type u \u2192 Type u)\nvariable [Applicative F] [LawfulApplicative F]\nvariable [Applicative G] [LawfulApplicative G]\nvariable {\u03b1 \u03b2 \u03b3 : Type u}\nvariable (g : \u03b1 \u2192 F \u03b2)\nvariable (h : \u03b2 \u2192 G \u03b3)\nvariable (f : \u03b2 \u2192 \u03b3)\n\n\ndef PureTransformation :\n    ApplicativeTransformation Id F where\n  app := @pure F _\n  preserves_pure' x := rfl\n  preserves_seq' f x := by\n    simp only [map_pure, seq_pure]\n    rfl\n#align traversable.pure_transformation Traversable.PureTransformation\n\n@[simp]\ntheorem pureTransformation_apply {\u03b1} (x : id \u03b1) : PureTransformation F x = pure x :=\n  rfl\n#align traversable.pure_transformation_apply Traversable.pureTransformation_apply\n\nvariable {F G} (x : t \u03b2)\n\n-- Porting note: need to specify `m/F/G := Id` because `id` no longer has a `Monad` instance\ntheorem map_eq_traverse_id : map (f := t) f = traverse (m := Id) (pure \u2218 f) :=\n  funext fun y => (traverse_eq_map_id f y).symm\n#align traversable.map_eq_traverse_id Traversable.map_eq_traverse_id\n\ntheorem map_traverse (x : t \u03b1) : map f <$> traverse g x = traverse (map f \u2218 g) x := by\n  rw [map_eq_traverse_id f]\n  refine (comp_traverse (pure \u2218 f) g x).symm.trans ?_\n  congr; apply Comp.applicative_comp_id\n#align traversable.map_traverse Traversable.map_traverse\n\ntheorem traverse_map (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 \u03b2) (x : t \u03b1) :\n    traverse f (g <$> x) = traverse (f \u2218 g) x := by\n  rw [@map_eq_traverse_id t _ _ _ _ g]\n  refine (comp_traverse (G := Id) f (pure \u2218 g) x).symm.trans ?_\n  congr; apply Comp.applicative_id_comp\n#align traversable.traverse_map Traversable.traverse_map\n\ntheorem pure_traverse (x : t \u03b1) : traverse pure x = (pure x : F (t \u03b1)) := by\n  have : traverse pure x = pure (traverse (m := Id) pure x) :=\n      (naturality (PureTransformation F) pure x).symm\n  rwa [id_traverse] at this\n#align traversable.pure_traverse Traversable.pure_traverse\n\ntheorem id_sequence (x : t \u03b1) : sequence (f := Id) (pure <$> x) = pure x := by\n  simp [sequence, traverse_map, id_traverse]\n#align traversable.id_sequence Traversable.id_sequence\n\n"}
{"name": "card_derangements_fin_add_two27", "split": "test", "formal_statement": "theorem card_derangements_fin_add_two (n : \u2115) :\n    card (derangements (Fin (n + 2))) =\n      (n + 1) * card (derangements (Fin n)) + (n + 1) * card (derangements (Fin (n + 1))) := by", "header": "\nimport Mathlib.Algebra.BigOperators.Ring\nimport Mathlib.Combinatorics.Derangements.Basic\nimport Mathlib.Data.Fintype.BigOperators\nimport Mathlib.Tactic.Ring\n\n#align_import combinatorics.derangements.finite from \"leanprover-community/mathlib\"@\"c3019c79074b0619edb4b27553a91b2e82242395\"\n\n\n\n\nopen derangements Equiv Fintype\n\nvariable {\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1]\n\ninstance : DecidablePred (derangements \u03b1) := fun _ => Fintype.decidableForallFintype\n\n-- Porting note: used to use the tactic delta_instance\ninstance : Fintype (derangements \u03b1) := Subtype.fintype (fun (_ : Perm \u03b1) => \u2200 (x_1 : \u03b1), \u00ac_ = x_1)\n\ntheorem card_derangements_invariant {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b1] [Fintype \u03b2]\n    [DecidableEq \u03b2] (h : card \u03b1 = card \u03b2) : card (derangements \u03b1) = card (derangements \u03b2) :=\n  Fintype.card_congr (Equiv.derangementsCongr <| equivOfCardEq h)\n#align card_derangements_invariant card_derangements_invariant\n\n"}
{"name": "le_hasProd28", "split": "test", "formal_statement": "theorem le_hasProd (hf : HasProd f a) (i : \u03b9) (hb : \u2200 j, j \u2260 i \u2192 1 \u2264 f j) : f i \u2264 a :=\n  calc\n    f i = \u220f i \u2208 {i}, f i := by", "header": "\nimport Mathlib.Algebra.Order.Archimedean\nimport Mathlib.Topology.Algebra.InfiniteSum.NatInt\nimport Mathlib.Topology.Algebra.Order.Field\nimport Mathlib.Topology.Order.MonotoneConvergence\n\n#align_import topology.algebra.infinite_sum.order from \"leanprover-community/mathlib\"@\"32253a1a1071173b33dc7d6a218cf722c6feb514\"\n\n\n\n\nopen Finset Filter Function\nopen scoped Classical\n\nvariable {\u03b9 \u03ba \u03b1 : Type*}\n\nsection OrderedCommMonoid\n\nvariable [OrderedCommMonoid \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] {f g : \u03b9 \u2192 \u03b1}\n  {a a\u2081 a\u2082 : \u03b1}\n\n@[to_additive]\ntheorem hasProd_le (h : \u2200 i, f i \u2264 g i) (hf : HasProd f a\u2081) (hg : HasProd g a\u2082) : a\u2081 \u2264 a\u2082 :=\n  le_of_tendsto_of_tendsto' hf hg fun _ \u21a6 prod_le_prod' fun i _ \u21a6 h i\n#align has_sum_le hasSum_le\n\n@[to_additive (attr := mono)]\ntheorem hasProd_mono (hf : HasProd f a\u2081) (hg : HasProd g a\u2082) (h : f \u2264 g) : a\u2081 \u2264 a\u2082 :=\n  hasProd_le h hf hg\n#align has_sum_mono hasSum_mono\n\n@[to_additive]\ntheorem hasProd_le_of_prod_le (hf : HasProd f a) (h : \u2200 s, \u220f i \u2208 s, f i \u2264 a\u2082) : a \u2264 a\u2082 :=\n  le_of_tendsto' hf h\n#align has_sum_le_of_sum_le hasSum_le_of_sum_le\n\n@[to_additive]\ntheorem le_hasProd_of_le_prod (hf : HasProd f a) (h : \u2200 s, a\u2082 \u2264 \u220f i \u2208 s, f i) : a\u2082 \u2264 a :=\n  ge_of_tendsto' hf h\n#align le_has_sum_of_le_sum le_hasSum_of_le_sum\n\n@[to_additive]\ntheorem hasProd_le_inj {g : \u03ba \u2192 \u03b1} (e : \u03b9 \u2192 \u03ba) (he : Injective e)\n    (hs : \u2200 c, c \u2209 Set.range e \u2192 1 \u2264 g c) (h : \u2200 i, f i \u2264 g (e i)) (hf : HasProd f a\u2081)\n    (hg : HasProd g a\u2082) : a\u2081 \u2264 a\u2082 := by\n  rw [\u2190 hasProd_extend_one he] at hf\n  refine hasProd_le (fun c \u21a6 ?_) hf hg\n  obtain \u27e8i, rfl\u27e9 | h := em (c \u2208 Set.range e)\n  \u00b7 rw [he.extend_apply]\n    exact h _\n  \u00b7 rw [extend_apply' _ _ _ h]\n    exact hs _ h\n#align has_sum_le_inj hasSum_le_inj\n\n@[to_additive]\ntheorem tprod_le_tprod_of_inj {g : \u03ba \u2192 \u03b1} (e : \u03b9 \u2192 \u03ba) (he : Injective e)\n    (hs : \u2200 c, c \u2209 Set.range e \u2192 1 \u2264 g c) (h : \u2200 i, f i \u2264 g (e i)) (hf : Multipliable f)\n    (hg : Multipliable g) : tprod f \u2264 tprod g :=\n  hasProd_le_inj _ he hs h hf.hasProd hg.hasProd\n#align tsum_le_tsum_of_inj tsum_le_tsum_of_inj\n\n@[to_additive]\nlemma tprod_subtype_le {\u03ba \u03b3 : Type*} [OrderedCommGroup \u03b3] [UniformSpace \u03b3] [UniformGroup \u03b3]\n    [OrderClosedTopology \u03b3] [ CompleteSpace \u03b3] (f : \u03ba \u2192 \u03b3) (\u03b2 : Set \u03ba) (h : \u2200 a : \u03ba, 1 \u2264 f a)\n    (hf : Multipliable f) : (\u220f' (b : \u03b2), f b) \u2264 (\u220f' (a : \u03ba), f a) := by\n  apply tprod_le_tprod_of_inj _ (Subtype.coe_injective) (by simp only [Subtype.range_coe_subtype,\n    Set.setOf_mem_eq, h, implies_true]) (by simp only [le_refl,\n    Subtype.forall, implies_true]) (by apply hf.subtype)\n  apply hf\n\n@[to_additive]\ntheorem prod_le_hasProd (s : Finset \u03b9) (hs : \u2200 i, i \u2209 s \u2192 1 \u2264 f i) (hf : HasProd f a) :\n    \u220f i \u2208 s, f i \u2264 a :=\n  ge_of_tendsto hf (eventually_atTop.2\n    \u27e8s, fun _t hst \u21a6 prod_le_prod_of_subset_of_one_le' hst fun i _ hbs \u21a6 hs i hbs\u27e9)\n#align sum_le_has_sum sum_le_hasSum\n\n@[to_additive]\ntheorem isLUB_hasProd (h : \u2200 i, 1 \u2264 f i) (hf : HasProd f a) :\n    IsLUB (Set.range fun s \u21a6 \u220f i \u2208 s, f i) a :=\n  isLUB_of_tendsto_atTop (Finset.prod_mono_set_of_one_le' h) hf\n#align is_lub_has_sum isLUB_hasSum\n\n@[to_additive]\n"}
{"name": "jacobiSymNat.mod_left29", "split": "test", "formal_statement": "theorem jacobiSymNat.mod_left (a b ab : \u2115) (r : \u2124) (hab : a % b = ab) (hr : jacobiSymNat ab b = r) :\n    jacobiSymNat a b = r := by", "header": "\nimport Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol\n\n#align_import number_theory.legendre_symbol.norm_num from \"leanprover-community/mathlib\"@\"e2621d935895abe70071ab828a4ee6e26a52afe4\"\n\n\n\n\nsection Lemmas\n\nnamespace Mathlib.Meta.NormNum\n\n\ndef jacobiSymNat (a b : \u2115) : \u2124 :=\n  jacobiSym a b\n#align norm_num.jacobi_sym_nat Mathlib.Meta.NormNum.jacobiSymNat\n\n\n\n\n\ntheorem jacobiSymNat.zero_right (a : \u2115) : jacobiSymNat a 0 = 1 := by\n  rw [jacobiSymNat, jacobiSym.zero_right]\n#align norm_num.jacobi_sym_nat.zero_right Mathlib.Meta.NormNum.jacobiSymNat.zero_right\n\ntheorem jacobiSymNat.one_right (a : \u2115) : jacobiSymNat a 1 = 1 := by\n  rw [jacobiSymNat, jacobiSym.one_right]\n#align norm_num.jacobi_sym_nat.one_right Mathlib.Meta.NormNum.jacobiSymNat.one_right\n\ntheorem jacobiSymNat.zero_left (b : \u2115) (hb : Nat.beq (b / 2) 0 = false) : jacobiSymNat 0 b = 0 := by\n  rw [jacobiSymNat, Nat.cast_zero, jacobiSym.zero_left ?_]\n  calc\n    1 < 2 * 1       := by decide\n    _ \u2264 2 * (b / 2) :=\n      Nat.mul_le_mul_left _ (Nat.succ_le.mpr (Nat.pos_of_ne_zero (Nat.ne_of_beq_eq_false hb)))\n    _ \u2264 b           := Nat.mul_div_le b 2\n#align norm_num.jacobi_sym_nat.zero_left_even Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n#align norm_num.jacobi_sym_nat.zero_left_odd Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n\ntheorem jacobiSymNat.one_left (b : \u2115) : jacobiSymNat 1 b = 1 := by\n  rw [jacobiSymNat, Nat.cast_one, jacobiSym.one_left]\n#align norm_num.jacobi_sym_nat.one_left_even Mathlib.Meta.NormNum.jacobiSymNat.one_left\n#align norm_num.jacobi_sym_nat.one_left_odd Mathlib.Meta.NormNum.jacobiSymNat.one_left\n\n\ntheorem LegendreSym.to_jacobiSym (p : \u2115) (pp : Fact p.Prime) (a r : \u2124)\n    (hr : IsInt (jacobiSym a p) r) : IsInt (legendreSym p a) r := by\n  rwa [@jacobiSym.legendreSym.to_jacobiSym p pp a]\n#align norm_num.legendre_sym.to_jacobi_sym Mathlib.Meta.NormNum.LegendreSym.to_jacobiSym\n\n\ntheorem JacobiSym.mod_left (a : \u2124) (b ab' : \u2115) (ab r b' : \u2124) (hb' : (b : \u2124) = b')\n    (hab : a % b' = ab) (h : (ab' : \u2124) = ab) (hr : jacobiSymNat ab' b = r) : jacobiSym a b = r := by\n  rw [\u2190 hr, jacobiSymNat, jacobiSym.mod_left, hb', hab, \u2190 h]\n#align norm_num.jacobi_sym.mod_left Mathlib.Meta.NormNum.JacobiSym.mod_left\n\n"}
{"name": "image_cast_int_Iic30", "split": "test", "formal_statement": "theorem image_cast_int_Iic (a : \u2115) : (\u2191) '' Iic a = Icc (0 : \u2124) a := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Int\nimport Mathlib.Data.Nat.Cast.Order\nimport Mathlib.Order.UpperLower.Basic\n\n\n\nopen Set\n\nnamespace Nat\n\n@[simp]\ntheorem range_cast_int : range ((\u2191) : \u2115 \u2192 \u2124) = Ici 0 :=\n  Subset.antisymm (range_subset_iff.2 Int.ofNat_nonneg) CanLift.prf\n\ntheorem image_cast_int_Icc (a b : \u2115) : (\u2191) '' Icc a b = Icc (a : \u2124) b :=\n  (castOrderEmbedding (\u03b1 := \u2124)).image_Icc (by simp [ordConnected_Ici]) a b\n\ntheorem image_cast_int_Ico (a b : \u2115) : (\u2191) '' Ico a b = Ico (a : \u2124) b :=\n  (castOrderEmbedding (\u03b1 := \u2124)).image_Ico (by simp [ordConnected_Ici]) a b\n\ntheorem image_cast_int_Ioc (a b : \u2115) : (\u2191) '' Ioc a b = Ioc (a : \u2124) b :=\n  (castOrderEmbedding (\u03b1 := \u2124)).image_Ioc (by simp [ordConnected_Ici]) a b\n\ntheorem image_cast_int_Ioo (a b : \u2115) : (\u2191) '' Ioo a b = Ioo (a : \u2124) b :=\n  (castOrderEmbedding (\u03b1 := \u2124)).image_Ioo (by simp [ordConnected_Ici]) a b\n\n"}
{"name": "dotProduct_stdBasis_eq_mul31", "split": "test", "formal_statement": "theorem dotProduct_stdBasis_eq_mul [DecidableEq n] (v : n \u2192 R) (c : R) (i : n) :\n    dotProduct v (LinearMap.stdBasis R (fun _ => R) i c) = v i * c := by", "header": "\nimport Mathlib.Algebra.Star.Order\nimport Mathlib.Data.Matrix.Basic\nimport Mathlib.LinearAlgebra.StdBasis\n\n#align_import linear_algebra.matrix.dot_product from \"leanprover-community/mathlib\"@\"31c24aa72e7b3e5ed97a8412470e904f82b81004\"\n\n\n\n\nvariable {m n p R : Type*}\n\nnamespace Matrix\n\nsection Semiring\n\nvariable [Semiring R] [Fintype n]\n\n@[simp]\n"}
{"name": "edgeFinset_ssubset_edgeFinset32", "split": "test", "formal_statement": "theorem edgeFinset_ssubset_edgeFinset : G\u2081.edgeFinset \u2282 G\u2082.edgeFinset \u2194 G\u2081 < G\u2082 := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Combinatorics.SimpleGraph.Basic\nimport Mathlib.Data.Sym.Card\n\n\n\n\nopen Finset Function\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V) {e : Sym2 V}\n\nsection EdgeFinset\n\nvariable {G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]\n\n\nabbrev edgeFinset : Finset (Sym2 V) :=\n  Set.toFinset G.edgeSet\n#align simple_graph.edge_finset SimpleGraph.edgeFinset\n\n@[norm_cast]\ntheorem coe_edgeFinset : (G.edgeFinset : Set (Sym2 V)) = G.edgeSet :=\n  Set.coe_toFinset _\n#align simple_graph.coe_edge_finset SimpleGraph.coe_edgeFinset\n\nvariable {G}\n\ntheorem mem_edgeFinset : e \u2208 G.edgeFinset \u2194 e \u2208 G.edgeSet :=\n  Set.mem_toFinset\n#align simple_graph.mem_edge_finset SimpleGraph.mem_edgeFinset\n\ntheorem not_isDiag_of_mem_edgeFinset : e \u2208 G.edgeFinset \u2192 \u00ace.IsDiag :=\n  not_isDiag_of_mem_edgeSet _ \u2218 mem_edgeFinset.1\n#align simple_graph.not_is_diag_of_mem_edge_finset SimpleGraph.not_isDiag_of_mem_edgeFinset\n\ntheorem edgeFinset_inj : G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082 := by simp\n#align simple_graph.edge_finset_inj SimpleGraph.edgeFinset_inj\n\ntheorem edgeFinset_subset_edgeFinset : G\u2081.edgeFinset \u2286 G\u2082.edgeFinset \u2194 G\u2081 \u2264 G\u2082 := by simp\n#align simple_graph.edge_finset_subset_edge_finset SimpleGraph.edgeFinset_subset_edgeFinset\n\n"}
{"name": "hasSum_nat_jacobiTheta33", "split": "test", "formal_statement": "theorem hasSum_nat_jacobiTheta {\u03c4 : \u2102} (h\u03c4 : 0 < im \u03c4) :\n    HasSum (fun n : \u2115 => cexp (\u03c0 * I * ((n : \u2102) + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2) := by", "header": "\nimport Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable\nimport Mathlib.Analysis.Complex.UpperHalfPlane.Basic\n\n#align_import number_theory.modular_forms.jacobi_theta.basic from \"leanprover-community/mathlib\"@\"57f9349f2fe19d2de7207e99b0341808d977cdcf\"\n\n\n\nopen Complex Real Asymptotics Filter Topology\n\nopen scoped Real UpperHalfPlane\n\n\nnoncomputable def jacobiTheta (\u03c4 : \u2102) : \u2102 := \u2211' n : \u2124, cexp (\u03c0 * I * (n : \u2102) ^ 2 * \u03c4)\n#align jacobi_theta jacobiTheta\n\nlemma jacobiTheta_eq_jacobiTheta\u2082 (\u03c4 : \u2102) : jacobiTheta \u03c4 = jacobiTheta\u2082 0 \u03c4 :=\n  tsum_congr (by simp [jacobiTheta\u2082_term])\n\ntheorem jacobiTheta_two_add (\u03c4 : \u2102) : jacobiTheta (2 + \u03c4) = jacobiTheta \u03c4 := by\n  simp_rw [jacobiTheta_eq_jacobiTheta\u2082, add_comm, jacobiTheta\u2082_add_right]\n#align jacobi_theta_two_add jacobiTheta_two_add\n\ntheorem jacobiTheta_T_sq_smul (\u03c4 : \u210d) : jacobiTheta (ModularGroup.T ^ 2 \u2022 \u03c4 :) = jacobiTheta \u03c4 := by\n  suffices (ModularGroup.T ^ 2 \u2022 \u03c4 :) = (2 : \u2102) + \u2191\u03c4 by simp_rw [this, jacobiTheta_two_add]\n  have : ModularGroup.T ^ (2 : \u2115) = ModularGroup.T ^ (2 : \u2124) := rfl\n  simp_rw [this, UpperHalfPlane.modular_T_zpow_smul, UpperHalfPlane.coe_vadd]\n  norm_cast\nset_option linter.uppercaseLean3 false in\n#align jacobi_theta_T_sq_smul jacobiTheta_T_sq_smul\n\ntheorem jacobiTheta_S_smul (\u03c4 : \u210d) :\n    jacobiTheta \u2191(ModularGroup.S \u2022 \u03c4) = (-I * \u03c4) ^ (1 / 2 : \u2102) * jacobiTheta \u03c4 := by\n  have h0 : (\u03c4 : \u2102) \u2260 0 := ne_of_apply_ne im (zero_im.symm \u25b8 ne_of_gt \u03c4.2)\n  have h1 : (-I * \u03c4) ^ (1 / 2 : \u2102) \u2260 0 := by\n    rw [Ne, cpow_eq_zero_iff, not_and_or]\n    exact Or.inl <| mul_ne_zero (neg_ne_zero.mpr I_ne_zero) h0\n  simp_rw [UpperHalfPlane.modular_S_smul, jacobiTheta_eq_jacobiTheta\u2082]\n  conv_rhs => erw [\u2190 ofReal_zero, jacobiTheta\u2082_functional_equation 0 \u03c4]\n  rw [zero_pow two_ne_zero, mul_zero, zero_div, Complex.exp_zero, mul_one, \u2190 mul_assoc, mul_one_div,\n    div_self h1, one_mul, UpperHalfPlane.coe_mk, inv_neg, neg_div, one_div]\nset_option linter.uppercaseLean3 false in\n#align jacobi_theta_S_smul jacobiTheta_S_smul\n\ntheorem norm_exp_mul_sq_le {\u03c4 : \u2102} (h\u03c4 : 0 < \u03c4.im) (n : \u2124) :\n    \u2016cexp (\u03c0 * I * (n : \u2102) ^ 2 * \u03c4)\u2016 \u2264 rexp (-\u03c0 * \u03c4.im) ^ n.natAbs := by\n  let y := rexp (-\u03c0 * \u03c4.im)\n  have h : y < 1 := exp_lt_one_iff.mpr (mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) h\u03c4)\n  refine (le_of_eq ?_).trans (?_ : y ^ n ^ 2 \u2264 _)\n  \u00b7 rw [Complex.norm_eq_abs, Complex.abs_exp]\n    have : (\u03c0 * I * n ^ 2 * \u03c4 : \u2102).re = -\u03c0 * \u03c4.im * (n : \u211d) ^ 2 := by\n      rw [(by push_cast; ring : (\u03c0 * I * n ^ 2 * \u03c4 : \u2102) = (\u03c0 * n ^ 2 : \u211d) * (\u03c4 * I)),\n        re_ofReal_mul, mul_I_re]\n      ring\n    obtain \u27e8m, hm\u27e9 := Int.eq_ofNat_of_zero_le (sq_nonneg n)\n    rw [this, exp_mul, \u2190 Int.cast_pow, rpow_intCast, hm, zpow_natCast]\n  \u00b7 have : n ^ 2 = (n.natAbs ^ 2 :) := by rw [Nat.cast_pow, Int.natAbs_sq]\n    rw [this, zpow_natCast]\n    exact pow_le_pow_of_le_one (exp_pos _).le h.le ((sq n.natAbs).symm \u25b8 n.natAbs.le_mul_self)\n#align norm_exp_mul_sq_le norm_exp_mul_sq_le\n\n"}
{"name": "toGHSpace_eq_toGHSpace_iff_isometryEquiv34", "split": "test", "formal_statement": "theorem toGHSpace_eq_toGHSpace_iff_isometryEquiv {X : Type u} [MetricSpace X] [CompactSpace X]\n    [Nonempty X] {Y : Type v} [MetricSpace Y] [CompactSpace Y] [Nonempty Y] :\n    toGHSpace X = toGHSpace Y \u2194 Nonempty (X \u2243\u1d62 Y) :=\n  \u27e8by\n    simp only [toGHSpace]\n    rw [Quotient.eq]\n    rintro \u27e8e\u27e9\n    have I :\n      (NonemptyCompacts.kuratowskiEmbedding X \u2243\u1d62 NonemptyCompacts.kuratowskiEmbedding Y) =\n        (range (kuratowskiEmbedding X) \u2243\u1d62 range (kuratowskiEmbedding Y)) := by", "header": "\nimport Mathlib.SetTheory.Cardinal.Basic\nimport Mathlib.Topology.MetricSpace.Closeds\nimport Mathlib.Topology.MetricSpace.Completion\nimport Mathlib.Topology.MetricSpace.GromovHausdorffRealized\nimport Mathlib.Topology.MetricSpace.Kuratowski\n\n#align_import topology.metric_space.gromov_hausdorff from \"leanprover-community/mathlib\"@\"0c1f285a9f6e608ae2bdffa3f993eafb01eba829\"\n\n\n\nnoncomputable section\n\nopen scoped Classical Topology ENNReal Cardinal\n\nset_option linter.uppercaseLean3 false\n\nlocal notation \"\u2113_infty_\u211d\" => lp (fun n : \u2115 => \u211d) \u221e\n\nuniverse u v w\n\nopen scoped Classical\nopen Set Function TopologicalSpace Filter Metric Quotient Bornology\n\nopen BoundedContinuousFunction Nat Int kuratowskiEmbedding\n\nopen Sum (inl inr)\n\nattribute [local instance] metricSpaceSum\n\nnamespace GromovHausdorff\n\n\nsection GHSpace\n\n\nprivate def IsometryRel (x : NonemptyCompacts \u2113_infty_\u211d) (y : NonemptyCompacts \u2113_infty_\u211d) : Prop :=\n  Nonempty (x \u2243\u1d62 y)\n\n\nprivate theorem equivalence_isometryRel : Equivalence IsometryRel :=\n  \u27e8fun _ => Nonempty.intro (IsometryEquiv.refl _), fun \u27e8e\u27e9 => \u27e8e.symm\u27e9, fun \u27e8e\u27e9 \u27e8f\u27e9 => \u27e8e.trans f\u27e9\u27e9\n\n\ninstance IsometryRel.setoid : Setoid (NonemptyCompacts \u2113_infty_\u211d) :=\n  Setoid.mk IsometryRel equivalence_isometryRel\n#align Gromov_Hausdorff.isometry_rel.setoid GromovHausdorff.IsometryRel.setoid\n\n\ndef GHSpace : Type :=\n  Quotient IsometryRel.setoid\n#align Gromov_Hausdorff.GH_space GromovHausdorff.GHSpace\n\n\ndef toGHSpace (X : Type u) [MetricSpace X] [CompactSpace X] [Nonempty X] : GHSpace :=\n  \u27e6NonemptyCompacts.kuratowskiEmbedding X\u27e7\n#align Gromov_Hausdorff.to_GH_space GromovHausdorff.toGHSpace\n\ninstance : Inhabited GHSpace :=\n  \u27e8Quot.mk _ \u27e8\u27e8{0}, isCompact_singleton\u27e9, singleton_nonempty _\u27e9\u27e9\n\n\n-- Porting note(#5171): linter not yet ported; removed @[nolint has_nonempty_instance]; why?\ndef GHSpace.Rep (p : GHSpace) : Type :=\n  (Quotient.out p : NonemptyCompacts \u2113_infty_\u211d)\n#align Gromov_Hausdorff.GH_space.rep GromovHausdorff.GHSpace.Rep\n\ntheorem eq_toGHSpace_iff {X : Type u} [MetricSpace X] [CompactSpace X] [Nonempty X]\n    {p : NonemptyCompacts \u2113_infty_\u211d} :\n    \u27e6p\u27e7 = toGHSpace X \u2194 \u2203 \u03a8 : X \u2192 \u2113_infty_\u211d, Isometry \u03a8 \u2227 range \u03a8 = p := by\n  simp only [toGHSpace, Quotient.eq]\n  refine \u27e8fun h => ?_, ?_\u27e9\n  \u00b7 rcases Setoid.symm h with \u27e8e\u27e9\n    have f := (kuratowskiEmbedding.isometry X).isometryEquivOnRange.trans e\n    use fun x => f x, isometry_subtype_coe.comp f.isometry\n    erw [range_comp, f.range_eq_univ, Set.image_univ, Subtype.range_coe]\n  \u00b7 rintro \u27e8\u03a8, \u27e8isom\u03a8, range\u03a8\u27e9\u27e9\n    have f :=\n      ((kuratowskiEmbedding.isometry X).isometryEquivOnRange.symm.trans\n          isom\u03a8.isometryEquivOnRange).symm\n    have E : (range \u03a8 \u2243\u1d62 NonemptyCompacts.kuratowskiEmbedding X)\n        = (p \u2243\u1d62 range (kuratowskiEmbedding X)) := by\n      dsimp only [NonemptyCompacts.kuratowskiEmbedding]; rw [range\u03a8]; rfl\n    exact \u27e8cast E f\u27e9\n#align Gromov_Hausdorff.eq_to_GH_space_iff GromovHausdorff.eq_toGHSpace_iff\n\ntheorem eq_toGHSpace {p : NonemptyCompacts \u2113_infty_\u211d} : \u27e6p\u27e7 = toGHSpace p :=\n  eq_toGHSpace_iff.2 \u27e8fun x => x, isometry_subtype_coe, Subtype.range_coe\u27e9\n#align Gromov_Hausdorff.eq_to_GH_space GromovHausdorff.eq_toGHSpace\n\nsection\n\ninstance repGHSpaceMetricSpace {p : GHSpace} : MetricSpace p.Rep :=\n  inferInstanceAs <| MetricSpace p.out\n#align Gromov_Hausdorff.rep_GH_space_metric_space GromovHausdorff.repGHSpaceMetricSpace\n\ninstance rep_gHSpace_compactSpace {p : GHSpace} : CompactSpace p.Rep :=\n  inferInstanceAs <| CompactSpace p.out\n#align Gromov_Hausdorff.rep_GH_space_compact_space GromovHausdorff.rep_gHSpace_compactSpace\n\ninstance rep_gHSpace_nonempty {p : GHSpace} : Nonempty p.Rep :=\n  inferInstanceAs <| Nonempty p.out\n#align Gromov_Hausdorff.rep_GH_space_nonempty GromovHausdorff.rep_gHSpace_nonempty\n\nend\n\ntheorem GHSpace.toGHSpace_rep (p : GHSpace) : toGHSpace p.Rep = p := by\n  change toGHSpace (Quot.out p : NonemptyCompacts \u2113_infty_\u211d) = p\n  rw [\u2190 eq_toGHSpace]\n  exact Quot.out_eq p\n#align Gromov_Hausdorff.GH_space.to_GH_space_rep GromovHausdorff.GHSpace.toGHSpace_rep\n\n\n"}
{"name": "map_comp35", "split": "test", "formal_statement": "theorem map_comp (P : PresheafOfModules R) {X Y Z : C\u1d52\u1d56} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    P.map (f \u226b g) = (P.map g).comp (P.map f) := by", "header": "\nimport Mathlib.Algebra.Category.ModuleCat.ChangeOfRings\nimport Mathlib.Algebra.Category.Ring.Basic\n\n\n\nuniverse v v\u2081 u\u2081 u\n\nopen CategoryTheory LinearMap Opposite\n\nvariable {C : Type u\u2081} [Category.{v\u2081} C]\n\n\nstructure PresheafOfModules (R : C\u1d52\u1d56 \u2964 RingCat.{u}) where\n  presheaf : C\u1d52\u1d56 \u2964 AddCommGroupCat.{v}\n  module : \u2200 X : C\u1d52\u1d56, Module (R.obj X) (presheaf.obj X) := by infer_instance\n  map_smul : \u2200 {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) (r : R.obj X) (x : presheaf.obj X),\n    presheaf.map f (r \u2022 x) = R.map f r \u2022 presheaf.map f x := by aesop_cat\n\nvariable {R : C\u1d52\u1d56 \u2964 RingCat.{u}}\n\nnamespace PresheafOfModules\n\nattribute [instance] PresheafOfModules.module\n\n\ndef obj (P : PresheafOfModules R) (X : C\u1d52\u1d56) : ModuleCat (R.obj X) :=\n  ModuleCat.of _ (P.presheaf.obj X)\n\n\ndef map (P : PresheafOfModules R) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) :\n    P.obj X \u2192\u209b\u2097[R.map f] P.obj Y :=\n  { toAddHom := (P.presheaf.map f).toAddHom,\n    map_smul' := P.map_smul f, }\n\ntheorem map_apply (P : PresheafOfModules R) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) (x) :\n    P.map f x = (P.presheaf.map f) x :=\n  rfl\n\ninstance (X : C\u1d52\u1d56) : RingHomId (R.map (\ud835\udfd9 X)) where\n  eq_id := R.map_id X\n\ninstance {X Y Z : C\u1d52\u1d56} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    RingHomCompTriple (R.map f) (R.map g) (R.map (f \u226b g)) where\n  comp_eq := (R.map_comp f g).symm\n\n@[simp]\ntheorem map_id (P : PresheafOfModules R) (X : C\u1d52\u1d56) :\n    P.map (\ud835\udfd9 X) = LinearMap.id' := by\n  ext\n  simp [map_apply]\n\n@[simp]\n"}
{"name": "map_sum_lt36", "split": "test", "formal_statement": "theorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i \u2208 s, f i) < g := by", "header": "\nimport Mathlib.Algebra.Order.Group.Basic\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.RingTheory.Ideal.Maps\nimport Mathlib.Tactic.TFAE\n\n#align_import ring_theory.valuation.basic from \"leanprover-community/mathlib\"@\"2196ab363eb097c008d4497125e0dde23fb36db2\"\n\n\n\n\nopen scoped Classical\nopen Function Ideal\n\nnoncomputable section\n\nvariable {K F R : Type*} [DivisionRing K]\n\nsection\n\nvariable (F R) (\u0393\u2080 : Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n\n--porting note (#5171): removed @[nolint has_nonempty_instance]\n\nstructure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  \n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)\n#align valuation Valuation\n\n\nclass ValuationClass (F) (R \u0393\u2080 : outParam Type*) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  [FunLike F R \u0393\u2080]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 : Prop where\n  \n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)\n#align valuation_class ValuationClass\n\nexport ValuationClass (map_add_le_max)\n\ninstance [FunLike F R \u0393\u2080] [ValuationClass F R \u0393\u2080] : CoeTC F (Valuation R \u0393\u2080) :=\n  \u27e8fun f =>\n    { toFun := f\n      map_one' := map_one f\n      map_zero' := map_zero f\n      map_mul' := map_mul f\n      map_add_le_max' := map_add_le_max f }\u27e9\n\nend\n\nnamespace Valuation\n\nvariable {\u0393\u2080 : Type*}\nvariable {\u0393'\u2080 : Type*}\nvariable {\u0393''\u2080 : Type*} [LinearOrderedCommMonoidWithZero \u0393''\u2080]\n\nsection Basic\n\nvariable [Ring R]\n\nsection Monoid\n\nvariable [LinearOrderedCommMonoidWithZero \u0393\u2080] [LinearOrderedCommMonoidWithZero \u0393'\u2080]\n\ninstance : FunLike (Valuation R \u0393\u2080) R \u0393\u2080 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8_,_\u27e9, _\u27e9, _\u27e9 := f\n    congr\n\ninstance : ValuationClass (Valuation R \u0393\u2080) R \u0393\u2080 where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_zero f := f.map_zero'\n  map_add_le_max f := f.map_add_le_max'\n\n@[simp]\ntheorem coe_mk (f : R \u2192*\u2080 \u0393\u2080) (h) : \u21d1(Valuation.mk f h) = f := rfl\n\ntheorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v := rfl\n#align valuation.to_fun_eq_coe Valuation.toFun_eq_coe\n\n@[simp] -- Porting note: requested by simpNF as toFun_eq_coe LHS simplifies\ntheorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v := rfl\n\n@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=\n  DFunLike.ext _ _ h\n#align valuation.ext Valuation.ext\n\nvariable (v : Valuation R \u0393\u2080) {x y z : R}\n\n@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v := rfl\n#align valuation.coe_coe Valuation.coe_coe\n\n-- @[simp] Porting note (#10618): simp can prove this\ntheorem map_zero : v 0 = 0 :=\n  v.map_zero'\n#align valuation.map_zero Valuation.map_zero\n\n-- @[simp] Porting note (#10618): simp can prove this\ntheorem map_one : v 1 = 1 :=\n  v.map_one'\n#align valuation.map_one Valuation.map_one\n\n-- @[simp] Porting note (#10618): simp can prove this\ntheorem map_mul : \u2200 x y, v (x * y) = v x * v y :=\n  v.map_mul'\n#align valuation.map_mul Valuation.map_mul\n\n-- Porting note: LHS side simplified so created map_add'\ntheorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y) :=\n  v.map_add_le_max'\n#align valuation.map_add Valuation.map_add\n\n@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y := by\n  intro x y\n  rw [\u2190 le_max_iff, \u2190 ge_iff_le]\n  apply map_add\n\ntheorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g :=\n  le_trans (v.map_add x y) <| max_le hx hy\n#align valuation.map_add_le Valuation.map_add_le\n\ntheorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g :=\n  lt_of_le_of_lt (v.map_add x y) <| max_lt hx hy\n#align valuation.map_add_lt Valuation.map_add_lt\n\ntheorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i \u2208 s, f i) \u2264 g := by\n  refine\n    Finset.induction_on s (fun _ => v.map_zero \u25b8 zero_le')\n      (fun a s has ih hf => ?_) hf\n  rw [Finset.forall_mem_insert] at hf; rw [Finset.sum_insert has]\n  exact v.map_add_le hf.1 (ih hf.2)\n#align valuation.map_sum_le Valuation.map_sum_le\n\n"}
{"name": "frequently_odd37", "split": "test", "formal_statement": "theorem frequently_odd : \u2203\u1da0 m : \u2115 in atTop, Odd m := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Abs\nimport Mathlib.Data.Nat.ModEq\nimport Mathlib.Order.Filter.AtTopBot\n\n#align_import order.filter.modeq from \"leanprover-community/mathlib\"@\"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c\"\n\n\n\n\nopen Filter\n\nnamespace Nat\n\n\ntheorem frequently_modEq {n : \u2115} (h : n \u2260 0) (d : \u2115) : \u2203\u1da0 m in atTop, m \u2261 d [MOD n] :=\n  ((tendsto_add_atTop_nat d).comp (tendsto_id.nsmul_atTop h.bot_lt)).frequently <|\n    frequently_of_forall fun m => by simp [Nat.modEq_iff_dvd, \u2190 sub_sub]\n#align nat.frequently_modeq Nat.frequently_modEq\n\ntheorem frequently_mod_eq {d n : \u2115} (h : d < n) : \u2203\u1da0 m in atTop, m % n = d := by\n  simpa only [Nat.ModEq, mod_eq_of_lt h] using frequently_modEq h.ne_bot d\n#align nat.frequently_mod_eq Nat.frequently_mod_eq\n\ntheorem frequently_even : \u2203\u1da0 m : \u2115 in atTop, Even m := by\n  simpa only [even_iff] using frequently_mod_eq zero_lt_two\n#align nat.frequently_even Nat.frequently_even\n\n"}
{"name": "range_eq_top38", "split": "test", "formal_statement": "theorem range_eq_top [RingHomSurjective \u03c4\u2081\u2082] {f : F} : range f = \u22a4 \u2194 Surjective f := by", "header": "\nimport Mathlib.Algebra.Module.Submodule.Ker\n\n#align_import linear_algebra.basic from \"leanprover-community/mathlib\"@\"9d684a893c52e1d6692a504a118bfccbae04feeb\"\n\n\n\nopen Function\n\nvariable {R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}\nvariable {K : Type*} {K\u2082 : Type*}\nvariable {M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}\nvariable {V : Type*} {V\u2082 : Type*}\n\nnamespace LinearMap\n\nsection AddCommMonoid\n\nvariable [Semiring R] [Semiring R\u2082] [Semiring R\u2083]\nvariable [AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]\nvariable {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083}\nvariable [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]\nvariable [Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]\n\nopen Submodule\n\nvariable {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} {\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}\nvariable [RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]\n\nsection\n\nvariable {F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]\n\n\ndef range [RingHomSurjective \u03c4\u2081\u2082] (f : F) : Submodule R\u2082 M\u2082 :=\n  (map f \u22a4).copy (Set.range f) Set.image_univ.symm\n#align linear_map.range LinearMap.range\n\ntheorem range_coe [RingHomSurjective \u03c4\u2081\u2082] (f : F) : (range f : Set M\u2082) = Set.range f :=\n  rfl\n#align linear_map.range_coe LinearMap.range_coe\n\ntheorem range_toAddSubmonoid [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) :\n    f.range.toAddSubmonoid = AddMonoidHom.mrange f :=\n  rfl\n#align linear_map.range_to_add_submonoid LinearMap.range_toAddSubmonoid\n\n@[simp]\ntheorem mem_range [RingHomSurjective \u03c4\u2081\u2082] {f : F} {x} : x \u2208 range f \u2194 \u2203 y, f y = x :=\n  Iff.rfl\n#align linear_map.mem_range LinearMap.mem_range\n\ntheorem range_eq_map [RingHomSurjective \u03c4\u2081\u2082] (f : F) : range f = map f \u22a4 := by\n  ext\n  simp\n#align linear_map.range_eq_map LinearMap.range_eq_map\n\ntheorem mem_range_self [RingHomSurjective \u03c4\u2081\u2082] (f : F) (x : M) : f x \u2208 range f :=\n  \u27e8x, rfl\u27e9\n#align linear_map.mem_range_self LinearMap.mem_range_self\n\n@[simp]\ntheorem range_id : range (LinearMap.id : M \u2192\u2097[R] M) = \u22a4 :=\n  SetLike.coe_injective Set.range_id\n#align linear_map.range_id LinearMap.range_id\n\ntheorem range_comp [RingHomSurjective \u03c4\u2081\u2082] [RingHomSurjective \u03c4\u2082\u2083] [RingHomSurjective \u03c4\u2081\u2083]\n    (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) : range (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) = map g (range f) :=\n  SetLike.coe_injective (Set.range_comp g f)\n#align linear_map.range_comp LinearMap.range_comp\n\ntheorem range_comp_le_range [RingHomSurjective \u03c4\u2082\u2083] [RingHomSurjective \u03c4\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082)\n    (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) : range (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) \u2264 range g :=\n  SetLike.coe_mono (Set.range_comp_subset_range f g)\n#align linear_map.range_comp_le_range LinearMap.range_comp_le_range\n\n"}
{"name": "bicone_\u03b9_\u03c0_self39", "split": "test", "formal_statement": "theorem bicone_\u03b9_\u03c0_self {F : J \u2192 C} (B : Bicone F) (j : J) : B.\u03b9 j \u226b B.\u03c0 j = \ud835\udfd9 (F j) := by", "header": "\nimport Mathlib.CategoryTheory.Limits.Shapes.FiniteProducts\nimport Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts\nimport Mathlib.CategoryTheory.Limits.Shapes.Kernels\n\n#align_import category_theory.limits.shapes.biproducts from \"leanprover-community/mathlib\"@\"ac3ae212f394f508df43e37aa093722fa9b65d31\"\n\n\n\nnoncomputable section\n\nuniverse w w' v u\n\nopen CategoryTheory\n\nopen CategoryTheory.Functor\n\nopen scoped Classical\n\nnamespace CategoryTheory\n\nnamespace Limits\n\nvariable {J : Type w}\nuniverse uC' uC uD' uD\nvariable {C : Type uC} [Category.{uC'} C] [HasZeroMorphisms C]\nvariable {D : Type uD} [Category.{uD'} D] [HasZeroMorphisms D]\n\n\n-- @[nolint has_nonempty_instance] Porting note (#5171): removed\nstructure Bicone (F : J \u2192 C) where\n  pt : C\n  \u03c0 : \u2200 j, pt \u27f6 F j\n  \u03b9 : \u2200 j, F j \u27f6 pt\n  \u03b9_\u03c0 : \u2200 j j', \u03b9 j \u226b \u03c0 j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n#align category_theory.limits.bicone CategoryTheory.Limits.Bicone\nset_option linter.uppercaseLean3 false in\n#align category_theory.limits.bicone_X CategoryTheory.Limits.Bicone.pt\n\nattribute [inherit_doc Bicone] Bicone.pt Bicone.\u03c0 Bicone.\u03b9 Bicone.\u03b9_\u03c0\n\n@[reassoc (attr := simp)]\n"}
{"name": "isOpen_support40", "split": "test", "formal_statement": "theorem isOpen_support : IsOpen (support f) := by", "header": "\nimport Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension\nimport Mathlib.Geometry.Manifold.ContMDiff.Atlas\nimport Mathlib.Geometry.Manifold.ContMDiff.NormedSpace\n\n#align_import geometry.manifold.bump_function from \"leanprover-community/mathlib\"@\"b018406ad2f2a73223a3a9e198ccae61e6f05318\"\n\n\n\nuniverse uE uF uH uM\n\nvariable {E : Type uE} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\n  {H : Type uH} [TopologicalSpace H] (I : ModelWithCorners \u211d E H) {M : Type uM} [TopologicalSpace M]\n  [ChartedSpace H M] [SmoothManifoldWithCorners I M]\n\nopen Function Filter FiniteDimensional Set Metric\n\nopen scoped Topology Manifold Classical Filter\n\nnoncomputable section\n\n\n\n\nstructure SmoothBumpFunction (c : M) extends ContDiffBump (extChartAt I c c) where\n  closedBall_subset : closedBall (extChartAt I c c) rOut \u2229 range I \u2286 (extChartAt I c).target\n#align smooth_bump_function SmoothBumpFunction\n\nnamespace SmoothBumpFunction\n\nvariable {c : M} (f : SmoothBumpFunction I c) {x : M} {I}\n\n\n@[coe] def toFun : M \u2192 \u211d :=\n  indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c)\n#align smooth_bump_function.to_fun SmoothBumpFunction.toFun\n\ninstance : CoeFun (SmoothBumpFunction I c) fun _ => M \u2192 \u211d :=\n  \u27e8toFun\u27e9\n\ntheorem coe_def : \u21d1f = indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c) :=\n  rfl\n#align smooth_bump_function.coe_def SmoothBumpFunction.coe_def\n\ntheorem rOut_pos : 0 < f.rOut :=\n  f.toContDiffBump.rOut_pos\nset_option linter.uppercaseLean3 false in\n#align smooth_bump_function.R_pos SmoothBumpFunction.rOut_pos\n\ntheorem ball_subset : ball (extChartAt I c c) f.rOut \u2229 range I \u2286 (extChartAt I c).target :=\n  Subset.trans (inter_subset_inter_left _ ball_subset_closedBall) f.closedBall_subset\n#align smooth_bump_function.ball_subset SmoothBumpFunction.ball_subset\n\ntheorem ball_inter_range_eq_ball_inter_target :\n    ball (extChartAt I c c) f.rOut \u2229 range I =\n      ball (extChartAt I c c) f.rOut \u2229 (extChartAt I c).target :=\n  (subset_inter inter_subset_left f.ball_subset).antisymm <| inter_subset_inter_right _ <|\n    extChartAt_target_subset_range _ _\n\ntheorem eqOn_source : EqOn f (f.toContDiffBump \u2218 extChartAt I c) (chartAt H c).source :=\n  eqOn_indicator\n#align smooth_bump_function.eq_on_source SmoothBumpFunction.eqOn_source\n\ntheorem eventuallyEq_of_mem_source (hx : x \u2208 (chartAt H c).source) :\n    f =\u1da0[\ud835\udcdd x] f.toContDiffBump \u2218 extChartAt I c :=\n  f.eqOn_source.eventuallyEq_of_mem <| (chartAt H c).open_source.mem_nhds hx\n#align smooth_bump_function.eventually_eq_of_mem_source SmoothBumpFunction.eventuallyEq_of_mem_source\n\ntheorem one_of_dist_le (hs : x \u2208 (chartAt H c).source)\n    (hd : dist (extChartAt I c x) (extChartAt I c c) \u2264 f.rIn) : f x = 1 := by\n  simp only [f.eqOn_source hs, (\u00b7 \u2218 \u00b7), f.one_of_mem_closedBall hd]\n#align smooth_bump_function.one_of_dist_le SmoothBumpFunction.one_of_dist_le\n\ntheorem support_eq_inter_preimage :\n    support f = (chartAt H c).source \u2229 extChartAt I c \u207b\u00b9' ball (extChartAt I c c) f.rOut := by\n  rw [coe_def, support_indicator, support_comp_eq_preimage, \u2190 extChartAt_source I,\n    \u2190 (extChartAt I c).symm_image_target_inter_eq', \u2190 (extChartAt I c).symm_image_target_inter_eq',\n    f.support_eq]\n#align smooth_bump_function.support_eq_inter_preimage SmoothBumpFunction.support_eq_inter_preimage\n\n"}
{"name": "smul_zero_mk41", "split": "test", "formal_statement": "theorem smul_zero_mk {\u03b1 : Type*} [Monoid M] [AddMonoid \u03b1] [DistribMulAction M \u03b1] (a : M) (c : \u03b2) :\n    a \u2022 ((0 : \u03b1), c) = (0, a \u2022 c) := by", "header": "\nimport Mathlib.Algebra.Group.Prod\nimport Mathlib.GroupTheory.GroupAction.Defs\n\n#align_import group_theory.group_action.prod from \"leanprover-community/mathlib\"@\"aba57d4d3dae35460225919dcd82fe91355162f9\"\n\n\n\nassert_not_exists MonoidWithZero\n\nvariable {M N P E \u03b1 \u03b2 : Type*}\n\nnamespace Prod\n\nsection\n\nvariable [SMul M \u03b1] [SMul M \u03b2] [SMul N \u03b1] [SMul N \u03b2] (a : M) (x : \u03b1 \u00d7 \u03b2)\n\n@[to_additive]\ninstance smul : SMul M (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun a p => (a \u2022 p.1, a \u2022 p.2)\u27e9\n\n@[to_additive (attr := simp)]\ntheorem smul_fst : (a \u2022 x).1 = a \u2022 x.1 :=\n  rfl\n#align prod.smul_fst Prod.smul_fst\n#align prod.vadd_fst Prod.vadd_fst\n\n@[to_additive (attr := simp)]\ntheorem smul_snd : (a \u2022 x).2 = a \u2022 x.2 :=\n  rfl\n#align prod.smul_snd Prod.smul_snd\n#align prod.vadd_snd Prod.vadd_snd\n\n@[to_additive (attr := simp)]\ntheorem smul_mk (a : M) (b : \u03b1) (c : \u03b2) : a \u2022 (b, c) = (a \u2022 b, a \u2022 c) :=\n  rfl\n#align prod.smul_mk Prod.smul_mk\n#align prod.vadd_mk Prod.vadd_mk\n\n@[to_additive]\ntheorem smul_def (a : M) (x : \u03b1 \u00d7 \u03b2) : a \u2022 x = (a \u2022 x.1, a \u2022 x.2) :=\n  rfl\n#align prod.smul_def Prod.smul_def\n#align prod.vadd_def Prod.vadd_def\n\n@[to_additive (attr := simp)]\ntheorem smul_swap : (a \u2022 x).swap = a \u2022 x.swap :=\n  rfl\n#align prod.smul_swap Prod.smul_swap\n#align prod.vadd_swap Prod.vadd_swap\n\n"}
{"name": "noncommFold_coe42", "split": "test", "formal_statement": "theorem noncommFold_coe (l : List \u03b1) (comm) (a : \u03b1) :\n    noncommFold op (l : Multiset \u03b1) comm a = l.foldr op a := by", "header": "\nimport Mathlib.Algebra.BigOperators.Group.Finset\nimport Mathlib.Algebra.Group.Commute.Hom\nimport Mathlib.Data.Fintype.Card\n\n#align_import data.finset.noncomm_prod from \"leanprover-community/mathlib\"@\"509de852e1de55e1efa8eacfa11df0823f26f226\"\n\n\n\nvariable {F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n\nnamespace Multiset\n\n\ndef noncommFoldr (s : Multiset \u03b1)\n    (comm : { x | x \u2208 s }.Pairwise fun x y => \u2200 b, f x (f y b) = f y (f x b)) (b : \u03b2) : \u03b2 :=\n  s.attach.foldr (f \u2218 Subtype.val)\n    (fun \u27e8_, hx\u27e9 \u27e8_, hy\u27e9 =>\n      haveI : IsRefl \u03b1 fun x y => \u2200 b, f x (f y b) = f y (f x b) := \u27e8fun _ _ => rfl\u27e9\n      comm.of_refl hx hy)\n    b\n#align multiset.noncomm_foldr Multiset.noncommFoldr\n\n@[simp]\ntheorem noncommFoldr_coe (l : List \u03b1) (comm) (b : \u03b2) :\n    noncommFoldr f (l : Multiset \u03b1) comm b = l.foldr f b := by\n  simp only [noncommFoldr, coe_foldr, coe_attach, List.attach, List.attachWith, Function.comp]\n  rw [\u2190 List.foldr_map]\n  simp [List.map_pmap]\n#align multiset.noncomm_foldr_coe Multiset.noncommFoldr_coe\n\n@[simp]\ntheorem noncommFoldr_empty (h) (b : \u03b2) : noncommFoldr f (0 : Multiset \u03b1) h b = b :=\n  rfl\n#align multiset.noncomm_foldr_empty Multiset.noncommFoldr_empty\n\ntheorem noncommFoldr_cons (s : Multiset \u03b1) (a : \u03b1) (h h') (b : \u03b2) :\n    noncommFoldr f (a ::\u2098 s) h b = f a (noncommFoldr f s h' b) := by\n  induction s using Quotient.inductionOn\n  simp\n#align multiset.noncomm_foldr_cons Multiset.noncommFoldr_cons\n\ntheorem noncommFoldr_eq_foldr (s : Multiset \u03b1) (h : LeftCommutative f) (b : \u03b2) :\n    noncommFoldr f s (fun x _ y _ _ => h x y) b = foldr f h b s := by\n  induction s using Quotient.inductionOn\n  simp\n#align multiset.noncomm_foldr_eq_foldr Multiset.noncommFoldr_eq_foldr\n\nsection assoc\n\nvariable [assoc : Std.Associative op]\n\n\ndef noncommFold (s : Multiset \u03b1) (comm : { x | x \u2208 s }.Pairwise fun x y => op x y = op y x) :\n    \u03b1 \u2192 \u03b1 :=\n  noncommFoldr op s fun x hx y hy h b => by rw [\u2190 assoc.assoc, comm hx hy h, assoc.assoc]\n#align multiset.noncomm_fold Multiset.noncommFold\n\n@[simp]\n"}
{"name": "angle_self_neg_of_nonzero43", "split": "test", "formal_statement": "theorem angle_self_neg_of_nonzero {x : V} (hx : x \u2260 0) : angle x (-x) = \u03c0 := by", "header": "\nimport Mathlib.Analysis.InnerProductSpace.Basic\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Inverse\n\n#align_import geometry.euclidean.angle.unoriented.basic from \"leanprover-community/mathlib\"@\"46b633fd842bef9469441c0209906f6dddd2b4f5\"\n\n\n\n\nassert_not_exists HasFDerivAt\n\nassert_not_exists ConformalAt\n\nnoncomputable section\n\nopen Real Set\n\nopen Real\n\nopen RealInnerProductSpace\n\nnamespace InnerProductGeometry\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] {x y : V}\n\n\ndef angle (x y : V) : \u211d :=\n  Real.arccos (\u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016))\n#align inner_product_geometry.angle InnerProductGeometry.angle\n\ntheorem continuousAt_angle {x : V \u00d7 V} (hx1 : x.1 \u2260 0) (hx2 : x.2 \u2260 0) :\n    ContinuousAt (fun y : V \u00d7 V => angle y.1 y.2) x :=\n  Real.continuous_arccos.continuousAt.comp <|\n    continuous_inner.continuousAt.div\n      ((continuous_norm.comp continuous_fst).mul (continuous_norm.comp continuous_snd)).continuousAt\n      (by simp [hx1, hx2])\n#align inner_product_geometry.continuous_at_angle InnerProductGeometry.continuousAt_angle\n\ntheorem angle_smul_smul {c : \u211d} (hc : c \u2260 0) (x y : V) : angle (c \u2022 x) (c \u2022 y) = angle x y := by\n  have : c * c \u2260 0 := mul_ne_zero hc hc\n  rw [angle, angle, real_inner_smul_left, inner_smul_right, norm_smul, norm_smul, Real.norm_eq_abs,\n    mul_mul_mul_comm _ \u2016x\u2016, abs_mul_abs_self, \u2190 mul_assoc c c, mul_div_mul_left _ _ this]\n#align inner_product_geometry.angle_smul_smul InnerProductGeometry.angle_smul_smul\n\n@[simp]\ntheorem _root_.LinearIsometry.angle_map {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F]\n    [InnerProductSpace \u211d E] [InnerProductSpace \u211d F] (f : E \u2192\u2097\u1d62[\u211d] F) (u v : E) :\n    angle (f u) (f v) = angle u v := by\n  rw [angle, angle, f.inner_map_map, f.norm_map, f.norm_map]\n#align linear_isometry.angle_map LinearIsometry.angle_map\n\n@[simp, norm_cast]\ntheorem _root_.Submodule.angle_coe {s : Submodule \u211d V} (x y : s) :\n    angle (x : V) (y : V) = angle x y :=\n  s.subtype\u2097\u1d62.angle_map x y\n#align submodule.angle_coe Submodule.angle_coe\n\n\ntheorem cos_angle (x y : V) : Real.cos (angle x y) = \u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016) :=\n  Real.cos_arccos (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).1\n    (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2\n#align inner_product_geometry.cos_angle InnerProductGeometry.cos_angle\n\n\ntheorem angle_comm (x y : V) : angle x y = angle y x := by\n  unfold angle\n  rw [real_inner_comm, mul_comm]\n#align inner_product_geometry.angle_comm InnerProductGeometry.angle_comm\n\n\n@[simp]\ntheorem angle_neg_neg (x y : V) : angle (-x) (-y) = angle x y := by\n  unfold angle\n  rw [inner_neg_neg, norm_neg, norm_neg]\n#align inner_product_geometry.angle_neg_neg InnerProductGeometry.angle_neg_neg\n\n\ntheorem angle_nonneg (x y : V) : 0 \u2264 angle x y :=\n  Real.arccos_nonneg _\n#align inner_product_geometry.angle_nonneg InnerProductGeometry.angle_nonneg\n\n\ntheorem angle_le_pi (x y : V) : angle x y \u2264 \u03c0 :=\n  Real.arccos_le_pi _\n#align inner_product_geometry.angle_le_pi InnerProductGeometry.angle_le_pi\n\n\ntheorem angle_neg_right (x y : V) : angle x (-y) = \u03c0 - angle x y := by\n  unfold angle\n  rw [\u2190 Real.arccos_neg, norm_neg, inner_neg_right, neg_div]\n#align inner_product_geometry.angle_neg_right InnerProductGeometry.angle_neg_right\n\n\ntheorem angle_neg_left (x y : V) : angle (-x) y = \u03c0 - angle x y := by\n  rw [\u2190 angle_neg_neg, neg_neg, angle_neg_right]\n#align inner_product_geometry.angle_neg_left InnerProductGeometry.angle_neg_left\n\nproof_wanted angle_triangle (x y z : V) : angle x z \u2264 angle x y + angle y z\n\n\n@[simp]\ntheorem angle_zero_left (x : V) : angle 0 x = \u03c0 / 2 := by\n  unfold angle\n  rw [inner_zero_left, zero_div, Real.arccos_zero]\n#align inner_product_geometry.angle_zero_left InnerProductGeometry.angle_zero_left\n\n\n@[simp]\ntheorem angle_zero_right (x : V) : angle x 0 = \u03c0 / 2 := by\n  unfold angle\n  rw [inner_zero_right, zero_div, Real.arccos_zero]\n#align inner_product_geometry.angle_zero_right InnerProductGeometry.angle_zero_right\n\n\n@[simp]\ntheorem angle_self {x : V} (hx : x \u2260 0) : angle x x = 0 := by\n  unfold angle\n  rw [\u2190 real_inner_self_eq_norm_mul_norm, div_self (inner_self_ne_zero.2 hx : \u27eax, x\u27eb \u2260 0),\n    Real.arccos_one]\n#align inner_product_geometry.angle_self InnerProductGeometry.angle_self\n\n\n@[simp]\n"}
{"name": "\u03c3_comp_PInfty44", "split": "test", "formal_statement": "theorem \u03c3_comp_PInfty (X : SimplicialObject C) {n : \u2115} (i : Fin (n + 1)) :\n    X.\u03c3 i \u226b PInfty.f (n + 1) = 0 := by", "header": "\nimport Mathlib.AlgebraicTopology.DoldKan.Decomposition\nimport Mathlib.Tactic.FinCases\n\n#align_import algebraic_topology.dold_kan.degeneracies from \"leanprover-community/mathlib\"@\"32a7e535287f9c73f2e4d2aef306a39190f0b504\"\n\n\n\n\nopen CategoryTheory CategoryTheory.Category CategoryTheory.Limits\n  CategoryTheory.Preadditive Simplicial\n\nnamespace AlgebraicTopology\n\nnamespace DoldKan\n\nvariable {C : Type*} [Category C] [Preadditive C]\n\ntheorem HigherFacesVanish.comp_\u03c3 {Y : C} {X : SimplicialObject C} {n b q : \u2115} {\u03c6 : Y \u27f6 X _[n + 1]}\n    (v : HigherFacesVanish q \u03c6) (hnbq : n + 1 = b + q) :\n    HigherFacesVanish q\n      (\u03c6 \u226b\n        X.\u03c3 \u27e8b, by\n          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]\u27e9) :=\n  fun j hj => by\n  rw [assoc, SimplicialObject.\u03b4_comp_\u03c3_of_gt', Fin.pred_succ, v.comp_\u03b4_eq_zero_assoc _ _ hj,\n    zero_comp]\n  \u00b7 dsimp\n    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]\n    linarith\n  \u00b7 intro hj'\n    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,\n      nonpos_iff_eq_zero, add_eq_zero, false_and] at hj\n#align algebraic_topology.dold_kan.higher_faces_vanish.comp_\u03c3 AlgebraicTopology.DoldKan.HigherFacesVanish.comp_\u03c3\n\ntheorem \u03c3_comp_P_eq_zero (X : SimplicialObject C) {n q : \u2115} (i : Fin (n + 1)) (hi : n + 1 \u2264 i + q) :\n    X.\u03c3 i \u226b (P q).f (n + 1) = 0 := by\n  revert i hi\n  induction' q with q hq\n  \u00b7 intro i (hi : n + 1 \u2264 i)\n    exfalso\n    linarith [Fin.is_lt i]\n  \u00b7 intro i (hi : n + 1 \u2264 i + q + 1)\n    by_cases h : n + 1 \u2264 (i : \u2115) + q\n    \u00b7 rw [P_succ, HomologicalComplex.comp_f, \u2190 assoc, hq i h, zero_comp]\n    \u00b7 replace hi : n = i + q := by\n        obtain \u27e8j, hj\u27e9 := le_iff_exists_add.mp hi\n        rw [\u2190 Nat.lt_succ_iff, Nat.succ_eq_add_one, hj, not_lt, add_le_iff_nonpos_right,\n          nonpos_iff_eq_zero] at h\n        rw [\u2190 add_left_inj 1, hj, self_eq_add_right, h]\n      rcases n with _|n\n      \u00b7 fin_cases i\n        dsimp at h hi\n        rw [show q = 0 by omega]\n        change X.\u03c3 0 \u226b (P 1).f 1 = 0\n        simp only [P_succ, HomologicalComplex.add_f_apply, comp_add,\n          HomologicalComplex.id_f, AlternatingFaceMapComplex.obj_d_eq, H\u03c3,\n          HomologicalComplex.comp_f, Homotopy.nullHomotopicMap'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl),\n          comp_id]\n        erw [h\u03c3'_eq' (zero_add 0).symm, h\u03c3'_eq' (add_zero 1).symm, comp_id, Fin.sum_univ_two,\n          Fin.sum_univ_succ, Fin.sum_univ_two]\n        simp only [Fin.val_zero, pow_zero, pow_one, pow_add, one_smul, neg_smul, Fin.mk_one,\n          Fin.val_succ, Fin.val_one, Fin.succ_one_eq_two, P_zero, HomologicalComplex.id_f,\n          Fin.val_two, pow_two, mul_neg, one_mul, neg_mul, neg_neg, id_comp, add_comp,\n          comp_add, Fin.mk_zero, neg_comp, comp_neg, Fin.succ_zero_eq_one]\n        erw [SimplicialObject.\u03b4_comp_\u03c3_self, SimplicialObject.\u03b4_comp_\u03c3_self_assoc,\n          SimplicialObject.\u03b4_comp_\u03c3_succ, comp_id,\n          SimplicialObject.\u03b4_comp_\u03c3_of_le X\n            (show (0 : Fin 2) \u2264 Fin.castSucc 0 by rw [Fin.castSucc_zero]),\n          SimplicialObject.\u03b4_comp_\u03c3_self_assoc, SimplicialObject.\u03b4_comp_\u03c3_succ_assoc]\n        simp only [add_right_neg, add_zero, zero_add]\n      \u00b7 rw [\u2190 id_comp (X.\u03c3 i), \u2190 (P_add_Q_f q n.succ : _ = \ud835\udfd9 (X.obj _)), add_comp, add_comp,\n          P_succ]\n        have v : HigherFacesVanish q ((P q).f n.succ \u226b X.\u03c3 i) :=\n          (HigherFacesVanish.of_P q n).comp_\u03c3 hi\n        erw [\u2190 assoc, v.comp_P_eq_self, HomologicalComplex.add_f_apply, Preadditive.comp_add,\n          comp_id, v.comp_H\u03c3_eq hi, assoc, SimplicialObject.\u03b4_comp_\u03c3_succ_assoc, Fin.eta,\n          decomposition_Q n q, sum_comp, sum_comp, Finset.sum_eq_zero, add_zero, add_neg_eq_zero]\n        intro j hj\n        simp only [true_and_iff, Finset.mem_univ, Finset.mem_filter] at hj\n        simp only [Nat.succ_eq_add_one] at hi\n        obtain \u27e8k, hk\u27e9 := Nat.le.dest (Nat.lt_succ_iff.mp (Fin.is_lt j))\n        rw [add_comm] at hk\n        have hi' : i = Fin.castSucc \u27e8i, by omega\u27e9 := by\n          ext\n          simp only [Fin.castSucc_mk, Fin.eta]\n        have eq := hq j.rev.succ (by\n          simp only [\u2190 hk, Fin.rev_eq j hk.symm, Nat.succ_eq_add_one, Fin.succ_mk, Fin.val_mk]\n          omega)\n        rw [HomologicalComplex.comp_f, assoc, assoc, assoc, hi',\n          SimplicialObject.\u03c3_comp_\u03c3_assoc, reassoc_of% eq, zero_comp, comp_zero, comp_zero,\n          comp_zero]\n        simp only [Fin.rev_eq j hk.symm, Fin.le_iff_val_le_val, Fin.val_mk]\n        omega\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.dold_kan.\u03c3_comp_P_eq_zero AlgebraicTopology.DoldKan.\u03c3_comp_P_eq_zero\n\n@[reassoc (attr := simp)]\n"}
{"name": "invOf_two_add_invOf_two45", "split": "test", "formal_statement": "theorem invOf_two_add_invOf_two [NonAssocSemiring \u03b1] [Invertible (2 : \u03b1)] :\n    (\u215f 2 : \u03b1) + (\u215f 2 : \u03b1) = 1 := by", "header": "\nimport Mathlib.Algebra.GroupWithZero.Invertible\nimport Mathlib.Algebra.Ring.Defs\n\n#align_import algebra.invertible from \"leanprover-community/mathlib\"@\"722b3b152ddd5e0cf21c0a29787c76596cb6b422\"\n\n\nuniverse u\n\nvariable {\u03b1 : Type u}\n\n\ndef invertibleNeg [Mul \u03b1] [One \u03b1] [HasDistribNeg \u03b1] (a : \u03b1) [Invertible a] : Invertible (-a) :=\n  \u27e8-\u215f a, by simp, by simp\u27e9\n#align invertible_neg invertibleNeg\n\n@[simp]\ntheorem invOf_neg [Monoid \u03b1] [HasDistribNeg \u03b1] (a : \u03b1) [Invertible a] [Invertible (-a)] :\n    \u215f (-a) = -\u215f a :=\n  invOf_eq_right_inv (by simp)\n#align inv_of_neg invOf_neg\n\n@[simp]\ntheorem one_sub_invOf_two [Ring \u03b1] [Invertible (2 : \u03b1)] : 1 - (\u215f 2 : \u03b1) = \u215f 2 :=\n  (isUnit_of_invertible (2 : \u03b1)).mul_right_inj.1 <| by\n    rw [mul_sub, mul_invOf_self, mul_one, \u2190 one_add_one_eq_two, add_sub_cancel_right]\n#align one_sub_inv_of_two one_sub_invOf_two\n\n@[simp]\n"}
{"name": "bind\u2082_C_left46", "split": "test", "formal_statement": "theorem bind\u2082_C_left : bind\u2082 (C : R \u2192+* MvPolynomial \u03c3 R) = RingHom.id _ := by", "header": "\nimport Mathlib.Algebra.MvPolynomial.Rename\nimport Mathlib.Algebra.MvPolynomial.Variables\n\n#align_import data.mv_polynomial.monad from \"leanprover-community/mathlib\"@\"2f5b500a507264de86d666a5f87ddb976e2d8de4\"\n\n\n\n\nnoncomputable section\n\nnamespace MvPolynomial\n\nopen Finsupp\n\nvariable {\u03c3 : Type*} {\u03c4 : Type*}\nvariable {R S T : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring T]\n\n\ndef bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R :=\n  aeval f\n#align mv_polynomial.bind\u2081 MvPolynomial.bind\u2081\n\n\ndef bind\u2082 (f : R \u2192+* MvPolynomial \u03c3 S) : MvPolynomial \u03c3 R \u2192+* MvPolynomial \u03c3 S :=\n  eval\u2082Hom f X\n#align mv_polynomial.bind\u2082 MvPolynomial.bind\u2082\n\n\ndef join\u2081 : MvPolynomial (MvPolynomial \u03c3 R) R \u2192\u2090[R] MvPolynomial \u03c3 R :=\n  aeval id\n#align mv_polynomial.join\u2081 MvPolynomial.join\u2081\n\n\ndef join\u2082 : MvPolynomial \u03c3 (MvPolynomial \u03c3 R) \u2192+* MvPolynomial \u03c3 R :=\n  eval\u2082Hom (RingHom.id _) X\n#align mv_polynomial.join\u2082 MvPolynomial.join\u2082\n\n@[simp]\ntheorem aeval_eq_bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : aeval f = bind\u2081 f :=\n  rfl\n#align mv_polynomial.aeval_eq_bind\u2081 MvPolynomial.aeval_eq_bind\u2081\n\n@[simp]\ntheorem eval\u2082Hom_C_eq_bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : eval\u2082Hom C f = bind\u2081 f :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.eval\u2082_hom_C_eq_bind\u2081 MvPolynomial.eval\u2082Hom_C_eq_bind\u2081\n\n@[simp]\ntheorem eval\u2082Hom_eq_bind\u2082 (f : R \u2192+* MvPolynomial \u03c3 S) : eval\u2082Hom f X = bind\u2082 f :=\n  rfl\n#align mv_polynomial.eval\u2082_hom_eq_bind\u2082 MvPolynomial.eval\u2082Hom_eq_bind\u2082\n\nsection\n\nvariable (\u03c3 R)\n\n@[simp]\ntheorem aeval_id_eq_join\u2081 : aeval id = @join\u2081 \u03c3 R _ :=\n  rfl\n#align mv_polynomial.aeval_id_eq_join\u2081 MvPolynomial.aeval_id_eq_join\u2081\n\ntheorem eval\u2082Hom_C_id_eq_join\u2081 (\u03c6 : MvPolynomial (MvPolynomial \u03c3 R) R) :\n    eval\u2082Hom C id \u03c6 = join\u2081 \u03c6 :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.eval\u2082_hom_C_id_eq_join\u2081 MvPolynomial.eval\u2082Hom_C_id_eq_join\u2081\n\n@[simp]\ntheorem eval\u2082Hom_id_X_eq_join\u2082 : eval\u2082Hom (RingHom.id _) X = @join\u2082 \u03c3 R _ :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.eval\u2082_hom_id_X_eq_join\u2082 MvPolynomial.eval\u2082Hom_id_X_eq_join\u2082\n\nend\n\n-- In this file, we don't want to use these simp lemmas,\n-- because we first need to show how these new definitions interact\n-- and the proofs fall back on unfolding the definitions and call simp afterwards\nattribute [-simp]\n  aeval_eq_bind\u2081 eval\u2082Hom_C_eq_bind\u2081 eval\u2082Hom_eq_bind\u2082 aeval_id_eq_join\u2081 eval\u2082Hom_id_X_eq_join\u2082\n\n@[simp]\ntheorem bind\u2081_X_right (f : \u03c3 \u2192 MvPolynomial \u03c4 R) (i : \u03c3) : bind\u2081 f (X i) = f i :=\n  aeval_X f i\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2081_X_right MvPolynomial.bind\u2081_X_right\n\n@[simp]\ntheorem bind\u2082_X_right (f : R \u2192+* MvPolynomial \u03c3 S) (i : \u03c3) : bind\u2082 f (X i) = X i :=\n  eval\u2082Hom_X' f X i\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2082_X_right MvPolynomial.bind\u2082_X_right\n\n@[simp]\ntheorem bind\u2081_X_left : bind\u2081 (X : \u03c3 \u2192 MvPolynomial \u03c3 R) = AlgHom.id R _ := by\n  ext1 i\n  simp\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2081_X_left MvPolynomial.bind\u2081_X_left\n\nvariable (f : \u03c3 \u2192 MvPolynomial \u03c4 R)\n\ntheorem bind\u2081_C_right (f : \u03c3 \u2192 MvPolynomial \u03c4 R) (x) : bind\u2081 f (C x) = C x := algHom_C _ _\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2081_C_right MvPolynomial.bind\u2081_C_right\n\n@[simp]\ntheorem bind\u2082_C_right (f : R \u2192+* MvPolynomial \u03c3 S) (r : R) : bind\u2082 f (C r) = f r :=\n  eval\u2082Hom_C f X r\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2082_C_right MvPolynomial.bind\u2082_C_right\n\n@[simp]\n"}
{"name": "centralMoment_zero47", "split": "test", "formal_statement": "theorem centralMoment_zero (hp : p \u2260 0) : centralMoment 0 p \u03bc = 0 := by", "header": "\nimport Mathlib.Probability.Variance\n\n#align_import probability.moments from \"leanprover-community/mathlib\"@\"85453a2a14be8da64caf15ca50930cf4c6e5d8de\"\n\n\n\n\nopen MeasureTheory Filter Finset Real\n\nnoncomputable section\n\nopen scoped MeasureTheory ProbabilityTheory ENNReal NNReal\n\nnamespace ProbabilityTheory\n\nvariable {\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}\n\n\ndef moment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d :=\n  \u03bc[X ^ p]\n#align probability_theory.moment ProbabilityTheory.moment\n\n\ndef centralMoment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d := by\n  have m := fun (x : \u03a9) => \u03bc[X] -- Porting note: Lean deems `\u03bc[(X - fun x => \u03bc[X]) ^ p]` ambiguous\n  exact \u03bc[(X - m) ^ p]\n#align probability_theory.central_moment ProbabilityTheory.centralMoment\n\n@[simp]\ntheorem moment_zero (hp : p \u2260 0) : moment 0 p \u03bc = 0 := by\n  simp only [moment, hp, zero_pow, Ne, not_false_iff, Pi.zero_apply, integral_const,\n    smul_eq_mul, mul_zero, integral_zero]\n#align probability_theory.moment_zero ProbabilityTheory.moment_zero\n\n@[simp]\n"}
{"name": "exists_prime_and_dvd48", "split": "test", "formal_statement": "theorem exists_prime_and_dvd {n : \u2115+} (hn : n \u2260 1) : \u2203 p : \u2115+, p.Prime \u2227 p \u2223 n := by", "header": "\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.prime from \"leanprover-community/mathlib\"@\"09597669f02422ed388036273d8848119699c22f\"\n\n\n\n\nnamespace PNat\n\nopen Nat\n\n\ndef gcd (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.gcd (n : \u2115) (m : \u2115), Nat.gcd_pos_of_pos_left (m : \u2115) n.pos\u27e9\n#align pnat.gcd PNat.gcd\n\n\ndef lcm (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.lcm (n : \u2115) (m : \u2115), by\n    let h := mul_pos n.pos m.pos\n    rw [\u2190 gcd_mul_lcm (n : \u2115) (m : \u2115), mul_comm] at h\n    exact pos_of_dvd_of_pos (Dvd.intro (Nat.gcd (n : \u2115) (m : \u2115)) rfl) h\u27e9\n#align pnat.lcm PNat.lcm\n\n@[simp, norm_cast]\ntheorem gcd_coe (n m : \u2115+) : (gcd n m : \u2115) = Nat.gcd n m :=\n  rfl\n#align pnat.gcd_coe PNat.gcd_coe\n\n@[simp, norm_cast]\ntheorem lcm_coe (n m : \u2115+) : (lcm n m : \u2115) = Nat.lcm n m :=\n  rfl\n#align pnat.lcm_coe PNat.lcm_coe\n\ntheorem gcd_dvd_left (n m : \u2115+) : gcd n m \u2223 n :=\n  dvd_iff.2 (Nat.gcd_dvd_left (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_left PNat.gcd_dvd_left\n\ntheorem gcd_dvd_right (n m : \u2115+) : gcd n m \u2223 m :=\n  dvd_iff.2 (Nat.gcd_dvd_right (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_right PNat.gcd_dvd_right\n\ntheorem dvd_gcd {m n k : \u2115+} (hm : k \u2223 m) (hn : k \u2223 n) : k \u2223 gcd m n :=\n  dvd_iff.2 (Nat.dvd_gcd (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.dvd_gcd PNat.dvd_gcd\n\ntheorem dvd_lcm_left (n m : \u2115+) : n \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_left (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_left PNat.dvd_lcm_left\n\ntheorem dvd_lcm_right (n m : \u2115+) : m \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_right (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_right PNat.dvd_lcm_right\n\ntheorem lcm_dvd {m n k : \u2115+} (hm : m \u2223 k) (hn : n \u2223 k) : lcm m n \u2223 k :=\n  dvd_iff.2 (@Nat.lcm_dvd (m : \u2115) (n : \u2115) (k : \u2115) (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.lcm_dvd PNat.lcm_dvd\n\ntheorem gcd_mul_lcm (n m : \u2115+) : gcd n m * lcm n m = n * m :=\n  Subtype.eq (Nat.gcd_mul_lcm (n : \u2115) (m : \u2115))\n#align pnat.gcd_mul_lcm PNat.gcd_mul_lcm\n\ntheorem eq_one_of_lt_two {n : \u2115+} : n < 2 \u2192 n = 1 := by\n  intro h; apply le_antisymm; swap\n  \u00b7 apply PNat.one_le\n  \u00b7 exact PNat.lt_add_one_iff.1 h\n#align pnat.eq_one_of_lt_two PNat.eq_one_of_lt_two\n\nsection Prime\n\n\n\n\n\ndef Prime (p : \u2115+) : Prop :=\n  (p : \u2115).Prime\n#align pnat.prime PNat.Prime\n\ntheorem Prime.one_lt {p : \u2115+} : p.Prime \u2192 1 < p :=\n  Nat.Prime.one_lt\n#align pnat.prime.one_lt PNat.Prime.one_lt\n\ntheorem prime_two : (2 : \u2115+).Prime :=\n  Nat.prime_two\n#align pnat.prime_two PNat.prime_two\n\ninstance {p : \u2115+} [h : Fact p.Prime] : Fact (p : \u2115).Prime := h\n\ninstance fact_prime_two : Fact (2 : \u2115+).Prime :=\n  \u27e8prime_two\u27e9\n\ntheorem prime_three : (3 : \u2115+).Prime :=\n  Nat.prime_three\n\ninstance fact_prime_three : Fact (3 : \u2115+).Prime :=\n  \u27e8prime_three\u27e9\n\ntheorem prime_five : (5 : \u2115+).Prime :=\n  Nat.prime_five\n\ninstance fact_prime_five : Fact (5 : \u2115+).Prime :=\n  \u27e8prime_five\u27e9\n\ntheorem dvd_prime {p m : \u2115+} (pp : p.Prime) : m \u2223 p \u2194 m = 1 \u2228 m = p := by\n  rw [PNat.dvd_iff]\n  rw [Nat.dvd_prime pp]\n  simp\n#align pnat.dvd_prime PNat.dvd_prime\n\ntheorem Prime.ne_one {p : \u2115+} : p.Prime \u2192 p \u2260 1 := by\n  intro pp\n  intro contra\n  apply Nat.Prime.ne_one pp\n  rw [PNat.coe_eq_one_iff]\n  apply contra\n#align pnat.prime.ne_one PNat.Prime.ne_one\n\n@[simp]\ntheorem not_prime_one : \u00ac(1 : \u2115+).Prime :=\n  Nat.not_prime_one\n#align pnat.not_prime_one PNat.not_prime_one\n\ntheorem Prime.not_dvd_one {p : \u2115+} : p.Prime \u2192 \u00acp \u2223 1 := fun pp : p.Prime => by\n  rw [dvd_iff]\n  apply Nat.Prime.not_dvd_one pp\n#align pnat.prime.not_dvd_one PNat.Prime.not_dvd_one\n\n"}
{"name": "Matrix.toLin_transpose49", "split": "test", "formal_statement": "theorem Matrix.toLin_transpose (M : Matrix \u03b9\u2081 \u03b9\u2082 K) : Matrix.toLin B\u2081.dualBasis B\u2082.dualBasis M\u1d40 =\n    Module.Dual.transpose (R := K) (Matrix.toLin B\u2082 B\u2081 M) := by", "header": "\nimport Mathlib.LinearAlgebra.Dual\nimport Mathlib.LinearAlgebra.Matrix.ToLin\n\n#align_import linear_algebra.matrix.dual from \"leanprover-community/mathlib\"@\"738c19f572805cff525a93aa4ffbdf232df05aa8\"\n\n\n\n\nopen Matrix\n\nsection Transpose\n\nvariable {K V\u2081 V\u2082 \u03b9\u2081 \u03b9\u2082 : Type*} [Field K] [AddCommGroup V\u2081] [Module K V\u2081] [AddCommGroup V\u2082]\n  [Module K V\u2082] [Fintype \u03b9\u2081] [Fintype \u03b9\u2082] [DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082] {B\u2081 : Basis \u03b9\u2081 K V\u2081}\n  {B\u2082 : Basis \u03b9\u2082 K V\u2082}\n\n@[simp]\ntheorem LinearMap.toMatrix_transpose (u : V\u2081 \u2192\u2097[K] V\u2082) :\n    LinearMap.toMatrix B\u2082.dualBasis B\u2081.dualBasis (Module.Dual.transpose (R := K) u) =\n      (LinearMap.toMatrix B\u2081 B\u2082 u)\u1d40 := by\n  ext i j\n  simp only [LinearMap.toMatrix_apply, Module.Dual.transpose_apply, B\u2081.dualBasis_repr,\n    B\u2082.dualBasis_apply, Matrix.transpose_apply, LinearMap.comp_apply]\n#align linear_map.to_matrix_transpose LinearMap.toMatrix_transpose\n\n@[simp]\n"}
{"name": "map_fundamentalDomain50", "split": "test", "formal_statement": "theorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by", "header": "\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n\n\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\ntheorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by simp [span_span_of_tower]\n\n\ndef fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}\n#align zspan.fundamental_domain Zspan.fundamentalDomain\n\n@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1 := Iff.rfl\n#align zspan.mem_fundamental_domain Zspan.mem_fundamentalDomain\n\n"}
{"name": "unit_inverse_comp51", "split": "test", "formal_statement": "theorem unit_inverse_comp (e : C \u224c D) (Y : D) :\n    e.unit.app (e.inverse.obj Y) \u226b e.inverse.map (e.counit.app Y) = \ud835\udfd9 (e.inverse.obj Y) := by", "header": "\nimport Mathlib.CategoryTheory.Functor.FullyFaithful\nimport Mathlib.CategoryTheory.FullSubcategory\nimport Mathlib.CategoryTheory.Whiskering\nimport Mathlib.CategoryTheory.EssentialImage\nimport Mathlib.Tactic.CategoryTheory.Slice\n\n#align_import category_theory.equivalence from \"leanprover-community/mathlib\"@\"9aba7801eeecebb61f58a5763c2b6dd1b47dc6ef\"\n\n\nnamespace CategoryTheory\n\nopen CategoryTheory.Functor NatIso Category\n\n-- declare the `v`'s first; see `CategoryTheory.Category` for an explanation\nuniverse v\u2081 v\u2082 v\u2083 u\u2081 u\u2082 u\u2083\n\n\n@[ext]\nstructure Equivalence (C : Type u\u2081) (D : Type u\u2082) [Category.{v\u2081} C] [Category.{v\u2082} D] where mk' ::\n  \n  functor : C \u2964 D\n  \n  inverse : D \u2964 C\n  \n  unitIso : \ud835\udfed C \u2245 functor \u22d9 inverse\n  \n  counitIso : inverse \u22d9 functor \u2245 \ud835\udfed D\n  \n  functor_unitIso_comp :\n    \u2200 X : C, functor.map (unitIso.hom.app X) \u226b counitIso.hom.app (functor.obj X) =\n      \ud835\udfd9 (functor.obj X) := by aesop_cat\n#align category_theory.equivalence CategoryTheory.Equivalence\n#align category_theory.equivalence.unit_iso CategoryTheory.Equivalence.unitIso\n#align category_theory.equivalence.counit_iso CategoryTheory.Equivalence.counitIso\n#align category_theory.equivalence.functor_unit_iso_comp CategoryTheory.Equivalence.functor_unitIso_comp\n\n\ninfixr:10 \" \u224c \" => Equivalence\n\nvariable {C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]\n\nnamespace Equivalence\n\n\nabbrev unit (e : C \u224c D) : \ud835\udfed C \u27f6 e.functor \u22d9 e.inverse :=\n  e.unitIso.hom\n#align category_theory.equivalence.unit CategoryTheory.Equivalence.unit\n\n\nabbrev counit (e : C \u224c D) : e.inverse \u22d9 e.functor \u27f6 \ud835\udfed D :=\n  e.counitIso.hom\n#align category_theory.equivalence.counit CategoryTheory.Equivalence.counit\n\n\nabbrev unitInv (e : C \u224c D) : e.functor \u22d9 e.inverse \u27f6 \ud835\udfed C :=\n  e.unitIso.inv\n#align category_theory.equivalence.unit_inv CategoryTheory.Equivalence.unitInv\n\n\nabbrev counitInv (e : C \u224c D) : \ud835\udfed D \u27f6 e.inverse \u22d9 e.functor :=\n  e.counitIso.inv\n#align category_theory.equivalence.counit_inv CategoryTheory.Equivalence.counitInv\n\n\n@[simp]\ntheorem Equivalence_mk'_unit (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).unit = unit_iso.hom :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_unit CategoryTheory.Equivalence.Equivalence_mk'_unit\n\n@[simp]\ntheorem Equivalence_mk'_counit (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).counit = counit_iso.hom :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_counit CategoryTheory.Equivalence.Equivalence_mk'_counit\n\n@[simp]\ntheorem Equivalence_mk'_unitInv (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).unitInv = unit_iso.inv :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_unit_inv CategoryTheory.Equivalence.Equivalence_mk'_unitInv\n\n@[simp]\ntheorem Equivalence_mk'_counitInv (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).counitInv = counit_iso.inv :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_counit_inv CategoryTheory.Equivalence.Equivalence_mk'_counitInv\n\n@[reassoc (attr := simp)]\ntheorem functor_unit_comp (e : C \u224c D) (X : C) :\n    e.functor.map (e.unit.app X) \u226b e.counit.app (e.functor.obj X) = \ud835\udfd9 (e.functor.obj X) :=\n  e.functor_unitIso_comp X\n#align category_theory.equivalence.functor_unit_comp CategoryTheory.Equivalence.functor_unit_comp\n\n@[reassoc (attr := simp)]\ntheorem counitInv_functor_comp (e : C \u224c D) (X : C) :\n    e.counitInv.app (e.functor.obj X) \u226b e.functor.map (e.unitInv.app X) = \ud835\udfd9 (e.functor.obj X) := by\n  erw [Iso.inv_eq_inv (e.functor.mapIso (e.unitIso.app X) \u226a\u226b e.counitIso.app (e.functor.obj X))\n      (Iso.refl _)]\n  exact e.functor_unit_comp X\n#align category_theory.equivalence.counit_inv_functor_comp CategoryTheory.Equivalence.counitInv_functor_comp\n\ntheorem counitInv_app_functor (e : C \u224c D) (X : C) :\n    e.counitInv.app (e.functor.obj X) = e.functor.map (e.unit.app X) := by\n  symm\n  erw [\u2190 Iso.comp_hom_eq_id (e.counitIso.app _), functor_unit_comp]\n  rfl\n#align category_theory.equivalence.counit_inv_app_functor CategoryTheory.Equivalence.counitInv_app_functor\n\ntheorem counit_app_functor (e : C \u224c D) (X : C) :\n    e.counit.app (e.functor.obj X) = e.functor.map (e.unitInv.app X) := by\n  erw [\u2190 Iso.hom_comp_eq_id (e.functor.mapIso (e.unitIso.app X)), functor_unit_comp]\n  rfl\n#align category_theory.equivalence.counit_app_functor CategoryTheory.Equivalence.counit_app_functor\n\n\n@[reassoc (attr := simp)]\n"}
{"name": "Bornology.IsBounded.mul52", "split": "test", "formal_statement": "theorem Bornology.IsBounded.mul (hs : IsBounded s) (ht : IsBounded t) : IsBounded (s * t) := by", "header": "\nimport Mathlib.Analysis.Normed.Group.Basic\nimport Mathlib.Topology.MetricSpace.Thickening\nimport Mathlib.Topology.MetricSpace.IsometricSMul\n\n#align_import analysis.normed.group.pointwise from \"leanprover-community/mathlib\"@\"c8f305514e0d47dfaa710f5a52f0d21b588e6328\"\n\n\n\n\nopen Metric Set Pointwise Topology\n\nvariable {E : Type*}\n\nsection SeminormedGroup\n\nvariable [SeminormedGroup E] {\u03b5 \u03b4 : \u211d} {s t : Set E} {x y : E}\n\n-- note: we can't use `LipschitzOnWith.isBounded_image2` here without adding `[IsometricSMul E E]`\n@[to_additive]\n"}
{"name": "closure_neg53", "split": "test", "formal_statement": "theorem closure_neg (s : Set M) : span R (-s) = -span R s := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Pointwise\nimport Mathlib.Algebra.Module.BigOperators\nimport Mathlib.Algebra.Order.Group.Action\nimport Mathlib.LinearAlgebra.Finsupp\nimport Mathlib.LinearAlgebra.Span\nimport Mathlib.RingTheory.Ideal.Basic\n\n#align_import algebra.module.submodule.pointwise from \"leanprover-community/mathlib\"@\"48085f140e684306f9e7da907cd5932056d1aded\"\n\n\n\n\nvariable {\u03b1 : Type*} {R : Type*} {M : Type*}\n\nopen Pointwise\n\nnamespace Submodule\n\nsection Neg\n\nsection Semiring\n\nvariable [Semiring R] [AddCommGroup M] [Module R M]\n\n\nprotected def pointwiseNeg : Neg (Submodule R M) where\n  neg p :=\n    { -p.toAddSubmonoid with\n      smul_mem' := fun r m hm => Set.mem_neg.2 <| smul_neg r m \u25b8 p.smul_mem r <| Set.mem_neg.1 hm }\n#align submodule.has_pointwise_neg Submodule.pointwiseNeg\n\nscoped[Pointwise] attribute [instance] Submodule.pointwiseNeg\n\nopen Pointwise\n\n@[simp]\ntheorem coe_set_neg (S : Submodule R M) : \u2191(-S) = -(S : Set M) :=\n  rfl\n#align submodule.coe_set_neg Submodule.coe_set_neg\n\n@[simp]\ntheorem neg_toAddSubmonoid (S : Submodule R M) : (-S).toAddSubmonoid = -S.toAddSubmonoid :=\n  rfl\n#align submodule.neg_to_add_submonoid Submodule.neg_toAddSubmonoid\n\n@[simp]\ntheorem mem_neg {g : M} {S : Submodule R M} : g \u2208 -S \u2194 -g \u2208 S :=\n  Iff.rfl\n#align submodule.mem_neg Submodule.mem_neg\n\n\nprotected def involutivePointwiseNeg : InvolutiveNeg (Submodule R M) where\n  neg := Neg.neg\n  neg_neg _S := SetLike.coe_injective <| neg_neg _\n#align submodule.has_involutive_pointwise_neg Submodule.involutivePointwiseNeg\n\nscoped[Pointwise] attribute [instance] Submodule.involutivePointwiseNeg\n\n@[simp]\ntheorem neg_le_neg (S T : Submodule R M) : -S \u2264 -T \u2194 S \u2264 T :=\n  SetLike.coe_subset_coe.symm.trans Set.neg_subset_neg\n#align submodule.neg_le_neg Submodule.neg_le_neg\n\ntheorem neg_le (S T : Submodule R M) : -S \u2264 T \u2194 S \u2264 -T :=\n  SetLike.coe_subset_coe.symm.trans Set.neg_subset\n#align submodule.neg_le Submodule.neg_le\n\n\ndef negOrderIso : Submodule R M \u2243o Submodule R M where\n  toEquiv := Equiv.neg _\n  map_rel_iff' := @neg_le_neg _ _ _ _ _\n#align submodule.neg_order_iso Submodule.negOrderIso\n\n"}
{"name": "mulIndicator_eq_one54", "split": "test", "formal_statement": "theorem mulIndicator_eq_one : (mulIndicator s f = fun x => 1) \u2194 Disjoint (mulSupport f) s := by", "header": "\nimport Mathlib.Algebra.Group.Pi.Lemmas\nimport Mathlib.Algebra.Group.Support\n\n#align_import algebra.indicator_function from \"leanprover-community/mathlib\"@\"2445c98ae4b87eabebdde552593519b9b6dc350c\"\n\n\n\nassert_not_exists MonoidWithZero\n\nopen Function\n\nvariable {\u03b1 \u03b2 \u03b9 M N : Type*}\n\nnamespace Set\n\nsection One\n\nvariable [One M] [One N] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1}\n\n\n@[to_additive \"`Set.indicator s f a` is `f a` if `a \u2208 s`, `0` otherwise.\"]\nnoncomputable def mulIndicator (s : Set \u03b1) (f : \u03b1 \u2192 M) (x : \u03b1) : M :=\n  haveI := Classical.decPred (\u00b7 \u2208 s)\n  if x \u2208 s then f x else 1\n#align set.mul_indicator Set.mulIndicator\n\n@[to_additive (attr := simp)]\ntheorem piecewise_eq_mulIndicator [DecidablePred (\u00b7 \u2208 s)] : s.piecewise f 1 = s.mulIndicator f :=\n  funext fun _ => @if_congr _ _ _ _ (id _) _ _ _ _ Iff.rfl rfl rfl\n#align set.piecewise_eq_mul_indicator Set.piecewise_eq_mulIndicator\n#align set.piecewise_eq_indicator Set.piecewise_eq_indicator\n\n-- Porting note: needed unfold for mulIndicator\n@[to_additive]\ntheorem mulIndicator_apply (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) [Decidable (a \u2208 s)] :\n    mulIndicator s f a = if a \u2208 s then f a else 1 := by\n  unfold mulIndicator\n  congr\n#align set.mul_indicator_apply Set.mulIndicator_apply\n#align set.indicator_apply Set.indicator_apply\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_of_mem (h : a \u2208 s) (f : \u03b1 \u2192 M) : mulIndicator s f a = f a :=\n  if_pos h\n#align set.mul_indicator_of_mem Set.mulIndicator_of_mem\n#align set.indicator_of_mem Set.indicator_of_mem\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_of_not_mem (h : a \u2209 s) (f : \u03b1 \u2192 M) : mulIndicator s f a = 1 :=\n  if_neg h\n#align set.mul_indicator_of_not_mem Set.mulIndicator_of_not_mem\n#align set.indicator_of_not_mem Set.indicator_of_not_mem\n\n@[to_additive]\ntheorem mulIndicator_eq_one_or_self (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a := by\n  by_cases h : a \u2208 s\n  \u00b7 exact Or.inr (mulIndicator_of_mem h f)\n  \u00b7 exact Or.inl (mulIndicator_of_not_mem h f)\n#align set.mul_indicator_eq_one_or_self Set.mulIndicator_eq_one_or_self\n#align set.indicator_eq_zero_or_self Set.indicator_eq_zero_or_self\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_self : s.mulIndicator f a = f a \u2194 a \u2209 s \u2192 f a = 1 :=\n  letI := Classical.dec (a \u2208 s)\n  ite_eq_left_iff.trans (by rw [@eq_comm _ (f a)])\n#align set.mul_indicator_apply_eq_self Set.mulIndicator_apply_eq_self\n#align set.indicator_apply_eq_self Set.indicator_apply_eq_self\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_self : s.mulIndicator f = f \u2194 mulSupport f \u2286 s := by\n  simp only [funext_iff, subset_def, mem_mulSupport, mulIndicator_apply_eq_self, not_imp_comm]\n#align set.mul_indicator_eq_self Set.mulIndicator_eq_self\n#align set.indicator_eq_self Set.indicator_eq_self\n\n@[to_additive]\ntheorem mulIndicator_eq_self_of_superset (h1 : s.mulIndicator f = f) (h2 : s \u2286 t) :\n    t.mulIndicator f = f := by\n  rw [mulIndicator_eq_self] at h1 \u22a2\n  exact Subset.trans h1 h2\n#align set.mul_indicator_eq_self_of_superset Set.mulIndicator_eq_self_of_superset\n#align set.indicator_eq_self_of_superset Set.indicator_eq_self_of_superset\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_one : mulIndicator s f a = 1 \u2194 a \u2208 s \u2192 f a = 1 :=\n  letI := Classical.dec (a \u2208 s)\n  ite_eq_right_iff\n#align set.mul_indicator_apply_eq_one Set.mulIndicator_apply_eq_one\n#align set.indicator_apply_eq_zero Set.indicator_apply_eq_zero\n\n@[to_additive (attr := simp)]\n"}
{"name": "star_algebraMap55", "split": "test", "formal_statement": "theorem star_algebraMap (r : R) : star (algebraMap R (FreeAlgebra R X) r) = algebraMap R _ r := by", "header": "\nimport Mathlib.Algebra.Star.Basic\nimport Mathlib.Algebra.FreeAlgebra\n\n#align_import algebra.star.free from \"leanprover-community/mathlib\"@\"07c3cf2d851866ff7198219ed3fedf42e901f25c\"\n\n\n\n\nnamespace FreeAlgebra\n\nvariable {R : Type*} [CommSemiring R] {X : Type*}\n\n\ninstance : StarRing (FreeAlgebra R X) where\n  star := MulOpposite.unop \u2218 lift R (MulOpposite.op \u2218 \u03b9 R)\n  star_involutive x := by\n    unfold Star.star\n    simp only [Function.comp_apply]\n    let y := lift R (X := X) (MulOpposite.op \u2218 \u03b9 R)\n    apply induction (C := fun x \u21a6 (y (y x).unop).unop = x) _ _ _ _ x\n    \u00b7 intros\n      simp only [AlgHom.commutes, MulOpposite.algebraMap_apply, MulOpposite.unop_op]\n    \u00b7 intros\n      simp only [y, lift_\u03b9_apply, Function.comp_apply, MulOpposite.unop_op]\n    \u00b7 intros\n      simp only [*, map_mul, MulOpposite.unop_mul]\n    \u00b7 intros\n      simp only [*, map_add, MulOpposite.unop_add]\n  star_mul a b := by simp only [Function.comp_apply, map_mul, MulOpposite.unop_mul]\n  star_add a b := by simp only [Function.comp_apply, map_add, MulOpposite.unop_add]\n\n@[simp]\ntheorem star_\u03b9 (x : X) : star (\u03b9 R x) = \u03b9 R x := by simp [star, Star.star]\n#align free_algebra.star_\u03b9 FreeAlgebra.star_\u03b9\n\n@[simp]\n"}
{"name": "exists_separating_of_ne56", "split": "test", "formal_statement": "theorem exists_separating_of_ne {x y : V} (h : x \u2260 y) :\n    \u2203 f : V \u2192L[R] R, f x \u2260 f y := by", "header": "\nimport Mathlib.Analysis.NormedSpace.HahnBanach.Extension\nimport Mathlib.Analysis.NormedSpace.HahnBanach.Separation\nimport Mathlib.LinearAlgebra.Dual\nimport Mathlib.Analysis.NormedSpace.BoundedLinearMaps\n\n\n\n\n@[mk_iff separatingDual_def]\nclass SeparatingDual (R V : Type*) [Ring R] [AddCommGroup V] [TopologicalSpace V]\n    [TopologicalSpace R] [Module R V] : Prop :=\n  \n  exists_ne_zero' : \u2200 (x : V), x \u2260 0 \u2192 \u2203 f : V \u2192L[R] R, f x \u2260 0\n\ninstance {E : Type*} [TopologicalSpace E] [AddCommGroup E] [TopologicalAddGroup E]\n    [Module \u211d E] [ContinuousSMul \u211d E] [LocallyConvexSpace \u211d E] [T1Space E] : SeparatingDual \u211d E :=\n  \u27e8fun x hx \u21a6 by\n    rcases geometric_hahn_banach_point_point hx.symm with \u27e8f, hf\u27e9\n    simp only [map_zero] at hf\n    exact \u27e8f, hf.ne'\u27e9\u27e9\n\ninstance {E \ud835\udd5c : Type*} [RCLike \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] : SeparatingDual \ud835\udd5c E :=\n  \u27e8fun x hx \u21a6 by\n    rcases exists_dual_vector \ud835\udd5c x hx with \u27e8f, -, hf\u27e9\n    refine \u27e8f, ?_\u27e9\n    simpa [hf] using hx\u27e9\n\nnamespace SeparatingDual\n\nsection Ring\n\nvariable {R V : Type*} [Ring R] [AddCommGroup V] [TopologicalSpace V]\n  [TopologicalSpace R] [Module R V] [SeparatingDual R V]\n\nlemma exists_ne_zero {x : V} (hx : x \u2260 0) :\n    \u2203 f : V \u2192L[R] R, f x \u2260 0 :=\n  exists_ne_zero' x hx\n\n"}
{"name": "Submodule.closure_subset_topologicalClosure_span57", "split": "test", "formal_statement": "theorem Submodule.closure_subset_topologicalClosure_span (s : Set M) :\n    closure s \u2286 (span R s).topologicalClosure := by", "header": "\nimport Mathlib.Topology.Algebra.Ring.Basic\nimport Mathlib.Topology.Algebra.MulAction\nimport Mathlib.Topology.Algebra.UniformGroup\nimport Mathlib.Topology.ContinuousFunction.Basic\nimport Mathlib.Topology.UniformSpace.UniformEmbedding\nimport Mathlib.Algebra.Algebra.Defs\nimport Mathlib.LinearAlgebra.Projection\nimport Mathlib.LinearAlgebra.Pi\nimport Mathlib.LinearAlgebra.Finsupp\n\n#align_import topology.algebra.module.basic from \"leanprover-community/mathlib\"@\"6285167a053ad0990fc88e56c48ccd9fae6550eb\"\n\n\n\nopen LinearMap (ker range)\nopen Topology Filter Pointwise\n\nuniverse u v w u'\n\nsection\n\nvariable {R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]\n  [AddCommGroup M] [Module R M]\n\ntheorem ContinuousSMul.of_nhds_zero [TopologicalRing R] [TopologicalAddGroup M]\n    (hmul : Tendsto (fun p : R \u00d7 M => p.1 \u2022 p.2) (\ud835\udcdd 0 \u00d7\u02e2 \ud835\udcdd 0) (\ud835\udcdd 0))\n    (hmulleft : \u2200 m : M, Tendsto (fun a : R => a \u2022 m) (\ud835\udcdd 0) (\ud835\udcdd 0))\n    (hmulright : \u2200 a : R, Tendsto (fun m : M => a \u2022 m) (\ud835\udcdd 0) (\ud835\udcdd 0)) : ContinuousSMul R M where\n  continuous_smul := by\n    refine continuous_of_continuousAt_zero\u2082 (AddMonoidHom.smul : R \u2192+ M \u2192+ M) ?_ ?_ ?_ <;>\n      simpa [ContinuousAt, nhds_prod_eq]\n#align has_continuous_smul.of_nhds_zero ContinuousSMul.of_nhds_zero\n\nend\n\nsection\n\nvariable {R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]\n  [AddCommGroup M] [ContinuousAdd M] [Module R M] [ContinuousSMul R M]\n\n\ntheorem Submodule.eq_top_of_nonempty_interior' [NeBot (\ud835\udcdd[{ x : R | IsUnit x }] 0)]\n    (s : Submodule R M) (hs : (interior (s : Set M)).Nonempty) : s = \u22a4 := by\n  rcases hs with \u27e8y, hy\u27e9\n  refine Submodule.eq_top_iff'.2 fun x => ?_\n  rw [mem_interior_iff_mem_nhds] at hy\n  have : Tendsto (fun c : R => y + c \u2022 x) (\ud835\udcdd[{ x : R | IsUnit x }] 0) (\ud835\udcdd (y + (0 : R) \u2022 x)) :=\n    tendsto_const_nhds.add ((tendsto_nhdsWithin_of_tendsto_nhds tendsto_id).smul tendsto_const_nhds)\n  rw [zero_smul, add_zero] at this\n  obtain \u27e8_, hu : y + _ \u2022 _ \u2208 s, u, rfl\u27e9 :=\n    nonempty_of_mem (inter_mem (Filter.mem_map.1 (this hy)) self_mem_nhdsWithin)\n  have hy' : y \u2208 \u2191s := mem_of_mem_nhds hy\n  rwa [s.add_mem_iff_right hy', \u2190 Units.smul_def, s.smul_mem_iff' u] at hu\n#align submodule.eq_top_of_nonempty_interior' Submodule.eq_top_of_nonempty_interior'\n\nvariable (R M)\n\n\ntheorem Module.punctured_nhds_neBot [Nontrivial M] [NeBot (\ud835\udcdd[\u2260] (0 : R))] [NoZeroSMulDivisors R M]\n    (x : M) : NeBot (\ud835\udcdd[\u2260] x) := by\n  rcases exists_ne (0 : M) with \u27e8y, hy\u27e9\n  suffices Tendsto (fun c : R => x + c \u2022 y) (\ud835\udcdd[\u2260] 0) (\ud835\udcdd[\u2260] x) from this.neBot\n  refine Tendsto.inf ?_ (tendsto_principal_principal.2 <| ?_)\n  \u00b7 convert tendsto_const_nhds.add ((@tendsto_id R _).smul_const y)\n    rw [zero_smul, add_zero]\n  \u00b7 intro c hc\n    simpa [hy] using hc\n#align module.punctured_nhds_ne_bot Module.punctured_nhds_neBot\n\nend\n\n\nlemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]\n    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]\n    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :\n    IsSeparable (Submodule.span R s : Set M) := by\n  rw [span_eq_iUnion_nat]\n  refine .iUnion fun n \u21a6 .image ?_ ?_\n  \u00b7 have : IsSeparable {f : Fin n \u2192 R \u00d7 M | \u2200 (i : Fin n), f i \u2208 Set.univ \u00d7\u02e2 s} := by\n      apply isSeparable_pi (fun i \u21a6 .prod (.of_separableSpace Set.univ) hs)\n    rwa [Set.univ_prod] at this\n  \u00b7 apply continuous_finset_sum _ (fun i _ \u21a6 ?_)\n    exact (continuous_fst.comp (continuous_apply i)).smul (continuous_snd.comp (continuous_apply i))\n\nsection closure\n\nvariable {R R' : Type u} {M M' : Type v} [Semiring R] [Ring R']\n  [TopologicalSpace M] [AddCommMonoid M] [TopologicalSpace M'] [AddCommGroup M'] [Module R M]\n  [ContinuousConstSMul R M] [Module R' M'] [ContinuousConstSMul R' M']\n\ntheorem Submodule.mapsTo_smul_closure (s : Submodule R M) (c : R) :\n    Set.MapsTo (c \u2022 \u00b7) (closure s : Set M) (closure s) :=\n  have : Set.MapsTo (c \u2022 \u00b7) (s : Set M) s := fun _ h \u21a6 s.smul_mem c h\n  this.closure (continuous_const_smul c)\n\ntheorem Submodule.smul_closure_subset (s : Submodule R M) (c : R) :\n    c \u2022 closure (s : Set M) \u2286 closure (s : Set M) :=\n  (s.mapsTo_smul_closure c).image_subset\n\nvariable [ContinuousAdd M]\n\n\ndef Submodule.topologicalClosure (s : Submodule R M) : Submodule R M :=\n  { s.toAddSubmonoid.topologicalClosure with\n    smul_mem' := s.mapsTo_smul_closure }\n#align submodule.topological_closure Submodule.topologicalClosure\n\n@[simp]\ntheorem Submodule.topologicalClosure_coe (s : Submodule R M) :\n    (s.topologicalClosure : Set M) = closure (s : Set M) :=\n  rfl\n#align submodule.topological_closure_coe Submodule.topologicalClosure_coe\n\ntheorem Submodule.le_topologicalClosure (s : Submodule R M) : s \u2264 s.topologicalClosure :=\n  subset_closure\n#align submodule.le_topological_closure Submodule.le_topologicalClosure\n\n"}
{"name": "lpMeas.ae_eq_zero_of_forall_setIntegral_eq_zero58", "split": "test", "formal_statement": "theorem lpMeas.ae_eq_zero_of_forall_setIntegral_eq_zero (hm : m \u2264 m0) (f : lpMeas E' \ud835\udd5c m p \u03bc)\n    (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e)\n    -- Porting note: needed to add explicit casts in the next two hypotheses\n    (hf_int_finite : \u2200 s, MeasurableSet[m] s \u2192 \u03bc s < \u221e \u2192 IntegrableOn (f : Lp E' p \u03bc) s \u03bc)\n    (hf_zero : \u2200 s : Set \u03b1, MeasurableSet[m] s \u2192 \u03bc s < \u221e \u2192 \u222b x in s, (f : Lp E' p \u03bc) x \u2202\u03bc = 0) :\n    f =\u1d50[\u03bc] (0 : \u03b1 \u2192 E') := by", "header": "\nimport Mathlib.MeasureTheory.Function.AEEqOfIntegral\nimport Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable\n\n#align_import measure_theory.function.conditional_expectation.unique from \"leanprover-community/mathlib\"@\"d8bbb04e2d2a44596798a9207ceefc0fb236e41e\"\n\n\n\nset_option linter.uppercaseLean3 false\n\nopen scoped ENNReal MeasureTheory\n\nnamespace MeasureTheory\n\nvariable {\u03b1 E' F' \ud835\udd5c : Type*} {p : \u211d\u22650\u221e} {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [RCLike \ud835\udd5c]\n  -- \ud835\udd5c for \u211d or \u2102\n  -- E' for an inner product space on which we compute integrals\n  [NormedAddCommGroup E']\n  [InnerProductSpace \ud835\udd5c E'] [CompleteSpace E'] [NormedSpace \u211d E']\n  -- F' for integrals on a Lp submodule\n  [NormedAddCommGroup F']\n  [NormedSpace \ud835\udd5c F'] [NormedSpace \u211d F'] [CompleteSpace F']\n\nsection UniquenessOfConditionalExpectation\n\n\n\n"}
{"name": "stoppedValue_ae_eq_condexp_of_le_const_of_countable_range59", "split": "test", "formal_statement": "theorem stoppedValue_ae_eq_condexp_of_le_const_of_countable_range (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n) (h_countable_range : (Set.range \u03c4).Countable)\n    [SigmaFinite (\u03bc.trim (h\u03c4.measurableSpace_le_of_le h\u03c4_le))] :\n    stoppedValue f \u03c4 =\u1d50[\u03bc] \u03bc[f n|h\u03c4.measurableSpace] := by", "header": "\nimport Mathlib.Order.SuccPred.LinearLocallyFinite\nimport Mathlib.Probability.Martingale.Basic\n\n#align_import probability.martingale.optional_sampling from \"leanprover-community/mathlib\"@\"ba074af83b6cf54c3104e59402b39410ddbd6dca\"\n\n\n\n\nopen scoped MeasureTheory ENNReal\n\nopen TopologicalSpace\n\nnamespace MeasureTheory\n\nnamespace Martingale\n\nvariable {\u03a9 E : Type*} {m : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} [NormedAddCommGroup E]\n  [NormedSpace \u211d E] [CompleteSpace E]\n\nsection FirstCountableTopology\n\nvariable {\u03b9 : Type*} [LinearOrder \u03b9] [TopologicalSpace \u03b9] [OrderTopology \u03b9]\n  [FirstCountableTopology \u03b9] {\u2131 : Filtration \u03b9 m} [SigmaFiniteFiltration \u03bc \u2131] {\u03c4 \u03c3 : \u03a9 \u2192 \u03b9}\n  {f : \u03b9 \u2192 \u03a9 \u2192 E} {i n : \u03b9}\n\ntheorem condexp_stopping_time_ae_eq_restrict_eq_const\n    [(Filter.atTop : Filter \u03b9).IsCountablyGenerated] (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) [SigmaFinite (\u03bc.trim h\u03c4.measurableSpace_le)] (hin : i \u2264 n) :\n    \u03bc[f n|h\u03c4.measurableSpace] =\u1d50[\u03bc.restrict {x | \u03c4 x = i}] f i := by\n  refine Filter.EventuallyEq.trans ?_ (ae_restrict_of_ae (h.condexp_ae_eq hin))\n  refine condexp_ae_eq_restrict_of_measurableSpace_eq_on h\u03c4.measurableSpace_le (\u2131.le i)\n    (h\u03c4.measurableSet_eq' i) fun t => ?_\n  rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_eq_iff]\n#align measure_theory.martingale.condexp_stopping_time_ae_eq_restrict_eq_const MeasureTheory.Martingale.condexp_stopping_time_ae_eq_restrict_eq_const\n\ntheorem condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n)\n    [SigmaFinite (\u03bc.trim (h\u03c4.measurableSpace_le_of_le h\u03c4_le))] (i : \u03b9) :\n    \u03bc[f n|h\u03c4.measurableSpace] =\u1d50[\u03bc.restrict {x | \u03c4 x = i}] f i := by\n  by_cases hin : i \u2264 n\n  \u00b7 refine Filter.EventuallyEq.trans ?_ (ae_restrict_of_ae (h.condexp_ae_eq hin))\n    refine condexp_ae_eq_restrict_of_measurableSpace_eq_on (h\u03c4.measurableSpace_le_of_le h\u03c4_le)\n      (\u2131.le i) (h\u03c4.measurableSet_eq' i) fun t => ?_\n    rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_eq_iff]\n  \u00b7 suffices {x : \u03a9 | \u03c4 x = i} = \u2205 by simp [this]; norm_cast\n    ext1 x\n    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]\n    rintro rfl\n    exact hin (h\u03c4_le x)\n#align measure_theory.martingale.condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const MeasureTheory.Martingale.condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const\n\ntheorem stoppedValue_ae_eq_restrict_eq (h : Martingale f \u2131 \u03bc) (h\u03c4 : IsStoppingTime \u2131 \u03c4)\n    (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n) [SigmaFinite (\u03bc.trim (h\u03c4.measurableSpace_le_of_le h\u03c4_le))] (i : \u03b9) :\n    stoppedValue f \u03c4 =\u1d50[\u03bc.restrict {x | \u03c4 x = i}] \u03bc[f n|h\u03c4.measurableSpace] := by\n  refine Filter.EventuallyEq.trans ?_\n    (condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const h h\u03c4 h\u03c4_le i).symm\n  rw [Filter.EventuallyEq, ae_restrict_iff' (\u2131.le _ _ (h\u03c4.measurableSet_eq i))]\n  refine Filter.eventually_of_forall fun x hx => ?_\n  rw [Set.mem_setOf_eq] at hx\n  simp_rw [stoppedValue, hx]\n#align measure_theory.martingale.stopped_value_ae_eq_restrict_eq MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq\n\n\n"}
{"name": "jacobiTheta_eq_tsum_nat60", "split": "test", "formal_statement": "theorem jacobiTheta_eq_tsum_nat {\u03c4 : \u2102} (h\u03c4 : 0 < im \u03c4) :\n    jacobiTheta \u03c4 = \u21911 + \u21912 * \u2211' n : \u2115, cexp (\u03c0 * I * ((n : \u2102) + 1) ^ 2 * \u03c4) := by", "header": "\nimport Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable\nimport Mathlib.Analysis.Complex.UpperHalfPlane.Basic\n\n#align_import number_theory.modular_forms.jacobi_theta.basic from \"leanprover-community/mathlib\"@\"57f9349f2fe19d2de7207e99b0341808d977cdcf\"\n\n\n\nopen Complex Real Asymptotics Filter Topology\n\nopen scoped Real UpperHalfPlane\n\n\nnoncomputable def jacobiTheta (\u03c4 : \u2102) : \u2102 := \u2211' n : \u2124, cexp (\u03c0 * I * (n : \u2102) ^ 2 * \u03c4)\n#align jacobi_theta jacobiTheta\n\nlemma jacobiTheta_eq_jacobiTheta\u2082 (\u03c4 : \u2102) : jacobiTheta \u03c4 = jacobiTheta\u2082 0 \u03c4 :=\n  tsum_congr (by simp [jacobiTheta\u2082_term])\n\ntheorem jacobiTheta_two_add (\u03c4 : \u2102) : jacobiTheta (2 + \u03c4) = jacobiTheta \u03c4 := by\n  simp_rw [jacobiTheta_eq_jacobiTheta\u2082, add_comm, jacobiTheta\u2082_add_right]\n#align jacobi_theta_two_add jacobiTheta_two_add\n\ntheorem jacobiTheta_T_sq_smul (\u03c4 : \u210d) : jacobiTheta (ModularGroup.T ^ 2 \u2022 \u03c4 :) = jacobiTheta \u03c4 := by\n  suffices (ModularGroup.T ^ 2 \u2022 \u03c4 :) = (2 : \u2102) + \u2191\u03c4 by simp_rw [this, jacobiTheta_two_add]\n  have : ModularGroup.T ^ (2 : \u2115) = ModularGroup.T ^ (2 : \u2124) := rfl\n  simp_rw [this, UpperHalfPlane.modular_T_zpow_smul, UpperHalfPlane.coe_vadd]\n  norm_cast\nset_option linter.uppercaseLean3 false in\n#align jacobi_theta_T_sq_smul jacobiTheta_T_sq_smul\n\ntheorem jacobiTheta_S_smul (\u03c4 : \u210d) :\n    jacobiTheta \u2191(ModularGroup.S \u2022 \u03c4) = (-I * \u03c4) ^ (1 / 2 : \u2102) * jacobiTheta \u03c4 := by\n  have h0 : (\u03c4 : \u2102) \u2260 0 := ne_of_apply_ne im (zero_im.symm \u25b8 ne_of_gt \u03c4.2)\n  have h1 : (-I * \u03c4) ^ (1 / 2 : \u2102) \u2260 0 := by\n    rw [Ne, cpow_eq_zero_iff, not_and_or]\n    exact Or.inl <| mul_ne_zero (neg_ne_zero.mpr I_ne_zero) h0\n  simp_rw [UpperHalfPlane.modular_S_smul, jacobiTheta_eq_jacobiTheta\u2082]\n  conv_rhs => erw [\u2190 ofReal_zero, jacobiTheta\u2082_functional_equation 0 \u03c4]\n  rw [zero_pow two_ne_zero, mul_zero, zero_div, Complex.exp_zero, mul_one, \u2190 mul_assoc, mul_one_div,\n    div_self h1, one_mul, UpperHalfPlane.coe_mk, inv_neg, neg_div, one_div]\nset_option linter.uppercaseLean3 false in\n#align jacobi_theta_S_smul jacobiTheta_S_smul\n\ntheorem norm_exp_mul_sq_le {\u03c4 : \u2102} (h\u03c4 : 0 < \u03c4.im) (n : \u2124) :\n    \u2016cexp (\u03c0 * I * (n : \u2102) ^ 2 * \u03c4)\u2016 \u2264 rexp (-\u03c0 * \u03c4.im) ^ n.natAbs := by\n  let y := rexp (-\u03c0 * \u03c4.im)\n  have h : y < 1 := exp_lt_one_iff.mpr (mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) h\u03c4)\n  refine (le_of_eq ?_).trans (?_ : y ^ n ^ 2 \u2264 _)\n  \u00b7 rw [Complex.norm_eq_abs, Complex.abs_exp]\n    have : (\u03c0 * I * n ^ 2 * \u03c4 : \u2102).re = -\u03c0 * \u03c4.im * (n : \u211d) ^ 2 := by\n      rw [(by push_cast; ring : (\u03c0 * I * n ^ 2 * \u03c4 : \u2102) = (\u03c0 * n ^ 2 : \u211d) * (\u03c4 * I)),\n        re_ofReal_mul, mul_I_re]\n      ring\n    obtain \u27e8m, hm\u27e9 := Int.eq_ofNat_of_zero_le (sq_nonneg n)\n    rw [this, exp_mul, \u2190 Int.cast_pow, rpow_intCast, hm, zpow_natCast]\n  \u00b7 have : n ^ 2 = (n.natAbs ^ 2 :) := by rw [Nat.cast_pow, Int.natAbs_sq]\n    rw [this, zpow_natCast]\n    exact pow_le_pow_of_le_one (exp_pos _).le h.le ((sq n.natAbs).symm \u25b8 n.natAbs.le_mul_self)\n#align norm_exp_mul_sq_le norm_exp_mul_sq_le\n\ntheorem hasSum_nat_jacobiTheta {\u03c4 : \u2102} (h\u03c4 : 0 < im \u03c4) :\n    HasSum (fun n : \u2115 => cexp (\u03c0 * I * ((n : \u2102) + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2) := by\n  have := hasSum_jacobiTheta\u2082_term 0 h\u03c4\n  simp_rw [jacobiTheta\u2082_term, mul_zero, zero_add, \u2190 jacobiTheta_eq_jacobiTheta\u2082] at this\n  have := this.nat_add_neg\n  rw [\u2190 hasSum_nat_add_iff' 1] at this\n  simp_rw [Finset.sum_range_one, Int.cast_neg, Int.cast_natCast, Nat.cast_zero, neg_zero,\n    Int.cast_zero, sq (0 : \u2102), mul_zero, zero_mul, neg_sq, \u2190 mul_two,\n    Complex.exp_zero, add_sub_assoc, (by norm_num : (1 : \u2102) - 1 * 2 = -1), \u2190 sub_eq_add_neg,\n    Nat.cast_add, Nat.cast_one] at this\n  convert this.div_const 2 using 1\n  simp_rw [mul_div_cancel_right\u2080 _ (two_ne_zero' \u2102)]\n#align has_sum_nat_jacobi_theta hasSum_nat_jacobiTheta\n\n"}
{"name": "counit_app_functor61", "split": "test", "formal_statement": "theorem counit_app_functor (e : C \u224c D) (X : C) :\n    e.counit.app (e.functor.obj X) = e.functor.map (e.unitInv.app X) := by", "header": "\nimport Mathlib.CategoryTheory.Functor.FullyFaithful\nimport Mathlib.CategoryTheory.FullSubcategory\nimport Mathlib.CategoryTheory.Whiskering\nimport Mathlib.CategoryTheory.EssentialImage\nimport Mathlib.Tactic.CategoryTheory.Slice\n\n#align_import category_theory.equivalence from \"leanprover-community/mathlib\"@\"9aba7801eeecebb61f58a5763c2b6dd1b47dc6ef\"\n\n\nnamespace CategoryTheory\n\nopen CategoryTheory.Functor NatIso Category\n\n-- declare the `v`'s first; see `CategoryTheory.Category` for an explanation\nuniverse v\u2081 v\u2082 v\u2083 u\u2081 u\u2082 u\u2083\n\n\n@[ext]\nstructure Equivalence (C : Type u\u2081) (D : Type u\u2082) [Category.{v\u2081} C] [Category.{v\u2082} D] where mk' ::\n  \n  functor : C \u2964 D\n  \n  inverse : D \u2964 C\n  \n  unitIso : \ud835\udfed C \u2245 functor \u22d9 inverse\n  \n  counitIso : inverse \u22d9 functor \u2245 \ud835\udfed D\n  \n  functor_unitIso_comp :\n    \u2200 X : C, functor.map (unitIso.hom.app X) \u226b counitIso.hom.app (functor.obj X) =\n      \ud835\udfd9 (functor.obj X) := by aesop_cat\n#align category_theory.equivalence CategoryTheory.Equivalence\n#align category_theory.equivalence.unit_iso CategoryTheory.Equivalence.unitIso\n#align category_theory.equivalence.counit_iso CategoryTheory.Equivalence.counitIso\n#align category_theory.equivalence.functor_unit_iso_comp CategoryTheory.Equivalence.functor_unitIso_comp\n\n\ninfixr:10 \" \u224c \" => Equivalence\n\nvariable {C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]\n\nnamespace Equivalence\n\n\nabbrev unit (e : C \u224c D) : \ud835\udfed C \u27f6 e.functor \u22d9 e.inverse :=\n  e.unitIso.hom\n#align category_theory.equivalence.unit CategoryTheory.Equivalence.unit\n\n\nabbrev counit (e : C \u224c D) : e.inverse \u22d9 e.functor \u27f6 \ud835\udfed D :=\n  e.counitIso.hom\n#align category_theory.equivalence.counit CategoryTheory.Equivalence.counit\n\n\nabbrev unitInv (e : C \u224c D) : e.functor \u22d9 e.inverse \u27f6 \ud835\udfed C :=\n  e.unitIso.inv\n#align category_theory.equivalence.unit_inv CategoryTheory.Equivalence.unitInv\n\n\nabbrev counitInv (e : C \u224c D) : \ud835\udfed D \u27f6 e.inverse \u22d9 e.functor :=\n  e.counitIso.inv\n#align category_theory.equivalence.counit_inv CategoryTheory.Equivalence.counitInv\n\n\n@[simp]\ntheorem Equivalence_mk'_unit (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).unit = unit_iso.hom :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_unit CategoryTheory.Equivalence.Equivalence_mk'_unit\n\n@[simp]\ntheorem Equivalence_mk'_counit (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).counit = counit_iso.hom :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_counit CategoryTheory.Equivalence.Equivalence_mk'_counit\n\n@[simp]\ntheorem Equivalence_mk'_unitInv (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).unitInv = unit_iso.inv :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_unit_inv CategoryTheory.Equivalence.Equivalence_mk'_unitInv\n\n@[simp]\ntheorem Equivalence_mk'_counitInv (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).counitInv = counit_iso.inv :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_counit_inv CategoryTheory.Equivalence.Equivalence_mk'_counitInv\n\n@[reassoc (attr := simp)]\ntheorem functor_unit_comp (e : C \u224c D) (X : C) :\n    e.functor.map (e.unit.app X) \u226b e.counit.app (e.functor.obj X) = \ud835\udfd9 (e.functor.obj X) :=\n  e.functor_unitIso_comp X\n#align category_theory.equivalence.functor_unit_comp CategoryTheory.Equivalence.functor_unit_comp\n\n@[reassoc (attr := simp)]\ntheorem counitInv_functor_comp (e : C \u224c D) (X : C) :\n    e.counitInv.app (e.functor.obj X) \u226b e.functor.map (e.unitInv.app X) = \ud835\udfd9 (e.functor.obj X) := by\n  erw [Iso.inv_eq_inv (e.functor.mapIso (e.unitIso.app X) \u226a\u226b e.counitIso.app (e.functor.obj X))\n      (Iso.refl _)]\n  exact e.functor_unit_comp X\n#align category_theory.equivalence.counit_inv_functor_comp CategoryTheory.Equivalence.counitInv_functor_comp\n\ntheorem counitInv_app_functor (e : C \u224c D) (X : C) :\n    e.counitInv.app (e.functor.obj X) = e.functor.map (e.unit.app X) := by\n  symm\n  erw [\u2190 Iso.comp_hom_eq_id (e.counitIso.app _), functor_unit_comp]\n  rfl\n#align category_theory.equivalence.counit_inv_app_functor CategoryTheory.Equivalence.counitInv_app_functor\n\n"}
{"name": "counitInv_app_functor62", "split": "test", "formal_statement": "theorem counitInv_app_functor (e : C \u224c D) (X : C) :\n    e.counitInv.app (e.functor.obj X) = e.functor.map (e.unit.app X) := by", "header": "\nimport Mathlib.CategoryTheory.Functor.FullyFaithful\nimport Mathlib.CategoryTheory.FullSubcategory\nimport Mathlib.CategoryTheory.Whiskering\nimport Mathlib.CategoryTheory.EssentialImage\nimport Mathlib.Tactic.CategoryTheory.Slice\n\n#align_import category_theory.equivalence from \"leanprover-community/mathlib\"@\"9aba7801eeecebb61f58a5763c2b6dd1b47dc6ef\"\n\n\nnamespace CategoryTheory\n\nopen CategoryTheory.Functor NatIso Category\n\n-- declare the `v`'s first; see `CategoryTheory.Category` for an explanation\nuniverse v\u2081 v\u2082 v\u2083 u\u2081 u\u2082 u\u2083\n\n\n@[ext]\nstructure Equivalence (C : Type u\u2081) (D : Type u\u2082) [Category.{v\u2081} C] [Category.{v\u2082} D] where mk' ::\n  \n  functor : C \u2964 D\n  \n  inverse : D \u2964 C\n  \n  unitIso : \ud835\udfed C \u2245 functor \u22d9 inverse\n  \n  counitIso : inverse \u22d9 functor \u2245 \ud835\udfed D\n  \n  functor_unitIso_comp :\n    \u2200 X : C, functor.map (unitIso.hom.app X) \u226b counitIso.hom.app (functor.obj X) =\n      \ud835\udfd9 (functor.obj X) := by aesop_cat\n#align category_theory.equivalence CategoryTheory.Equivalence\n#align category_theory.equivalence.unit_iso CategoryTheory.Equivalence.unitIso\n#align category_theory.equivalence.counit_iso CategoryTheory.Equivalence.counitIso\n#align category_theory.equivalence.functor_unit_iso_comp CategoryTheory.Equivalence.functor_unitIso_comp\n\n\ninfixr:10 \" \u224c \" => Equivalence\n\nvariable {C : Type u\u2081} [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D]\n\nnamespace Equivalence\n\n\nabbrev unit (e : C \u224c D) : \ud835\udfed C \u27f6 e.functor \u22d9 e.inverse :=\n  e.unitIso.hom\n#align category_theory.equivalence.unit CategoryTheory.Equivalence.unit\n\n\nabbrev counit (e : C \u224c D) : e.inverse \u22d9 e.functor \u27f6 \ud835\udfed D :=\n  e.counitIso.hom\n#align category_theory.equivalence.counit CategoryTheory.Equivalence.counit\n\n\nabbrev unitInv (e : C \u224c D) : e.functor \u22d9 e.inverse \u27f6 \ud835\udfed C :=\n  e.unitIso.inv\n#align category_theory.equivalence.unit_inv CategoryTheory.Equivalence.unitInv\n\n\nabbrev counitInv (e : C \u224c D) : \ud835\udfed D \u27f6 e.inverse \u22d9 e.functor :=\n  e.counitIso.inv\n#align category_theory.equivalence.counit_inv CategoryTheory.Equivalence.counitInv\n\n\n@[simp]\ntheorem Equivalence_mk'_unit (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).unit = unit_iso.hom :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_unit CategoryTheory.Equivalence.Equivalence_mk'_unit\n\n@[simp]\ntheorem Equivalence_mk'_counit (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).counit = counit_iso.hom :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_counit CategoryTheory.Equivalence.Equivalence_mk'_counit\n\n@[simp]\ntheorem Equivalence_mk'_unitInv (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).unitInv = unit_iso.inv :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_unit_inv CategoryTheory.Equivalence.Equivalence_mk'_unitInv\n\n@[simp]\ntheorem Equivalence_mk'_counitInv (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).counitInv = counit_iso.inv :=\n  rfl\n#align category_theory.equivalence.equivalence_mk'_counit_inv CategoryTheory.Equivalence.Equivalence_mk'_counitInv\n\n@[reassoc (attr := simp)]\ntheorem functor_unit_comp (e : C \u224c D) (X : C) :\n    e.functor.map (e.unit.app X) \u226b e.counit.app (e.functor.obj X) = \ud835\udfd9 (e.functor.obj X) :=\n  e.functor_unitIso_comp X\n#align category_theory.equivalence.functor_unit_comp CategoryTheory.Equivalence.functor_unit_comp\n\n@[reassoc (attr := simp)]\ntheorem counitInv_functor_comp (e : C \u224c D) (X : C) :\n    e.counitInv.app (e.functor.obj X) \u226b e.functor.map (e.unitInv.app X) = \ud835\udfd9 (e.functor.obj X) := by\n  erw [Iso.inv_eq_inv (e.functor.mapIso (e.unitIso.app X) \u226a\u226b e.counitIso.app (e.functor.obj X))\n      (Iso.refl _)]\n  exact e.functor_unit_comp X\n#align category_theory.equivalence.counit_inv_functor_comp CategoryTheory.Equivalence.counitInv_functor_comp\n\n"}
{"name": "dedup_eq_nil63", "split": "test", "formal_statement": "theorem dedup_eq_nil (l : List \u03b1) : l.dedup = [] \u2194 l = [] := by", "header": "\nimport Mathlib.Data.List.Nodup\n\n#align_import data.list.dedup from \"leanprover-community/mathlib\"@\"d9e96a3e3e0894e93e10aff5244f4c96655bac1c\"\n\n\n\n\nuniverse u\n\nnamespace List\n\nvariable {\u03b1 : Type u} [DecidableEq \u03b1]\n\n@[simp]\ntheorem dedup_nil : dedup [] = ([] : List \u03b1) :=\n  rfl\n#align list.dedup_nil List.dedup_nil\n\ntheorem dedup_cons_of_mem' {a : \u03b1} {l : List \u03b1} (h : a \u2208 dedup l) : dedup (a :: l) = dedup l :=\n  pwFilter_cons_of_neg <| by simpa only [forall_mem_ne, not_not] using h\n#align list.dedup_cons_of_mem' List.dedup_cons_of_mem'\n\ntheorem dedup_cons_of_not_mem' {a : \u03b1} {l : List \u03b1} (h : a \u2209 dedup l) :\n    dedup (a :: l) = a :: dedup l :=\n  pwFilter_cons_of_pos <| by simpa only [forall_mem_ne] using h\n#align list.dedup_cons_of_not_mem' List.dedup_cons_of_not_mem'\n\n@[simp]\ntheorem mem_dedup {a : \u03b1} {l : List \u03b1} : a \u2208 dedup l \u2194 a \u2208 l := by\n  have := not_congr (@forall_mem_pwFilter \u03b1 (\u00b7 \u2260 \u00b7) _ ?_ a l)\n  \u00b7 simpa only [dedup, forall_mem_ne, not_not] using this\n  \u00b7 intros x y z xz\n    exact not_and_or.1 <| mt (fun h \u21a6 h.1.trans h.2) xz\n#align list.mem_dedup List.mem_dedup\n\n@[simp]\ntheorem dedup_cons_of_mem {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) : dedup (a :: l) = dedup l :=\n  dedup_cons_of_mem' <| mem_dedup.2 h\n#align list.dedup_cons_of_mem List.dedup_cons_of_mem\n\n@[simp]\ntheorem dedup_cons_of_not_mem {a : \u03b1} {l : List \u03b1} (h : a \u2209 l) : dedup (a :: l) = a :: dedup l :=\n  dedup_cons_of_not_mem' <| mt mem_dedup.1 h\n#align list.dedup_cons_of_not_mem List.dedup_cons_of_not_mem\n\ntheorem dedup_sublist : \u2200 l : List \u03b1, dedup l <+ l :=\n  pwFilter_sublist\n#align list.dedup_sublist List.dedup_sublist\n\ntheorem dedup_subset : \u2200 l : List \u03b1, dedup l \u2286 l :=\n  pwFilter_subset\n#align list.dedup_subset List.dedup_subset\n\ntheorem subset_dedup (l : List \u03b1) : l \u2286 dedup l := fun _ => mem_dedup.2\n#align list.subset_dedup List.subset_dedup\n\ntheorem nodup_dedup : \u2200 l : List \u03b1, Nodup (dedup l) :=\n  pairwise_pwFilter\n#align list.nodup_dedup List.nodup_dedup\n\ntheorem headI_dedup [Inhabited \u03b1] (l : List \u03b1) :\n    l.dedup.headI = if l.headI \u2208 l.tail then l.tail.dedup.headI else l.headI :=\n  match l with\n  | [] => rfl\n  | a :: l => by by_cases ha : a \u2208 l <;> simp [ha, List.dedup_cons_of_mem]\n#align list.head_dedup List.headI_dedup\n\ntheorem tail_dedup [Inhabited \u03b1] (l : List \u03b1) :\n    l.dedup.tail = if l.headI \u2208 l.tail then l.tail.dedup.tail else l.tail.dedup :=\n  match l with\n  | [] => rfl\n  | a :: l => by by_cases ha : a \u2208 l <;> simp [ha, List.dedup_cons_of_mem]\n#align list.tail_dedup List.tail_dedup\n\ntheorem dedup_eq_self {l : List \u03b1} : dedup l = l \u2194 Nodup l :=\n  pwFilter_eq_self\n#align list.dedup_eq_self List.dedup_eq_self\n\ntheorem dedup_eq_cons (l : List \u03b1) (a : \u03b1) (l' : List \u03b1) :\n    l.dedup = a :: l' \u2194 a \u2208 l \u2227 a \u2209 l' \u2227 l.dedup.tail = l' := by\n  refine \u27e8fun h => ?_, fun h => ?_\u27e9\n  \u00b7 refine \u27e8mem_dedup.1 (h.symm \u25b8 mem_cons_self _ _), fun ha => ?_, by rw [h, tail_cons]\u27e9\n    have := count_pos_iff_mem.2 ha\n    have : count a l.dedup \u2264 1 := nodup_iff_count_le_one.1 (nodup_dedup l) a\n    rw [h, count_cons_self] at this\n    omega\n  \u00b7 have := @List.cons_head!_tail \u03b1 \u27e8a\u27e9 _ (ne_nil_of_mem (mem_dedup.2 h.1))\n    have hal : a \u2208 l.dedup := mem_dedup.2 h.1\n    rw [\u2190 this, mem_cons, or_iff_not_imp_right] at hal\n    exact this \u25b8 h.2.2.symm \u25b8 cons_eq_cons.2 \u27e8(hal (h.2.2.symm \u25b8 h.2.1)).symm, rfl\u27e9\n#align list.dedup_eq_cons List.dedup_eq_cons\n\n@[simp]\n"}
{"name": "exists_subset_iUnion_ball_radius_pos_lt64", "split": "test", "formal_statement": "theorem exists_subset_iUnion_ball_radius_pos_lt {r : \u03b9 \u2192 \u211d} (hr : \u2200 i, 0 < r i) (hs : IsClosed s)\n    (uf : \u2200 x \u2208 s, { i | x \u2208 ball (c i) (r i) }.Finite) (us : s \u2286 \u22c3 i, ball (c i) (r i)) :\n    \u2203 r' : \u03b9 \u2192 \u211d, (s \u2286 \u22c3 i, ball (c i) (r' i)) \u2227 \u2200 i, r' i \u2208 Ioo 0 (r i) := by", "header": "\nimport Mathlib.Topology.EMetricSpace.Paracompact\nimport Mathlib.Topology.MetricSpace.Basic\nimport Mathlib.Topology.MetricSpace.ProperSpace\nimport Mathlib.Topology.ShrinkingLemma\n\n#align_import topology.metric_space.shrinking_lemma from \"leanprover-community/mathlib\"@\"f2ce6086713c78a7f880485f7917ea547a215982\"\n\n\n\n\nuniverse u v\n\nopen Set Metric\n\nopen Topology\n\nvariable {\u03b1 : Type u} {\u03b9 : Type v} [MetricSpace \u03b1] [ProperSpace \u03b1] {c : \u03b9 \u2192 \u03b1}\nvariable {x : \u03b1} {r : \u211d} {s : Set \u03b1}\n\n\ntheorem exists_subset_iUnion_ball_radius_lt {r : \u03b9 \u2192 \u211d} (hs : IsClosed s)\n    (uf : \u2200 x \u2208 s, { i | x \u2208 ball (c i) (r i) }.Finite) (us : s \u2286 \u22c3 i, ball (c i) (r i)) :\n    \u2203 r' : \u03b9 \u2192 \u211d, (s \u2286 \u22c3 i, ball (c i) (r' i)) \u2227 \u2200 i, r' i < r i := by\n  rcases exists_subset_iUnion_closed_subset hs (fun i => @isOpen_ball _ _ (c i) (r i)) uf us with\n    \u27e8v, hsv, hvc, hcv\u27e9\n  have := fun i => exists_lt_subset_ball (hvc i) (hcv i)\n  choose r' hlt hsub using this\n  exact \u27e8r', hsv.trans <| iUnion_mono <| hsub, hlt\u27e9\n#align exists_subset_Union_ball_radius_lt exists_subset_iUnion_ball_radius_lt\n\n\ntheorem exists_iUnion_ball_eq_radius_lt {r : \u03b9 \u2192 \u211d} (uf : \u2200 x, { i | x \u2208 ball (c i) (r i) }.Finite)\n    (uU : \u22c3 i, ball (c i) (r i) = univ) :\n    \u2203 r' : \u03b9 \u2192 \u211d, \u22c3 i, ball (c i) (r' i) = univ \u2227 \u2200 i, r' i < r i :=\n  let \u27e8r', hU, hv\u27e9 := exists_subset_iUnion_ball_radius_lt isClosed_univ (fun x _ => uf x) uU.ge\n  \u27e8r', univ_subset_iff.1 hU, hv\u27e9\n#align exists_Union_ball_eq_radius_lt exists_iUnion_ball_eq_radius_lt\n\n\n"}
{"name": "EffectiveEpiFamily.transitive_of_finite65", "split": "test", "formal_statement": "theorem EffectiveEpiFamily.transitive_of_finite {\u03b1 : Type} [Finite \u03b1] {Y : \u03b1 \u2192 C}\n    (\u03c0 : (a : \u03b1) \u2192 (Y a \u27f6 X)) (h : EffectiveEpiFamily Y \u03c0) {\u03b2 : \u03b1 \u2192 Type} [\u2200 (a: \u03b1), Finite (\u03b2 a)]\n    {Y_n : (a : \u03b1) \u2192 \u03b2 a \u2192 C} (\u03c0_n : (a : \u03b1) \u2192 (b : \u03b2 a) \u2192 (Y_n a b \u27f6 Y a))\n    (H : \u2200 a, EffectiveEpiFamily (Y_n a) (\u03c0_n a)) :\n    EffectiveEpiFamily\n      (fun (c : \u03a3 a, \u03b2 a) => Y_n c.fst c.snd) (fun c => \u03c0_n c.fst c.snd \u226b \u03c0 c.fst) := by", "header": "\nimport Mathlib.CategoryTheory.Sites.Coherent.CoherentSheaves\n\n\nnamespace CategoryTheory\n\nvariable {C : Type*} [Category C] [Precoherent C] {X : C}\n\n\ntheorem coherentTopology.mem_sieves_of_hasEffectiveEpiFamily (S : Sieve X) :\n    (\u2203 (\u03b1 : Type) (_ : Finite \u03b1) (Y : \u03b1 \u2192 C) (\u03c0 : (a : \u03b1) \u2192 (Y a \u27f6 X)),\n      EffectiveEpiFamily Y \u03c0 \u2227 (\u2200 a : \u03b1, (S.arrows) (\u03c0 a)) ) \u2192\n        (S \u2208 GrothendieckTopology.sieves (coherentTopology C) X) := by\n  intro \u27e8\u03b1, _, Y, \u03c0, h\u03c0\u27e9\n  apply (coherentCoverage C).mem_toGrothendieck_sieves_of_superset (R := Presieve.ofArrows Y \u03c0)\n  \u00b7 exact fun _ _ h \u21a6 by cases h; exact h\u03c0.2 _\n  \u00b7 exact \u27e8_, inferInstance, Y, \u03c0, rfl, h\u03c0.1\u27e9\n\n\n"}
{"name": "max_self66", "split": "test", "formal_statement": "theorem max_self (a : \u03b1) : max a a = a := by", "header": "\nimport Mathlib.Init.Order.Defs\n\n#align_import init.algebra.functions from \"leanprover-community/lean\"@\"c2bcdbcbe741ed37c361a30d38e179182b989f76\"\n\n\n\nuniverse u\n\nsection\n\nopen Decidable\n\nvariable {\u03b1 : Type u} [LinearOrder \u03b1]\n\ntheorem min_def (a b : \u03b1) : min a b = if a \u2264 b then a else b := by\n  rw [LinearOrder.min_def a]\n#align min_def min_def\n\ntheorem max_def (a b : \u03b1) : max a b = if a \u2264 b then b else a := by\n  rw [LinearOrder.max_def a]\n#align max_def max_def\n\ntheorem min_le_left (a b : \u03b1) : min a b \u2264 a := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h, le_refl]\n  else simp [min_def, if_neg h]; exact le_of_not_le h\n#align min_le_left min_le_left\n\ntheorem min_le_right (a b : \u03b1) : min a b \u2264 b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h]; exact h\n  else simp [min_def, if_neg h, le_refl]\n#align min_le_right min_le_right\n\ntheorem le_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) : c \u2264 min a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h]; exact h\u2081\n  else simp [min_def, if_neg h]; exact h\u2082\n#align le_min le_min\n\ntheorem le_max_left (a b : \u03b1) : a \u2264 max a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h]; exact h\n  else simp [max_def, if_neg h, le_refl]\n#align le_max_left le_max_left\n\ntheorem le_max_right (a b : \u03b1) : b \u2264 max a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h, le_refl]\n  else simp [max_def, if_neg h]; exact le_of_not_le h\n#align le_max_right le_max_right\n\ntheorem max_le {a b c : \u03b1} (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : max a b \u2264 c := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h]; exact h\u2082\n  else simp [max_def, if_neg h]; exact h\u2081\n#align max_le max_le\n\ntheorem eq_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) (h\u2083 : \u2200 {d}, d \u2264 a \u2192 d \u2264 b \u2192 d \u2264 c) :\n    c = min a b :=\n  le_antisymm (le_min h\u2081 h\u2082) (h\u2083 (min_le_left a b) (min_le_right a b))\n#align eq_min eq_min\n\ntheorem min_comm (a b : \u03b1) : min a b = min b a :=\n  eq_min (min_le_right a b) (min_le_left a b) fun h\u2081 h\u2082 => le_min h\u2082 h\u2081\n#align min_comm min_comm\n\ntheorem min_assoc (a b c : \u03b1) : min (min a b) c = min a (min b c) := by\n  apply eq_min\n  \u00b7 apply le_trans; apply min_le_left; apply min_le_left\n  \u00b7 apply le_min; apply le_trans; apply min_le_left; apply min_le_right; apply min_le_right\n  \u00b7 intro d h\u2081 h\u2082; apply le_min; apply le_min h\u2081; apply le_trans h\u2082; apply min_le_left\n    apply le_trans h\u2082; apply min_le_right\n#align min_assoc min_assoc\n\ntheorem min_left_comm : \u2200 a b c : \u03b1, min a (min b c) = min b (min a c) :=\n  left_comm (@min \u03b1 _) (@min_comm \u03b1 _) (@min_assoc \u03b1 _)\n#align min_left_comm min_left_comm\n\n@[simp]\ntheorem min_self (a : \u03b1) : min a a = a := by simp [min_def]\n#align min_self min_self\n\ntheorem min_eq_left {a b : \u03b1} (h : a \u2264 b) : min a b = a := by\n  apply Eq.symm; apply eq_min (le_refl _) h; intros; assumption\n#align min_eq_left min_eq_left\n\ntheorem min_eq_right {a b : \u03b1} (h : b \u2264 a) : min a b = b :=\n  min_comm b a \u25b8 min_eq_left h\n#align min_eq_right min_eq_right\n\ntheorem eq_max {a b c : \u03b1} (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) (h\u2083 : \u2200 {d}, a \u2264 d \u2192 b \u2264 d \u2192 c \u2264 d) :\n    c = max a b :=\n  le_antisymm (h\u2083 (le_max_left a b) (le_max_right a b)) (max_le h\u2081 h\u2082)\n#align eq_max eq_max\n\ntheorem max_comm (a b : \u03b1) : max a b = max b a :=\n  eq_max (le_max_right a b) (le_max_left a b) fun h\u2081 h\u2082 => max_le h\u2082 h\u2081\n#align max_comm max_comm\n\ntheorem max_assoc (a b c : \u03b1) : max (max a b) c = max a (max b c) := by\n  apply eq_max\n  \u00b7 apply le_trans; apply le_max_left a b; apply le_max_left\n  \u00b7 apply max_le; apply le_trans; apply le_max_right a b; apply le_max_left; apply le_max_right\n  \u00b7 intro d h\u2081 h\u2082; apply max_le; apply max_le h\u2081; apply le_trans (le_max_left _ _) h\u2082\n    apply le_trans (le_max_right _ _) h\u2082\n#align max_assoc max_assoc\n\ntheorem max_left_comm : \u2200 a b c : \u03b1, max a (max b c) = max b (max a c) :=\n  left_comm (@max \u03b1 _) (@max_comm \u03b1 _) (@max_assoc \u03b1 _)\n#align max_left_comm max_left_comm\n\n@[simp]\n"}
{"name": "exists_isNilpotent_isSemisimple_of_separable_of_dvd_pow67", "split": "test", "formal_statement": "theorem exists_isNilpotent_isSemisimple_of_separable_of_dvd_pow {P : K[X]} {k : \u2115}\n    (sep : P.Separable) (nil : minpoly K f \u2223 P ^ k) :\n    \u2203\u1d49 (n \u2208 adjoin K {f}) (s \u2208 adjoin K {f}), IsNilpotent n \u2227 IsSemisimple s \u2227 f = n + s := by", "header": "\nimport Mathlib.Dynamics.Newton\nimport Mathlib.LinearAlgebra.Semisimple\n\n\n\nopen Algebra Polynomial\n\nnamespace Module.End\n\nvariable {K V : Type*} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f : End K V}\n\n"}
{"name": "le_pow_of_le_ramificationIdx68", "split": "test", "formal_statement": "theorem le_pow_of_le_ramificationIdx {n : \u2115} (hn : n \u2264 ramificationIdx f p P) :\n    map f p \u2264 P ^ n := by", "header": "\nimport Mathlib.RingTheory.DedekindDomain.Ideal\n\n#align_import number_theory.ramification_inertia from \"leanprover-community/mathlib\"@\"039a089d2a4b93c761b234f3e5f5aeb752bac60f\"\n\n\n\n\nnamespace Ideal\n\nuniverse u v\n\nvariable {R : Type u} [CommRing R]\nvariable {S : Type v} [CommRing S] (f : R \u2192+* S)\nvariable (p : Ideal R) (P : Ideal S)\n\nopen FiniteDimensional\n\nopen UniqueFactorizationMonoid\n\nsection DecEq\n\nopen scoped Classical\n\n\nnoncomputable def ramificationIdx : \u2115 := sSup {n | map f p \u2264 P ^ n}\n#align ideal.ramification_idx Ideal.ramificationIdx\n\nvariable {f p P}\n\ntheorem ramificationIdx_eq_find (h : \u2203 n, \u2200 k, map f p \u2264 P ^ k \u2192 k \u2264 n) :\n    ramificationIdx f p P = Nat.find h :=\n  Nat.sSup_def h\n#align ideal.ramification_idx_eq_find Ideal.ramificationIdx_eq_find\n\ntheorem ramificationIdx_eq_zero (h : \u2200 n : \u2115, \u2203 k, map f p \u2264 P ^ k \u2227 n < k) :\n    ramificationIdx f p P = 0 :=\n  dif_neg (by push_neg; exact h)\n#align ideal.ramification_idx_eq_zero Ideal.ramificationIdx_eq_zero\n\ntheorem ramificationIdx_spec {n : \u2115} (hle : map f p \u2264 P ^ n) (hgt : \u00acmap f p \u2264 P ^ (n + 1)) :\n    ramificationIdx f p P = n := by\n  let Q : \u2115 \u2192 Prop := fun m => \u2200 k : \u2115, map f p \u2264 P ^ k \u2192 k \u2264 m\n  have : Q n := by\n    intro k hk\n    refine le_of_not_lt fun hnk => ?_\n    exact hgt (hk.trans (Ideal.pow_le_pow_right hnk))\n  rw [ramificationIdx_eq_find \u27e8n, this\u27e9]\n  refine le_antisymm (Nat.find_min' _ this) (le_of_not_gt fun h : Nat.find _ < n => ?_)\n  obtain this' := Nat.find_spec \u27e8n, this\u27e9\n  exact h.not_le (this' _ hle)\n#align ideal.ramification_idx_spec Ideal.ramificationIdx_spec\n\ntheorem ramificationIdx_lt {n : \u2115} (hgt : \u00acmap f p \u2264 P ^ n) : ramificationIdx f p P < n := by\n  cases' n with n n\n  \u00b7 simp at hgt\n  \u00b7 rw [Nat.lt_succ_iff]\n    have : \u2200 k, map f p \u2264 P ^ k \u2192 k \u2264 n := by\n      refine fun k hk => le_of_not_lt fun hnk => ?_\n      exact hgt (hk.trans (Ideal.pow_le_pow_right hnk))\n    rw [ramificationIdx_eq_find \u27e8n, this\u27e9]\n    exact Nat.find_min' \u27e8n, this\u27e9 this\n#align ideal.ramification_idx_lt Ideal.ramificationIdx_lt\n\n@[simp]\ntheorem ramificationIdx_bot : ramificationIdx f \u22a5 P = 0 :=\n  dif_neg <| not_exists.mpr fun n hn => n.lt_succ_self.not_le (hn _ (by simp))\n#align ideal.ramification_idx_bot Ideal.ramificationIdx_bot\n\n@[simp]\ntheorem ramificationIdx_of_not_le (h : \u00acmap f p \u2264 P) : ramificationIdx f p P = 0 :=\n  ramificationIdx_spec (by simp) (by simpa using h)\n#align ideal.ramification_idx_of_not_le Ideal.ramificationIdx_of_not_le\n\ntheorem ramificationIdx_ne_zero {e : \u2115} (he : e \u2260 0) (hle : map f p \u2264 P ^ e)\n    (hnle : \u00acmap f p \u2264 P ^ (e + 1)) : ramificationIdx f p P \u2260 0 := by\n  rwa [ramificationIdx_spec hle hnle]\n#align ideal.ramification_idx_ne_zero Ideal.ramificationIdx_ne_zero\n\n"}
{"name": "continuous_proj69", "split": "test", "formal_statement": "theorem continuous_proj :\n    Continuous (Proj J : (I \u2192 Bool) \u2192 (I \u2192 Bool)) := by", "header": "\nimport Mathlib.Algebra.Category.ModuleCat.Free\nimport Mathlib.Topology.Category.Profinite.CofilteredLimit\nimport Mathlib.Topology.Category.Profinite.Product\nimport Mathlib.Topology.LocallyConstant.Algebra\nimport Mathlib.Init.Data.Bool.Lemmas\n\n\n\nuniverse u\n\nnamespace Profinite\n\nnamespace NobelingProof\n\nvariable {I : Type u} [LinearOrder I] [IsWellOrder I (\u00b7<\u00b7)] (C : Set (I \u2192 Bool))\n\nopen Profinite ContinuousMap CategoryTheory Limits Opposite Submodule\n\nsection Projections\n\n\nvariable (J K L : I \u2192 Prop) [\u2200 i, Decidable (J i)] [\u2200 i, Decidable (K i)] [\u2200 i, Decidable (L i)]\n\n\ndef Proj : (I \u2192 Bool) \u2192 (I \u2192 Bool) :=\n  fun c i \u21a6 if J i then c i else false\n\n@[simp]\n"}
{"name": "lt_find_iff70", "split": "test", "formal_statement": "theorem lt_find_iff (n : \u2115+) : n < PNat.find h \u2194 \u2200 m \u2264 n, \u00acp m := by", "header": "\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.find from \"leanprover-community/mathlib\"@\"207cfac9fcd06138865b5d04f7091e46d9320432\"\n\n\n\n\nnamespace PNat\n\nvariable {p q : \u2115+ \u2192 Prop} [DecidablePred p] [DecidablePred q] (h : \u2203 n, p n)\n\ninstance decidablePredExistsNat : DecidablePred fun n' : \u2115 => \u2203 (n : \u2115+) (_ : n' = n), p n :=\n  fun n' =>\n  decidable_of_iff' (\u2203 h : 0 < n', p \u27e8n', h\u27e9) <|\n    Subtype.exists.trans <| by\n      simp_rw [mk_coe, @exists_comm (_ < _) (_ = _), exists_prop, exists_eq_left']\n#align pnat.decidable_pred_exists_nat PNat.decidablePredExistsNat\n\n\nprotected def findX : { n // p n \u2227 \u2200 m : \u2115+, m < n \u2192 \u00acp m } := by\n  have : \u2203 (n' : \u2115) (n : \u2115+) (_ : n' = n), p n := Exists.elim h fun n hn => \u27e8n, n, rfl, hn\u27e9\n  have n := Nat.findX this\n  refine \u27e8\u27e8n, ?_\u27e9, ?_, fun m hm pm => ?_\u27e9\n  \u00b7 obtain \u27e8n', hn', -\u27e9 := n.prop.1\n    rw [hn']\n    exact n'.prop\n  \u00b7 obtain \u27e8n', hn', pn'\u27e9 := n.prop.1\n    simpa [hn', Subtype.coe_eta] using pn'\n  \u00b7 exact n.prop.2 m hm \u27e8m, rfl, pm\u27e9\n#align pnat.find_x PNat.findX\n\n\nprotected def find : \u2115+ :=\n  PNat.findX h\n#align pnat.find PNat.find\n\nprotected theorem find_spec : p (PNat.find h) :=\n  (PNat.findX h).prop.left\n#align pnat.find_spec PNat.find_spec\n\nprotected theorem find_min : \u2200 {m : \u2115+}, m < PNat.find h \u2192 \u00acp m :=\n  @(PNat.findX h).prop.right\n#align pnat.find_min PNat.find_min\n\nprotected theorem find_min' {m : \u2115+} (hm : p m) : PNat.find h \u2264 m :=\n  le_of_not_lt fun l => PNat.find_min h l hm\n#align pnat.find_min' PNat.find_min'\n\nvariable {n m : \u2115+}\n\ntheorem find_eq_iff : PNat.find h = m \u2194 p m \u2227 \u2200 n < m, \u00acp n := by\n  constructor\n  \u00b7 rintro rfl\n    exact \u27e8PNat.find_spec h, fun _ => PNat.find_min h\u27e9\n  \u00b7 rintro \u27e8hm, hlt\u27e9\n    exact le_antisymm (PNat.find_min' h hm) (not_lt.1 <| imp_not_comm.1 (hlt _) <| PNat.find_spec h)\n#align pnat.find_eq_iff PNat.find_eq_iff\n\n@[simp]\ntheorem find_lt_iff (n : \u2115+) : PNat.find h < n \u2194 \u2203 m < n, p m :=\n  \u27e8fun h2 => \u27e8PNat.find h, h2, PNat.find_spec h\u27e9, fun \u27e8_, hmn, hm\u27e9 =>\n    (PNat.find_min' h hm).trans_lt hmn\u27e9\n#align pnat.find_lt_iff PNat.find_lt_iff\n\n@[simp]\ntheorem find_le_iff (n : \u2115+) : PNat.find h \u2264 n \u2194 \u2203 m \u2264 n, p m := by\n  simp only [exists_prop, \u2190 lt_add_one_iff, find_lt_iff]\n#align pnat.find_le_iff PNat.find_le_iff\n\n@[simp]\ntheorem le_find_iff (n : \u2115+) : n \u2264 PNat.find h \u2194 \u2200 m < n, \u00acp m := by\n  simp only [\u2190 not_lt, find_lt_iff, not_exists, not_and]\n#align pnat.le_find_iff PNat.le_find_iff\n\n@[simp]\n"}
{"name": "map_map_symm71", "split": "test", "formal_statement": "theorem map_map_symm (g : P \u2243\u2090[R] P') : (I.map (g : P \u2192\u2090[R] P')).map (g.symm : P' \u2192\u2090[R] P) = I := by", "header": "\nimport Mathlib.RingTheory.IntegralClosure\nimport Mathlib.RingTheory.FractionalIdeal.Basic\n\n#align_import ring_theory.fractional_ideal from \"leanprover-community/mathlib\"@\"ed90a7d327c3a5caf65a6faf7e8a0d63c4605df7\"\n\n\n\n\nopen IsLocalization Pointwise nonZeroDivisors\n\nnamespace FractionalIdeal\n\nopen Set Submodule\n\nvariable {R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]\nvariable [Algebra R P] [loc : IsLocalization S P]\n\nsection\n\nvariable {P' : Type*} [CommRing P'] [Algebra R P'] [loc' : IsLocalization S P']\nvariable {P'' : Type*} [CommRing P''] [Algebra R P''] [loc'' : IsLocalization S P'']\n\ntheorem _root_.IsFractional.map (g : P \u2192\u2090[R] P') {I : Submodule R P} :\n    IsFractional S I \u2192 IsFractional S (Submodule.map g.toLinearMap I)\n  | \u27e8a, a_nonzero, hI\u27e9 =>\n    \u27e8a, a_nonzero, fun b hb => by\n      obtain \u27e8b', b'_mem, hb'\u27e9 := Submodule.mem_map.mp hb\n      rw [AlgHom.toLinearMap_apply] at hb'\n      obtain \u27e8x, hx\u27e9 := hI b' b'_mem\n      use x\n      rw [\u2190 g.commutes, hx, g.map_smul, hb']\u27e9\n#align is_fractional.map IsFractional.map\n\n\ndef map (g : P \u2192\u2090[R] P') : FractionalIdeal S P \u2192 FractionalIdeal S P' := fun I =>\n  \u27e8Submodule.map g.toLinearMap I, I.isFractional.map g\u27e9\n#align fractional_ideal.map FractionalIdeal.map\n\n@[simp, norm_cast]\ntheorem coe_map (g : P \u2192\u2090[R] P') (I : FractionalIdeal S P) :\n    \u2191(map g I) = Submodule.map g.toLinearMap I :=\n  rfl\n#align fractional_ideal.coe_map FractionalIdeal.coe_map\n\n@[simp]\ntheorem mem_map {I : FractionalIdeal S P} {g : P \u2192\u2090[R] P'} {y : P'} :\n    y \u2208 I.map g \u2194 \u2203 x, x \u2208 I \u2227 g x = y :=\n  Submodule.mem_map\n#align fractional_ideal.mem_map FractionalIdeal.mem_map\n\nvariable (I J : FractionalIdeal S P) (g : P \u2192\u2090[R] P')\n\n@[simp]\ntheorem map_id : I.map (AlgHom.id _ _) = I :=\n  coeToSubmodule_injective (Submodule.map_id (I : Submodule R P))\n#align fractional_ideal.map_id FractionalIdeal.map_id\n\n@[simp]\ntheorem map_comp (g' : P' \u2192\u2090[R] P'') : I.map (g'.comp g) = (I.map g).map g' :=\n  coeToSubmodule_injective (Submodule.map_comp g.toLinearMap g'.toLinearMap I)\n#align fractional_ideal.map_comp FractionalIdeal.map_comp\n\n@[simp, norm_cast]\ntheorem map_coeIdeal (I : Ideal R) : (I : FractionalIdeal S P).map g = I := by\n  ext x\n  simp only [mem_coeIdeal]\n  constructor\n  \u00b7 rintro \u27e8_, \u27e8y, hy, rfl\u27e9, rfl\u27e9\n    exact \u27e8y, hy, (g.commutes y).symm\u27e9\n  \u00b7 rintro \u27e8y, hy, rfl\u27e9\n    exact \u27e8_, \u27e8y, hy, rfl\u27e9, g.commutes y\u27e9\n#align fractional_ideal.map_coe_ideal FractionalIdeal.map_coeIdeal\n\n@[simp]\ntheorem map_one : (1 : FractionalIdeal S P).map g = 1 :=\n  map_coeIdeal g \u22a4\n#align fractional_ideal.map_one FractionalIdeal.map_one\n\n@[simp]\ntheorem map_zero : (0 : FractionalIdeal S P).map g = 0 :=\n  map_coeIdeal g 0\n#align fractional_ideal.map_zero FractionalIdeal.map_zero\n\n@[simp]\ntheorem map_add : (I + J).map g = I.map g + J.map g :=\n  coeToSubmodule_injective (Submodule.map_sup _ _ _)\n#align fractional_ideal.map_add FractionalIdeal.map_add\n\n@[simp]\ntheorem map_mul : (I * J).map g = I.map g * J.map g := by\n  simp only [mul_def]\n  exact coeToSubmodule_injective (Submodule.map_mul _ _ _)\n#align fractional_ideal.map_mul FractionalIdeal.map_mul\n\n@[simp]\n"}
{"name": "isPrimePow_nat_iff72", "split": "test", "formal_statement": "theorem isPrimePow_nat_iff (n : \u2115) : IsPrimePow n \u2194 \u2203 p k : \u2115, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n := by", "header": "\nimport Mathlib.Algebra.Associated\nimport Mathlib.NumberTheory.Divisors\n\n#align_import algebra.is_prime_pow from \"leanprover-community/mathlib\"@\"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c\"\n\n\n\n\nvariable {R : Type*} [CommMonoidWithZero R] (n p : R) (k : \u2115)\n\n\ndef IsPrimePow : Prop :=\n  \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n\n#align is_prime_pow IsPrimePow\n\ntheorem isPrimePow_def : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n :=\n  Iff.rfl\n#align is_prime_pow_def isPrimePow_def\n\n\ntheorem isPrimePow_iff_pow_succ : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 p ^ (k + 1) = n :=\n  (isPrimePow_def _).trans\n    \u27e8fun \u27e8p, k, hp, hk, hn\u27e9 => \u27e8_, _, hp, by rwa [Nat.sub_add_cancel hk]\u27e9, fun \u27e8p, k, hp, hn\u27e9 =>\n      \u27e8_, _, hp, Nat.succ_pos', hn\u27e9\u27e9\n#align is_prime_pow_iff_pow_succ isPrimePow_iff_pow_succ\n\ntheorem not_isPrimePow_zero [NoZeroDivisors R] : \u00acIsPrimePow (0 : R) := by\n  simp only [isPrimePow_def, not_exists, not_and', and_imp]\n  intro x n _hn hx\n  rw [pow_eq_zero hx]\n  simp\n#align not_is_prime_pow_zero not_isPrimePow_zero\n\ntheorem IsPrimePow.not_unit {n : R} (h : IsPrimePow n) : \u00acIsUnit n :=\n  let \u27e8_p, _k, hp, hk, hn\u27e9 := h\n  hn \u25b8 (isUnit_pow_iff hk.ne').not.mpr hp.not_unit\n#align is_prime_pow.not_unit IsPrimePow.not_unit\n\ntheorem IsUnit.not_isPrimePow {n : R} (h : IsUnit n) : \u00acIsPrimePow n := fun h' => h'.not_unit h\n#align is_unit.not_is_prime_pow IsUnit.not_isPrimePow\n\ntheorem not_isPrimePow_one : \u00acIsPrimePow (1 : R) :=\n  isUnit_one.not_isPrimePow\n#align not_is_prime_pow_one not_isPrimePow_one\n\ntheorem Prime.isPrimePow {p : R} (hp : Prime p) : IsPrimePow p :=\n  \u27e8p, 1, hp, zero_lt_one, by simp\u27e9\n#align prime.is_prime_pow Prime.isPrimePow\n\ntheorem IsPrimePow.pow {n : R} (hn : IsPrimePow n) {k : \u2115} (hk : k \u2260 0) : IsPrimePow (n ^ k) :=\n  let \u27e8p, k', hp, hk', hn\u27e9 := hn\n  \u27e8p, k * k', hp, mul_pos hk.bot_lt hk', by rw [pow_mul', hn]\u27e9\n#align is_prime_pow.pow IsPrimePow.pow\n\ntheorem IsPrimePow.ne_zero [NoZeroDivisors R] {n : R} (h : IsPrimePow n) : n \u2260 0 := fun t =>\n  not_isPrimePow_zero (t \u25b8 h)\n#align is_prime_pow.ne_zero IsPrimePow.ne_zero\n\ntheorem IsPrimePow.ne_one {n : R} (h : IsPrimePow n) : n \u2260 1 := fun t =>\n  not_isPrimePow_one (t \u25b8 h)\n#align is_prime_pow.ne_one IsPrimePow.ne_one\n\nsection Nat\n\n"}
{"name": "LocallyIntegrableOn.exists_countable_integrableOn73", "split": "test", "formal_statement": "theorem LocallyIntegrableOn.exists_countable_integrableOn [SecondCountableTopology X]\n    (hf : LocallyIntegrableOn f s \u03bc) : \u2203 T : Set (Set X), T.Countable \u2227\n    (\u2200 u \u2208 T, IsOpen u) \u2227 (s \u2286 \u22c3 u \u2208 T, u) \u2227 (\u2200 u \u2208 T, IntegrableOn f (u \u2229 s) \u03bc) := by", "header": "\nimport Mathlib.MeasureTheory.Integral.IntegrableOn\n\n#align_import measure_theory.function.locally_integrable from \"leanprover-community/mathlib\"@\"08a4542bec7242a5c60f179e4e49de8c0d677b1b\"\n\n\n\nopen MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology\n\nopen scoped Topology Interval ENNReal\n\nvariable {X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]\nvariable [MeasurableSpace Y] [TopologicalSpace Y]\nvariable [NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}\n\nnamespace MeasureTheory\n\nsection LocallyIntegrableOn\n\n\ndef LocallyIntegrableOn (f : X \u2192 E) (s : Set X) (\u03bc : Measure X := by volume_tac) : Prop :=\n  \u2200 x : X, x \u2208 s \u2192 IntegrableAtFilter f (\ud835\udcdd[s] x) \u03bc\n#align measure_theory.locally_integrable_on MeasureTheory.LocallyIntegrableOn\n\ntheorem LocallyIntegrableOn.mono_set (hf : LocallyIntegrableOn f s \u03bc) {t : Set X}\n    (hst : t \u2286 s) : LocallyIntegrableOn f t \u03bc := fun x hx =>\n  (hf x <| hst hx).filter_mono (nhdsWithin_mono x hst)\n#align measure_theory.locally_integrable_on.mono MeasureTheory.LocallyIntegrableOn.mono_set\n\ntheorem LocallyIntegrableOn.norm (hf : LocallyIntegrableOn f s \u03bc) :\n    LocallyIntegrableOn (fun x => \u2016f x\u2016) s \u03bc := fun t ht =>\n  let \u27e8U, hU_nhd, hU_int\u27e9 := hf t ht\n  \u27e8U, hU_nhd, hU_int.norm\u27e9\n#align measure_theory.locally_integrable_on.norm MeasureTheory.LocallyIntegrableOn.norm\n\ntheorem LocallyIntegrableOn.mono (hf : LocallyIntegrableOn f s \u03bc) {g : X \u2192 F}\n    (hg : AEStronglyMeasurable g \u03bc) (h : \u2200\u1d50 x \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016) :\n    LocallyIntegrableOn g s \u03bc := by\n  intro x hx\n  rcases hf x hx with \u27e8t, t_mem, ht\u27e9\n  exact \u27e8t, t_mem, Integrable.mono ht hg.restrict (ae_restrict_of_ae h)\u27e9\n\ntheorem IntegrableOn.locallyIntegrableOn (hf : IntegrableOn f s \u03bc) : LocallyIntegrableOn f s \u03bc :=\n  fun _ _ => \u27e8s, self_mem_nhdsWithin, hf\u27e9\n#align measure_theory.integrable_on.locally_integrable_on MeasureTheory.IntegrableOn.locallyIntegrableOn\n\n\ntheorem LocallyIntegrableOn.integrableOn_isCompact (hf : LocallyIntegrableOn f s \u03bc)\n    (hs : IsCompact s) : IntegrableOn f s \u03bc :=\n  IsCompact.induction_on hs integrableOn_empty (fun _u _v huv hv => hv.mono_set huv)\n    (fun _u _v hu hv => integrableOn_union.mpr \u27e8hu, hv\u27e9) hf\n#align measure_theory.locally_integrable_on.integrable_on_is_compact MeasureTheory.LocallyIntegrableOn.integrableOn_isCompact\n\ntheorem LocallyIntegrableOn.integrableOn_compact_subset (hf : LocallyIntegrableOn f s \u03bc) {t : Set X}\n    (hst : t \u2286 s) (ht : IsCompact t) : IntegrableOn f t \u03bc :=\n  (hf.mono_set hst).integrableOn_isCompact ht\n#align measure_theory.locally_integrable_on.integrable_on_compact_subset MeasureTheory.LocallyIntegrableOn.integrableOn_compact_subset\n\n\n"}
{"name": "IsPiSystem.prod74", "split": "test", "formal_statement": "theorem IsPiSystem.prod {C : Set (Set \u03b1)} {D : Set (Set \u03b2)} (hC : IsPiSystem C)\n    (hD : IsPiSystem D) : IsPiSystem (image2 (\u00b7 \u00d7\u02e2 \u00b7) C D) := by", "header": "\nimport Mathlib.MeasureTheory.Measure.GiryMonad\nimport Mathlib.Dynamics.Ergodic.MeasurePreserving\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.OpenPos\n\n#align_import measure_theory.constructions.prod.basic from \"leanprover-community/mathlib\"@\"00abe0695d8767201e6d008afa22393978bb324d\"\n\n\n\n\nnoncomputable section\n\nopen scoped Classical\nopen Topology ENNReal MeasureTheory\n\nopen Set Function Real ENNReal\n\nopen MeasureTheory MeasurableSpace MeasureTheory.Measure\n\nopen TopologicalSpace hiding generateFrom\n\nopen Filter hiding prod_eq map\n\nvariable {\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 E : Type*}\n\n\n"}
{"name": "comp75", "split": "test", "formal_statement": "theorem comp {Cg rg : \u211d\u22650} {g : Y \u2192 Z} {t : Set Y} (hg : HolderOnWith Cg rg g t) {Cf rf : \u211d\u22650}\n    {f : X \u2192 Y} (hf : HolderOnWith Cf rf f s) (hst : MapsTo f s t) :\n    HolderOnWith (Cg * Cf ^ (rg : \u211d)) (rg * rf) (g \u2218 f) s := by", "header": "\nimport Mathlib.Topology.MetricSpace.Lipschitz\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\n\n#align_import topology.metric_space.holder from \"leanprover-community/mathlib\"@\"0b9eaaa7686280fad8cce467f5c3c57ee6ce77f8\"\n\n\n\n\nvariable {X Y Z : Type*}\n\nopen Filter Set\n\nopen NNReal ENNReal Topology\n\nsection Emetric\n\nvariable [PseudoEMetricSpace X] [PseudoEMetricSpace Y] [PseudoEMetricSpace Z]\n\n\ndef HolderWith (C r : \u211d\u22650) (f : X \u2192 Y) : Prop :=\n  \u2200 x y, edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * edist x y ^ (r : \u211d)\n#align holder_with HolderWith\n\n\ndef HolderOnWith (C r : \u211d\u22650) (f : X \u2192 Y) (s : Set X) : Prop :=\n  \u2200 x \u2208 s, \u2200 y \u2208 s, edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * edist x y ^ (r : \u211d)\n#align holder_on_with HolderOnWith\n\n@[simp]\ntheorem holderOnWith_empty (C r : \u211d\u22650) (f : X \u2192 Y) : HolderOnWith C r f \u2205 := fun _ hx => hx.elim\n#align holder_on_with_empty holderOnWith_empty\n\n@[simp]\ntheorem holderOnWith_singleton (C r : \u211d\u22650) (f : X \u2192 Y) (x : X) : HolderOnWith C r f {x} := by\n  rintro a (rfl : a = x) b (rfl : b = a)\n  rw [edist_self]\n  exact zero_le _\n#align holder_on_with_singleton holderOnWith_singleton\n\ntheorem Set.Subsingleton.holderOnWith {s : Set X} (hs : s.Subsingleton) (C r : \u211d\u22650) (f : X \u2192 Y) :\n    HolderOnWith C r f s :=\n  hs.induction_on (holderOnWith_empty C r f) (holderOnWith_singleton C r f)\n#align set.subsingleton.holder_on_with Set.Subsingleton.holderOnWith\n\ntheorem holderOnWith_univ {C r : \u211d\u22650} {f : X \u2192 Y} : HolderOnWith C r f univ \u2194 HolderWith C r f := by\n  simp only [HolderOnWith, HolderWith, mem_univ, true_imp_iff]\n#align holder_on_with_univ holderOnWith_univ\n\n@[simp]\ntheorem holderOnWith_one {C : \u211d\u22650} {f : X \u2192 Y} {s : Set X} :\n    HolderOnWith C 1 f s \u2194 LipschitzOnWith C f s := by\n  simp only [HolderOnWith, LipschitzOnWith, NNReal.coe_one, ENNReal.rpow_one]\n#align holder_on_with_one holderOnWith_one\n\nalias \u27e8_, LipschitzOnWith.holderOnWith\u27e9 := holderOnWith_one\n#align lipschitz_on_with.holder_on_with LipschitzOnWith.holderOnWith\n\n@[simp]\ntheorem holderWith_one {C : \u211d\u22650} {f : X \u2192 Y} : HolderWith C 1 f \u2194 LipschitzWith C f :=\n  holderOnWith_univ.symm.trans <| holderOnWith_one.trans lipschitzOn_univ\n#align holder_with_one holderWith_one\n\nalias \u27e8_, LipschitzWith.holderWith\u27e9 := holderWith_one\n#align lipschitz_with.holder_with LipschitzWith.holderWith\n\ntheorem holderWith_id : HolderWith 1 1 (id : X \u2192 X) :=\n  LipschitzWith.id.holderWith\n#align holder_with_id holderWith_id\n\nprotected theorem HolderWith.holderOnWith {C r : \u211d\u22650} {f : X \u2192 Y} (h : HolderWith C r f)\n    (s : Set X) : HolderOnWith C r f s := fun x _ y _ => h x y\n#align holder_with.holder_on_with HolderWith.holderOnWith\n\nnamespace HolderOnWith\n\nvariable {C r : \u211d\u22650} {f : X \u2192 Y} {s t : Set X}\n\ntheorem edist_le (h : HolderOnWith C r f s) {x y : X} (hx : x \u2208 s) (hy : y \u2208 s) :\n    edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * edist x y ^ (r : \u211d) :=\n  h x hx y hy\n#align holder_on_with.edist_le HolderOnWith.edist_le\n\ntheorem edist_le_of_le (h : HolderOnWith C r f s) {x y : X} (hx : x \u2208 s) (hy : y \u2208 s) {d : \u211d\u22650\u221e}\n    (hd : edist x y \u2264 d) : edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * d ^ (r : \u211d) :=\n  (h.edist_le hx hy).trans <| by gcongr\n#align holder_on_with.edist_le_of_le HolderOnWith.edist_le_of_le\n\n"}
{"name": "PreservesLimitPair.iso_inv_snd76", "split": "test", "formal_statement": "theorem PreservesLimitPair.iso_inv_snd :\n    (PreservesLimitPair.iso G X Y).inv \u226b G.map prod.snd = prod.snd := by", "header": "\nimport Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts\nimport Mathlib.CategoryTheory.Limits.Preserves.Basic\n\n#align_import category_theory.limits.preserves.shapes.binary_products from \"leanprover-community/mathlib\"@\"024a4231815538ac739f52d08dd20a55da0d6b23\"\n\n\n\n\nnoncomputable section\n\nuniverse v\u2081 v\u2082 u\u2081 u\u2082\n\nopen CategoryTheory CategoryTheory.Category CategoryTheory.Limits\n\nvariable {C : Type u\u2081} [Category.{v\u2081} C]\nvariable {D : Type u\u2082} [Category.{v\u2082} D]\nvariable (G : C \u2964 D)\n\nnamespace CategoryTheory.Limits\n\nsection\n\nvariable {P X Y Z : C} (f : P \u27f6 X) (g : P \u27f6 Y)\n\n\ndef isLimitMapConeBinaryFanEquiv :\n    IsLimit (G.mapCone (BinaryFan.mk f g)) \u2243 IsLimit (BinaryFan.mk (G.map f) (G.map g)) :=\n  (IsLimit.postcomposeHomEquiv (diagramIsoPair _) _).symm.trans\n    (IsLimit.equivIsoLimit\n      (Cones.ext (Iso.refl _)\n        (by rintro (_ | _) <;> simp)))\n#align category_theory.limits.is_limit_map_cone_binary_fan_equiv CategoryTheory.Limits.isLimitMapConeBinaryFanEquiv\n\n\ndef mapIsLimitOfPreservesOfIsLimit [PreservesLimit (pair X Y) G] (l : IsLimit (BinaryFan.mk f g)) :\n    IsLimit (BinaryFan.mk (G.map f) (G.map g)) :=\n  isLimitMapConeBinaryFanEquiv G f g (PreservesLimit.preserves l)\n#align category_theory.limits.map_is_limit_of_preserves_of_is_limit CategoryTheory.Limits.mapIsLimitOfPreservesOfIsLimit\n\n\ndef isLimitOfReflectsOfMapIsLimit [ReflectsLimit (pair X Y) G]\n    (l : IsLimit (BinaryFan.mk (G.map f) (G.map g))) : IsLimit (BinaryFan.mk f g) :=\n  ReflectsLimit.reflects ((isLimitMapConeBinaryFanEquiv G f g).symm l)\n#align category_theory.limits.is_limit_of_reflects_of_map_is_limit CategoryTheory.Limits.isLimitOfReflectsOfMapIsLimit\n\nvariable (X Y) [HasBinaryProduct X Y]\n\n\ndef isLimitOfHasBinaryProductOfPreservesLimit [PreservesLimit (pair X Y) G] :\n    IsLimit (BinaryFan.mk (G.map (Limits.prod.fst : X \u2a2f Y \u27f6 X)) (G.map Limits.prod.snd)) :=\n  mapIsLimitOfPreservesOfIsLimit G _ _ (prodIsProd X Y)\n#align category_theory.limits.is_limit_of_has_binary_product_of_preserves_limit CategoryTheory.Limits.isLimitOfHasBinaryProductOfPreservesLimit\n\nvariable [HasBinaryProduct (G.obj X) (G.obj Y)]\n\n\ndef PreservesLimitPair.ofIsoProdComparison [i : IsIso (prodComparison G X Y)] :\n    PreservesLimit (pair X Y) G := by\n  apply preservesLimitOfPreservesLimitCone (prodIsProd X Y)\n  apply (isLimitMapConeBinaryFanEquiv _ _ _).symm _\n  refine @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (pair (G.obj X) (G.obj Y))) ?_\n  apply i\n#align category_theory.limits.preserves_limit_pair.of_iso_prod_comparison CategoryTheory.Limits.PreservesLimitPair.ofIsoProdComparison\n\nvariable [PreservesLimit (pair X Y) G]\n\n\ndef PreservesLimitPair.iso : G.obj (X \u2a2f Y) \u2245 G.obj X \u2a2f G.obj Y :=\n  IsLimit.conePointUniqueUpToIso (isLimitOfHasBinaryProductOfPreservesLimit G X Y) (limit.isLimit _)\n#align category_theory.limits.preserves_limit_pair.iso CategoryTheory.Limits.PreservesLimitPair.iso\n\n@[simp]\ntheorem PreservesLimitPair.iso_hom : (PreservesLimitPair.iso G X Y).hom = prodComparison G X Y :=\n  rfl\n#align category_theory.limits.preserves_limit_pair.iso_hom CategoryTheory.Limits.PreservesLimitPair.iso_hom\n\n@[simp]\ntheorem PreservesLimitPair.iso_inv_fst :\n    (PreservesLimitPair.iso G X Y).inv \u226b G.map prod.fst = prod.fst := by\n  rw [\u2190 Iso.cancel_iso_hom_left (PreservesLimitPair.iso G X Y), \u2190 Category.assoc, Iso.hom_inv_id]\n  simp\n\n@[simp]\n"}
{"name": "measurable_condexpKernel77", "split": "test", "formal_statement": "theorem measurable_condexpKernel {s : Set \u03a9} (hs : MeasurableSet s) :\n    Measurable[m] fun \u03c9 => condexpKernel \u03bc m \u03c9 s := by", "header": "\nimport Mathlib.Probability.Kernel.CondDistrib\n\n#align_import probability.kernel.condexp from \"leanprover-community/mathlib\"@\"00abe0695d8767201e6d008afa22393978bb324d\"\n\n\n\n\nopen MeasureTheory Set Filter TopologicalSpace\n\nopen scoped ENNReal MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory\n\nvariable {\u03a9 F : Type*} {m : MeasurableSpace \u03a9} [m\u03a9 : MeasurableSpace \u03a9]\n  [StandardBorelSpace \u03a9] [Nonempty \u03a9] {\u03bc : Measure \u03a9} [IsFiniteMeasure \u03bc]\n\n\nnoncomputable irreducible_def condexpKernel (\u03bc : Measure \u03a9) [IsFiniteMeasure \u03bc]\n    (m : MeasurableSpace \u03a9) : @kernel \u03a9 \u03a9 m m\u03a9 :=\n  kernel.comap (@condDistrib \u03a9 \u03a9 \u03a9 m\u03a9 _ _ m\u03a9 (m \u2293 m\u03a9) id id \u03bc _) id\n    (measurable_id'' (inf_le_left : m \u2293 m\u03a9 \u2264 m))\n#align probability_theory.condexp_kernel ProbabilityTheory.condexpKernel\n\nlemma condexpKernel_apply_eq_condDistrib {\u03c9 : \u03a9} :\n    condexpKernel \u03bc m \u03c9 = @condDistrib \u03a9 \u03a9 \u03a9 m\u03a9 _ _ m\u03a9 (m \u2293 m\u03a9) id id \u03bc _ (id \u03c9) := by\n  simp_rw [condexpKernel, kernel.comap_apply]\n\ninstance : IsMarkovKernel (condexpKernel \u03bc m) := by simp only [condexpKernel]; infer_instance\n\nsection Measurability\n\nvariable [NormedAddCommGroup F] {f : \u03a9 \u2192 F}\n\n"}
{"name": "Coprime.gcd_mul_left_cancel_right78", "split": "test", "formal_statement": "theorem Coprime.gcd_mul_left_cancel_right (m : \u2115+) {n k : \u2115+} :\n    k.Coprime m \u2192 m.gcd (k * n) = m.gcd n := by", "header": "\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.prime from \"leanprover-community/mathlib\"@\"09597669f02422ed388036273d8848119699c22f\"\n\n\n\n\nnamespace PNat\n\nopen Nat\n\n\ndef gcd (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.gcd (n : \u2115) (m : \u2115), Nat.gcd_pos_of_pos_left (m : \u2115) n.pos\u27e9\n#align pnat.gcd PNat.gcd\n\n\ndef lcm (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.lcm (n : \u2115) (m : \u2115), by\n    let h := mul_pos n.pos m.pos\n    rw [\u2190 gcd_mul_lcm (n : \u2115) (m : \u2115), mul_comm] at h\n    exact pos_of_dvd_of_pos (Dvd.intro (Nat.gcd (n : \u2115) (m : \u2115)) rfl) h\u27e9\n#align pnat.lcm PNat.lcm\n\n@[simp, norm_cast]\ntheorem gcd_coe (n m : \u2115+) : (gcd n m : \u2115) = Nat.gcd n m :=\n  rfl\n#align pnat.gcd_coe PNat.gcd_coe\n\n@[simp, norm_cast]\ntheorem lcm_coe (n m : \u2115+) : (lcm n m : \u2115) = Nat.lcm n m :=\n  rfl\n#align pnat.lcm_coe PNat.lcm_coe\n\ntheorem gcd_dvd_left (n m : \u2115+) : gcd n m \u2223 n :=\n  dvd_iff.2 (Nat.gcd_dvd_left (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_left PNat.gcd_dvd_left\n\ntheorem gcd_dvd_right (n m : \u2115+) : gcd n m \u2223 m :=\n  dvd_iff.2 (Nat.gcd_dvd_right (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_right PNat.gcd_dvd_right\n\ntheorem dvd_gcd {m n k : \u2115+} (hm : k \u2223 m) (hn : k \u2223 n) : k \u2223 gcd m n :=\n  dvd_iff.2 (Nat.dvd_gcd (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.dvd_gcd PNat.dvd_gcd\n\ntheorem dvd_lcm_left (n m : \u2115+) : n \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_left (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_left PNat.dvd_lcm_left\n\ntheorem dvd_lcm_right (n m : \u2115+) : m \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_right (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_right PNat.dvd_lcm_right\n\ntheorem lcm_dvd {m n k : \u2115+} (hm : m \u2223 k) (hn : n \u2223 k) : lcm m n \u2223 k :=\n  dvd_iff.2 (@Nat.lcm_dvd (m : \u2115) (n : \u2115) (k : \u2115) (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.lcm_dvd PNat.lcm_dvd\n\ntheorem gcd_mul_lcm (n m : \u2115+) : gcd n m * lcm n m = n * m :=\n  Subtype.eq (Nat.gcd_mul_lcm (n : \u2115) (m : \u2115))\n#align pnat.gcd_mul_lcm PNat.gcd_mul_lcm\n\ntheorem eq_one_of_lt_two {n : \u2115+} : n < 2 \u2192 n = 1 := by\n  intro h; apply le_antisymm; swap\n  \u00b7 apply PNat.one_le\n  \u00b7 exact PNat.lt_add_one_iff.1 h\n#align pnat.eq_one_of_lt_two PNat.eq_one_of_lt_two\n\nsection Coprime\n\n\n\n\n\ndef Coprime (m n : \u2115+) : Prop :=\n  m.gcd n = 1\n#align pnat.coprime PNat.Coprime\n\n@[simp, norm_cast]\ntheorem coprime_coe {m n : \u2115+} : Nat.Coprime \u2191m \u2191n \u2194 m.Coprime n := by\n  unfold Nat.Coprime Coprime\n  rw [\u2190 coe_inj]\n  simp\n#align pnat.coprime_coe PNat.coprime_coe\n\ntheorem Coprime.mul {k m n : \u2115+} : m.Coprime k \u2192 n.Coprime k \u2192 (m * n).Coprime k := by\n  repeat rw [\u2190 coprime_coe]\n  rw [mul_coe]\n  apply Nat.Coprime.mul\n#align pnat.coprime.mul PNat.Coprime.mul\n\ntheorem Coprime.mul_right {k m n : \u2115+} : k.Coprime m \u2192 k.Coprime n \u2192 k.Coprime (m * n) := by\n  repeat rw [\u2190 coprime_coe]\n  rw [mul_coe]\n  apply Nat.Coprime.mul_right\n#align pnat.coprime.mul_right PNat.Coprime.mul_right\n\ntheorem gcd_comm {m n : \u2115+} : m.gcd n = n.gcd m := by\n  apply eq\n  simp only [gcd_coe]\n  apply Nat.gcd_comm\n#align pnat.gcd_comm PNat.gcd_comm\n\ntheorem gcd_eq_left_iff_dvd {m n : \u2115+} : m \u2223 n \u2194 m.gcd n = m := by\n  rw [dvd_iff]\n  rw [Nat.gcd_eq_left_iff_dvd]\n  rw [\u2190 coe_inj]\n  simp\n#align pnat.gcd_eq_left_iff_dvd PNat.gcd_eq_left_iff_dvd\n\ntheorem gcd_eq_right_iff_dvd {m n : \u2115+} : m \u2223 n \u2194 n.gcd m = m := by\n  rw [gcd_comm]\n  apply gcd_eq_left_iff_dvd\n#align pnat.gcd_eq_right_iff_dvd PNat.gcd_eq_right_iff_dvd\n\ntheorem Coprime.gcd_mul_left_cancel (m : \u2115+) {n k : \u2115+} :\n    k.Coprime n \u2192 (k * m).gcd n = m.gcd n := by\n  intro h; apply eq; simp only [gcd_coe, mul_coe]\n  apply Nat.Coprime.gcd_mul_left_cancel; simpa\n#align pnat.coprime.gcd_mul_left_cancel PNat.Coprime.gcd_mul_left_cancel\n\ntheorem Coprime.gcd_mul_right_cancel (m : \u2115+) {n k : \u2115+} :\n    k.Coprime n \u2192 (m * k).gcd n = m.gcd n := by rw [mul_comm]; apply Coprime.gcd_mul_left_cancel\n#align pnat.coprime.gcd_mul_right_cancel PNat.Coprime.gcd_mul_right_cancel\n\n"}
{"name": "Coprime.mul_right79", "split": "test", "formal_statement": "theorem Coprime.mul_right {k m n : \u2115+} : k.Coprime m \u2192 k.Coprime n \u2192 k.Coprime (m * n) := by", "header": "\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.prime from \"leanprover-community/mathlib\"@\"09597669f02422ed388036273d8848119699c22f\"\n\n\n\n\nnamespace PNat\n\nopen Nat\n\n\ndef gcd (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.gcd (n : \u2115) (m : \u2115), Nat.gcd_pos_of_pos_left (m : \u2115) n.pos\u27e9\n#align pnat.gcd PNat.gcd\n\n\ndef lcm (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.lcm (n : \u2115) (m : \u2115), by\n    let h := mul_pos n.pos m.pos\n    rw [\u2190 gcd_mul_lcm (n : \u2115) (m : \u2115), mul_comm] at h\n    exact pos_of_dvd_of_pos (Dvd.intro (Nat.gcd (n : \u2115) (m : \u2115)) rfl) h\u27e9\n#align pnat.lcm PNat.lcm\n\n@[simp, norm_cast]\ntheorem gcd_coe (n m : \u2115+) : (gcd n m : \u2115) = Nat.gcd n m :=\n  rfl\n#align pnat.gcd_coe PNat.gcd_coe\n\n@[simp, norm_cast]\ntheorem lcm_coe (n m : \u2115+) : (lcm n m : \u2115) = Nat.lcm n m :=\n  rfl\n#align pnat.lcm_coe PNat.lcm_coe\n\ntheorem gcd_dvd_left (n m : \u2115+) : gcd n m \u2223 n :=\n  dvd_iff.2 (Nat.gcd_dvd_left (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_left PNat.gcd_dvd_left\n\ntheorem gcd_dvd_right (n m : \u2115+) : gcd n m \u2223 m :=\n  dvd_iff.2 (Nat.gcd_dvd_right (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_right PNat.gcd_dvd_right\n\ntheorem dvd_gcd {m n k : \u2115+} (hm : k \u2223 m) (hn : k \u2223 n) : k \u2223 gcd m n :=\n  dvd_iff.2 (Nat.dvd_gcd (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.dvd_gcd PNat.dvd_gcd\n\ntheorem dvd_lcm_left (n m : \u2115+) : n \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_left (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_left PNat.dvd_lcm_left\n\ntheorem dvd_lcm_right (n m : \u2115+) : m \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_right (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_right PNat.dvd_lcm_right\n\ntheorem lcm_dvd {m n k : \u2115+} (hm : m \u2223 k) (hn : n \u2223 k) : lcm m n \u2223 k :=\n  dvd_iff.2 (@Nat.lcm_dvd (m : \u2115) (n : \u2115) (k : \u2115) (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.lcm_dvd PNat.lcm_dvd\n\ntheorem gcd_mul_lcm (n m : \u2115+) : gcd n m * lcm n m = n * m :=\n  Subtype.eq (Nat.gcd_mul_lcm (n : \u2115) (m : \u2115))\n#align pnat.gcd_mul_lcm PNat.gcd_mul_lcm\n\ntheorem eq_one_of_lt_two {n : \u2115+} : n < 2 \u2192 n = 1 := by\n  intro h; apply le_antisymm; swap\n  \u00b7 apply PNat.one_le\n  \u00b7 exact PNat.lt_add_one_iff.1 h\n#align pnat.eq_one_of_lt_two PNat.eq_one_of_lt_two\n\nsection Coprime\n\n\n\n\n\ndef Coprime (m n : \u2115+) : Prop :=\n  m.gcd n = 1\n#align pnat.coprime PNat.Coprime\n\n@[simp, norm_cast]\ntheorem coprime_coe {m n : \u2115+} : Nat.Coprime \u2191m \u2191n \u2194 m.Coprime n := by\n  unfold Nat.Coprime Coprime\n  rw [\u2190 coe_inj]\n  simp\n#align pnat.coprime_coe PNat.coprime_coe\n\ntheorem Coprime.mul {k m n : \u2115+} : m.Coprime k \u2192 n.Coprime k \u2192 (m * n).Coprime k := by\n  repeat rw [\u2190 coprime_coe]\n  rw [mul_coe]\n  apply Nat.Coprime.mul\n#align pnat.coprime.mul PNat.Coprime.mul\n\n"}
{"name": "smul_le_self_of_tower80", "split": "test", "formal_statement": "theorem smul_le_self_of_tower {\u03b1 : Type*} [Semiring \u03b1] [Module \u03b1 R] [Module \u03b1 M]\n    [SMulCommClass \u03b1 R M] [IsScalarTower \u03b1 R M] (a : \u03b1) (S : Submodule R M) : a \u2022 S \u2264 S := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Pointwise\nimport Mathlib.Algebra.Module.BigOperators\nimport Mathlib.Algebra.Order.Group.Action\nimport Mathlib.LinearAlgebra.Finsupp\nimport Mathlib.LinearAlgebra.Span\nimport Mathlib.RingTheory.Ideal.Basic\n\n#align_import algebra.module.submodule.pointwise from \"leanprover-community/mathlib\"@\"48085f140e684306f9e7da907cd5932056d1aded\"\n\n\n\n\nvariable {\u03b1 : Type*} {R : Type*} {M : Type*}\n\nopen Pointwise\n\nnamespace Submodule\n\nsection Neg\n\nvariable [Semiring R] [AddCommMonoid M] [Module R M]\n\ninstance pointwiseZero : Zero (Submodule R M) where\n  zero := \u22a5\n\ninstance pointwiseAdd : Add (Submodule R M) where\n  add := (\u00b7 \u2294 \u00b7)\n\ninstance pointwiseAddCommMonoid : AddCommMonoid (Submodule R M) where\n  add_assoc := sup_assoc\n  zero_add := bot_sup_eq\n  add_zero := sup_bot_eq\n  add_comm := sup_comm\n  nsmul := nsmulRec\n#align submodule.pointwise_add_comm_monoid Submodule.pointwiseAddCommMonoid\n\n@[simp]\ntheorem add_eq_sup (p q : Submodule R M) : p + q = p \u2294 q :=\n  rfl\n#align submodule.add_eq_sup Submodule.add_eq_sup\n\n@[simp]\ntheorem zero_eq_bot : (0 : Submodule R M) = \u22a5 :=\n  rfl\n#align submodule.zero_eq_bot Submodule.zero_eq_bot\n\ninstance : CanonicallyOrderedAddCommMonoid (Submodule R M) :=\n  { Submodule.pointwiseAddCommMonoid,\n    Submodule.completeLattice with\n    add_le_add_left := fun _a _b => sup_le_sup_left\n    exists_add_of_le := @fun _a b h => \u27e8b, (sup_eq_right.2 h).symm\u27e9\n    le_self_add := fun _a _b => le_sup_left }\n\nsection\n\nvariable [Monoid \u03b1] [DistribMulAction \u03b1 M] [SMulCommClass \u03b1 R M]\n\n\nprotected def pointwiseDistribMulAction : DistribMulAction \u03b1 (Submodule R M) where\n  smul a S := S.map (DistribMulAction.toLinearMap R M a : M \u2192\u2097[R] M)\n  one_smul S :=\n    (congr_arg (fun f : Module.End R M => S.map f) (LinearMap.ext <| one_smul \u03b1)).trans S.map_id\n  mul_smul _a\u2081 _a\u2082 S :=\n    (congr_arg (fun f : Module.End R M => S.map f) (LinearMap.ext <| mul_smul _ _)).trans\n      (S.map_comp _ _)\n  smul_zero _a := map_bot _\n  smul_add _a _S\u2081 _S\u2082 := map_sup _ _ _\n#align submodule.pointwise_distrib_mul_action Submodule.pointwiseDistribMulAction\n\nscoped[Pointwise] attribute [instance] Submodule.pointwiseDistribMulAction\n\nopen Pointwise\n\n@[simp]\ntheorem coe_pointwise_smul (a : \u03b1) (S : Submodule R M) : \u2191(a \u2022 S) = a \u2022 (S : Set M) :=\n  rfl\n#align submodule.coe_pointwise_smul Submodule.coe_pointwise_smul\n\n@[simp]\ntheorem pointwise_smul_toAddSubmonoid (a : \u03b1) (S : Submodule R M) :\n    (a \u2022 S).toAddSubmonoid = a \u2022 S.toAddSubmonoid :=\n  rfl\n#align submodule.pointwise_smul_to_add_submonoid Submodule.pointwise_smul_toAddSubmonoid\n\n@[simp]\ntheorem pointwise_smul_toAddSubgroup {R M : Type*} [Ring R] [AddCommGroup M] [DistribMulAction \u03b1 M]\n    [Module R M] [SMulCommClass \u03b1 R M] (a : \u03b1) (S : Submodule R M) :\n    (a \u2022 S).toAddSubgroup = a \u2022 S.toAddSubgroup :=\n  rfl\n#align submodule.pointwise_smul_to_add_subgroup Submodule.pointwise_smul_toAddSubgroup\n\ntheorem smul_mem_pointwise_smul (m : M) (a : \u03b1) (S : Submodule R M) : m \u2208 S \u2192 a \u2022 m \u2208 a \u2022 S :=\n  (Set.smul_mem_smul_set : _ \u2192 _ \u2208 a \u2022 (S : Set M))\n#align submodule.smul_mem_pointwise_smul Submodule.smul_mem_pointwise_smul\n\ninstance : CovariantClass \u03b1 (Submodule R M) HSMul.hSMul LE.le :=\n  \u27e8fun _ _ => map_mono\u27e9\n\n\n@[simp]\ntheorem smul_bot' (a : \u03b1) : a \u2022 (\u22a5 : Submodule R M) = \u22a5 :=\n  map_bot _\n#align submodule.smul_bot' Submodule.smul_bot'\n\n\ntheorem smul_sup' (a : \u03b1) (S T : Submodule R M) : a \u2022 (S \u2294 T) = a \u2022 S \u2294 a \u2022 T :=\n  map_sup _ _ _\n#align submodule.smul_sup' Submodule.smul_sup'\n\ntheorem smul_span (a : \u03b1) (s : Set M) : a \u2022 span R s = span R (a \u2022 s) :=\n  map_span _ _\n#align submodule.smul_span Submodule.smul_span\n\ntheorem span_smul (a : \u03b1) (s : Set M) : span R (a \u2022 s) = a \u2022 span R s :=\n  Eq.symm (span_image _).symm\n#align submodule.span_smul Submodule.span_smul\n\ninstance pointwiseCentralScalar [DistribMulAction \u03b1\u1d50\u1d52\u1d56 M] [SMulCommClass \u03b1\u1d50\u1d52\u1d56 R M]\n    [IsCentralScalar \u03b1 M] : IsCentralScalar \u03b1 (Submodule R M) :=\n  \u27e8fun _a S => (congr_arg fun f : Module.End R M => S.map f) <| LinearMap.ext <| op_smul_eq_smul _\u27e9\n#align submodule.pointwise_central_scalar Submodule.pointwiseCentralScalar\n\n@[simp]\n"}
{"name": "multipliable_mabs_iff81", "split": "test", "formal_statement": "theorem multipliable_mabs_iff [LinearOrderedCommGroup \u03b1] [UniformSpace \u03b1] [UniformGroup \u03b1]\n    [CompleteSpace \u03b1] {f : \u03b9 \u2192 \u03b1} : (Multipliable fun x \u21a6 mabs (f x)) \u2194 Multipliable f :=\n  let s := { x | 1 \u2264 f x }\n  have h1 : \u2200 x : s, mabs (f x) = f x := fun x \u21a6 mabs_of_one_le x.2\n  have h2 : \u2200 x : \u2191s\u1d9c, mabs (f x) = (f x)\u207b\u00b9 := fun x \u21a6 mabs_of_lt_one (not_le.1 x.2)\n  calc (Multipliable fun x \u21a6 mabs (f x)) \u2194\n      (Multipliable fun x : s \u21a6 mabs (f x)) \u2227 Multipliable fun x : \u2191s\u1d9c \u21a6 mabs (f x) :=\n        multipliable_subtype_and_compl.symm\n  _ \u2194 (Multipliable fun x : s \u21a6 f x) \u2227 Multipliable fun x : \u2191s\u1d9c \u21a6 (f x)\u207b\u00b9 := by", "header": "\nimport Mathlib.Algebra.Order.Archimedean\nimport Mathlib.Topology.Algebra.InfiniteSum.NatInt\nimport Mathlib.Topology.Algebra.Order.Field\nimport Mathlib.Topology.Order.MonotoneConvergence\n\n#align_import topology.algebra.infinite_sum.order from \"leanprover-community/mathlib\"@\"32253a1a1071173b33dc7d6a218cf722c6feb514\"\n\n\n\n\nopen Finset Filter Function\nopen scoped Classical\n\nvariable {\u03b9 \u03ba \u03b1 : Type*}\n\nsection LinearOrder\n\n\n\n@[to_additive]\ntheorem hasProd_of_isLUB_of_one_le [LinearOrderedCommMonoid \u03b1] [TopologicalSpace \u03b1]\n    [OrderTopology \u03b1] {f : \u03b9 \u2192 \u03b1} (i : \u03b1) (h : \u2200 i, 1 \u2264 f i)\n    (hf : IsLUB (Set.range fun s \u21a6 \u220f i \u2208 s, f i) i) : HasProd f i :=\n  tendsto_atTop_isLUB (Finset.prod_mono_set_of_one_le' h) hf\n#align has_sum_of_is_lub_of_nonneg hasSum_of_isLUB_of_nonneg\n\n@[to_additive]\ntheorem hasProd_of_isLUB [CanonicallyLinearOrderedCommMonoid \u03b1] [TopologicalSpace \u03b1]\n    [OrderTopology \u03b1] {f : \u03b9 \u2192 \u03b1} (b : \u03b1) (hf : IsLUB (Set.range fun s \u21a6 \u220f i \u2208 s, f i) b) :\n    HasProd f b :=\n  tendsto_atTop_isLUB (Finset.prod_mono_set' f) hf\n#align has_sum_of_is_lub hasSum_of_isLUB\n\n@[to_additive]\n"}
{"name": "factors_one82", "split": "test", "formal_statement": "theorem factors_one : factors 1 = [] := by", "header": "\nimport Mathlib.Algebra.BigOperators.Ring.List\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.List.Prime\nimport Mathlib.Data.List.Sort\nimport Mathlib.Data.List.Chain\n\n#align_import data.nat.factors from \"leanprover-community/mathlib\"@\"008205aa645b3f194c1da47025c5f110c8406eab\"\n\n\n\nopen Bool Subtype\n\nopen Nat\n\nnamespace Nat\n\nattribute [instance 0] instBEqNat\n\n\ndef factors : \u2115 \u2192 List \u2115\n  | 0 => []\n  | 1 => []\n  | k + 2 =>\n    let m := minFac (k + 2)\n    m :: factors ((k + 2) / m)\ndecreasing_by show (k + 2) / m < (k + 2); exact factors_lemma\n#align nat.factors Nat.factors\n\n@[simp]\ntheorem factors_zero : factors 0 = [] := by rw [factors]\n#align nat.factors_zero Nat.factors_zero\n\n@[simp]\n"}
{"name": "angle_self83", "split": "test", "formal_statement": "theorem angle_self {x : V} (hx : x \u2260 0) : angle x x = 0 := by", "header": "\nimport Mathlib.Analysis.InnerProductSpace.Basic\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Inverse\n\n#align_import geometry.euclidean.angle.unoriented.basic from \"leanprover-community/mathlib\"@\"46b633fd842bef9469441c0209906f6dddd2b4f5\"\n\n\n\n\nassert_not_exists HasFDerivAt\n\nassert_not_exists ConformalAt\n\nnoncomputable section\n\nopen Real Set\n\nopen Real\n\nopen RealInnerProductSpace\n\nnamespace InnerProductGeometry\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] {x y : V}\n\n\ndef angle (x y : V) : \u211d :=\n  Real.arccos (\u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016))\n#align inner_product_geometry.angle InnerProductGeometry.angle\n\ntheorem continuousAt_angle {x : V \u00d7 V} (hx1 : x.1 \u2260 0) (hx2 : x.2 \u2260 0) :\n    ContinuousAt (fun y : V \u00d7 V => angle y.1 y.2) x :=\n  Real.continuous_arccos.continuousAt.comp <|\n    continuous_inner.continuousAt.div\n      ((continuous_norm.comp continuous_fst).mul (continuous_norm.comp continuous_snd)).continuousAt\n      (by simp [hx1, hx2])\n#align inner_product_geometry.continuous_at_angle InnerProductGeometry.continuousAt_angle\n\ntheorem angle_smul_smul {c : \u211d} (hc : c \u2260 0) (x y : V) : angle (c \u2022 x) (c \u2022 y) = angle x y := by\n  have : c * c \u2260 0 := mul_ne_zero hc hc\n  rw [angle, angle, real_inner_smul_left, inner_smul_right, norm_smul, norm_smul, Real.norm_eq_abs,\n    mul_mul_mul_comm _ \u2016x\u2016, abs_mul_abs_self, \u2190 mul_assoc c c, mul_div_mul_left _ _ this]\n#align inner_product_geometry.angle_smul_smul InnerProductGeometry.angle_smul_smul\n\n@[simp]\ntheorem _root_.LinearIsometry.angle_map {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F]\n    [InnerProductSpace \u211d E] [InnerProductSpace \u211d F] (f : E \u2192\u2097\u1d62[\u211d] F) (u v : E) :\n    angle (f u) (f v) = angle u v := by\n  rw [angle, angle, f.inner_map_map, f.norm_map, f.norm_map]\n#align linear_isometry.angle_map LinearIsometry.angle_map\n\n@[simp, norm_cast]\ntheorem _root_.Submodule.angle_coe {s : Submodule \u211d V} (x y : s) :\n    angle (x : V) (y : V) = angle x y :=\n  s.subtype\u2097\u1d62.angle_map x y\n#align submodule.angle_coe Submodule.angle_coe\n\n\ntheorem cos_angle (x y : V) : Real.cos (angle x y) = \u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016) :=\n  Real.cos_arccos (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).1\n    (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2\n#align inner_product_geometry.cos_angle InnerProductGeometry.cos_angle\n\n\ntheorem angle_comm (x y : V) : angle x y = angle y x := by\n  unfold angle\n  rw [real_inner_comm, mul_comm]\n#align inner_product_geometry.angle_comm InnerProductGeometry.angle_comm\n\n\n@[simp]\ntheorem angle_neg_neg (x y : V) : angle (-x) (-y) = angle x y := by\n  unfold angle\n  rw [inner_neg_neg, norm_neg, norm_neg]\n#align inner_product_geometry.angle_neg_neg InnerProductGeometry.angle_neg_neg\n\n\ntheorem angle_nonneg (x y : V) : 0 \u2264 angle x y :=\n  Real.arccos_nonneg _\n#align inner_product_geometry.angle_nonneg InnerProductGeometry.angle_nonneg\n\n\ntheorem angle_le_pi (x y : V) : angle x y \u2264 \u03c0 :=\n  Real.arccos_le_pi _\n#align inner_product_geometry.angle_le_pi InnerProductGeometry.angle_le_pi\n\n\ntheorem angle_neg_right (x y : V) : angle x (-y) = \u03c0 - angle x y := by\n  unfold angle\n  rw [\u2190 Real.arccos_neg, norm_neg, inner_neg_right, neg_div]\n#align inner_product_geometry.angle_neg_right InnerProductGeometry.angle_neg_right\n\n\ntheorem angle_neg_left (x y : V) : angle (-x) y = \u03c0 - angle x y := by\n  rw [\u2190 angle_neg_neg, neg_neg, angle_neg_right]\n#align inner_product_geometry.angle_neg_left InnerProductGeometry.angle_neg_left\n\nproof_wanted angle_triangle (x y z : V) : angle x z \u2264 angle x y + angle y z\n\n\n@[simp]\ntheorem angle_zero_left (x : V) : angle 0 x = \u03c0 / 2 := by\n  unfold angle\n  rw [inner_zero_left, zero_div, Real.arccos_zero]\n#align inner_product_geometry.angle_zero_left InnerProductGeometry.angle_zero_left\n\n\n@[simp]\ntheorem angle_zero_right (x : V) : angle x 0 = \u03c0 / 2 := by\n  unfold angle\n  rw [inner_zero_right, zero_div, Real.arccos_zero]\n#align inner_product_geometry.angle_zero_right InnerProductGeometry.angle_zero_right\n\n\n@[simp]\n"}
{"name": "fromSingle\u2080KernelAtZeroIso_inv_eq84", "split": "test", "formal_statement": "theorem fromSingle\u2080KernelAtZeroIso_inv_eq [hf : QuasiIso' f] :\n    f.fromSingle\u2080KernelAtZeroIso.inv =\n      kernel.lift (X.d 0 1) (f.f 0) (by rw [f.2 0 1 rfl]; exact zero_comp) := by", "header": "\nimport Mathlib.Algebra.Homology.Homotopy\nimport Mathlib.Algebra.Homology.SingleHomology\nimport Mathlib.CategoryTheory.Abelian.Homology\n\n#align_import algebra.homology.quasi_iso from \"leanprover-community/mathlib\"@\"956af7c76589f444f2e1313911bad16366ea476d\"\n\n\n\n\nopen CategoryTheory Limits\n\nuniverse v u\n\nvariable {\u03b9 : Type*}\n\nsection\n\nvariable {V : Type u} [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]\nvariable [HasEqualizers V] [HasImages V] [HasImageMaps V] [HasCokernels V]\nvariable {c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}\n\n\nclass QuasiIso' (f : C \u27f6 D) : Prop where\n  isIso : \u2200 i, IsIso ((homology'Functor V c i).map f)\n#align quasi_iso QuasiIso'\n\nattribute [instance] QuasiIso'.isIso\n\ninstance (priority := 100) quasiIso'_of_iso (f : C \u27f6 D) [IsIso f] : QuasiIso' f where\n  isIso i := by\n    change IsIso ((homology'Functor V c i).mapIso (asIso f)).hom\n    infer_instance\n#align quasi_iso_of_iso quasiIso'_of_iso\n\ninstance quasiIso'_comp (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' g] :\n    QuasiIso' (f \u226b g) where\n  isIso i := by\n    rw [Functor.map_comp]\n    infer_instance\n#align quasi_iso_comp quasiIso'_comp\n\ntheorem quasiIso'_of_comp_left (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' (f \u226b g)] :\n    QuasiIso' g :=\n  { isIso := fun i => IsIso.of_isIso_fac_left ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_left quasiIso'_of_comp_left\n\ntheorem quasiIso'_of_comp_right (f : C \u27f6 D) (g : D \u27f6 E) [QuasiIso' g] [QuasiIso' (f \u226b g)] :\n    QuasiIso' f :=\n  { isIso := fun i => IsIso.of_isIso_fac_right ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_right quasiIso'_of_comp_right\n\nnamespace HomologicalComplex.Hom\n\nsection ToSingle\u2080\n\nvariable {W : Type*} [Category W] [Abelian W]\n\nsection\n\nvariable {X : ChainComplex W \u2115} {Y : W} (f : X \u27f6 (ChainComplex.single\u2080 _).obj Y) [hf : QuasiIso' f]\n\n\nnoncomputable def toSingle\u2080CokernelAtZeroIso : cokernel (X.d 1 0) \u2245 Y :=\n  X.homology'ZeroIso.symm.trans\n    ((@asIso _ _ _ _ _ (hf.1 0)).trans ((ChainComplex.homology'Functor0Single\u2080 W).app Y))\n#align homological_complex.hom.to_single\u2080_cokernel_at_zero_iso HomologicalComplex.Hom.toSingle\u2080CokernelAtZeroIso\n\ntheorem toSingle\u2080CokernelAtZeroIso_hom_eq [hf : QuasiIso' f] :\n    f.toSingle\u2080CokernelAtZeroIso.hom =\n      cokernel.desc (X.d 1 0) (f.f 0) (by rw [\u2190 f.2 1 0 rfl]; exact comp_zero) := by\n  ext\n  dsimp only [toSingle\u2080CokernelAtZeroIso, ChainComplex.homology'ZeroIso, homology'OfZeroRight,\n    homology'.mapIso, ChainComplex.homology'Functor0Single\u2080, cokernel.map]\n  dsimp [asIso]\n  simp only [cokernel.\u03c0_desc, Category.assoc, homology'.map_desc, cokernel.\u03c0_desc_assoc]\n  simp [homology'.desc, Iso.refl_inv (X.X 0)]\n#align homological_complex.hom.to_single\u2080_cokernel_at_zero_iso_hom_eq HomologicalComplex.Hom.toSingle\u2080CokernelAtZeroIso_hom_eq\n\ntheorem to_single\u2080_epi_at_zero [hf : QuasiIso' f] : Epi (f.f 0) := by\n  constructor\n  intro Z g h Hgh\n  rw [\u2190 cokernel.\u03c0_desc (X.d 1 0) (f.f 0) (by rw [\u2190 f.2 1 0 rfl]; exact comp_zero),\n    \u2190 toSingle\u2080CokernelAtZeroIso_hom_eq] at Hgh\n  rw [(@cancel_epi _ _ _ _ _ _ (epi_comp _ _) _ _).1 Hgh]\n#align homological_complex.hom.to_single\u2080_epi_at_zero HomologicalComplex.Hom.to_single\u2080_epi_at_zero\n\ntheorem to_single\u2080_exact_d_f_at_zero [hf : QuasiIso' f] : Exact (X.d 1 0) (f.f 0) := by\n  rw [Preadditive.exact_iff_homology'_zero]\n  have h : X.d 1 0 \u226b f.f 0 = 0 := by simp only [\u2190 f.comm 1 0, single_obj_d, comp_zero]\n  refine \u27e8h, Nonempty.intro (homology'IsoKernelDesc _ _ _ \u226a\u226b ?_)\u27e9\n  suffices IsIso (cokernel.desc _ _ h) by apply kernel.ofMono\n  rw [\u2190 toSingle\u2080CokernelAtZeroIso_hom_eq]\n  infer_instance\n#align homological_complex.hom.to_single\u2080_exact_d_f_at_zero HomologicalComplex.Hom.to_single\u2080_exact_d_f_at_zero\n\ntheorem to_single\u2080_exact_at_succ [hf : QuasiIso' f] (n : \u2115) :\n    Exact (X.d (n + 2) (n + 1)) (X.d (n + 1) n) :=\n  (Preadditive.exact_iff_homology'_zero _ _).2\n    \u27e8X.d_comp_d _ _ _,\n      \u27e8(ChainComplex.homology'SuccIso _ _).symm.trans\n          ((@asIso _ _ _ _ _ (hf.1 (n + 1))).trans homology'ZeroZero)\u27e9\u27e9\n#align homological_complex.hom.to_single\u2080_exact_at_succ HomologicalComplex.Hom.to_single\u2080_exact_at_succ\n\nend\n\nsection\n\nvariable {X : CochainComplex W \u2115} {Y : W} (f : (CochainComplex.single\u2080 _).obj Y \u27f6 X)\n\n\nnoncomputable def fromSingle\u2080KernelAtZeroIso [hf : QuasiIso' f] : kernel (X.d 0 1) \u2245 Y :=\n  X.homology'ZeroIso.symm.trans\n    ((@asIso _ _ _ _ _ (hf.1 0)).symm.trans ((CochainComplex.homologyFunctor0Single\u2080 W).app Y))\n#align homological_complex.hom.from_single\u2080_kernel_at_zero_iso HomologicalComplex.Hom.fromSingle\u2080KernelAtZeroIso\n\n"}
{"name": "tendstoInMeasure_iff_norm85", "split": "test", "formal_statement": "theorem tendstoInMeasure_iff_norm [SeminormedAddCommGroup E] {l : Filter \u03b9} {f : \u03b9 \u2192 \u03b1 \u2192 E}\n    {g : \u03b1 \u2192 E} :\n    TendstoInMeasure \u03bc f l g \u2194\n      \u2200 \u03b5, 0 < \u03b5 \u2192 Tendsto (fun i => \u03bc { x | \u03b5 \u2264 \u2016f i x - g x\u2016 }) l (\ud835\udcdd 0) := by", "header": "\nimport Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.MeasureTheory.Function.Egorov\nimport Mathlib.MeasureTheory.Function.LpSpace\n\n#align_import measure_theory.function.convergence_in_measure from \"leanprover-community/mathlib\"@\"0b9eaaa7686280fad8cce467f5c3c57ee6ce77f8\"\n\n\n\n\nopen TopologicalSpace Filter\n\nopen scoped NNReal ENNReal MeasureTheory Topology\n\nnamespace MeasureTheory\n\nvariable {\u03b1 \u03b9 E : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n\n\ndef TendstoInMeasure [Dist E] {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (f : \u03b9 \u2192 \u03b1 \u2192 E) (l : Filter \u03b9)\n    (g : \u03b1 \u2192 E) : Prop :=\n  \u2200 \u03b5, 0 < \u03b5 \u2192 Tendsto (fun i => \u03bc { x | \u03b5 \u2264 dist (f i x) (g x) }) l (\ud835\udcdd 0)\n#align measure_theory.tendsto_in_measure MeasureTheory.TendstoInMeasure\n\n"}
{"name": "MeasureTheory.measure_unitBall_eq_integral_div_gamma86", "split": "test", "formal_statement": "theorem MeasureTheory.measure_unitBall_eq_integral_div_gamma {E : Type*} {p : \u211d}\n    [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E]\n    [BorelSpace E] (\u03bc : Measure E) [IsAddHaarMeasure \u03bc] (hp : 0 < p) :\n    \u03bc (Metric.ball 0 1) =\n      .ofReal ((\u222b (x : E), Real.exp (- \u2016x\u2016 ^ p) \u2202\u03bc) / Real.Gamma (finrank \u211d E / p + 1)) := by", "header": "\nimport Mathlib.MeasureTheory.Constructions.HaarToSphere\nimport Mathlib.MeasureTheory.Integral.Gamma\nimport Mathlib.MeasureTheory.Integral.Pi\nimport Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup\n\n\n\nsection general_case\n\nopen MeasureTheory MeasureTheory.Measure FiniteDimensional ENNReal\n\n"}
{"name": "factors_add_two87", "split": "test", "formal_statement": "theorem factors_add_two (n : \u2115) :\n    factors (n + 2) = minFac (n + 2) :: factors ((n + 2) / minFac (n + 2)) := by", "header": "\nimport Mathlib.Algebra.BigOperators.Ring.List\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.List.Prime\nimport Mathlib.Data.List.Sort\nimport Mathlib.Data.List.Chain\n\n#align_import data.nat.factors from \"leanprover-community/mathlib\"@\"008205aa645b3f194c1da47025c5f110c8406eab\"\n\n\n\nopen Bool Subtype\n\nopen Nat\n\nnamespace Nat\n\nattribute [instance 0] instBEqNat\n\n\ndef factors : \u2115 \u2192 List \u2115\n  | 0 => []\n  | 1 => []\n  | k + 2 =>\n    let m := minFac (k + 2)\n    m :: factors ((k + 2) / m)\ndecreasing_by show (k + 2) / m < (k + 2); exact factors_lemma\n#align nat.factors Nat.factors\n\n@[simp]\ntheorem factors_zero : factors 0 = [] := by rw [factors]\n#align nat.factors_zero Nat.factors_zero\n\n@[simp]\ntheorem factors_one : factors 1 = [] := by rw [factors]\n#align nat.factors_one Nat.factors_one\n\n@[simp]\ntheorem factors_two : factors 2 = [2] := by simp [factors]\n\ntheorem prime_of_mem_factors {n : \u2115} : \u2200 {p : \u2115}, (h : p \u2208 factors n) \u2192 Prime p := by\n  match n with\n  | 0 => simp\n  | 1 => simp\n  | k + 2 =>\n      intro p h\n      let m := minFac (k + 2)\n      have : (k + 2) / m < (k + 2) := factors_lemma\n      have h\u2081 : p = m \u2228 p \u2208 factors ((k + 2) / m) :=\n        List.mem_cons.1 (by rwa [factors] at h)\n      exact Or.casesOn h\u2081 (fun h\u2082 => h\u2082.symm \u25b8 minFac_prime (by simp)) prime_of_mem_factors\n#align nat.prime_of_mem_factors Nat.prime_of_mem_factors\n\ntheorem pos_of_mem_factors {n p : \u2115} (h : p \u2208 factors n) : 0 < p :=\n  Prime.pos (prime_of_mem_factors h)\n#align nat.pos_of_mem_factors Nat.pos_of_mem_factors\n\ntheorem prod_factors : \u2200 {n}, n \u2260 0 \u2192 List.prod (factors n) = n\n  | 0 => by simp\n  | 1 => by simp\n  | k + 2 => fun _ =>\n    let m := minFac (k + 2)\n    have : (k + 2) / m < (k + 2) := factors_lemma\n    show (factors (k + 2)).prod = (k + 2) by\n      have h\u2081 : (k + 2) / m \u2260 0 := fun h => by\n        have : (k + 2) = 0 * m := (Nat.div_eq_iff_eq_mul_left (minFac_pos _) (minFac_dvd _)).1 h\n        rw [zero_mul] at this; exact (show k + 2 \u2260 0 by simp) this\n      rw [factors, List.prod_cons, prod_factors h\u2081, Nat.mul_div_cancel' (minFac_dvd _)]\n#align nat.prod_factors Nat.prod_factors\n\ntheorem factors_prime {p : \u2115} (hp : Nat.Prime p) : p.factors = [p] := by\n  have : p = p - 2 + 2 := (tsub_eq_iff_eq_add_of_le hp.two_le).mp rfl\n  rw [this, Nat.factors]\n  simp only [Eq.symm this]\n  have : Nat.minFac p = p := (Nat.prime_def_minFac.mp hp).2\n  simp only [this, Nat.factors, Nat.div_self (Nat.Prime.pos hp)]\n#align nat.factors_prime Nat.factors_prime\n\ntheorem factors_chain {n : \u2115} :\n    \u2200 {a}, (\u2200 p, Prime p \u2192 p \u2223 n \u2192 a \u2264 p) \u2192 List.Chain (\u00b7 \u2264 \u00b7) a (factors n) := by\n  match n with\n  | 0 => simp\n  | 1 => simp\n  | k + 2 =>\n      intro a h\n      let m := minFac (k + 2)\n      have : (k + 2) / m < (k + 2) := factors_lemma\n      rw [factors]\n      refine List.Chain.cons ((le_minFac.2 h).resolve_left (by simp)) (factors_chain ?_)\n      exact fun p pp d => minFac_le_of_dvd pp.two_le (d.trans <| div_dvd_of_dvd <| minFac_dvd _)\n#align nat.factors_chain Nat.factors_chain\n\ntheorem factors_chain_2 (n) : List.Chain (\u00b7 \u2264 \u00b7) 2 (factors n) :=\n  factors_chain fun _ pp _ => pp.two_le\n#align nat.factors_chain_2 Nat.factors_chain_2\n\ntheorem factors_chain' (n) : List.Chain' (\u00b7 \u2264 \u00b7) (factors n) :=\n  @List.Chain'.tail _ _ (_ :: _) (factors_chain_2 _)\n#align nat.factors_chain' Nat.factors_chain'\n\ntheorem factors_sorted (n : \u2115) : List.Sorted (\u00b7 \u2264 \u00b7) (factors n) :=\n  List.chain'_iff_pairwise.1 (factors_chain' _)\n#align nat.factors_sorted Nat.factors_sorted\n\n\n"}
{"name": "MeasureTheory.measure_le_eq_lt88", "split": "test", "formal_statement": "theorem MeasureTheory.measure_le_eq_lt [Nontrivial E] (r : \u211d) :\n    \u03bc {x : E | g x \u2264 r} = \u03bc {x : E | g x < r} := by", "header": "\nimport Mathlib.MeasureTheory.Constructions.HaarToSphere\nimport Mathlib.MeasureTheory.Integral.Gamma\nimport Mathlib.MeasureTheory.Integral.Pi\nimport Mathlib.Analysis.SpecialFunctions.Gamma.BohrMollerup\n\n\n\nsection general_case\n\nopen MeasureTheory MeasureTheory.Measure FiniteDimensional ENNReal\n\ntheorem MeasureTheory.measure_unitBall_eq_integral_div_gamma {E : Type*} {p : \u211d}\n    [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E] [MeasurableSpace E]\n    [BorelSpace E] (\u03bc : Measure E) [IsAddHaarMeasure \u03bc] (hp : 0 < p) :\n    \u03bc (Metric.ball 0 1) =\n      .ofReal ((\u222b (x : E), Real.exp (- \u2016x\u2016 ^ p) \u2202\u03bc) / Real.Gamma (finrank \u211d E / p + 1)) := by\n  obtain hE | hE := subsingleton_or_nontrivial E\n  \u00b7 rw [(Metric.nonempty_ball.mpr zero_lt_one).eq_zero, \u2190 integral_univ, Set.univ_nonempty.eq_zero,\n      integral_singleton, finrank_zero_of_subsingleton, Nat.cast_zero, zero_div, zero_add,\n      Real.Gamma_one, div_one, norm_zero, Real.zero_rpow (ne_of_gt hp), neg_zero, Real.exp_zero,\n      smul_eq_mul, mul_one, ofReal_toReal (measure_ne_top \u03bc {0})]\n  \u00b7 have : (0:\u211d) < finrank \u211d E := Nat.cast_pos.mpr finrank_pos\n    have : ((\u222b y in Set.Ioi (0:\u211d), y ^ (finrank \u211d E - 1) \u2022 Real.exp (-y ^ p)) /\n        Real.Gamma ((finrank \u211d E) / p + 1)) * (finrank \u211d E) = 1 := by\n      simp_rw [\u2190 Real.rpow_natCast _ (finrank \u211d E - 1), smul_eq_mul, Nat.cast_sub finrank_pos,\n        Nat.cast_one]\n      rw [integral_rpow_mul_exp_neg_rpow hp (by linarith), sub_add_cancel,\n        Real.Gamma_add_one (ne_of_gt (by positivity))]\n      field_simp; ring\n    rw [integral_fun_norm_addHaar \u03bc (fun x => Real.exp (- x ^ p)), nsmul_eq_mul, smul_eq_mul,\n      mul_div_assoc, mul_div_assoc, mul_comm, mul_assoc, this, mul_one, ofReal_toReal]\n    exact ne_of_lt measure_ball_lt_top\n\nvariable {E : Type*} [AddCommGroup E] [Module \u211d E] [FiniteDimensional \u211d E] [mE : MeasurableSpace E]\n  [tE : TopologicalSpace E] [TopologicalAddGroup E] [BorelSpace E] [T2Space E] [ContinuousSMul \u211d E]\n  (\u03bc : Measure E) [IsAddHaarMeasure \u03bc] {g : E \u2192 \u211d} (h1 : g 0 = 0) (h2 : \u2200 x, g (- x) = g x)\n  (h3 : \u2200 x y, g (x + y) \u2264 g x + g y) (h4 : \u2200 {x}, g x = 0 \u2192 x = 0)\n  (h5 : \u2200 r x, g (r \u2022 x) \u2264 |r| * (g x))\n\ntheorem MeasureTheory.measure_lt_one_eq_integral_div_gamma {p : \u211d} (hp : 0 < p) :\n    \u03bc {x : E | g x < 1} =\n      .ofReal ((\u222b (x : E), Real.exp (- (g x) ^ p) \u2202\u03bc) / Real.Gamma (finrank \u211d E / p + 1)) := by\n  -- We copy `E` to a new type `F` on which we will put the norm defined by `g`\n  letI F : Type _ := E\n  letI : NormedAddCommGroup F :=\n  { norm := g\n    dist := fun x y => g (x - y)\n    dist_self := by simp only [_root_.sub_self, h1, forall_const]\n    dist_comm := fun _ _ => by dsimp [dist]; rw [\u2190 h2, neg_sub]\n    dist_triangle := fun x y z => by convert h3 (x - y) (y - z) using 1; abel_nf\n    edist := fun x y => .ofReal (g (x - y))\n    edist_dist := fun _ _ => rfl\n    eq_of_dist_eq_zero := by convert fun _ _ h => eq_of_sub_eq_zero (h4 h) }\n  letI : NormedSpace \u211d F :=\n  { norm_smul_le := fun _ _ \u21a6 h5 _ _ }\n  -- We put the new topology on F\n  letI : TopologicalSpace F := UniformSpace.toTopologicalSpace\n  letI : MeasurableSpace F := borel F\n  have : BorelSpace F := { measurable_eq := rfl }\n  -- The map between `E` and `F` as a continuous linear equivalence\n  let \u03c6 := @LinearEquiv.toContinuousLinearEquiv \u211d _ E _ _ tE _ _ F _ _ _ _ _ _ _ _ _\n    (LinearEquiv.refl \u211d E : E \u2243\u2097[\u211d] F)\n  -- The measure `\u03bd` is the measure on `F` defined by `\u03bc`\n  -- Since we have two different topologies, it is necessary to specify the topology of E\n  let \u03bd : Measure F := @Measure.map E F _ mE \u03c6 \u03bc\n  have : IsAddHaarMeasure \u03bd :=\n    @ContinuousLinearEquiv.isAddHaarMeasure_map E F \u211d \u211d _ _ _ _ _ _ tE _ _ _ _ _ _ _ mE _ _ _ \u03c6 \u03bc _\n  convert (measure_unitBall_eq_integral_div_gamma \u03bd hp) using 1\n  \u00b7 rw [@Measure.map_apply E F mE _ \u03bc \u03c6 _ _ measurableSet_ball]\n    \u00b7 congr!\n      simp_rw [Metric.ball, dist_zero_right]\n      rfl\n    \u00b7 refine @Continuous.measurable E F tE mE _ _ _ _ \u03c6 ?_\n      exact @ContinuousLinearEquiv.continuous \u211d \u211d _ _ _ _ _ _ E tE _ F _ _ _ _ \u03c6\n  \u00b7 -- The map between `E` and `F` as a measurable equivalence\n    let \u03c8 := @Homeomorph.toMeasurableEquiv E F tE mE _ _ _ _\n      (@ContinuousLinearEquiv.toHomeomorph \u211d \u211d _ _ _ _ _ _ E tE _ F _ _ _ _ \u03c6)\n    -- The map `\u03c8` is measure preserving by construction\n    have : @MeasurePreserving E F mE _ \u03c8 \u03bc \u03bd :=\n      @Measurable.measurePreserving E F mE _ \u03c8 (@MeasurableEquiv.measurable E F mE _ \u03c8) _\n    erw [\u2190 this.integral_comp']\n    rfl\n\n"}
{"name": "repr_ceil_apply89", "split": "test", "formal_statement": "theorem repr_ceil_apply (m : E) (i : \u03b9) : b.repr (ceil b m) i = \u2308b.repr m i\u2309 := by", "header": "\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n\n\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\ntheorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by simp [span_span_of_tower]\n\n\ndef fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}\n#align zspan.fundamental_domain Zspan.fundamentalDomain\n\n@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1 := Iff.rfl\n#align zspan.mem_fundamental_domain Zspan.mem_fundamentalDomain\n\ntheorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by\n  ext x\n  rw [mem_fundamentalDomain, Basis.map_repr, LinearEquiv.trans_apply, \u2190 mem_fundamentalDomain,\n    show f.symm x = f.toEquiv.symm x by rfl, \u2190 Set.mem_image_equiv]\n  rfl\n\n@[simp]\ntheorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]\n\nlemma fundamentalDomain_pi_basisFun [Fintype \u03b9] :\n    fundamentalDomain (Pi.basisFun \u211d \u03b9) = Set.pi Set.univ fun _ : \u03b9 \u21a6 Set.Ico (0 : \u211d) 1 := by\n  ext; simp\n\nvariable [FloorRing K]\n\nsection Fintype\n\nvariable [Fintype \u03b9]\n\n\ndef floor (m : E) : span \u2124 (Set.range b) := \u2211 i, \u230ab.repr m i\u230b \u2022 b.restrictScalars \u2124 i\n#align zspan.floor Zspan.floor\n\n\ndef ceil (m : E) : span \u2124 (Set.range b) := \u2211 i, \u2308b.repr m i\u2309 \u2022 b.restrictScalars \u2124 i\n#align zspan.ceil Zspan.ceil\n\n@[simp]\ntheorem repr_floor_apply (m : E) (i : \u03b9) : b.repr (floor b m) i = \u230ab.repr m i\u230b := by\n  classical simp only [floor, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_floor_apply Zspan.repr_floor_apply\n\n@[simp]\n"}
{"name": "to_single\u2080_exact_d_f_at_zero90", "split": "test", "formal_statement": "theorem to_single\u2080_exact_d_f_at_zero [hf : QuasiIso' f] : Exact (X.d 1 0) (f.f 0) := by", "header": "\nimport Mathlib.Algebra.Homology.Homotopy\nimport Mathlib.Algebra.Homology.SingleHomology\nimport Mathlib.CategoryTheory.Abelian.Homology\n\n#align_import algebra.homology.quasi_iso from \"leanprover-community/mathlib\"@\"956af7c76589f444f2e1313911bad16366ea476d\"\n\n\n\n\nopen CategoryTheory Limits\n\nuniverse v u\n\nvariable {\u03b9 : Type*}\n\nsection\n\nvariable {V : Type u} [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]\nvariable [HasEqualizers V] [HasImages V] [HasImageMaps V] [HasCokernels V]\nvariable {c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}\n\n\nclass QuasiIso' (f : C \u27f6 D) : Prop where\n  isIso : \u2200 i, IsIso ((homology'Functor V c i).map f)\n#align quasi_iso QuasiIso'\n\nattribute [instance] QuasiIso'.isIso\n\ninstance (priority := 100) quasiIso'_of_iso (f : C \u27f6 D) [IsIso f] : QuasiIso' f where\n  isIso i := by\n    change IsIso ((homology'Functor V c i).mapIso (asIso f)).hom\n    infer_instance\n#align quasi_iso_of_iso quasiIso'_of_iso\n\ninstance quasiIso'_comp (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' g] :\n    QuasiIso' (f \u226b g) where\n  isIso i := by\n    rw [Functor.map_comp]\n    infer_instance\n#align quasi_iso_comp quasiIso'_comp\n\ntheorem quasiIso'_of_comp_left (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' (f \u226b g)] :\n    QuasiIso' g :=\n  { isIso := fun i => IsIso.of_isIso_fac_left ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_left quasiIso'_of_comp_left\n\ntheorem quasiIso'_of_comp_right (f : C \u27f6 D) (g : D \u27f6 E) [QuasiIso' g] [QuasiIso' (f \u226b g)] :\n    QuasiIso' f :=\n  { isIso := fun i => IsIso.of_isIso_fac_right ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_right quasiIso'_of_comp_right\n\nnamespace HomologicalComplex.Hom\n\nsection ToSingle\u2080\n\nvariable {W : Type*} [Category W] [Abelian W]\n\nsection\n\nvariable {X : ChainComplex W \u2115} {Y : W} (f : X \u27f6 (ChainComplex.single\u2080 _).obj Y) [hf : QuasiIso' f]\n\n\nnoncomputable def toSingle\u2080CokernelAtZeroIso : cokernel (X.d 1 0) \u2245 Y :=\n  X.homology'ZeroIso.symm.trans\n    ((@asIso _ _ _ _ _ (hf.1 0)).trans ((ChainComplex.homology'Functor0Single\u2080 W).app Y))\n#align homological_complex.hom.to_single\u2080_cokernel_at_zero_iso HomologicalComplex.Hom.toSingle\u2080CokernelAtZeroIso\n\ntheorem toSingle\u2080CokernelAtZeroIso_hom_eq [hf : QuasiIso' f] :\n    f.toSingle\u2080CokernelAtZeroIso.hom =\n      cokernel.desc (X.d 1 0) (f.f 0) (by rw [\u2190 f.2 1 0 rfl]; exact comp_zero) := by\n  ext\n  dsimp only [toSingle\u2080CokernelAtZeroIso, ChainComplex.homology'ZeroIso, homology'OfZeroRight,\n    homology'.mapIso, ChainComplex.homology'Functor0Single\u2080, cokernel.map]\n  dsimp [asIso]\n  simp only [cokernel.\u03c0_desc, Category.assoc, homology'.map_desc, cokernel.\u03c0_desc_assoc]\n  simp [homology'.desc, Iso.refl_inv (X.X 0)]\n#align homological_complex.hom.to_single\u2080_cokernel_at_zero_iso_hom_eq HomologicalComplex.Hom.toSingle\u2080CokernelAtZeroIso_hom_eq\n\ntheorem to_single\u2080_epi_at_zero [hf : QuasiIso' f] : Epi (f.f 0) := by\n  constructor\n  intro Z g h Hgh\n  rw [\u2190 cokernel.\u03c0_desc (X.d 1 0) (f.f 0) (by rw [\u2190 f.2 1 0 rfl]; exact comp_zero),\n    \u2190 toSingle\u2080CokernelAtZeroIso_hom_eq] at Hgh\n  rw [(@cancel_epi _ _ _ _ _ _ (epi_comp _ _) _ _).1 Hgh]\n#align homological_complex.hom.to_single\u2080_epi_at_zero HomologicalComplex.Hom.to_single\u2080_epi_at_zero\n\n"}
{"name": "norm_exp_mul_sq_le91", "split": "test", "formal_statement": "theorem norm_exp_mul_sq_le {\u03c4 : \u2102} (h\u03c4 : 0 < \u03c4.im) (n : \u2124) :\n    \u2016cexp (\u03c0 * I * (n : \u2102) ^ 2 * \u03c4)\u2016 \u2264 rexp (-\u03c0 * \u03c4.im) ^ n.natAbs := by", "header": "\nimport Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable\nimport Mathlib.Analysis.Complex.UpperHalfPlane.Basic\n\n#align_import number_theory.modular_forms.jacobi_theta.basic from \"leanprover-community/mathlib\"@\"57f9349f2fe19d2de7207e99b0341808d977cdcf\"\n\n\n\nopen Complex Real Asymptotics Filter Topology\n\nopen scoped Real UpperHalfPlane\n\n\nnoncomputable def jacobiTheta (\u03c4 : \u2102) : \u2102 := \u2211' n : \u2124, cexp (\u03c0 * I * (n : \u2102) ^ 2 * \u03c4)\n#align jacobi_theta jacobiTheta\n\nlemma jacobiTheta_eq_jacobiTheta\u2082 (\u03c4 : \u2102) : jacobiTheta \u03c4 = jacobiTheta\u2082 0 \u03c4 :=\n  tsum_congr (by simp [jacobiTheta\u2082_term])\n\ntheorem jacobiTheta_two_add (\u03c4 : \u2102) : jacobiTheta (2 + \u03c4) = jacobiTheta \u03c4 := by\n  simp_rw [jacobiTheta_eq_jacobiTheta\u2082, add_comm, jacobiTheta\u2082_add_right]\n#align jacobi_theta_two_add jacobiTheta_two_add\n\ntheorem jacobiTheta_T_sq_smul (\u03c4 : \u210d) : jacobiTheta (ModularGroup.T ^ 2 \u2022 \u03c4 :) = jacobiTheta \u03c4 := by\n  suffices (ModularGroup.T ^ 2 \u2022 \u03c4 :) = (2 : \u2102) + \u2191\u03c4 by simp_rw [this, jacobiTheta_two_add]\n  have : ModularGroup.T ^ (2 : \u2115) = ModularGroup.T ^ (2 : \u2124) := rfl\n  simp_rw [this, UpperHalfPlane.modular_T_zpow_smul, UpperHalfPlane.coe_vadd]\n  norm_cast\nset_option linter.uppercaseLean3 false in\n#align jacobi_theta_T_sq_smul jacobiTheta_T_sq_smul\n\ntheorem jacobiTheta_S_smul (\u03c4 : \u210d) :\n    jacobiTheta \u2191(ModularGroup.S \u2022 \u03c4) = (-I * \u03c4) ^ (1 / 2 : \u2102) * jacobiTheta \u03c4 := by\n  have h0 : (\u03c4 : \u2102) \u2260 0 := ne_of_apply_ne im (zero_im.symm \u25b8 ne_of_gt \u03c4.2)\n  have h1 : (-I * \u03c4) ^ (1 / 2 : \u2102) \u2260 0 := by\n    rw [Ne, cpow_eq_zero_iff, not_and_or]\n    exact Or.inl <| mul_ne_zero (neg_ne_zero.mpr I_ne_zero) h0\n  simp_rw [UpperHalfPlane.modular_S_smul, jacobiTheta_eq_jacobiTheta\u2082]\n  conv_rhs => erw [\u2190 ofReal_zero, jacobiTheta\u2082_functional_equation 0 \u03c4]\n  rw [zero_pow two_ne_zero, mul_zero, zero_div, Complex.exp_zero, mul_one, \u2190 mul_assoc, mul_one_div,\n    div_self h1, one_mul, UpperHalfPlane.coe_mk, inv_neg, neg_div, one_div]\nset_option linter.uppercaseLean3 false in\n#align jacobi_theta_S_smul jacobiTheta_S_smul\n\n"}
{"name": "ContinuousLinearMap.norm_map_tail_le92", "split": "test", "formal_statement": "theorem ContinuousLinearMap.norm_map_tail_le\n    (f : Ei 0 \u2192L[\ud835\udd5c] ContinuousMultilinearMap \ud835\udd5c (fun i : Fin n => Ei i.succ) G) (m : \u2200 i, Ei i) :\n    \u2016f (m 0) (tail m)\u2016 \u2264 \u2016f\u2016 * \u220f i, \u2016m i\u2016 :=\n  calc\n    \u2016f (m 0) (tail m)\u2016 \u2264 \u2016f (m 0)\u2016 * \u220f i, \u2016(tail m) i\u2016 := (f (m 0)).le_opNorm _\n    _ \u2264 \u2016f\u2016 * \u2016m 0\u2016 * \u220f i, \u2016tail m i\u2016 := mul_le_mul_of_nonneg_right (f.le_opNorm _) <| by positivity\n    _ = \u2016f\u2016 * (\u2016m 0\u2016 * \u220f i, \u2016(tail m) i\u2016) := by", "header": "\nimport Mathlib.Analysis.NormedSpace.Multilinear.Basic\n\n#align_import analysis.normed_space.multilinear from \"leanprover-community/mathlib\"@\"f40476639bac089693a489c9e354ebd75dc0f886\"\n\n\n\nsuppress_compilation\n\nnoncomputable section\n\nopen NNReal Finset Metric ContinuousMultilinearMap Fin Function\n\n\n\n\nuniverse u v v' wE wE\u2081 wE' wEi wG wG'\n\nvariable {\ud835\udd5c : Type u} {\u03b9 : Type v} {\u03b9' : Type v'} {n : \u2115} {E : \u03b9 \u2192 Type wE} {E\u2081 : \u03b9 \u2192 Type wE\u2081}\n  {E' : \u03b9' \u2192 Type wE'} {Ei : Fin n.succ \u2192 Type wEi} {G : Type wG} {G' : Type wG'} [Fintype \u03b9]\n  [Fintype \u03b9'] [NontriviallyNormedField \ud835\udd5c] [\u2200 i, NormedAddCommGroup (E i)]\n  [\u2200 i, NormedSpace \ud835\udd5c (E i)] [\u2200 i, NormedAddCommGroup (E\u2081 i)] [\u2200 i, NormedSpace \ud835\udd5c (E\u2081 i)]\n  [\u2200 i, NormedAddCommGroup (E' i)] [\u2200 i, NormedSpace \ud835\udd5c (E' i)] [\u2200 i, NormedAddCommGroup (Ei i)]\n  [\u2200 i, NormedSpace \ud835\udd5c (Ei i)] [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G] [NormedAddCommGroup G']\n  [NormedSpace \ud835\udd5c G']\n\n\n"}
{"name": "uncurry_curry93", "split": "test", "formal_statement": "theorem uncurry_curry (f : ((i : Fin n) \u2192 p i) \u2192 \u03c4) :\n    uncurry (curry f) = f := by", "header": "\nimport Mathlib.Data.Fin.Tuple.Basic\nimport Mathlib.Logic.Equiv.Fin\nimport Mathlib.Logic.Function.OfArity\n\n\n\nuniverse u v w w'\n\nnamespace Function.FromTypes\n\nopen Matrix (vecCons vecHead vecTail vecEmpty)\n\n\ndef uncurry : {n : \u2115} \u2192 {p : Fin n \u2192 Type u} \u2192 {\u03c4 : Type u} \u2192\n    (f : Function.FromTypes p \u03c4) \u2192 ((i : Fin n) \u2192 p i) \u2192 \u03c4\n  | 0    , _, _, f => fun _    => f\n  | _ + 1, _, _, f => fun args => (f (args 0)).uncurry (args \u2218' Fin.succ)\n\n\ndef curry : {n : \u2115} \u2192 {p : Fin n \u2192 Type u} \u2192 {\u03c4 : Type u} \u2192\n    (((i : Fin n) \u2192 p i) \u2192 \u03c4) \u2192 Function.FromTypes p \u03c4\n  | 0    , _, _, f => f isEmptyElim\n  | _ + 1, _, _, f => fun a => curry (fun args => f (Fin.cons a args))\n\n@[simp]\ntheorem uncurry_apply_cons {n : \u2115} {\u03b1} {p : Fin n \u2192 Type u} {\u03c4 : Type u}\n    (f : Function.FromTypes (vecCons \u03b1 p) \u03c4) (a : \u03b1) (args : (i : Fin n) \u2192 p i) :\n    uncurry f (Fin.cons a args) = @uncurry _ p _ (f a) args := rfl\n\n@[simp low]\ntheorem uncurry_apply_succ {n : \u2115} {p : Fin (n + 1) \u2192 Type u} {\u03c4 : Type u}\n    (f : Function.FromTypes p \u03c4) (args : (i : Fin (n + 1)) \u2192 p i) :\n    uncurry f args = uncurry (f (args 0)) (Fin.tail args) :=\n  @uncurry_apply_cons n (p 0) (vecTail p) \u03c4 f (args 0) (Fin.tail args)\n\n@[simp]\ntheorem curry_apply_cons {n : \u2115} {\u03b1} {p : Fin n \u2192 Type u} {\u03c4 : Type u}\n    (f : ((i : Fin (n + 1)) \u2192 (vecCons \u03b1 p) i) \u2192 \u03c4) (a : \u03b1) :\n    curry f a = @curry _ p _ (f \u2218' Fin.cons a) := rfl\n\n@[simp low]\ntheorem curry_apply_succ {n : \u2115} {p : Fin (n + 1) \u2192 Type u} {\u03c4 : Type u}\n    (f : ((i : Fin (n + 1)) \u2192 p i) \u2192 \u03c4) (a : p 0) :\n    curry f a = curry (f \u2218 Fin.cons a) := rfl\n\nvariable {n : \u2115} {p : Fin n \u2192 Type u} {\u03c4 : Type u}\n\n@[simp]\ntheorem curry_uncurry (f : Function.FromTypes p \u03c4) : curry (uncurry f) = f := by\n  induction n with\n  | zero => rfl\n  | succ n ih => exact funext (ih $ f \u00b7)\n\n@[simp]\n"}
{"name": "laurent_laurent94", "split": "test", "formal_statement": "theorem laurent_laurent : laurent r (laurent s f) = laurent (r + s) f := by", "header": "\nimport Mathlib.Algebra.Polynomial.Taylor\nimport Mathlib.FieldTheory.RatFunc.AsPolynomial\n\n#align_import field_theory.laurent from \"leanprover-community/mathlib\"@\"70fd9563a21e7b963887c9360bd29b2393e6225a\"\n\n\n\n\nuniverse u\n\nnamespace RatFunc\n\nnoncomputable section\n\nopen Polynomial\n\nopen scoped Classical nonZeroDivisors Polynomial\n\nvariable {R : Type u} [CommRing R] [hdomain : IsDomain R] (r s : R) (p q : R[X]) (f : RatFunc R)\n\ntheorem taylor_mem_nonZeroDivisors (hp : p \u2208 R[X]\u2070) : taylor r p \u2208 R[X]\u2070 := by\n  rw [mem_nonZeroDivisors_iff]\n  intro x hx\n  have : x = taylor (r - r) x := by simp\n  rwa [this, sub_eq_add_neg, \u2190 taylor_taylor, \u2190 taylor_mul,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _), mul_right_mem_nonZeroDivisors_eq_zero_iff hp,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _)] at hx\n#align ratfunc.taylor_mem_non_zero_divisors RatFunc.taylor_mem_nonZeroDivisors\n\n\ndef laurentAux : RatFunc R \u2192+* RatFunc R :=\n  RatFunc.mapRingHom\n    ( { toFun := taylor r\n        map_add' := map_add (taylor r)\n        map_mul' := taylor_mul _\n        map_zero' := map_zero (taylor r)\n        map_one' := taylor_one r } : R[X] \u2192+* R[X])\n    (taylor_mem_nonZeroDivisors _)\n#align ratfunc.laurent_aux RatFunc.laurentAux\n\ntheorem laurentAux_ofFractionRing_mk (q : R[X]\u2070) :\n    laurentAux r (ofFractionRing (Localization.mk p q)) =\n      ofFractionRing (.mk (taylor r p) \u27e8taylor r q, taylor_mem_nonZeroDivisors r q q.prop\u27e9) :=\n  map_apply_ofFractionRing_mk _ _ _ _\n#align ratfunc.laurent_aux_of_fraction_ring_mk RatFunc.laurentAux_ofFractionRing_mk\n\ntheorem laurentAux_div :\n    laurentAux r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q) :=\n  -- Porting note: added `by exact taylor_mem_nonZeroDivisors r`\n  map_apply_div _ (by exact taylor_mem_nonZeroDivisors r) _ _\n#align ratfunc.laurent_aux_div RatFunc.laurentAux_div\n\n@[simp]\ntheorem laurentAux_algebraMap : laurentAux r (algebraMap _ _ p) = algebraMap _ _ (taylor r p) := by\n  rw [\u2190 mk_one, \u2190 mk_one, mk_eq_div, laurentAux_div, mk_eq_div, taylor_one, map_one, map_one]\n#align ratfunc.laurent_aux_algebra_map RatFunc.laurentAux_algebraMap\n\n\ndef laurent : RatFunc R \u2192\u2090[R] RatFunc R :=\n  RatFunc.mapAlgHom (.ofLinearMap (taylor r) (taylor_one _) (taylor_mul _))\n    (taylor_mem_nonZeroDivisors _)\n#align ratfunc.laurent RatFunc.laurent\n\ntheorem laurent_div :\n    laurent r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q) :=\n  laurentAux_div r p q\n#align ratfunc.laurent_div RatFunc.laurent_div\n\n@[simp]\ntheorem laurent_algebraMap : laurent r (algebraMap _ _ p) = algebraMap _ _ (taylor r p) :=\n  laurentAux_algebraMap _ _\n#align ratfunc.laurent_algebra_map RatFunc.laurent_algebraMap\n\n@[simp]\ntheorem laurent_X : laurent r X = X + C r := by\n  rw [\u2190 algebraMap_X, laurent_algebraMap, taylor_X, _root_.map_add, algebraMap_C]\nset_option linter.uppercaseLean3 false in\n#align ratfunc.laurent_X RatFunc.laurent_X\n\n@[simp]\ntheorem laurent_C (x : R) : laurent r (C x) = C x := by\n  rw [\u2190 algebraMap_C, laurent_algebraMap, taylor_C]\nset_option linter.uppercaseLean3 false in\n#align ratfunc.laurent_C RatFunc.laurent_C\n\n@[simp]\ntheorem laurent_at_zero : laurent 0 f = f := by induction f using RatFunc.induction_on; simp\n#align ratfunc.laurent_at_zero RatFunc.laurent_at_zero\n\n"}
{"name": "gcd_eq_right_iff_dvd95", "split": "test", "formal_statement": "theorem gcd_eq_right_iff_dvd {m n : \u2115+} : m \u2223 n \u2194 n.gcd m = m := by", "header": "\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.prime from \"leanprover-community/mathlib\"@\"09597669f02422ed388036273d8848119699c22f\"\n\n\n\n\nnamespace PNat\n\nopen Nat\n\n\ndef gcd (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.gcd (n : \u2115) (m : \u2115), Nat.gcd_pos_of_pos_left (m : \u2115) n.pos\u27e9\n#align pnat.gcd PNat.gcd\n\n\ndef lcm (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.lcm (n : \u2115) (m : \u2115), by\n    let h := mul_pos n.pos m.pos\n    rw [\u2190 gcd_mul_lcm (n : \u2115) (m : \u2115), mul_comm] at h\n    exact pos_of_dvd_of_pos (Dvd.intro (Nat.gcd (n : \u2115) (m : \u2115)) rfl) h\u27e9\n#align pnat.lcm PNat.lcm\n\n@[simp, norm_cast]\ntheorem gcd_coe (n m : \u2115+) : (gcd n m : \u2115) = Nat.gcd n m :=\n  rfl\n#align pnat.gcd_coe PNat.gcd_coe\n\n@[simp, norm_cast]\ntheorem lcm_coe (n m : \u2115+) : (lcm n m : \u2115) = Nat.lcm n m :=\n  rfl\n#align pnat.lcm_coe PNat.lcm_coe\n\ntheorem gcd_dvd_left (n m : \u2115+) : gcd n m \u2223 n :=\n  dvd_iff.2 (Nat.gcd_dvd_left (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_left PNat.gcd_dvd_left\n\ntheorem gcd_dvd_right (n m : \u2115+) : gcd n m \u2223 m :=\n  dvd_iff.2 (Nat.gcd_dvd_right (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_right PNat.gcd_dvd_right\n\ntheorem dvd_gcd {m n k : \u2115+} (hm : k \u2223 m) (hn : k \u2223 n) : k \u2223 gcd m n :=\n  dvd_iff.2 (Nat.dvd_gcd (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.dvd_gcd PNat.dvd_gcd\n\ntheorem dvd_lcm_left (n m : \u2115+) : n \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_left (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_left PNat.dvd_lcm_left\n\ntheorem dvd_lcm_right (n m : \u2115+) : m \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_right (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_right PNat.dvd_lcm_right\n\ntheorem lcm_dvd {m n k : \u2115+} (hm : m \u2223 k) (hn : n \u2223 k) : lcm m n \u2223 k :=\n  dvd_iff.2 (@Nat.lcm_dvd (m : \u2115) (n : \u2115) (k : \u2115) (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.lcm_dvd PNat.lcm_dvd\n\ntheorem gcd_mul_lcm (n m : \u2115+) : gcd n m * lcm n m = n * m :=\n  Subtype.eq (Nat.gcd_mul_lcm (n : \u2115) (m : \u2115))\n#align pnat.gcd_mul_lcm PNat.gcd_mul_lcm\n\ntheorem eq_one_of_lt_two {n : \u2115+} : n < 2 \u2192 n = 1 := by\n  intro h; apply le_antisymm; swap\n  \u00b7 apply PNat.one_le\n  \u00b7 exact PNat.lt_add_one_iff.1 h\n#align pnat.eq_one_of_lt_two PNat.eq_one_of_lt_two\n\nsection Coprime\n\n\n\n\n\ndef Coprime (m n : \u2115+) : Prop :=\n  m.gcd n = 1\n#align pnat.coprime PNat.Coprime\n\n@[simp, norm_cast]\ntheorem coprime_coe {m n : \u2115+} : Nat.Coprime \u2191m \u2191n \u2194 m.Coprime n := by\n  unfold Nat.Coprime Coprime\n  rw [\u2190 coe_inj]\n  simp\n#align pnat.coprime_coe PNat.coprime_coe\n\ntheorem Coprime.mul {k m n : \u2115+} : m.Coprime k \u2192 n.Coprime k \u2192 (m * n).Coprime k := by\n  repeat rw [\u2190 coprime_coe]\n  rw [mul_coe]\n  apply Nat.Coprime.mul\n#align pnat.coprime.mul PNat.Coprime.mul\n\ntheorem Coprime.mul_right {k m n : \u2115+} : k.Coprime m \u2192 k.Coprime n \u2192 k.Coprime (m * n) := by\n  repeat rw [\u2190 coprime_coe]\n  rw [mul_coe]\n  apply Nat.Coprime.mul_right\n#align pnat.coprime.mul_right PNat.Coprime.mul_right\n\ntheorem gcd_comm {m n : \u2115+} : m.gcd n = n.gcd m := by\n  apply eq\n  simp only [gcd_coe]\n  apply Nat.gcd_comm\n#align pnat.gcd_comm PNat.gcd_comm\n\ntheorem gcd_eq_left_iff_dvd {m n : \u2115+} : m \u2223 n \u2194 m.gcd n = m := by\n  rw [dvd_iff]\n  rw [Nat.gcd_eq_left_iff_dvd]\n  rw [\u2190 coe_inj]\n  simp\n#align pnat.gcd_eq_left_iff_dvd PNat.gcd_eq_left_iff_dvd\n\n"}
{"name": "infEdist_le_infEdist_add_edist96", "split": "test", "formal_statement": "theorem infEdist_le_infEdist_add_edist : infEdist x s \u2264 infEdist y s + edist x y :=\n  calc\n    \u2a05 z \u2208 s, edist x z \u2264 \u2a05 z \u2208 s, edist y z + edist x y :=\n      iInf\u2082_mono fun z _ => (edist_triangle _ _ _).trans_eq (add_comm _ _)\n    _ = (\u2a05 z \u2208 s, edist y z) + edist x y := by", "header": "\nimport Mathlib.Analysis.SpecificLimits.Basic\nimport Mathlib.Topology.MetricSpace.IsometricSMul\n\n#align_import topology.metric_space.hausdorff_distance from \"leanprover-community/mathlib\"@\"bc91ed7093bf098d253401e69df601fc33dde156\"\n\n\n\n\nnoncomputable section\n\nopen NNReal ENNReal Topology Set Filter Pointwise Bornology\n\nuniverse u v w\n\nvariable {\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}\n\nnamespace EMetric\n\nsection InfEdist\n\nvariable [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}\n\n\n\n\ndef infEdist (x : \u03b1) (s : Set \u03b1) : \u211d\u22650\u221e :=\n  \u2a05 y \u2208 s, edist x y\n#align emetric.inf_edist EMetric.infEdist\n\n@[simp]\ntheorem infEdist_empty : infEdist x \u2205 = \u221e :=\n  iInf_emptyset\n#align emetric.inf_edist_empty EMetric.infEdist_empty\n\ntheorem le_infEdist {d} : d \u2264 infEdist x s \u2194 \u2200 y \u2208 s, d \u2264 edist x y := by\n  simp only [infEdist, le_iInf_iff]\n#align emetric.le_inf_edist EMetric.le_infEdist\n\n\n@[simp]\ntheorem infEdist_union : infEdist x (s \u222a t) = infEdist x s \u2293 infEdist x t :=\n  iInf_union\n#align emetric.inf_edist_union EMetric.infEdist_union\n\n@[simp]\ntheorem infEdist_iUnion (f : \u03b9 \u2192 Set \u03b1) (x : \u03b1) : infEdist x (\u22c3 i, f i) = \u2a05 i, infEdist x (f i) :=\n  iInf_iUnion f _\n#align emetric.inf_edist_Union EMetric.infEdist_iUnion\n\nlemma infEdist_biUnion {\u03b9 : Type*} (f : \u03b9 \u2192 Set \u03b1) (I : Set \u03b9) (x : \u03b1) :\n    infEdist x (\u22c3 i \u2208 I, f i) = \u2a05 i \u2208 I, infEdist x (f i) := by simp only [infEdist_iUnion]\n\n\n@[simp]\ntheorem infEdist_singleton : infEdist x {y} = edist x y :=\n  iInf_singleton\n#align emetric.inf_edist_singleton EMetric.infEdist_singleton\n\n\ntheorem infEdist_le_edist_of_mem (h : y \u2208 s) : infEdist x s \u2264 edist x y :=\n  iInf\u2082_le y h\n#align emetric.inf_edist_le_edist_of_mem EMetric.infEdist_le_edist_of_mem\n\n\ntheorem infEdist_zero_of_mem (h : x \u2208 s) : infEdist x s = 0 :=\n  nonpos_iff_eq_zero.1 <| @edist_self _ _ x \u25b8 infEdist_le_edist_of_mem h\n#align emetric.inf_edist_zero_of_mem EMetric.infEdist_zero_of_mem\n\n\ntheorem infEdist_anti (h : s \u2286 t) : infEdist x t \u2264 infEdist x s :=\n  iInf_le_iInf_of_subset h\n#align emetric.inf_edist_anti EMetric.infEdist_anti\n\n\ntheorem infEdist_lt_iff {r : \u211d\u22650\u221e} : infEdist x s < r \u2194 \u2203 y \u2208 s, edist x y < r := by\n  simp_rw [infEdist, iInf_lt_iff, exists_prop]\n#align emetric.inf_edist_lt_iff EMetric.infEdist_lt_iff\n\n\n"}
{"name": "dedup_append97", "split": "test", "formal_statement": "theorem dedup_append (l\u2081 l\u2082 : List \u03b1) : dedup (l\u2081 ++ l\u2082) = l\u2081 \u222a dedup l\u2082 := by", "header": "\nimport Mathlib.Data.List.Nodup\n\n#align_import data.list.dedup from \"leanprover-community/mathlib\"@\"d9e96a3e3e0894e93e10aff5244f4c96655bac1c\"\n\n\n\n\nuniverse u\n\nnamespace List\n\nvariable {\u03b1 : Type u} [DecidableEq \u03b1]\n\n@[simp]\ntheorem dedup_nil : dedup [] = ([] : List \u03b1) :=\n  rfl\n#align list.dedup_nil List.dedup_nil\n\ntheorem dedup_cons_of_mem' {a : \u03b1} {l : List \u03b1} (h : a \u2208 dedup l) : dedup (a :: l) = dedup l :=\n  pwFilter_cons_of_neg <| by simpa only [forall_mem_ne, not_not] using h\n#align list.dedup_cons_of_mem' List.dedup_cons_of_mem'\n\ntheorem dedup_cons_of_not_mem' {a : \u03b1} {l : List \u03b1} (h : a \u2209 dedup l) :\n    dedup (a :: l) = a :: dedup l :=\n  pwFilter_cons_of_pos <| by simpa only [forall_mem_ne] using h\n#align list.dedup_cons_of_not_mem' List.dedup_cons_of_not_mem'\n\n@[simp]\ntheorem mem_dedup {a : \u03b1} {l : List \u03b1} : a \u2208 dedup l \u2194 a \u2208 l := by\n  have := not_congr (@forall_mem_pwFilter \u03b1 (\u00b7 \u2260 \u00b7) _ ?_ a l)\n  \u00b7 simpa only [dedup, forall_mem_ne, not_not] using this\n  \u00b7 intros x y z xz\n    exact not_and_or.1 <| mt (fun h \u21a6 h.1.trans h.2) xz\n#align list.mem_dedup List.mem_dedup\n\n@[simp]\ntheorem dedup_cons_of_mem {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) : dedup (a :: l) = dedup l :=\n  dedup_cons_of_mem' <| mem_dedup.2 h\n#align list.dedup_cons_of_mem List.dedup_cons_of_mem\n\n@[simp]\ntheorem dedup_cons_of_not_mem {a : \u03b1} {l : List \u03b1} (h : a \u2209 l) : dedup (a :: l) = a :: dedup l :=\n  dedup_cons_of_not_mem' <| mt mem_dedup.1 h\n#align list.dedup_cons_of_not_mem List.dedup_cons_of_not_mem\n\ntheorem dedup_sublist : \u2200 l : List \u03b1, dedup l <+ l :=\n  pwFilter_sublist\n#align list.dedup_sublist List.dedup_sublist\n\ntheorem dedup_subset : \u2200 l : List \u03b1, dedup l \u2286 l :=\n  pwFilter_subset\n#align list.dedup_subset List.dedup_subset\n\ntheorem subset_dedup (l : List \u03b1) : l \u2286 dedup l := fun _ => mem_dedup.2\n#align list.subset_dedup List.subset_dedup\n\ntheorem nodup_dedup : \u2200 l : List \u03b1, Nodup (dedup l) :=\n  pairwise_pwFilter\n#align list.nodup_dedup List.nodup_dedup\n\ntheorem headI_dedup [Inhabited \u03b1] (l : List \u03b1) :\n    l.dedup.headI = if l.headI \u2208 l.tail then l.tail.dedup.headI else l.headI :=\n  match l with\n  | [] => rfl\n  | a :: l => by by_cases ha : a \u2208 l <;> simp [ha, List.dedup_cons_of_mem]\n#align list.head_dedup List.headI_dedup\n\ntheorem tail_dedup [Inhabited \u03b1] (l : List \u03b1) :\n    l.dedup.tail = if l.headI \u2208 l.tail then l.tail.dedup.tail else l.tail.dedup :=\n  match l with\n  | [] => rfl\n  | a :: l => by by_cases ha : a \u2208 l <;> simp [ha, List.dedup_cons_of_mem]\n#align list.tail_dedup List.tail_dedup\n\ntheorem dedup_eq_self {l : List \u03b1} : dedup l = l \u2194 Nodup l :=\n  pwFilter_eq_self\n#align list.dedup_eq_self List.dedup_eq_self\n\ntheorem dedup_eq_cons (l : List \u03b1) (a : \u03b1) (l' : List \u03b1) :\n    l.dedup = a :: l' \u2194 a \u2208 l \u2227 a \u2209 l' \u2227 l.dedup.tail = l' := by\n  refine \u27e8fun h => ?_, fun h => ?_\u27e9\n  \u00b7 refine \u27e8mem_dedup.1 (h.symm \u25b8 mem_cons_self _ _), fun ha => ?_, by rw [h, tail_cons]\u27e9\n    have := count_pos_iff_mem.2 ha\n    have : count a l.dedup \u2264 1 := nodup_iff_count_le_one.1 (nodup_dedup l) a\n    rw [h, count_cons_self] at this\n    omega\n  \u00b7 have := @List.cons_head!_tail \u03b1 \u27e8a\u27e9 _ (ne_nil_of_mem (mem_dedup.2 h.1))\n    have hal : a \u2208 l.dedup := mem_dedup.2 h.1\n    rw [\u2190 this, mem_cons, or_iff_not_imp_right] at hal\n    exact this \u25b8 h.2.2.symm \u25b8 cons_eq_cons.2 \u27e8(hal (h.2.2.symm \u25b8 h.2.1)).symm, rfl\u27e9\n#align list.dedup_eq_cons List.dedup_eq_cons\n\n@[simp]\ntheorem dedup_eq_nil (l : List \u03b1) : l.dedup = [] \u2194 l = [] := by\n  induction' l with a l hl\n  \u00b7 exact Iff.rfl\n  \u00b7 by_cases h : a \u2208 l\n    \u00b7 simp only [List.dedup_cons_of_mem h, hl, List.ne_nil_of_mem h]\n    \u00b7 simp only [List.dedup_cons_of_not_mem h, List.cons_ne_nil]\n#align list.dedup_eq_nil List.dedup_eq_nil\n\nprotected theorem Nodup.dedup {l : List \u03b1} (h : l.Nodup) : l.dedup = l :=\n  List.dedup_eq_self.2 h\n#align list.nodup.dedup List.Nodup.dedup\n\n@[simp]\ntheorem dedup_idem {l : List \u03b1} : dedup (dedup l) = dedup l :=\n  pwFilter_idem\n#align list.dedup_idempotent List.dedup_idem\n\n"}
{"name": "Equiv.Perm.exists_with_cycleType_iff98", "split": "test", "formal_statement": "theorem Equiv.Perm.exists_with_cycleType_iff {m : Multiset \u2115} :\n    (\u2203 g : Equiv.Perm \u03b1, g.cycleType = m) \u2194\n      (m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a) := by", "header": "\n\nimport Mathlib.GroupTheory.Perm.Cycle.Concrete\n\n\n\nvariable (\u03b1 : Type*) [DecidableEq \u03b1] [Fintype \u03b1]\n\n\n"}
{"name": "to_single\u2080_epi_at_zero99", "split": "test", "formal_statement": "theorem to_single\u2080_epi_at_zero [hf : QuasiIso' f] : Epi (f.f 0) := by", "header": "\nimport Mathlib.Algebra.Homology.Homotopy\nimport Mathlib.Algebra.Homology.SingleHomology\nimport Mathlib.CategoryTheory.Abelian.Homology\n\n#align_import algebra.homology.quasi_iso from \"leanprover-community/mathlib\"@\"956af7c76589f444f2e1313911bad16366ea476d\"\n\n\n\n\nopen CategoryTheory Limits\n\nuniverse v u\n\nvariable {\u03b9 : Type*}\n\nsection\n\nvariable {V : Type u} [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]\nvariable [HasEqualizers V] [HasImages V] [HasImageMaps V] [HasCokernels V]\nvariable {c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}\n\n\nclass QuasiIso' (f : C \u27f6 D) : Prop where\n  isIso : \u2200 i, IsIso ((homology'Functor V c i).map f)\n#align quasi_iso QuasiIso'\n\nattribute [instance] QuasiIso'.isIso\n\ninstance (priority := 100) quasiIso'_of_iso (f : C \u27f6 D) [IsIso f] : QuasiIso' f where\n  isIso i := by\n    change IsIso ((homology'Functor V c i).mapIso (asIso f)).hom\n    infer_instance\n#align quasi_iso_of_iso quasiIso'_of_iso\n\ninstance quasiIso'_comp (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' g] :\n    QuasiIso' (f \u226b g) where\n  isIso i := by\n    rw [Functor.map_comp]\n    infer_instance\n#align quasi_iso_comp quasiIso'_comp\n\ntheorem quasiIso'_of_comp_left (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' (f \u226b g)] :\n    QuasiIso' g :=\n  { isIso := fun i => IsIso.of_isIso_fac_left ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_left quasiIso'_of_comp_left\n\ntheorem quasiIso'_of_comp_right (f : C \u27f6 D) (g : D \u27f6 E) [QuasiIso' g] [QuasiIso' (f \u226b g)] :\n    QuasiIso' f :=\n  { isIso := fun i => IsIso.of_isIso_fac_right ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_right quasiIso'_of_comp_right\n\nnamespace HomologicalComplex.Hom\n\nsection ToSingle\u2080\n\nvariable {W : Type*} [Category W] [Abelian W]\n\nsection\n\nvariable {X : ChainComplex W \u2115} {Y : W} (f : X \u27f6 (ChainComplex.single\u2080 _).obj Y) [hf : QuasiIso' f]\n\n\nnoncomputable def toSingle\u2080CokernelAtZeroIso : cokernel (X.d 1 0) \u2245 Y :=\n  X.homology'ZeroIso.symm.trans\n    ((@asIso _ _ _ _ _ (hf.1 0)).trans ((ChainComplex.homology'Functor0Single\u2080 W).app Y))\n#align homological_complex.hom.to_single\u2080_cokernel_at_zero_iso HomologicalComplex.Hom.toSingle\u2080CokernelAtZeroIso\n\ntheorem toSingle\u2080CokernelAtZeroIso_hom_eq [hf : QuasiIso' f] :\n    f.toSingle\u2080CokernelAtZeroIso.hom =\n      cokernel.desc (X.d 1 0) (f.f 0) (by rw [\u2190 f.2 1 0 rfl]; exact comp_zero) := by\n  ext\n  dsimp only [toSingle\u2080CokernelAtZeroIso, ChainComplex.homology'ZeroIso, homology'OfZeroRight,\n    homology'.mapIso, ChainComplex.homology'Functor0Single\u2080, cokernel.map]\n  dsimp [asIso]\n  simp only [cokernel.\u03c0_desc, Category.assoc, homology'.map_desc, cokernel.\u03c0_desc_assoc]\n  simp [homology'.desc, Iso.refl_inv (X.X 0)]\n#align homological_complex.hom.to_single\u2080_cokernel_at_zero_iso_hom_eq HomologicalComplex.Hom.toSingle\u2080CokernelAtZeroIso_hom_eq\n\n"}
{"name": "naturality_pf100", "split": "test", "formal_statement": "theorem naturality_pf (\u03b7 : ApplicativeTransformation F G) (f : \u03b1 \u2192 F \u03b2) :\n    traverse (@\u03b7 _ \u2218 f) = @\u03b7 _ \u2218 (traverse f : t \u03b1 \u2192 F (t \u03b2)) := by", "header": "\nimport Mathlib.Control.Applicative\nimport Mathlib.Control.Traversable.Basic\n\n#align_import control.traversable.lemmas from \"leanprover-community/mathlib\"@\"3342d1b2178381196f818146ff79bc0e7ccd9e2d\"\n\n\n\n\nuniverse u\n\nopen LawfulTraversable\n\nopen Function hiding comp\n\nopen Functor\n\nattribute [functor_norm] LawfulTraversable.naturality\n\nattribute [simp] LawfulTraversable.id_traverse\n\nnamespace Traversable\n\nvariable {t : Type u \u2192 Type u}\nvariable [Traversable t] [LawfulTraversable t]\nvariable (F G : Type u \u2192 Type u)\nvariable [Applicative F] [LawfulApplicative F]\nvariable [Applicative G] [LawfulApplicative G]\nvariable {\u03b1 \u03b2 \u03b3 : Type u}\nvariable (g : \u03b1 \u2192 F \u03b2)\nvariable (h : \u03b2 \u2192 G \u03b3)\nvariable (f : \u03b2 \u2192 \u03b3)\n\n\ndef PureTransformation :\n    ApplicativeTransformation Id F where\n  app := @pure F _\n  preserves_pure' x := rfl\n  preserves_seq' f x := by\n    simp only [map_pure, seq_pure]\n    rfl\n#align traversable.pure_transformation Traversable.PureTransformation\n\n@[simp]\ntheorem pureTransformation_apply {\u03b1} (x : id \u03b1) : PureTransformation F x = pure x :=\n  rfl\n#align traversable.pure_transformation_apply Traversable.pureTransformation_apply\n\nvariable {F G} (x : t \u03b2)\n\n-- Porting note: need to specify `m/F/G := Id` because `id` no longer has a `Monad` instance\ntheorem map_eq_traverse_id : map (f := t) f = traverse (m := Id) (pure \u2218 f) :=\n  funext fun y => (traverse_eq_map_id f y).symm\n#align traversable.map_eq_traverse_id Traversable.map_eq_traverse_id\n\ntheorem map_traverse (x : t \u03b1) : map f <$> traverse g x = traverse (map f \u2218 g) x := by\n  rw [map_eq_traverse_id f]\n  refine (comp_traverse (pure \u2218 f) g x).symm.trans ?_\n  congr; apply Comp.applicative_comp_id\n#align traversable.map_traverse Traversable.map_traverse\n\ntheorem traverse_map (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 \u03b2) (x : t \u03b1) :\n    traverse f (g <$> x) = traverse (f \u2218 g) x := by\n  rw [@map_eq_traverse_id t _ _ _ _ g]\n  refine (comp_traverse (G := Id) f (pure \u2218 g) x).symm.trans ?_\n  congr; apply Comp.applicative_id_comp\n#align traversable.traverse_map Traversable.traverse_map\n\ntheorem pure_traverse (x : t \u03b1) : traverse pure x = (pure x : F (t \u03b1)) := by\n  have : traverse pure x = pure (traverse (m := Id) pure x) :=\n      (naturality (PureTransformation F) pure x).symm\n  rwa [id_traverse] at this\n#align traversable.pure_traverse Traversable.pure_traverse\n\ntheorem id_sequence (x : t \u03b1) : sequence (f := Id) (pure <$> x) = pure x := by\n  simp [sequence, traverse_map, id_traverse]\n#align traversable.id_sequence Traversable.id_sequence\n\ntheorem comp_sequence (x : t (F (G \u03b1))) :\n    sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x) := by\n  simp only [sequence, traverse_map, id_comp]; rw [\u2190 comp_traverse]; simp [map_id]\n#align traversable.comp_sequence Traversable.comp_sequence\n\ntheorem naturality' (\u03b7 : ApplicativeTransformation F G) (x : t (F \u03b1)) :\n    \u03b7 (sequence x) = sequence (@\u03b7 _ <$> x) := by simp [sequence, naturality, traverse_map]\n#align traversable.naturality' Traversable.naturality'\n\n@[functor_norm]\ntheorem traverse_id : traverse pure = (pure : t \u03b1 \u2192 Id (t \u03b1)) := by\n  ext\n  exact id_traverse _\n#align traversable.traverse_id Traversable.traverse_id\n\n@[functor_norm]\ntheorem traverse_comp (g : \u03b1 \u2192 F \u03b2) (h : \u03b2 \u2192 G \u03b3) :\n    traverse (Comp.mk \u2218 map h \u2218 g) =\n      (Comp.mk \u2218 map (traverse h) \u2218 traverse g : t \u03b1 \u2192 Comp F G (t \u03b3)) := by\n  ext\n  exact comp_traverse _ _ _\n#align traversable.traverse_comp Traversable.traverse_comp\n\ntheorem traverse_eq_map_id' (f : \u03b2 \u2192 \u03b3) :\n    traverse (m := Id) (pure \u2218 f) = pure \u2218 (map f : t \u03b2 \u2192 t \u03b3) := by\n  ext\n  exact traverse_eq_map_id _ _\n#align traversable.traverse_eq_map_id' Traversable.traverse_eq_map_id'\n\n-- @[functor_norm]\ntheorem traverse_map' (g : \u03b1 \u2192 \u03b2) (h : \u03b2 \u2192 G \u03b3) :\n    traverse (h \u2218 g) = (traverse h \u2218 map g : t \u03b1 \u2192 G (t \u03b3)) := by\n  ext\n  rw [comp_apply, traverse_map]\n#align traversable.traverse_map' Traversable.traverse_map'\n\ntheorem map_traverse' (g : \u03b1 \u2192 G \u03b2) (h : \u03b2 \u2192 \u03b3) :\n    traverse (map h \u2218 g) = (map (map h) \u2218 traverse g : t \u03b1 \u2192 G (t \u03b3)) := by\n  ext\n  rw [comp_apply, map_traverse]\n#align traversable.map_traverse' Traversable.map_traverse'\n\n"}
{"name": "intPow_negOfNat_bit1101", "split": "test", "formal_statement": "theorem intPow_negOfNat_bit1 (h1 : Nat.pow a b' = c')\n    (hb : nat_lit 2 * b' + nat_lit 1 = b) (hc : c' * (c' * a) = c) :\n    Int.pow (Int.negOfNat a) b = Int.negOfNat c := by", "header": "\nimport Mathlib.Data.Int.Cast.Lemmas\nimport Mathlib.Tactic.NormNum.Basic\n\n\n\nset_option autoImplicit true\n\nnamespace Mathlib\nopen Lean hiding Rat mkRat\nopen Meta\n\nnamespace Meta.NormNum\nopen Qq\n\ntheorem natPow_zero : Nat.pow a (nat_lit 0) = nat_lit 1 := rfl\ntheorem natPow_one : Nat.pow a (nat_lit 1) = a := Nat.pow_one _\ntheorem zero_natPow : Nat.pow (nat_lit 0) (Nat.succ b) = nat_lit 0 := rfl\ntheorem one_natPow : Nat.pow (nat_lit 1) b = nat_lit 1 := Nat.one_pow _\n\n\nstructure IsNatPowT (p : Prop) (a b c : Nat) : Prop where\n  \n  run' : p \u2192 Nat.pow a b = c\n\ntheorem IsNatPowT.run\n    (p : IsNatPowT (Nat.pow a (nat_lit 1) = a) a b c) : Nat.pow a b = c := p.run' (Nat.pow_one _)\n\n\ntheorem IsNatPowT.trans (h1 : IsNatPowT p a b c) (h2 : IsNatPowT (Nat.pow a b = c) a b' c') :\n    IsNatPowT p a b' c' := \u27e8h2.run' \u2218 h1.run'\u27e9\n\ntheorem IsNatPowT.bit0 : IsNatPowT (Nat.pow a b = c) a (nat_lit 2 * b) (Nat.mul c c) :=\n  \u27e8fun h1 => by simp [two_mul, pow_add, \u2190 h1]\u27e9\ntheorem IsNatPowT.bit1 :\n    IsNatPowT (Nat.pow a b = c) a (nat_lit 2 * b + nat_lit 1) (Nat.mul c (Nat.mul c a)) :=\n  \u27e8fun h1 => by simp [two_mul, pow_add, mul_assoc, \u2190 h1]\u27e9\n\n\npartial def evalNatPow (a b : Q(\u2115)) : (c : Q(\u2115)) \u00d7 Q(Nat.pow $a $b = $c) :=\n  if b.natLit! = 0 then\n    haveI : $b =Q 0 := \u27e8\u27e9\n    \u27e8q(nat_lit 1), q(natPow_zero)\u27e9\n  else if a.natLit! = 0 then\n    haveI : $a =Q 0 := \u27e8\u27e9\n    have b' : Q(\u2115) := mkRawNatLit (b.natLit! - 1)\n    haveI : $b =Q Nat.succ $b' := \u27e8\u27e9\n    \u27e8q(nat_lit 0), q(zero_natPow)\u27e9\n  else if a.natLit! = 1 then\n    haveI : $a =Q 1 := \u27e8\u27e9\n    \u27e8q(nat_lit 1), q(one_natPow)\u27e9\n  else if b.natLit! = 1 then\n    haveI : $b =Q 1 := \u27e8\u27e9\n    \u27e8a, q(natPow_one)\u27e9\n  else\n    let \u27e8c, p\u27e9 := go b.natLit!.log2 a (mkRawNatLit 1) a b _ .rfl\n    \u27e8c, q(($p).run)\u27e9\nwhere\n  \n  go (depth : Nat) (a b\u2080 c\u2080 b : Q(\u2115)) (p : Q(Prop)) (hp : $p =Q (Nat.pow $a $b\u2080 = $c\u2080)) :\n      (c : Q(\u2115)) \u00d7 Q(IsNatPowT $p $a $b $c) :=\n    let b' := b.natLit!\n    if depth \u2264 1 then\n      let a' := a.natLit!\n      let c\u2080' := c\u2080.natLit!\n      if b' &&& 1 == 0 then\n        have c : Q(\u2115) := mkRawNatLit (c\u2080' * c\u2080')\n        haveI : $c =Q Nat.mul $c\u2080 $c\u2080 := \u27e8\u27e9\n        haveI : $b =Q 2 * $b\u2080 := \u27e8\u27e9\n        \u27e8c, q(IsNatPowT.bit0)\u27e9\n      else\n        have c : Q(\u2115) := mkRawNatLit (c\u2080' * (c\u2080' * a'))\n        haveI : $c =Q Nat.mul $c\u2080 (Nat.mul $c\u2080 $a) := \u27e8\u27e9\n        haveI : $b =Q 2 * $b\u2080 + 1 := \u27e8\u27e9\n        \u27e8c, q(IsNatPowT.bit1)\u27e9\n    else\n      let d := depth >>> 1\n      have hi : Q(\u2115) := mkRawNatLit (b' >>> d)\n      let \u27e8c1, p1\u27e9 := go (depth - d) a b\u2080 c\u2080 hi p (by exact hp)\n      let \u27e8c2, p2\u27e9 := go d a hi c1 b q(Nat.pow $a $hi = $c1) \u27e8\u27e9\n      \u27e8c2, q(($p1).trans $p2)\u27e9\n\ntheorem intPow_ofNat (h1 : Nat.pow a b = c) :\n    Int.pow (Int.ofNat a) b = Int.ofNat c := by simp [\u2190 h1]\n\ntheorem intPow_negOfNat_bit0 (h1 : Nat.pow a b' = c')\n    (hb : nat_lit 2 * b' = b) (hc : c' * c' = c) :\n    Int.pow (Int.negOfNat a) b = Int.ofNat c := by\n  rw [\u2190 hb, Int.negOfNat_eq, Int.pow_eq, pow_mul, neg_pow_two, \u2190 pow_mul, two_mul, pow_add, \u2190 hc,\n    \u2190 h1]\n  simp\n\n"}
{"name": "lapMatrix_toLinearMap\u2082'_apply'_eq_zero_iff_forall_reachable102", "split": "test", "formal_statement": "theorem lapMatrix_toLinearMap\u2082'_apply'_eq_zero_iff_forall_reachable (x : V \u2192 \u211d) :\n    Matrix.toLinearMap\u2082' (G.lapMatrix \u211d) x x = 0 \u2194 \u2200 i j : V, G.Reachable i j \u2192 x i = x j := by", "header": "\nimport Mathlib.Combinatorics.SimpleGraph.AdjMatrix\nimport Mathlib.LinearAlgebra.Matrix.PosDef\n\n\n\n\nopen Finset Matrix\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (R : Type*)\nvariable [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]\n\n\ndef degMatrix [AddMonoidWithOne R] : Matrix V V R := Matrix.diagonal (G.degree \u00b7)\n\n\ndef lapMatrix [AddGroupWithOne R] : Matrix V V R := G.degMatrix R - G.adjMatrix R\n\nvariable {R}\n\ntheorem isSymm_degMatrix [AddMonoidWithOne R] : (G.degMatrix R).IsSymm :=\n  isSymm_diagonal _\n\ntheorem isSymm_lapMatrix [AddGroupWithOne R] : (G.lapMatrix R).IsSymm :=\n  (isSymm_degMatrix _).sub (isSymm_adjMatrix _)\n\ntheorem degMatrix_mulVec_apply [NonAssocSemiring R] (v : V) (vec : V \u2192 R) :\n    (G.degMatrix R *\u1d65 vec) v = G.degree v * vec v := by\n  rw [degMatrix, mulVec_diagonal]\n\ntheorem lapMatrix_mulVec_apply [NonAssocRing R] (v : V) (vec : V \u2192 R) :\n    (G.lapMatrix R *\u1d65 vec) v = G.degree v * vec v - \u2211 u \u2208 G.neighborFinset v, vec u := by\n  simp_rw [lapMatrix, sub_mulVec, Pi.sub_apply, degMatrix_mulVec_apply, adjMatrix_mulVec_apply]\n\ntheorem lapMatrix_mulVec_const_eq_zero [Ring R] : mulVec (G.lapMatrix R) (fun _ \u21a6 1) = 0 := by\n  ext1 i\n  rw [lapMatrix_mulVec_apply]\n  simp\n\ntheorem dotProduct_mulVec_degMatrix [CommRing R] (x : V \u2192 R) :\n    x \u2b1d\u1d65 (G.degMatrix R *\u1d65 x) = \u2211 i : V, G.degree i * x i * x i := by\n  simp only [dotProduct, degMatrix, mulVec_diagonal, \u2190 mul_assoc, mul_comm]\n\nvariable (R)\n\ntheorem degree_eq_sum_if_adj [AddCommMonoidWithOne R] (i : V) :\n    (G.degree i : R) = \u2211 j : V, if G.Adj i j then 1 else 0 := by\n  unfold degree neighborFinset neighborSet\n  rw [sum_boole, Set.toFinset_setOf]\n\n\ntheorem lapMatrix_toLinearMap\u2082' [Field R] [CharZero R] (x : V \u2192 R) :\n    toLinearMap\u2082' (G.lapMatrix R) x x =\n    (\u2211 i : V, \u2211 j : V, if G.Adj i j then (x i - x j)^2 else 0) / 2 := by\n  simp_rw [toLinearMap\u2082'_apply', lapMatrix, sub_mulVec, dotProduct_sub, dotProduct_mulVec_degMatrix,\n    dotProduct_mulVec_adjMatrix, \u2190 sum_sub_distrib, degree_eq_sum_if_adj, sum_mul, ite_mul, one_mul,\n    zero_mul, \u2190 sum_sub_distrib, ite_sub_ite, sub_zero]\n  rw [\u2190 half_add_self (\u2211 x_1 : V, \u2211 x_2 : V, _)]\n  conv_lhs => enter [1,2,2,i,2,j]; rw [if_congr (adj_comm G i j) rfl rfl]\n  conv_lhs => enter [1,2]; rw [Finset.sum_comm]\n  simp_rw [\u2190 sum_add_distrib, ite_add_ite]\n  congr 2 with i\n  congr 2 with j\n  ring_nf\n\n\ntheorem posSemidef_lapMatrix [LinearOrderedField R] [StarRing R] [StarOrderedRing R]\n    [TrivialStar R] : PosSemidef (G.lapMatrix R) := by\n  constructor\n  \u00b7 rw [IsHermitian, conjTranspose_eq_transpose_of_trivial, isSymm_lapMatrix]\n  \u00b7 intro x\n    rw [star_trivial, \u2190 toLinearMap\u2082'_apply', lapMatrix_toLinearMap\u2082']\n    positivity\n\ntheorem lapMatrix_toLinearMap\u2082'_apply'_eq_zero_iff_forall_adj [LinearOrderedField R] (x : V \u2192 R) :\n    Matrix.toLinearMap\u2082' (G.lapMatrix R) x x = 0 \u2194 \u2200 i j : V, G.Adj i j \u2192 x i = x j := by\n  simp (disch := intros; positivity)\n    [lapMatrix_toLinearMap\u2082', sum_eq_zero_iff_of_nonneg, sub_eq_zero]\n\ntheorem lapMatrix_toLin'_apply_eq_zero_iff_forall_adj (x : V \u2192 \u211d) :\n    Matrix.toLin' (G.lapMatrix \u211d) x = 0 \u2194 \u2200 i j : V, G.Adj i j \u2192 x i = x j := by\n  rw [\u2190 (posSemidef_lapMatrix \u211d G).toLinearMap\u2082'_zero_iff, star_trivial,\n      lapMatrix_toLinearMap\u2082'_apply'_eq_zero_iff_forall_adj]\n\n"}
{"name": "edgeFinset_sup103", "split": "test", "formal_statement": "theorem edgeFinset_sup [Fintype (edgeSet (G\u2081 \u2294 G\u2082))] [DecidableEq V] :\n    (G\u2081 \u2294 G\u2082).edgeFinset = G\u2081.edgeFinset \u222a G\u2082.edgeFinset := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Combinatorics.SimpleGraph.Basic\nimport Mathlib.Data.Sym.Card\n\n\n\n\nopen Finset Function\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V) {e : Sym2 V}\n\nsection EdgeFinset\n\nvariable {G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]\n\n\nabbrev edgeFinset : Finset (Sym2 V) :=\n  Set.toFinset G.edgeSet\n#align simple_graph.edge_finset SimpleGraph.edgeFinset\n\n@[norm_cast]\ntheorem coe_edgeFinset : (G.edgeFinset : Set (Sym2 V)) = G.edgeSet :=\n  Set.coe_toFinset _\n#align simple_graph.coe_edge_finset SimpleGraph.coe_edgeFinset\n\nvariable {G}\n\ntheorem mem_edgeFinset : e \u2208 G.edgeFinset \u2194 e \u2208 G.edgeSet :=\n  Set.mem_toFinset\n#align simple_graph.mem_edge_finset SimpleGraph.mem_edgeFinset\n\ntheorem not_isDiag_of_mem_edgeFinset : e \u2208 G.edgeFinset \u2192 \u00ace.IsDiag :=\n  not_isDiag_of_mem_edgeSet _ \u2218 mem_edgeFinset.1\n#align simple_graph.not_is_diag_of_mem_edge_finset SimpleGraph.not_isDiag_of_mem_edgeFinset\n\ntheorem edgeFinset_inj : G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082 := by simp\n#align simple_graph.edge_finset_inj SimpleGraph.edgeFinset_inj\n\ntheorem edgeFinset_subset_edgeFinset : G\u2081.edgeFinset \u2286 G\u2082.edgeFinset \u2194 G\u2081 \u2264 G\u2082 := by simp\n#align simple_graph.edge_finset_subset_edge_finset SimpleGraph.edgeFinset_subset_edgeFinset\n\ntheorem edgeFinset_ssubset_edgeFinset : G\u2081.edgeFinset \u2282 G\u2082.edgeFinset \u2194 G\u2081 < G\u2082 := by simp\n#align simple_graph.edge_finset_ssubset_edge_finset SimpleGraph.edgeFinset_ssubset_edgeFinset\n\n@[gcongr] alias \u27e8_, edgeFinset_mono\u27e9 := edgeFinset_subset_edgeFinset\n#align simple_graph.edge_finset_mono SimpleGraph.edgeFinset_mono\n\nalias \u27e8_, edgeFinset_strict_mono\u27e9 := edgeFinset_ssubset_edgeFinset\n#align simple_graph.edge_finset_strict_mono SimpleGraph.edgeFinset_strict_mono\n\nattribute [mono] edgeFinset_mono edgeFinset_strict_mono\n\n@[simp]\ntheorem edgeFinset_bot : (\u22a5 : SimpleGraph V).edgeFinset = \u2205 := by simp [edgeFinset]\n#align simple_graph.edge_finset_bot SimpleGraph.edgeFinset_bot\n\n@[simp]\n"}
{"name": "reindex_relationsSet104", "split": "test", "formal_statement": "theorem reindex_relationsSet :\n    (M.reindex e).relationsSet =\n    FreeGroup.freeGroupCongr e '' M.relationsSet := let M' := M.reindex e; calc\n  Set.range (uncurry M'.relation)\n  _ = Set.range (uncurry M'.relation \u2218 Prod.map e e) := by", "header": "\nimport Mathlib.Algebra.Ring.Int\nimport Mathlib.GroupTheory.PresentedGroup\nimport Mathlib.GroupTheory.Coxeter.Matrix\n\n\n\nopen Function Set List\n\n\n\nnamespace CoxeterMatrix\n\nvariable {B B' : Type*} (M : CoxeterMatrix B) (e : B \u2243 B')\n\n\ndef relation (i i' : B) : FreeGroup B := (FreeGroup.of i * FreeGroup.of i') ^ M i i'\n\n\ndef relationsSet : Set (FreeGroup B) := range <| uncurry M.relation\n\n\nprotected def Group : Type _ := PresentedGroup M.relationsSet\n\ninstance : Group M.Group := QuotientGroup.Quotient.group _\n\n\ndef simple (i : B) : M.Group := PresentedGroup.of i\n\n"}
{"name": "star_mul_self105", "split": "test", "formal_statement": "theorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Basic\nimport Mathlib.Algebra.Module.Defs\nimport Mathlib.Algebra.Star.Pi\n\n#align_import algebra.star.self_adjoint from \"leanprover-community/mathlib\"@\"a6ece35404f60597c651689c1b46ead86de5ac1b\"\n\n\n\nopen Function\n\nvariable {R A : Type*}\n\n\ndef IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x\n#align is_self_adjoint IsSelfAdjoint\n\n\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x\n#align is_star_normal IsStarNormal\n\nexport IsStarNormal (star_comm_self)\n\ntheorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n#align star_comm_self' star_comm_self'\n\nnamespace IsSelfAdjoint\n\n-- named to match `Commute.all\u2093`\n\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n#align is_self_adjoint.all IsSelfAdjoint.all\n\ntheorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n#align is_self_adjoint.star_eq IsSelfAdjoint.star_eq\n\ntheorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x :=\n  Iff.rfl\n#align is_self_adjoint_iff isSelfAdjoint_iff\n\n@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n#align is_self_adjoint.star_iff IsSelfAdjoint.star_iff\n\n@[simp]\n"}
{"name": "jacobiSymNat.even_even106", "split": "test", "formal_statement": "theorem jacobiSymNat.even_even (a b : \u2115) (hb\u2080 : Nat.beq (b / 2) 0 = false) (ha : a % 2 = 0)\n    (hb\u2081 : b % 2 = 0) : jacobiSymNat a b = 0 := by", "header": "\nimport Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol\n\n#align_import number_theory.legendre_symbol.norm_num from \"leanprover-community/mathlib\"@\"e2621d935895abe70071ab828a4ee6e26a52afe4\"\n\n\n\n\nsection Lemmas\n\nnamespace Mathlib.Meta.NormNum\n\n\ndef jacobiSymNat (a b : \u2115) : \u2124 :=\n  jacobiSym a b\n#align norm_num.jacobi_sym_nat Mathlib.Meta.NormNum.jacobiSymNat\n\n\n\n\n\ntheorem jacobiSymNat.zero_right (a : \u2115) : jacobiSymNat a 0 = 1 := by\n  rw [jacobiSymNat, jacobiSym.zero_right]\n#align norm_num.jacobi_sym_nat.zero_right Mathlib.Meta.NormNum.jacobiSymNat.zero_right\n\ntheorem jacobiSymNat.one_right (a : \u2115) : jacobiSymNat a 1 = 1 := by\n  rw [jacobiSymNat, jacobiSym.one_right]\n#align norm_num.jacobi_sym_nat.one_right Mathlib.Meta.NormNum.jacobiSymNat.one_right\n\ntheorem jacobiSymNat.zero_left (b : \u2115) (hb : Nat.beq (b / 2) 0 = false) : jacobiSymNat 0 b = 0 := by\n  rw [jacobiSymNat, Nat.cast_zero, jacobiSym.zero_left ?_]\n  calc\n    1 < 2 * 1       := by decide\n    _ \u2264 2 * (b / 2) :=\n      Nat.mul_le_mul_left _ (Nat.succ_le.mpr (Nat.pos_of_ne_zero (Nat.ne_of_beq_eq_false hb)))\n    _ \u2264 b           := Nat.mul_div_le b 2\n#align norm_num.jacobi_sym_nat.zero_left_even Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n#align norm_num.jacobi_sym_nat.zero_left_odd Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n\ntheorem jacobiSymNat.one_left (b : \u2115) : jacobiSymNat 1 b = 1 := by\n  rw [jacobiSymNat, Nat.cast_one, jacobiSym.one_left]\n#align norm_num.jacobi_sym_nat.one_left_even Mathlib.Meta.NormNum.jacobiSymNat.one_left\n#align norm_num.jacobi_sym_nat.one_left_odd Mathlib.Meta.NormNum.jacobiSymNat.one_left\n\n\ntheorem LegendreSym.to_jacobiSym (p : \u2115) (pp : Fact p.Prime) (a r : \u2124)\n    (hr : IsInt (jacobiSym a p) r) : IsInt (legendreSym p a) r := by\n  rwa [@jacobiSym.legendreSym.to_jacobiSym p pp a]\n#align norm_num.legendre_sym.to_jacobi_sym Mathlib.Meta.NormNum.LegendreSym.to_jacobiSym\n\n\ntheorem JacobiSym.mod_left (a : \u2124) (b ab' : \u2115) (ab r b' : \u2124) (hb' : (b : \u2124) = b')\n    (hab : a % b' = ab) (h : (ab' : \u2124) = ab) (hr : jacobiSymNat ab' b = r) : jacobiSym a b = r := by\n  rw [\u2190 hr, jacobiSymNat, jacobiSym.mod_left, hb', hab, \u2190 h]\n#align norm_num.jacobi_sym.mod_left Mathlib.Meta.NormNum.JacobiSym.mod_left\n\ntheorem jacobiSymNat.mod_left (a b ab : \u2115) (r : \u2124) (hab : a % b = ab) (hr : jacobiSymNat ab b = r) :\n    jacobiSymNat a b = r := by\n  rw [\u2190 hr, jacobiSymNat, jacobiSymNat, _root_.jacobiSym.mod_left a b, \u2190 hab]; rfl\n#align norm_num.jacobi_sym_nat.mod_left Mathlib.Meta.NormNum.jacobiSymNat.mod_left\n\n\n"}
{"name": "card_Ico107", "split": "test", "formal_statement": "theorem card_Ico : (Ico a b).card = (\u220f i, (Icc (a i) (b i)).card) - 1 := by", "header": "\nimport Mathlib.Order.Interval.Finset.Basic\nimport Mathlib.Data.Fintype.BigOperators\n\n#align_import data.pi.interval from \"leanprover-community/mathlib\"@\"1d29de43a5ba4662dd33b5cfeecfc2a27a5a8a29\"\n\n\n\n\nopen Finset Fintype\n\nvariable {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [Fintype \u03b9] [DecidableEq \u03b9] [\u2200 i, DecidableEq (\u03b1 i)]\n\nnamespace Pi\nsection PartialOrder\nvariable [\u2200 i, PartialOrder (\u03b1 i)]\n\nsection LocallyFiniteOrder\nvariable [\u2200 i, LocallyFiniteOrder (\u03b1 i)]\n\ninstance instLocallyFiniteOrder : LocallyFiniteOrder (\u2200 i, \u03b1 i) :=\n  LocallyFiniteOrder.ofIcc _ (fun a b => piFinset fun i => Icc (a i) (b i)) fun a b x => by\n    simp_rw [mem_piFinset, mem_Icc, le_def, forall_and]\n\nvariable (a b : \u2200 i, \u03b1 i)\n\ntheorem Icc_eq : Icc a b = piFinset fun i => Icc (a i) (b i) :=\n  rfl\n#align pi.Icc_eq Pi.Icc_eq\n\ntheorem card_Icc : (Icc a b).card = \u220f i, (Icc (a i) (b i)).card :=\n  card_piFinset _\n#align pi.card_Icc Pi.card_Icc\n\n"}
{"name": "normalize.reduced'108", "split": "test", "formal_statement": "theorem normalize.reduced' {num : Int} {den g : Nat} (den_nz : den \u2260 0)\n    (e : g = num.natAbs.gcd den) : (num / g).natAbs.Coprime (den / g) := by", "header": "\nimport Batteries.Data.Rat.Basic\nimport Batteries.Tactic.SeqFocus\n\n\n\nnamespace Rat\n\ntheorem ext : {p q : Rat} \u2192 p.num = q.num \u2192 p.den = q.den \u2192 p = q\n  | \u27e8_,_,_,_\u27e9, \u27e8_,_,_,_\u27e9, rfl, rfl => rfl\n\n@[simp] theorem mk_den_one {r : Int} :\n    \u27e8r, 1, Nat.one_ne_zero, (Nat.coprime_one_right _)\u27e9 = (r : Rat) := rfl\n\n@[simp] theorem zero_num : (0 : Rat).num = 0 := rfl\n@[simp] theorem zero_den : (0 : Rat).den = 1 := rfl\n@[simp] theorem one_num : (1 : Rat).num = 1 := rfl\n@[simp] theorem one_den : (1 : Rat).den = 1 := rfl\n\n@[simp] theorem maybeNormalize_eq {num den g} (den_nz reduced) :\n    maybeNormalize num den g den_nz reduced =\n    { num := num.div g, den := den / g, den_nz, reduced } := by\n  unfold maybeNormalize; split\n  \u00b7 subst g; simp\n  \u00b7 rfl\n\n"}
{"name": "aeval_pow_two_pow_dvd_aeval_iterate_newtonMap109", "split": "test", "formal_statement": "theorem aeval_pow_two_pow_dvd_aeval_iterate_newtonMap\n    (h : IsNilpotent (aeval x P)) (h' : IsUnit (aeval x <| derivative P)) (n : \u2115) :\n    (aeval x P) ^ (2 ^ n) \u2223 aeval (P.newtonMap^[n] x) P := by", "header": "\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Identities\nimport Mathlib.RingTheory.Nilpotent.Lemmas\nimport Mathlib.RingTheory.Polynomial.Nilpotent\nimport Mathlib.RingTheory.Polynomial.Tower\n\n\n\nopen Set Function\n\nnoncomputable section\n\nnamespace Polynomial\n\nvariable {R S : Type*} [CommRing R] [CommRing S] [Algebra R S] (P : R[X]) {x : S}\n\n\ndef newtonMap (x : S) : S :=\n  x - (Ring.inverse <| aeval x (derivative P)) * aeval x P\n\ntheorem newtonMap_apply :\n    P.newtonMap x = x - (Ring.inverse <| aeval x (derivative P)) * (aeval x P) :=\n  rfl\n\nvariable {P}\n\ntheorem newtonMap_apply_of_isUnit (h : IsUnit <| aeval x (derivative P)) :\n    P.newtonMap x = x - h.unit\u207b\u00b9 * aeval x P := by\n  simp [newtonMap_apply, Ring.inverse, h]\n\ntheorem newtonMap_apply_of_not_isUnit (h : \u00ac (IsUnit <| aeval x (derivative P))) :\n    P.newtonMap x = x := by\n  simp [newtonMap_apply, Ring.inverse, h]\n\ntheorem isNilpotent_iterate_newtonMap_sub_of_isNilpotent (h : IsNilpotent <| aeval x P) (n : \u2115) :\n    IsNilpotent <| P.newtonMap^[n] x - x := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [iterate_succ', comp_apply, newtonMap_apply, sub_right_comm]\n    refine (Commute.all _ _).isNilpotent_sub ih <| (Commute.all _ _).isNilpotent_mul_right ?_\n    simpa using Commute.isNilpotent_add (Commute.all _ _)\n      (isNilpotent_aeval_sub_of_isNilpotent_sub P ih) h\n\ntheorem isFixedPt_newtonMap_of_aeval_eq_zero (h : aeval x P = 0) :\n    IsFixedPt P.newtonMap x := by\n  rw [IsFixedPt, newtonMap_apply, h, mul_zero, sub_zero]\n\ntheorem isFixedPt_newtonMap_of_isUnit_iff (h : IsUnit <| aeval x (derivative P)) :\n    IsFixedPt P.newtonMap x \u2194 aeval x P = 0 := by\n  rw [IsFixedPt, newtonMap_apply, sub_eq_self, Ring.inverse_mul_eq_iff_eq_mul _ _ _ h, mul_zero]\n\n\n"}
{"name": "floor_eq_self_of_mem110", "split": "test", "formal_statement": "theorem floor_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (floor b m : E) = m := by", "header": "\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n\n\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\ntheorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by simp [span_span_of_tower]\n\n\ndef fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}\n#align zspan.fundamental_domain Zspan.fundamentalDomain\n\n@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1 := Iff.rfl\n#align zspan.mem_fundamental_domain Zspan.mem_fundamentalDomain\n\ntheorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by\n  ext x\n  rw [mem_fundamentalDomain, Basis.map_repr, LinearEquiv.trans_apply, \u2190 mem_fundamentalDomain,\n    show f.symm x = f.toEquiv.symm x by rfl, \u2190 Set.mem_image_equiv]\n  rfl\n\n@[simp]\ntheorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]\n\nlemma fundamentalDomain_pi_basisFun [Fintype \u03b9] :\n    fundamentalDomain (Pi.basisFun \u211d \u03b9) = Set.pi Set.univ fun _ : \u03b9 \u21a6 Set.Ico (0 : \u211d) 1 := by\n  ext; simp\n\nvariable [FloorRing K]\n\nsection Fintype\n\nvariable [Fintype \u03b9]\n\n\ndef floor (m : E) : span \u2124 (Set.range b) := \u2211 i, \u230ab.repr m i\u230b \u2022 b.restrictScalars \u2124 i\n#align zspan.floor Zspan.floor\n\n\ndef ceil (m : E) : span \u2124 (Set.range b) := \u2211 i, \u2308b.repr m i\u2309 \u2022 b.restrictScalars \u2124 i\n#align zspan.ceil Zspan.ceil\n\n@[simp]\ntheorem repr_floor_apply (m : E) (i : \u03b9) : b.repr (floor b m) i = \u230ab.repr m i\u230b := by\n  classical simp only [floor, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_floor_apply Zspan.repr_floor_apply\n\n@[simp]\ntheorem repr_ceil_apply (m : E) (i : \u03b9) : b.repr (ceil b m) i = \u2308b.repr m i\u2309 := by\n  classical simp only [ceil, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_ceil_apply Zspan.repr_ceil_apply\n\n@[simp]\n"}
{"name": "deriv_inv111", "split": "test", "formal_statement": "theorem deriv_inv : deriv (fun x => x\u207b\u00b9) x = -(x ^ 2)\u207b\u00b9 := by", "header": "\nimport Mathlib.Analysis.Calculus.Deriv.Mul\nimport Mathlib.Analysis.Calculus.Deriv.Comp\n\n#align_import analysis.calculus.deriv.inv from \"leanprover-community/mathlib\"@\"3bce8d800a6f2b8f63fe1e588fd76a9ff4adcebe\"\n\n\n\n\nuniverse u v w\n\nopen scoped Classical\nopen Topology Filter ENNReal\n\nopen Filter Asymptotics Set\n\nopen ContinuousLinearMap (smulRight smulRight_one_eq_iff)\n\nvariable {\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]\nvariable {F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\nvariable {E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\nvariable {f f\u2080 f\u2081 g : \ud835\udd5c \u2192 F}\nvariable {f' f\u2080' f\u2081' g' : F}\nvariable {x : \ud835\udd5c}\nvariable {s t : Set \ud835\udd5c}\nvariable {L : Filter \ud835\udd5c}\n\nsection Inverse\n\n\n\ntheorem hasStrictDerivAt_inv (hx : x \u2260 0) : HasStrictDerivAt Inv.inv (-(x ^ 2)\u207b\u00b9) x := by\n  suffices\n    (fun p : \ud835\udd5c \u00d7 \ud835\udd5c => (p.1 - p.2) * ((x * x)\u207b\u00b9 - (p.1 * p.2)\u207b\u00b9)) =o[\ud835\udcdd (x, x)] fun p =>\n      (p.1 - p.2) * 1 by\n    refine this.congr' ?_ (eventually_of_forall fun _ => mul_one _)\n    refine Eventually.mono ((isOpen_ne.prod isOpen_ne).mem_nhds \u27e8hx, hx\u27e9) ?_\n    rintro \u27e8y, z\u27e9 \u27e8hy, hz\u27e9\n    simp only [mem_setOf_eq] at hy hz\n    -- hy : y \u2260 0, hz : z \u2260 0\n    field_simp [hx, hy, hz]\n    ring\n  refine (isBigO_refl (fun p : \ud835\udd5c \u00d7 \ud835\udd5c => p.1 - p.2) _).mul_isLittleO ((isLittleO_one_iff \ud835\udd5c).2 ?_)\n  rw [\u2190 sub_self (x * x)\u207b\u00b9]\n  exact tendsto_const_nhds.sub ((continuous_mul.tendsto (x, x)).inv\u2080 <| mul_ne_zero hx hx)\n#align has_strict_deriv_at_inv hasStrictDerivAt_inv\n\ntheorem hasDerivAt_inv (x_ne_zero : x \u2260 0) : HasDerivAt (fun y => y\u207b\u00b9) (-(x ^ 2)\u207b\u00b9) x :=\n  (hasStrictDerivAt_inv x_ne_zero).hasDerivAt\n#align has_deriv_at_inv hasDerivAt_inv\n\ntheorem hasDerivWithinAt_inv (x_ne_zero : x \u2260 0) (s : Set \ud835\udd5c) :\n    HasDerivWithinAt (fun x => x\u207b\u00b9) (-(x ^ 2)\u207b\u00b9) s x :=\n  (hasDerivAt_inv x_ne_zero).hasDerivWithinAt\n#align has_deriv_within_at_inv hasDerivWithinAt_inv\n\ntheorem differentiableAt_inv : DifferentiableAt \ud835\udd5c (fun x => x\u207b\u00b9) x \u2194 x \u2260 0 :=\n  \u27e8fun H => NormedField.continuousAt_inv.1 H.continuousAt, fun H =>\n    (hasDerivAt_inv H).differentiableAt\u27e9\n#align differentiable_at_inv differentiableAt_inv\n\ntheorem differentiableWithinAt_inv (x_ne_zero : x \u2260 0) :\n    DifferentiableWithinAt \ud835\udd5c (fun x => x\u207b\u00b9) s x :=\n  (differentiableAt_inv.2 x_ne_zero).differentiableWithinAt\n#align differentiable_within_at_inv differentiableWithinAt_inv\n\ntheorem differentiableOn_inv : DifferentiableOn \ud835\udd5c (fun x : \ud835\udd5c => x\u207b\u00b9) { x | x \u2260 0 } := fun _x hx =>\n  differentiableWithinAt_inv hx\n#align differentiable_on_inv differentiableOn_inv\n\n"}
{"name": "dvd_prime112", "split": "test", "formal_statement": "theorem dvd_prime {p m : \u2115+} (pp : p.Prime) : m \u2223 p \u2194 m = 1 \u2228 m = p := by", "header": "\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.prime from \"leanprover-community/mathlib\"@\"09597669f02422ed388036273d8848119699c22f\"\n\n\n\n\nnamespace PNat\n\nopen Nat\n\n\ndef gcd (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.gcd (n : \u2115) (m : \u2115), Nat.gcd_pos_of_pos_left (m : \u2115) n.pos\u27e9\n#align pnat.gcd PNat.gcd\n\n\ndef lcm (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.lcm (n : \u2115) (m : \u2115), by\n    let h := mul_pos n.pos m.pos\n    rw [\u2190 gcd_mul_lcm (n : \u2115) (m : \u2115), mul_comm] at h\n    exact pos_of_dvd_of_pos (Dvd.intro (Nat.gcd (n : \u2115) (m : \u2115)) rfl) h\u27e9\n#align pnat.lcm PNat.lcm\n\n@[simp, norm_cast]\ntheorem gcd_coe (n m : \u2115+) : (gcd n m : \u2115) = Nat.gcd n m :=\n  rfl\n#align pnat.gcd_coe PNat.gcd_coe\n\n@[simp, norm_cast]\ntheorem lcm_coe (n m : \u2115+) : (lcm n m : \u2115) = Nat.lcm n m :=\n  rfl\n#align pnat.lcm_coe PNat.lcm_coe\n\ntheorem gcd_dvd_left (n m : \u2115+) : gcd n m \u2223 n :=\n  dvd_iff.2 (Nat.gcd_dvd_left (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_left PNat.gcd_dvd_left\n\ntheorem gcd_dvd_right (n m : \u2115+) : gcd n m \u2223 m :=\n  dvd_iff.2 (Nat.gcd_dvd_right (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_right PNat.gcd_dvd_right\n\ntheorem dvd_gcd {m n k : \u2115+} (hm : k \u2223 m) (hn : k \u2223 n) : k \u2223 gcd m n :=\n  dvd_iff.2 (Nat.dvd_gcd (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.dvd_gcd PNat.dvd_gcd\n\ntheorem dvd_lcm_left (n m : \u2115+) : n \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_left (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_left PNat.dvd_lcm_left\n\ntheorem dvd_lcm_right (n m : \u2115+) : m \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_right (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_right PNat.dvd_lcm_right\n\ntheorem lcm_dvd {m n k : \u2115+} (hm : m \u2223 k) (hn : n \u2223 k) : lcm m n \u2223 k :=\n  dvd_iff.2 (@Nat.lcm_dvd (m : \u2115) (n : \u2115) (k : \u2115) (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.lcm_dvd PNat.lcm_dvd\n\ntheorem gcd_mul_lcm (n m : \u2115+) : gcd n m * lcm n m = n * m :=\n  Subtype.eq (Nat.gcd_mul_lcm (n : \u2115) (m : \u2115))\n#align pnat.gcd_mul_lcm PNat.gcd_mul_lcm\n\ntheorem eq_one_of_lt_two {n : \u2115+} : n < 2 \u2192 n = 1 := by\n  intro h; apply le_antisymm; swap\n  \u00b7 apply PNat.one_le\n  \u00b7 exact PNat.lt_add_one_iff.1 h\n#align pnat.eq_one_of_lt_two PNat.eq_one_of_lt_two\n\nsection Prime\n\n\n\n\n\ndef Prime (p : \u2115+) : Prop :=\n  (p : \u2115).Prime\n#align pnat.prime PNat.Prime\n\ntheorem Prime.one_lt {p : \u2115+} : p.Prime \u2192 1 < p :=\n  Nat.Prime.one_lt\n#align pnat.prime.one_lt PNat.Prime.one_lt\n\ntheorem prime_two : (2 : \u2115+).Prime :=\n  Nat.prime_two\n#align pnat.prime_two PNat.prime_two\n\ninstance {p : \u2115+} [h : Fact p.Prime] : Fact (p : \u2115).Prime := h\n\ninstance fact_prime_two : Fact (2 : \u2115+).Prime :=\n  \u27e8prime_two\u27e9\n\ntheorem prime_three : (3 : \u2115+).Prime :=\n  Nat.prime_three\n\ninstance fact_prime_three : Fact (3 : \u2115+).Prime :=\n  \u27e8prime_three\u27e9\n\ntheorem prime_five : (5 : \u2115+).Prime :=\n  Nat.prime_five\n\ninstance fact_prime_five : Fact (5 : \u2115+).Prime :=\n  \u27e8prime_five\u27e9\n\n"}
{"name": "integral_inter_add_diff\u2080113", "split": "test", "formal_statement": "theorem integral_inter_add_diff\u2080 (ht : NullMeasurableSet t \u03bc) (hfs : IntegrableOn f s \u03bc) :\n    \u222b x in s \u2229 t, f x \u2202\u03bc + \u222b x in s \\ t, f x \u2202\u03bc = \u222b x in s, f x \u2202\u03bc := by", "header": "\nimport Mathlib.MeasureTheory.Integral.IntegrableOn\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Function.LocallyIntegrable\nimport Mathlib.Topology.MetricSpace.ThickenedIndicator\nimport Mathlib.Topology.ContinuousFunction.Compact\nimport Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual\n\n#align_import measure_theory.integral.setIntegral from \"leanprover-community/mathlib\"@\"24e0c85412ff6adbeca08022c25ba4876eedf37a\"\n\n\n\n\nassert_not_exists InnerProductSpace\n\nnoncomputable section\n\nopen Set Filter TopologicalSpace MeasureTheory Function RCLike\n\nopen scoped Classical Topology ENNReal NNReal\n\nvariable {X Y E F : Type*} [MeasurableSpace X]\n\nnamespace MeasureTheory\n\nsection NormedAddCommGroup\n\nvariable [NormedAddCommGroup E] [NormedSpace \u211d E]\n  {f g : X \u2192 E} {s t : Set X} {\u03bc \u03bd : Measure X} {l l' : Filter X}\n\ntheorem setIntegral_congr_ae\u2080 (hs : NullMeasurableSet s \u03bc) (h : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x = g x) :\n    \u222b x in s, f x \u2202\u03bc = \u222b x in s, g x \u2202\u03bc :=\n  integral_congr_ae ((ae_restrict_iff'\u2080 hs).2 h)\n#align measure_theory.set_integral_congr_ae\u2080 MeasureTheory.setIntegral_congr_ae\u2080\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr_ae\u2080 := setIntegral_congr_ae\u2080\n\ntheorem setIntegral_congr_ae (hs : MeasurableSet s) (h : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x = g x) :\n    \u222b x in s, f x \u2202\u03bc = \u222b x in s, g x \u2202\u03bc :=\n  integral_congr_ae ((ae_restrict_iff' hs).2 h)\n#align measure_theory.set_integral_congr_ae MeasureTheory.setIntegral_congr_ae\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr_ae := setIntegral_congr_ae\n\ntheorem setIntegral_congr\u2080 (hs : NullMeasurableSet s \u03bc) (h : EqOn f g s) :\n    \u222b x in s, f x \u2202\u03bc = \u222b x in s, g x \u2202\u03bc :=\n  setIntegral_congr_ae\u2080 hs <| eventually_of_forall h\n#align measure_theory.set_integral_congr\u2080 MeasureTheory.setIntegral_congr\u2080\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr\u2080 := setIntegral_congr\u2080\n\ntheorem setIntegral_congr (hs : MeasurableSet s) (h : EqOn f g s) :\n    \u222b x in s, f x \u2202\u03bc = \u222b x in s, g x \u2202\u03bc :=\n  setIntegral_congr_ae hs <| eventually_of_forall h\n#align measure_theory.set_integral_congr MeasureTheory.setIntegral_congr\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr := setIntegral_congr\n\ntheorem setIntegral_congr_set_ae (hst : s =\u1d50[\u03bc] t) : \u222b x in s, f x \u2202\u03bc = \u222b x in t, f x \u2202\u03bc := by\n  rw [Measure.restrict_congr_set hst]\n#align measure_theory.set_integral_congr_set_ae MeasureTheory.setIntegral_congr_set_ae\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr_set_ae := setIntegral_congr_set_ae\n\ntheorem integral_union_ae (hst : AEDisjoint \u03bc s t) (ht : NullMeasurableSet t \u03bc)\n    (hfs : IntegrableOn f s \u03bc) (hft : IntegrableOn f t \u03bc) :\n    \u222b x in s \u222a t, f x \u2202\u03bc = \u222b x in s, f x \u2202\u03bc + \u222b x in t, f x \u2202\u03bc := by\n  simp only [IntegrableOn, Measure.restrict_union\u2080 hst ht, integral_add_measure hfs hft]\n#align measure_theory.integral_union_ae MeasureTheory.integral_union_ae\n\ntheorem integral_union (hst : Disjoint s t) (ht : MeasurableSet t) (hfs : IntegrableOn f s \u03bc)\n    (hft : IntegrableOn f t \u03bc) : \u222b x in s \u222a t, f x \u2202\u03bc = \u222b x in s, f x \u2202\u03bc + \u222b x in t, f x \u2202\u03bc :=\n  integral_union_ae hst.aedisjoint ht.nullMeasurableSet hfs hft\n#align measure_theory.integral_union MeasureTheory.integral_union\n\ntheorem integral_diff (ht : MeasurableSet t) (hfs : IntegrableOn f s \u03bc) (hts : t \u2286 s) :\n    \u222b x in s \\ t, f x \u2202\u03bc = \u222b x in s, f x \u2202\u03bc - \u222b x in t, f x \u2202\u03bc := by\n  rw [eq_sub_iff_add_eq, \u2190 integral_union, diff_union_of_subset hts]\n  exacts [disjoint_sdiff_self_left, ht, hfs.mono_set diff_subset, hfs.mono_set hts]\n#align measure_theory.integral_diff MeasureTheory.integral_diff\n\n"}
{"name": "edgeFinset_top114", "split": "test", "formal_statement": "theorem edgeFinset_top [DecidableEq V] :\n    (\u22a4 : SimpleGraph V).edgeFinset = univ.filter fun e => \u00ace.IsDiag := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Combinatorics.SimpleGraph.Basic\nimport Mathlib.Data.Sym.Card\n\n\n\n\nopen Finset Function\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V) {e : Sym2 V}\n\nsection EdgeFinset\n\nvariable {G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]\n\n\nabbrev edgeFinset : Finset (Sym2 V) :=\n  Set.toFinset G.edgeSet\n#align simple_graph.edge_finset SimpleGraph.edgeFinset\n\n@[norm_cast]\ntheorem coe_edgeFinset : (G.edgeFinset : Set (Sym2 V)) = G.edgeSet :=\n  Set.coe_toFinset _\n#align simple_graph.coe_edge_finset SimpleGraph.coe_edgeFinset\n\nvariable {G}\n\ntheorem mem_edgeFinset : e \u2208 G.edgeFinset \u2194 e \u2208 G.edgeSet :=\n  Set.mem_toFinset\n#align simple_graph.mem_edge_finset SimpleGraph.mem_edgeFinset\n\ntheorem not_isDiag_of_mem_edgeFinset : e \u2208 G.edgeFinset \u2192 \u00ace.IsDiag :=\n  not_isDiag_of_mem_edgeSet _ \u2218 mem_edgeFinset.1\n#align simple_graph.not_is_diag_of_mem_edge_finset SimpleGraph.not_isDiag_of_mem_edgeFinset\n\ntheorem edgeFinset_inj : G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082 := by simp\n#align simple_graph.edge_finset_inj SimpleGraph.edgeFinset_inj\n\ntheorem edgeFinset_subset_edgeFinset : G\u2081.edgeFinset \u2286 G\u2082.edgeFinset \u2194 G\u2081 \u2264 G\u2082 := by simp\n#align simple_graph.edge_finset_subset_edge_finset SimpleGraph.edgeFinset_subset_edgeFinset\n\ntheorem edgeFinset_ssubset_edgeFinset : G\u2081.edgeFinset \u2282 G\u2082.edgeFinset \u2194 G\u2081 < G\u2082 := by simp\n#align simple_graph.edge_finset_ssubset_edge_finset SimpleGraph.edgeFinset_ssubset_edgeFinset\n\n@[gcongr] alias \u27e8_, edgeFinset_mono\u27e9 := edgeFinset_subset_edgeFinset\n#align simple_graph.edge_finset_mono SimpleGraph.edgeFinset_mono\n\nalias \u27e8_, edgeFinset_strict_mono\u27e9 := edgeFinset_ssubset_edgeFinset\n#align simple_graph.edge_finset_strict_mono SimpleGraph.edgeFinset_strict_mono\n\nattribute [mono] edgeFinset_mono edgeFinset_strict_mono\n\n@[simp]\ntheorem edgeFinset_bot : (\u22a5 : SimpleGraph V).edgeFinset = \u2205 := by simp [edgeFinset]\n#align simple_graph.edge_finset_bot SimpleGraph.edgeFinset_bot\n\n@[simp]\ntheorem edgeFinset_sup [Fintype (edgeSet (G\u2081 \u2294 G\u2082))] [DecidableEq V] :\n    (G\u2081 \u2294 G\u2082).edgeFinset = G\u2081.edgeFinset \u222a G\u2082.edgeFinset := by simp [edgeFinset]\n#align simple_graph.edge_finset_sup SimpleGraph.edgeFinset_sup\n\n@[simp]\ntheorem edgeFinset_inf [DecidableEq V] : (G\u2081 \u2293 G\u2082).edgeFinset = G\u2081.edgeFinset \u2229 G\u2082.edgeFinset := by\n  simp [edgeFinset]\n#align simple_graph.edge_finset_inf SimpleGraph.edgeFinset_inf\n\n@[simp]\ntheorem edgeFinset_sdiff [DecidableEq V] :\n    (G\u2081 \\ G\u2082).edgeFinset = G\u2081.edgeFinset \\ G\u2082.edgeFinset := by simp [edgeFinset]\n#align simple_graph.edge_finset_sdiff SimpleGraph.edgeFinset_sdiff\n\ntheorem edgeFinset_card : G.edgeFinset.card = Fintype.card G.edgeSet :=\n  Set.toFinset_card _\n#align simple_graph.edge_finset_card SimpleGraph.edgeFinset_card\n\n@[simp]\ntheorem edgeSet_univ_card : (univ : Finset G.edgeSet).card = G.edgeFinset.card :=\n  Fintype.card_of_subtype G.edgeFinset fun _ => mem_edgeFinset\n#align simple_graph.edge_set_univ_card SimpleGraph.edgeSet_univ_card\n\nvariable [Fintype V]\n\n@[simp]\n"}
{"name": "image_eq_inter_preimage_of_subset_support115", "split": "test", "formal_statement": "theorem image_eq_inter_preimage_of_subset_support {s : Set M} (hs : s \u2286 support f) :\n    extChartAt I c '' s =\n      closedBall (extChartAt I c c) f.rOut \u2229 range I \u2229 (extChartAt I c).symm \u207b\u00b9' s := by", "header": "\nimport Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension\nimport Mathlib.Geometry.Manifold.ContMDiff.Atlas\nimport Mathlib.Geometry.Manifold.ContMDiff.NormedSpace\n\n#align_import geometry.manifold.bump_function from \"leanprover-community/mathlib\"@\"b018406ad2f2a73223a3a9e198ccae61e6f05318\"\n\n\n\nuniverse uE uF uH uM\n\nvariable {E : Type uE} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\n  {H : Type uH} [TopologicalSpace H] (I : ModelWithCorners \u211d E H) {M : Type uM} [TopologicalSpace M]\n  [ChartedSpace H M] [SmoothManifoldWithCorners I M]\n\nopen Function Filter FiniteDimensional Set Metric\n\nopen scoped Topology Manifold Classical Filter\n\nnoncomputable section\n\n\n\n\nstructure SmoothBumpFunction (c : M) extends ContDiffBump (extChartAt I c c) where\n  closedBall_subset : closedBall (extChartAt I c c) rOut \u2229 range I \u2286 (extChartAt I c).target\n#align smooth_bump_function SmoothBumpFunction\n\nnamespace SmoothBumpFunction\n\nvariable {c : M} (f : SmoothBumpFunction I c) {x : M} {I}\n\n\n@[coe] def toFun : M \u2192 \u211d :=\n  indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c)\n#align smooth_bump_function.to_fun SmoothBumpFunction.toFun\n\ninstance : CoeFun (SmoothBumpFunction I c) fun _ => M \u2192 \u211d :=\n  \u27e8toFun\u27e9\n\ntheorem coe_def : \u21d1f = indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c) :=\n  rfl\n#align smooth_bump_function.coe_def SmoothBumpFunction.coe_def\n\ntheorem rOut_pos : 0 < f.rOut :=\n  f.toContDiffBump.rOut_pos\nset_option linter.uppercaseLean3 false in\n#align smooth_bump_function.R_pos SmoothBumpFunction.rOut_pos\n\ntheorem ball_subset : ball (extChartAt I c c) f.rOut \u2229 range I \u2286 (extChartAt I c).target :=\n  Subset.trans (inter_subset_inter_left _ ball_subset_closedBall) f.closedBall_subset\n#align smooth_bump_function.ball_subset SmoothBumpFunction.ball_subset\n\ntheorem ball_inter_range_eq_ball_inter_target :\n    ball (extChartAt I c c) f.rOut \u2229 range I =\n      ball (extChartAt I c c) f.rOut \u2229 (extChartAt I c).target :=\n  (subset_inter inter_subset_left f.ball_subset).antisymm <| inter_subset_inter_right _ <|\n    extChartAt_target_subset_range _ _\n\ntheorem eqOn_source : EqOn f (f.toContDiffBump \u2218 extChartAt I c) (chartAt H c).source :=\n  eqOn_indicator\n#align smooth_bump_function.eq_on_source SmoothBumpFunction.eqOn_source\n\ntheorem eventuallyEq_of_mem_source (hx : x \u2208 (chartAt H c).source) :\n    f =\u1da0[\ud835\udcdd x] f.toContDiffBump \u2218 extChartAt I c :=\n  f.eqOn_source.eventuallyEq_of_mem <| (chartAt H c).open_source.mem_nhds hx\n#align smooth_bump_function.eventually_eq_of_mem_source SmoothBumpFunction.eventuallyEq_of_mem_source\n\ntheorem one_of_dist_le (hs : x \u2208 (chartAt H c).source)\n    (hd : dist (extChartAt I c x) (extChartAt I c c) \u2264 f.rIn) : f x = 1 := by\n  simp only [f.eqOn_source hs, (\u00b7 \u2218 \u00b7), f.one_of_mem_closedBall hd]\n#align smooth_bump_function.one_of_dist_le SmoothBumpFunction.one_of_dist_le\n\ntheorem support_eq_inter_preimage :\n    support f = (chartAt H c).source \u2229 extChartAt I c \u207b\u00b9' ball (extChartAt I c c) f.rOut := by\n  rw [coe_def, support_indicator, support_comp_eq_preimage, \u2190 extChartAt_source I,\n    \u2190 (extChartAt I c).symm_image_target_inter_eq', \u2190 (extChartAt I c).symm_image_target_inter_eq',\n    f.support_eq]\n#align smooth_bump_function.support_eq_inter_preimage SmoothBumpFunction.support_eq_inter_preimage\n\ntheorem isOpen_support : IsOpen (support f) := by\n  rw [support_eq_inter_preimage]\n  exact isOpen_extChartAt_preimage I c isOpen_ball\n#align smooth_bump_function.is_open_support SmoothBumpFunction.isOpen_support\n\ntheorem support_eq_symm_image :\n    support f = (extChartAt I c).symm '' (ball (extChartAt I c c) f.rOut \u2229 range I) := by\n  rw [f.support_eq_inter_preimage, \u2190 extChartAt_source I,\n    \u2190 (extChartAt I c).symm_image_target_inter_eq', inter_comm,\n    ball_inter_range_eq_ball_inter_target]\n#align smooth_bump_function.support_eq_symm_image SmoothBumpFunction.support_eq_symm_image\n\ntheorem support_subset_source : support f \u2286 (chartAt H c).source := by\n  rw [f.support_eq_inter_preimage, \u2190 extChartAt_source I]; exact inter_subset_left\n#align smooth_bump_function.support_subset_source SmoothBumpFunction.support_subset_source\n\n"}
{"name": "innerContent_bot116", "split": "test", "formal_statement": "theorem innerContent_bot : \u03bc.innerContent \u22a5 = 0 := by", "header": "\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport Mathlib.MeasureTheory.Measure.Regular\nimport Mathlib.Topology.Sets.Compacts\n\n#align_import measure_theory.measure.content from \"leanprover-community/mathlib\"@\"d39590fc8728fbf6743249802486f8c91ffe07bc\"\n\n\n\n\nuniverse u v w\n\nnoncomputable section\n\nopen Set TopologicalSpace\n\nopen NNReal ENNReal MeasureTheory\n\nnamespace MeasureTheory\n\nvariable {G : Type w} [TopologicalSpace G]\n\n\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G \u2192 \u211d\u22650\n  mono' : \u2200 K\u2081 K\u2082 : Compacts G, (K\u2081 : Set G) \u2286 K\u2082 \u2192 toFun K\u2081 \u2264 toFun K\u2082\n  sup_disjoint' :\n    \u2200 K\u2081 K\u2082 : Compacts G, Disjoint (K\u2081 : Set G) K\u2082 \u2192 IsClosed (K\u2081 : Set G) \u2192 IsClosed (K\u2082 : Set G)\n      \u2192 toFun (K\u2081 \u2294 K\u2082) = toFun K\u2081 + toFun K\u2082\n  sup_le' : \u2200 K\u2081 K\u2082 : Compacts G, toFun (K\u2081 \u2294 K\u2082) \u2264 toFun K\u2081 + toFun K\u2082\n#align measure_theory.content MeasureTheory.Content\n\ninstance : Inhabited (Content G) :=\n  \u27e8{  toFun := fun _ => 0\n      mono' := by simp\n      sup_disjoint' := by simp\n      sup_le' := by simp }\u27e9\n\n\ninstance : CoeFun (Content G) fun _ => Compacts G \u2192 \u211d\u22650\u221e :=\n  \u27e8fun \u03bc s => \u03bc.toFun s\u27e9\n\nnamespace Content\n\nvariable (\u03bc : Content G)\n\ntheorem apply_eq_coe_toFun (K : Compacts G) : \u03bc K = \u03bc.toFun K :=\n  rfl\n#align measure_theory.content.apply_eq_coe_to_fun MeasureTheory.Content.apply_eq_coe_toFun\n\ntheorem mono (K\u2081 K\u2082 : Compacts G) (h : (K\u2081 : Set G) \u2286 K\u2082) : \u03bc K\u2081 \u2264 \u03bc K\u2082 := by\n  simp [apply_eq_coe_toFun, \u03bc.mono' _ _ h]\n#align measure_theory.content.mono MeasureTheory.Content.mono\n\ntheorem sup_disjoint (K\u2081 K\u2082 : Compacts G) (h : Disjoint (K\u2081 : Set G) K\u2082)\n    (h\u2081 : IsClosed (K\u2081 : Set G)) (h\u2082 : IsClosed (K\u2082 : Set G)) :\n    \u03bc (K\u2081 \u2294 K\u2082) = \u03bc K\u2081 + \u03bc K\u2082 := by\n  simp [apply_eq_coe_toFun, \u03bc.sup_disjoint' _ _ h]\n#align measure_theory.content.sup_disjoint MeasureTheory.Content.sup_disjoint\n\ntheorem sup_le (K\u2081 K\u2082 : Compacts G) : \u03bc (K\u2081 \u2294 K\u2082) \u2264 \u03bc K\u2081 + \u03bc K\u2082 := by\n  simp only [apply_eq_coe_toFun]\n  norm_cast\n  exact \u03bc.sup_le' _ _\n#align measure_theory.content.sup_le MeasureTheory.Content.sup_le\n\ntheorem lt_top (K : Compacts G) : \u03bc K < \u221e :=\n  ENNReal.coe_lt_top\n#align measure_theory.content.lt_top MeasureTheory.Content.lt_top\n\ntheorem empty : \u03bc \u22a5 = 0 := by\n  have := \u03bc.sup_disjoint' \u22a5 \u22a5\n  simpa [apply_eq_coe_toFun] using this\n#align measure_theory.content.empty MeasureTheory.Content.empty\n\n\ndef innerContent (U : Opens G) : \u211d\u22650\u221e :=\n  \u2a06 (K : Compacts G) (_ : (K : Set G) \u2286 U), \u03bc K\n#align measure_theory.content.inner_content MeasureTheory.Content.innerContent\n\ntheorem le_innerContent (K : Compacts G) (U : Opens G) (h2 : (K : Set G) \u2286 U) :\n    \u03bc K \u2264 \u03bc.innerContent U :=\n  le_iSup_of_le K <| le_iSup (fun _ \u21a6 (\u03bc.toFun K : \u211d\u22650\u221e)) h2\n#align measure_theory.content.le_inner_content MeasureTheory.Content.le_innerContent\n\ntheorem innerContent_le (U : Opens G) (K : Compacts G) (h2 : (U : Set G) \u2286 K) :\n    \u03bc.innerContent U \u2264 \u03bc K :=\n  iSup\u2082_le fun _ hK' => \u03bc.mono _ _ (Subset.trans hK' h2)\n#align measure_theory.content.inner_content_le MeasureTheory.Content.innerContent_le\n\ntheorem innerContent_of_isCompact {K : Set G} (h1K : IsCompact K) (h2K : IsOpen K) :\n    \u03bc.innerContent \u27e8K, h2K\u27e9 = \u03bc \u27e8K, h1K\u27e9 :=\n  le_antisymm (iSup\u2082_le fun _ hK' => \u03bc.mono _ \u27e8K, h1K\u27e9 hK') (\u03bc.le_innerContent _ _ Subset.rfl)\n#align measure_theory.content.inner_content_of_is_compact MeasureTheory.Content.innerContent_of_isCompact\n\n"}
{"name": "noncommFoldr_cons117", "split": "test", "formal_statement": "theorem noncommFoldr_cons (s : Multiset \u03b1) (a : \u03b1) (h h') (b : \u03b2) :\n    noncommFoldr f (a ::\u2098 s) h b = f a (noncommFoldr f s h' b) := by", "header": "\nimport Mathlib.Algebra.BigOperators.Group.Finset\nimport Mathlib.Algebra.Group.Commute.Hom\nimport Mathlib.Data.Fintype.Card\n\n#align_import data.finset.noncomm_prod from \"leanprover-community/mathlib\"@\"509de852e1de55e1efa8eacfa11df0823f26f226\"\n\n\n\nvariable {F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n\nnamespace Multiset\n\n\ndef noncommFoldr (s : Multiset \u03b1)\n    (comm : { x | x \u2208 s }.Pairwise fun x y => \u2200 b, f x (f y b) = f y (f x b)) (b : \u03b2) : \u03b2 :=\n  s.attach.foldr (f \u2218 Subtype.val)\n    (fun \u27e8_, hx\u27e9 \u27e8_, hy\u27e9 =>\n      haveI : IsRefl \u03b1 fun x y => \u2200 b, f x (f y b) = f y (f x b) := \u27e8fun _ _ => rfl\u27e9\n      comm.of_refl hx hy)\n    b\n#align multiset.noncomm_foldr Multiset.noncommFoldr\n\n@[simp]\ntheorem noncommFoldr_coe (l : List \u03b1) (comm) (b : \u03b2) :\n    noncommFoldr f (l : Multiset \u03b1) comm b = l.foldr f b := by\n  simp only [noncommFoldr, coe_foldr, coe_attach, List.attach, List.attachWith, Function.comp]\n  rw [\u2190 List.foldr_map]\n  simp [List.map_pmap]\n#align multiset.noncomm_foldr_coe Multiset.noncommFoldr_coe\n\n@[simp]\ntheorem noncommFoldr_empty (h) (b : \u03b2) : noncommFoldr f (0 : Multiset \u03b1) h b = b :=\n  rfl\n#align multiset.noncomm_foldr_empty Multiset.noncommFoldr_empty\n\n"}
{"name": "fderivWithin_inv118", "split": "test", "formal_statement": "theorem fderivWithin_inv (x_ne_zero : x \u2260 0) (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c (fun x => x\u207b\u00b9) s x = smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (-(x ^ 2)\u207b\u00b9) := by", "header": "\nimport Mathlib.Analysis.Calculus.Deriv.Mul\nimport Mathlib.Analysis.Calculus.Deriv.Comp\n\n#align_import analysis.calculus.deriv.inv from \"leanprover-community/mathlib\"@\"3bce8d800a6f2b8f63fe1e588fd76a9ff4adcebe\"\n\n\n\n\nuniverse u v w\n\nopen scoped Classical\nopen Topology Filter ENNReal\n\nopen Filter Asymptotics Set\n\nopen ContinuousLinearMap (smulRight smulRight_one_eq_iff)\n\nvariable {\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]\nvariable {F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\nvariable {E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\nvariable {f f\u2080 f\u2081 g : \ud835\udd5c \u2192 F}\nvariable {f' f\u2080' f\u2081' g' : F}\nvariable {x : \ud835\udd5c}\nvariable {s t : Set \ud835\udd5c}\nvariable {L : Filter \ud835\udd5c}\n\nsection Inverse\n\n\n\ntheorem hasStrictDerivAt_inv (hx : x \u2260 0) : HasStrictDerivAt Inv.inv (-(x ^ 2)\u207b\u00b9) x := by\n  suffices\n    (fun p : \ud835\udd5c \u00d7 \ud835\udd5c => (p.1 - p.2) * ((x * x)\u207b\u00b9 - (p.1 * p.2)\u207b\u00b9)) =o[\ud835\udcdd (x, x)] fun p =>\n      (p.1 - p.2) * 1 by\n    refine this.congr' ?_ (eventually_of_forall fun _ => mul_one _)\n    refine Eventually.mono ((isOpen_ne.prod isOpen_ne).mem_nhds \u27e8hx, hx\u27e9) ?_\n    rintro \u27e8y, z\u27e9 \u27e8hy, hz\u27e9\n    simp only [mem_setOf_eq] at hy hz\n    -- hy : y \u2260 0, hz : z \u2260 0\n    field_simp [hx, hy, hz]\n    ring\n  refine (isBigO_refl (fun p : \ud835\udd5c \u00d7 \ud835\udd5c => p.1 - p.2) _).mul_isLittleO ((isLittleO_one_iff \ud835\udd5c).2 ?_)\n  rw [\u2190 sub_self (x * x)\u207b\u00b9]\n  exact tendsto_const_nhds.sub ((continuous_mul.tendsto (x, x)).inv\u2080 <| mul_ne_zero hx hx)\n#align has_strict_deriv_at_inv hasStrictDerivAt_inv\n\ntheorem hasDerivAt_inv (x_ne_zero : x \u2260 0) : HasDerivAt (fun y => y\u207b\u00b9) (-(x ^ 2)\u207b\u00b9) x :=\n  (hasStrictDerivAt_inv x_ne_zero).hasDerivAt\n#align has_deriv_at_inv hasDerivAt_inv\n\ntheorem hasDerivWithinAt_inv (x_ne_zero : x \u2260 0) (s : Set \ud835\udd5c) :\n    HasDerivWithinAt (fun x => x\u207b\u00b9) (-(x ^ 2)\u207b\u00b9) s x :=\n  (hasDerivAt_inv x_ne_zero).hasDerivWithinAt\n#align has_deriv_within_at_inv hasDerivWithinAt_inv\n\ntheorem differentiableAt_inv : DifferentiableAt \ud835\udd5c (fun x => x\u207b\u00b9) x \u2194 x \u2260 0 :=\n  \u27e8fun H => NormedField.continuousAt_inv.1 H.continuousAt, fun H =>\n    (hasDerivAt_inv H).differentiableAt\u27e9\n#align differentiable_at_inv differentiableAt_inv\n\ntheorem differentiableWithinAt_inv (x_ne_zero : x \u2260 0) :\n    DifferentiableWithinAt \ud835\udd5c (fun x => x\u207b\u00b9) s x :=\n  (differentiableAt_inv.2 x_ne_zero).differentiableWithinAt\n#align differentiable_within_at_inv differentiableWithinAt_inv\n\ntheorem differentiableOn_inv : DifferentiableOn \ud835\udd5c (fun x : \ud835\udd5c => x\u207b\u00b9) { x | x \u2260 0 } := fun _x hx =>\n  differentiableWithinAt_inv hx\n#align differentiable_on_inv differentiableOn_inv\n\ntheorem deriv_inv : deriv (fun x => x\u207b\u00b9) x = -(x ^ 2)\u207b\u00b9 := by\n  rcases eq_or_ne x 0 with (rfl | hne)\n  \u00b7 simp [deriv_zero_of_not_differentiableAt (mt differentiableAt_inv.1 (not_not.2 rfl))]\n  \u00b7 exact (hasDerivAt_inv hne).deriv\n#align deriv_inv deriv_inv\n\n@[simp]\ntheorem deriv_inv' : (deriv fun x : \ud835\udd5c => x\u207b\u00b9) = fun x => -(x ^ 2)\u207b\u00b9 :=\n  funext fun _ => deriv_inv\n#align deriv_inv' deriv_inv'\n\ntheorem derivWithin_inv (x_ne_zero : x \u2260 0) (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    derivWithin (fun x => x\u207b\u00b9) s x = -(x ^ 2)\u207b\u00b9 := by\n  rw [DifferentiableAt.derivWithin (differentiableAt_inv.2 x_ne_zero) hxs]\n  exact deriv_inv\n#align deriv_within_inv derivWithin_inv\n\ntheorem hasFDerivAt_inv (x_ne_zero : x \u2260 0) :\n    HasFDerivAt (fun x => x\u207b\u00b9) (smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (-(x ^ 2)\u207b\u00b9) : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) x :=\n  hasDerivAt_inv x_ne_zero\n#align has_fderiv_at_inv hasFDerivAt_inv\n\ntheorem hasFDerivWithinAt_inv (x_ne_zero : x \u2260 0) :\n    HasFDerivWithinAt (fun x => x\u207b\u00b9) (smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (-(x ^ 2)\u207b\u00b9) : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) s x :=\n  (hasFDerivAt_inv x_ne_zero).hasFDerivWithinAt\n#align has_fderiv_within_at_inv hasFDerivWithinAt_inv\n\ntheorem fderiv_inv : fderiv \ud835\udd5c (fun x => x\u207b\u00b9) x = smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (-(x ^ 2)\u207b\u00b9) := by\n  rw [\u2190 deriv_fderiv, deriv_inv]\n#align fderiv_inv fderiv_inv\n\n"}
{"name": "exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt119", "split": "test", "formal_statement": "theorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]\n    (f : E \u2192 F) (s : Set E) (f' : E \u2192 E \u2192L[\u211d] F) (hf' : \u2200 x \u2208 s, HasFDerivWithinAt f (f' x) s x)\n    (r : (E \u2192L[\u211d] F) \u2192 \u211d\u22650) (rpos : \u2200 A, r A \u2260 0) :\n    \u2203 (t : \u2115 \u2192 Set E) (A : \u2115 \u2192 E \u2192L[\u211d] F),\n      (\u2200 n, IsClosed (t n)) \u2227\n        (s \u2286 \u22c3 n, t n) \u2227\n          (\u2200 n, ApproximatesLinearOn f (A n) (s \u2229 t n) (r (A n))) \u2227\n            (s.Nonempty \u2192 \u2200 n, \u2203 y \u2208 s, A n = f' y) := by", "header": "\nimport Mathlib.Analysis.Calculus.Deriv.Basic\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.ContinuousLinearMap\nimport Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.Analysis.NormedSpace.Pointwise\nimport Mathlib.MeasureTheory.Constructions.Polish\nimport Mathlib.Analysis.Calculus.InverseFunctionTheorem.ApproximatesLinearOn\n\n#align_import measure_theory.function.jacobian from \"leanprover-community/mathlib\"@\"b84aee748341da06a6d78491367e2c0e9f15e8a5\"\n\n\n\nopen MeasureTheory MeasureTheory.Measure Metric Filter Set FiniteDimensional Asymptotics\n  TopologicalSpace\n\nopen scoped NNReal ENNReal Topology Pointwise\n\nvariable {E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\n  [NormedAddCommGroup F] [NormedSpace \u211d F] {s : Set E} {f : E \u2192 E} {f' : E \u2192 E \u2192L[\u211d] E}\n\n\n\n\n"}
{"name": "mem_invSubmonoid_iff_exists_mk'120", "split": "test", "formal_statement": "theorem mem_invSubmonoid_iff_exists_mk' (x : S) :\n    x \u2208 invSubmonoid M S \u2194 \u2203 m : M, mk' S 1 m = x := by", "header": "\nimport Mathlib.GroupTheory.Submonoid.Inverses\nimport Mathlib.RingTheory.FiniteType\nimport Mathlib.RingTheory.Localization.Basic\n\n#align_import ring_theory.localization.inv_submonoid from \"leanprover-community/mathlib\"@\"6e7ca692c98bbf8a64868f61a67fb9c33b10770d\"\n\n\n\n\nvariable {R : Type*} [CommRing R] (M : Submonoid R) (S : Type*) [CommRing S]\nvariable [Algebra R S] {P : Type*} [CommRing P]\n\nopen Function\n\nnamespace IsLocalization\n\nsection InvSubmonoid\n\n\ndef invSubmonoid : Submonoid S :=\n  (M.map (algebraMap R S)).leftInv\n#align is_localization.inv_submonoid IsLocalization.invSubmonoid\n\nvariable [IsLocalization M S]\n\ntheorem submonoid_map_le_is_unit : M.map (algebraMap R S) \u2264 IsUnit.submonoid S := by\n  rintro _ \u27e8a, ha, rfl\u27e9\n  exact IsLocalization.map_units S \u27e8_, ha\u27e9\n#align is_localization.submonoid_map_le_is_unit IsLocalization.submonoid_map_le_is_unit\n\n\nnoncomputable abbrev equivInvSubmonoid : M.map (algebraMap R S) \u2243* invSubmonoid M S :=\n  ((M.map (algebraMap R S)).leftInvEquiv (submonoid_map_le_is_unit M S)).symm\n#align is_localization.equiv_inv_submonoid IsLocalization.equivInvSubmonoid\n\n\nnoncomputable def toInvSubmonoid : M \u2192* invSubmonoid M S :=\n  (equivInvSubmonoid M S).toMonoidHom.comp ((algebraMap R S : R \u2192* S).submonoidMap M)\n#align is_localization.to_inv_submonoid IsLocalization.toInvSubmonoid\n\ntheorem toInvSubmonoid_surjective : Function.Surjective (toInvSubmonoid M S) :=\n  Function.Surjective.comp (\u03b2 := M.map (algebraMap R S))\n    (Equiv.surjective (equivInvSubmonoid _ _).toEquiv) (MonoidHom.submonoidMap_surjective _ _)\n#align is_localization.to_inv_submonoid_surjective IsLocalization.toInvSubmonoid_surjective\n\n@[simp]\ntheorem toInvSubmonoid_mul (m : M) : (toInvSubmonoid M S m : S) * algebraMap R S m = 1 :=\n  Submonoid.leftInvEquiv_symm_mul _ (submonoid_map_le_is_unit _ _) _\n#align is_localization.to_inv_submonoid_mul IsLocalization.toInvSubmonoid_mul\n\n@[simp]\ntheorem mul_toInvSubmonoid (m : M) : algebraMap R S m * (toInvSubmonoid M S m : S) = 1 :=\n  Submonoid.mul_leftInvEquiv_symm _ (submonoid_map_le_is_unit _ _) \u27e8_, _\u27e9\n#align is_localization.mul_to_inv_submonoid IsLocalization.mul_toInvSubmonoid\n\n@[simp]\ntheorem smul_toInvSubmonoid (m : M) : m \u2022 (toInvSubmonoid M S m : S) = 1 := by\n  convert mul_toInvSubmonoid M S m\n  ext\n  rw [\u2190 Algebra.smul_def]\n  rfl\n#align is_localization.smul_to_inv_submonoid IsLocalization.smul_toInvSubmonoid\n\nvariable {S}\n\n-- Porting note: `surj'` was taken, so use `surj''` instead\ntheorem surj'' (z : S) : \u2203 (r : R) (m : M), z = r \u2022 (toInvSubmonoid M S m : S) := by\n  rcases IsLocalization.surj M z with \u27e8\u27e8r, m\u27e9, e : z * _ = algebraMap R S r\u27e9\n  refine \u27e8r, m, ?_\u27e9\n  rw [Algebra.smul_def, \u2190 e, mul_assoc]\n  simp\n#align is_localization.surj' IsLocalization.surj''\n\ntheorem toInvSubmonoid_eq_mk' (x : M) : (toInvSubmonoid M S x : S) = mk' S 1 x := by\n  rw [\u2190 (IsLocalization.map_units S x).mul_left_inj]\n  simp\n#align is_localization.to_inv_submonoid_eq_mk' IsLocalization.toInvSubmonoid_eq_mk'\n\n"}
{"name": "angle_zero_right121", "split": "test", "formal_statement": "theorem angle_zero_right (x : V) : angle x 0 = \u03c0 / 2 := by", "header": "\nimport Mathlib.Analysis.InnerProductSpace.Basic\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Inverse\n\n#align_import geometry.euclidean.angle.unoriented.basic from \"leanprover-community/mathlib\"@\"46b633fd842bef9469441c0209906f6dddd2b4f5\"\n\n\n\n\nassert_not_exists HasFDerivAt\n\nassert_not_exists ConformalAt\n\nnoncomputable section\n\nopen Real Set\n\nopen Real\n\nopen RealInnerProductSpace\n\nnamespace InnerProductGeometry\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] {x y : V}\n\n\ndef angle (x y : V) : \u211d :=\n  Real.arccos (\u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016))\n#align inner_product_geometry.angle InnerProductGeometry.angle\n\ntheorem continuousAt_angle {x : V \u00d7 V} (hx1 : x.1 \u2260 0) (hx2 : x.2 \u2260 0) :\n    ContinuousAt (fun y : V \u00d7 V => angle y.1 y.2) x :=\n  Real.continuous_arccos.continuousAt.comp <|\n    continuous_inner.continuousAt.div\n      ((continuous_norm.comp continuous_fst).mul (continuous_norm.comp continuous_snd)).continuousAt\n      (by simp [hx1, hx2])\n#align inner_product_geometry.continuous_at_angle InnerProductGeometry.continuousAt_angle\n\ntheorem angle_smul_smul {c : \u211d} (hc : c \u2260 0) (x y : V) : angle (c \u2022 x) (c \u2022 y) = angle x y := by\n  have : c * c \u2260 0 := mul_ne_zero hc hc\n  rw [angle, angle, real_inner_smul_left, inner_smul_right, norm_smul, norm_smul, Real.norm_eq_abs,\n    mul_mul_mul_comm _ \u2016x\u2016, abs_mul_abs_self, \u2190 mul_assoc c c, mul_div_mul_left _ _ this]\n#align inner_product_geometry.angle_smul_smul InnerProductGeometry.angle_smul_smul\n\n@[simp]\ntheorem _root_.LinearIsometry.angle_map {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F]\n    [InnerProductSpace \u211d E] [InnerProductSpace \u211d F] (f : E \u2192\u2097\u1d62[\u211d] F) (u v : E) :\n    angle (f u) (f v) = angle u v := by\n  rw [angle, angle, f.inner_map_map, f.norm_map, f.norm_map]\n#align linear_isometry.angle_map LinearIsometry.angle_map\n\n@[simp, norm_cast]\ntheorem _root_.Submodule.angle_coe {s : Submodule \u211d V} (x y : s) :\n    angle (x : V) (y : V) = angle x y :=\n  s.subtype\u2097\u1d62.angle_map x y\n#align submodule.angle_coe Submodule.angle_coe\n\n\ntheorem cos_angle (x y : V) : Real.cos (angle x y) = \u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016) :=\n  Real.cos_arccos (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).1\n    (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2\n#align inner_product_geometry.cos_angle InnerProductGeometry.cos_angle\n\n\ntheorem angle_comm (x y : V) : angle x y = angle y x := by\n  unfold angle\n  rw [real_inner_comm, mul_comm]\n#align inner_product_geometry.angle_comm InnerProductGeometry.angle_comm\n\n\n@[simp]\ntheorem angle_neg_neg (x y : V) : angle (-x) (-y) = angle x y := by\n  unfold angle\n  rw [inner_neg_neg, norm_neg, norm_neg]\n#align inner_product_geometry.angle_neg_neg InnerProductGeometry.angle_neg_neg\n\n\ntheorem angle_nonneg (x y : V) : 0 \u2264 angle x y :=\n  Real.arccos_nonneg _\n#align inner_product_geometry.angle_nonneg InnerProductGeometry.angle_nonneg\n\n\ntheorem angle_le_pi (x y : V) : angle x y \u2264 \u03c0 :=\n  Real.arccos_le_pi _\n#align inner_product_geometry.angle_le_pi InnerProductGeometry.angle_le_pi\n\n\ntheorem angle_neg_right (x y : V) : angle x (-y) = \u03c0 - angle x y := by\n  unfold angle\n  rw [\u2190 Real.arccos_neg, norm_neg, inner_neg_right, neg_div]\n#align inner_product_geometry.angle_neg_right InnerProductGeometry.angle_neg_right\n\n\ntheorem angle_neg_left (x y : V) : angle (-x) y = \u03c0 - angle x y := by\n  rw [\u2190 angle_neg_neg, neg_neg, angle_neg_right]\n#align inner_product_geometry.angle_neg_left InnerProductGeometry.angle_neg_left\n\nproof_wanted angle_triangle (x y z : V) : angle x z \u2264 angle x y + angle y z\n\n\n@[simp]\ntheorem angle_zero_left (x : V) : angle 0 x = \u03c0 / 2 := by\n  unfold angle\n  rw [inner_zero_left, zero_div, Real.arccos_zero]\n#align inner_product_geometry.angle_zero_left InnerProductGeometry.angle_zero_left\n\n\n@[simp]\n"}
{"name": "factors_prime122", "split": "test", "formal_statement": "theorem factors_prime {p : \u2115} (hp : Nat.Prime p) : p.factors = [p] := by", "header": "\nimport Mathlib.Algebra.BigOperators.Ring.List\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.List.Prime\nimport Mathlib.Data.List.Sort\nimport Mathlib.Data.List.Chain\n\n#align_import data.nat.factors from \"leanprover-community/mathlib\"@\"008205aa645b3f194c1da47025c5f110c8406eab\"\n\n\n\nopen Bool Subtype\n\nopen Nat\n\nnamespace Nat\n\nattribute [instance 0] instBEqNat\n\n\ndef factors : \u2115 \u2192 List \u2115\n  | 0 => []\n  | 1 => []\n  | k + 2 =>\n    let m := minFac (k + 2)\n    m :: factors ((k + 2) / m)\ndecreasing_by show (k + 2) / m < (k + 2); exact factors_lemma\n#align nat.factors Nat.factors\n\n@[simp]\ntheorem factors_zero : factors 0 = [] := by rw [factors]\n#align nat.factors_zero Nat.factors_zero\n\n@[simp]\ntheorem factors_one : factors 1 = [] := by rw [factors]\n#align nat.factors_one Nat.factors_one\n\n@[simp]\ntheorem factors_two : factors 2 = [2] := by simp [factors]\n\ntheorem prime_of_mem_factors {n : \u2115} : \u2200 {p : \u2115}, (h : p \u2208 factors n) \u2192 Prime p := by\n  match n with\n  | 0 => simp\n  | 1 => simp\n  | k + 2 =>\n      intro p h\n      let m := minFac (k + 2)\n      have : (k + 2) / m < (k + 2) := factors_lemma\n      have h\u2081 : p = m \u2228 p \u2208 factors ((k + 2) / m) :=\n        List.mem_cons.1 (by rwa [factors] at h)\n      exact Or.casesOn h\u2081 (fun h\u2082 => h\u2082.symm \u25b8 minFac_prime (by simp)) prime_of_mem_factors\n#align nat.prime_of_mem_factors Nat.prime_of_mem_factors\n\ntheorem pos_of_mem_factors {n p : \u2115} (h : p \u2208 factors n) : 0 < p :=\n  Prime.pos (prime_of_mem_factors h)\n#align nat.pos_of_mem_factors Nat.pos_of_mem_factors\n\ntheorem prod_factors : \u2200 {n}, n \u2260 0 \u2192 List.prod (factors n) = n\n  | 0 => by simp\n  | 1 => by simp\n  | k + 2 => fun _ =>\n    let m := minFac (k + 2)\n    have : (k + 2) / m < (k + 2) := factors_lemma\n    show (factors (k + 2)).prod = (k + 2) by\n      have h\u2081 : (k + 2) / m \u2260 0 := fun h => by\n        have : (k + 2) = 0 * m := (Nat.div_eq_iff_eq_mul_left (minFac_pos _) (minFac_dvd _)).1 h\n        rw [zero_mul] at this; exact (show k + 2 \u2260 0 by simp) this\n      rw [factors, List.prod_cons, prod_factors h\u2081, Nat.mul_div_cancel' (minFac_dvd _)]\n#align nat.prod_factors Nat.prod_factors\n\n"}
{"name": "add_eq_left_iff_le123", "split": "test", "formal_statement": "theorem add_eq_left_iff_le : a + b = a \u2194 b \u2264 a := by", "header": "\nimport Mathlib.Algebra.Ring.Pi\nimport Mathlib.Algebra.Ring.Prod\nimport Mathlib.Algebra.Ring.InjSurj\nimport Mathlib.Tactic.Monotonicity.Attr\n\n#align_import algebra.order.kleene from \"leanprover-community/mathlib\"@\"98e83c3d541c77cdb7da20d79611a780ff8e7d90\"\n\n\n\n\nopen Function\n\nuniverse u\n\nvariable {\u03b1 \u03b2 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*}\n\n\nclass IdemSemiring (\u03b1 : Type u) extends Semiring \u03b1, SemilatticeSup \u03b1 where\n  protected sup := (\u00b7 + \u00b7)\n  protected add_eq_sup : \u2200 a b : \u03b1, a + b = a \u2294 b := by\n    intros\n    rfl\n  \n  protected bot : \u03b1 := 0\n  protected bot_le : \u2200 a, bot \u2264 a\n#align idem_semiring IdemSemiring\n\n\nclass IdemCommSemiring (\u03b1 : Type u) extends CommSemiring \u03b1, IdemSemiring \u03b1\n#align idem_comm_semiring IdemCommSemiring\n\n\nclass KStar (\u03b1 : Type*) where\n  \n  protected kstar : \u03b1 \u2192 \u03b1\n#align has_kstar KStar\n\n@[inherit_doc] scoped[Computability] postfix:1024 \"\u2217\" => KStar.kstar\n\nopen Computability\n\n\nclass KleeneAlgebra (\u03b1 : Type*) extends IdemSemiring \u03b1, KStar \u03b1 where\n  protected one_le_kstar : \u2200 a : \u03b1, 1 \u2264 a\u2217\n  protected mul_kstar_le_kstar : \u2200 a : \u03b1, a * a\u2217 \u2264 a\u2217\n  protected kstar_mul_le_kstar : \u2200 a : \u03b1, a\u2217 * a \u2264 a\u2217\n  protected mul_kstar_le_self : \u2200 a b : \u03b1, b * a \u2264 b \u2192 b * a\u2217 \u2264 b\n  protected kstar_mul_le_self : \u2200 a b : \u03b1, a * b \u2264 b \u2192 a\u2217 * b \u2264 b\n#align kleene_algebra KleeneAlgebra\n\n-- See note [lower instance priority]\ninstance (priority := 100) IdemSemiring.toOrderBot [IdemSemiring \u03b1] : OrderBot \u03b1 :=\n  { \u2039IdemSemiring \u03b1\u203a with }\n#align idem_semiring.to_order_bot IdemSemiring.toOrderBot\n\n-- See note [reducible non-instances]\n\nabbrev IdemSemiring.ofSemiring [Semiring \u03b1] (h : \u2200 a : \u03b1, a + a = a) : IdemSemiring \u03b1 :=\n  { \u2039Semiring \u03b1\u203a with\n    le := fun a b \u21a6 a + b = b\n    le_refl := h\n    le_trans := fun a b c hab hbc \u21a6 by\n      simp only\n      rw [\u2190 hbc, \u2190 add_assoc, hab]\n    le_antisymm := fun a b hab hba \u21a6 by rwa [\u2190 hba, add_comm]\n    sup := (\u00b7 + \u00b7)\n    le_sup_left := fun a b \u21a6 by\n      simp only\n      rw [\u2190 add_assoc, h]\n    le_sup_right := fun a b \u21a6 by\n      simp only\n      rw [add_comm, add_assoc, h]\n    sup_le := fun a b c hab hbc \u21a6 by\n      simp only\n      rwa [add_assoc, hbc]\n    bot := 0\n    bot_le := zero_add }\n#align idem_semiring.of_semiring IdemSemiring.ofSemiring\n\nsection IdemSemiring\n\nvariable [IdemSemiring \u03b1] {a b c : \u03b1}\n\ntheorem add_eq_sup (a b : \u03b1) : a + b = a \u2294 b :=\n  IdemSemiring.add_eq_sup _ _\n#align add_eq_sup add_eq_sup\n\n-- Porting note: This simp theorem often leads to timeout when `\u03b1` has rich structure.\n--               So, this theorem should be scoped.\nscoped[Computability] attribute [simp] add_eq_sup\n\ntheorem add_idem (a : \u03b1) : a + a = a := by simp\n#align add_idem add_idem\n\ntheorem nsmul_eq_self : \u2200 {n : \u2115} (_ : n \u2260 0) (a : \u03b1), n \u2022 a = a\n  | 0, h => (h rfl).elim\n  | 1, _ => one_nsmul\n  | n + 2, _ => fun a \u21a6 by rw [succ_nsmul, nsmul_eq_self n.succ_ne_zero, add_idem]\n#align nsmul_eq_self nsmul_eq_self\n\n"}
{"name": "tendsto_measure_thickening_of_isClosed124", "split": "test", "formal_statement": "theorem tendsto_measure_thickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (thickening r s)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc s)) := by", "header": "\nimport Mathlib.Topology.MetricSpace.Thickening\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Real\n\n#align_import measure_theory.constructions.borel_space.basic from \"leanprover-community/mathlib\"@\"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce\"\n\n\n\nopen Set Filter MeasureTheory MeasurableSpace TopologicalSpace\n\nopen scoped Classical Topology NNReal ENNReal MeasureTheory\n\nuniverse u v w x y\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}\n\nsection PseudoEMetricSpace\n\nvariable [PseudoEMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]\nvariable [MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d\u22650\u221e}\n\nopen EMetric\n\n@[measurability]\ntheorem measurableSet_eball : MeasurableSet (EMetric.ball x \u03b5) :=\n  EMetric.isOpen_ball.measurableSet\n#align measurable_set_eball measurableSet_eball\n\n@[measurability]\ntheorem measurable_edist_right : Measurable (edist x) :=\n  (continuous_const.edist continuous_id).measurable\n#align measurable_edist_right measurable_edist_right\n\n@[measurability]\ntheorem measurable_edist_left : Measurable fun y => edist y x :=\n  (continuous_id.edist continuous_const).measurable\n#align measurable_edist_left measurable_edist_left\n\n@[measurability]\ntheorem measurable_infEdist {s : Set \u03b1} : Measurable fun x => infEdist x s :=\n  continuous_infEdist.measurable\n#align measurable_inf_edist measurable_infEdist\n\n@[measurability]\ntheorem Measurable.infEdist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infEdist (f x) s :=\n  measurable_infEdist.comp hf\n#align measurable.inf_edist Measurable.infEdist\n\nopen Metric EMetric\n\n\ntheorem tendsto_measure_cthickening {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc (closure s))) := by\n  have A : Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd[Ioi 0] 0) (\ud835\udcdd (\u03bc (closure s))) := by\n    rw [closure_eq_iInter_cthickening]\n    exact\n      tendsto_measure_biInter_gt (fun r _ => isClosed_cthickening.measurableSet)\n        (fun i j _ ij => cthickening_mono ij _) hs\n  have B : Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd[Iic 0] 0) (\ud835\udcdd (\u03bc (closure s))) := by\n    apply Tendsto.congr' _ tendsto_const_nhds\n    filter_upwards [self_mem_nhdsWithin (\u03b1 := \u211d)] with _ hr\n    rw [cthickening_of_nonpos hr]\n  convert B.sup A\n  exact (nhds_left_sup_nhds_right' 0).symm\n#align tendsto_measure_cthickening tendsto_measure_cthickening\n\n\ntheorem tendsto_measure_cthickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc s)) := by\n  convert tendsto_measure_cthickening hs\n  exact h's.closure_eq.symm\n#align tendsto_measure_cthickening_of_is_closed tendsto_measure_cthickening_of_isClosed\n\n\ntheorem tendsto_measure_thickening {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u221e) :\n    Tendsto (fun r => \u03bc (thickening r s)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc (closure s))) := by\n  rw [closure_eq_iInter_thickening]\n  exact tendsto_measure_biInter_gt (fun r _ => isOpen_thickening.measurableSet)\n      (fun i j _ ij => thickening_mono ij _) hs\n\n\n"}
{"name": "Semiconj.symm_adjoint125", "split": "test", "formal_statement": "theorem Semiconj.symm_adjoint [PartialOrder \u03b1] [Preorder \u03b2] {fa : \u03b1 \u2243o \u03b1} {fb : \u03b2 \u21aao \u03b2} {g : \u03b1 \u2192 \u03b2}\n    (h : Function.Semiconj g fa fb) {g' : \u03b2 \u2192 \u03b1} (hg' : IsOrderRightAdjoint g g') :\n    Function.Semiconj g' fb fa := by", "header": "\nimport Mathlib.Algebra.Group.Units.Equiv\nimport Mathlib.Logic.Function.Conjugate\nimport Mathlib.Order.Bounds.OrderIso\nimport Mathlib.Order.ConditionallyCompleteLattice.Basic\nimport Mathlib.Order.OrdContinuous\nimport Mathlib.Order.RelIso.Group\n\n#align_import order.semiconj_Sup from \"leanprover-community/mathlib\"@\"422e70f7ce183d2900c586a8cda8381e788a0c62\"\n\n\n\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*}\n\nopen Set\n\n\ndef IsOrderRightAdjoint [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :=\n  \u2200 y, IsLUB { x | f x \u2264 y } (g y)\n#align is_order_right_adjoint IsOrderRightAdjoint\n\ntheorem isOrderRightAdjoint_sSup [CompleteLattice \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    IsOrderRightAdjoint f fun y => sSup { x | f x \u2264 y } := fun _ => isLUB_sSup _\n#align is_order_right_adjoint_Sup isOrderRightAdjoint_sSup\n\ntheorem isOrderRightAdjoint_csSup [ConditionallyCompleteLattice \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hne : \u2200 y, \u2203 x, f x \u2264 y) (hbdd : \u2200 y, BddAbove { x | f x \u2264 y }) :\n    IsOrderRightAdjoint f fun y => sSup { x | f x \u2264 y } := fun y => isLUB_csSup (hne y) (hbdd y)\n#align is_order_right_adjoint_cSup isOrderRightAdjoint_csSup\n\nnamespace Function\n\n\n"}
{"name": "LegendreSym.to_jacobiSym126", "split": "test", "formal_statement": "theorem LegendreSym.to_jacobiSym (p : \u2115) (pp : Fact p.Prime) (a r : \u2124)\n    (hr : IsInt (jacobiSym a p) r) : IsInt (legendreSym p a) r := by", "header": "\nimport Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol\n\n#align_import number_theory.legendre_symbol.norm_num from \"leanprover-community/mathlib\"@\"e2621d935895abe70071ab828a4ee6e26a52afe4\"\n\n\n\n\nsection Lemmas\n\nnamespace Mathlib.Meta.NormNum\n\n\ndef jacobiSymNat (a b : \u2115) : \u2124 :=\n  jacobiSym a b\n#align norm_num.jacobi_sym_nat Mathlib.Meta.NormNum.jacobiSymNat\n\n\n\n\n\ntheorem jacobiSymNat.zero_right (a : \u2115) : jacobiSymNat a 0 = 1 := by\n  rw [jacobiSymNat, jacobiSym.zero_right]\n#align norm_num.jacobi_sym_nat.zero_right Mathlib.Meta.NormNum.jacobiSymNat.zero_right\n\ntheorem jacobiSymNat.one_right (a : \u2115) : jacobiSymNat a 1 = 1 := by\n  rw [jacobiSymNat, jacobiSym.one_right]\n#align norm_num.jacobi_sym_nat.one_right Mathlib.Meta.NormNum.jacobiSymNat.one_right\n\ntheorem jacobiSymNat.zero_left (b : \u2115) (hb : Nat.beq (b / 2) 0 = false) : jacobiSymNat 0 b = 0 := by\n  rw [jacobiSymNat, Nat.cast_zero, jacobiSym.zero_left ?_]\n  calc\n    1 < 2 * 1       := by decide\n    _ \u2264 2 * (b / 2) :=\n      Nat.mul_le_mul_left _ (Nat.succ_le.mpr (Nat.pos_of_ne_zero (Nat.ne_of_beq_eq_false hb)))\n    _ \u2264 b           := Nat.mul_div_le b 2\n#align norm_num.jacobi_sym_nat.zero_left_even Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n#align norm_num.jacobi_sym_nat.zero_left_odd Mathlib.Meta.NormNum.jacobiSymNat.zero_left\n\ntheorem jacobiSymNat.one_left (b : \u2115) : jacobiSymNat 1 b = 1 := by\n  rw [jacobiSymNat, Nat.cast_one, jacobiSym.one_left]\n#align norm_num.jacobi_sym_nat.one_left_even Mathlib.Meta.NormNum.jacobiSymNat.one_left\n#align norm_num.jacobi_sym_nat.one_left_odd Mathlib.Meta.NormNum.jacobiSymNat.one_left\n\n\n"}
{"name": "of_convergence_epsilon127", "split": "test", "formal_statement": "theorem of_convergence_epsilon :\n    \u2200 \u03b5 > (0 : K), \u2203 N : \u2115, \u2200 n \u2265 N, |v - (of v).convergents n| < \u03b5 := by", "header": "\nimport Mathlib.Algebra.ContinuedFractions.Computation.Approximations\nimport Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv\nimport Mathlib.Algebra.Order.Archimedean\nimport Mathlib.Tactic.GCongr\nimport Mathlib.Topology.Order.LeftRightNhds\n\n#align_import algebra.continued_fractions.computation.approximation_corollaries from \"leanprover-community/mathlib\"@\"f0c8bf9245297a541f468be517f1bde6195105e9\"\n\n\n\n\nvariable {K : Type*} (v : K) [LinearOrderedField K] [FloorRing K]\n\nopen GeneralizedContinuedFraction (of)\nopen GeneralizedContinuedFraction\nopen scoped Topology\n\ntheorem GeneralizedContinuedFraction.of_isSimpleContinuedFraction :\n    (of v).IsSimpleContinuedFraction := fun _ _ nth_part_num_eq =>\n  of_part_num_eq_one nth_part_num_eq\n#align generalized_continued_fraction.of_is_simple_continued_fraction GeneralizedContinuedFraction.of_isSimpleContinuedFraction\n\n\nnonrec def SimpleContinuedFraction.of : SimpleContinuedFraction K :=\n  \u27e8of v, GeneralizedContinuedFraction.of_isSimpleContinuedFraction v\u27e9\n#align simple_continued_fraction.of SimpleContinuedFraction.of\n\ntheorem SimpleContinuedFraction.of_isContinuedFraction :\n    (SimpleContinuedFraction.of v).IsContinuedFraction := fun _ _ nth_part_denom_eq =>\n  lt_of_lt_of_le zero_lt_one (of_one_le_get?_part_denom nth_part_denom_eq)\n#align simple_continued_fraction.of_is_continued_fraction SimpleContinuedFraction.of_isContinuedFraction\n\n\ndef ContinuedFraction.of : ContinuedFraction K :=\n  \u27e8SimpleContinuedFraction.of v, SimpleContinuedFraction.of_isContinuedFraction v\u27e9\n#align continued_fraction.of ContinuedFraction.of\n\nnamespace GeneralizedContinuedFraction\n\ntheorem of_convergents_eq_convergents' : (of v).convergents = (of v).convergents' :=\n  @ContinuedFraction.convergents_eq_convergents' _ _ (ContinuedFraction.of v)\n#align generalized_continued_fraction.of_convergents_eq_convergents' GeneralizedContinuedFraction.of_convergents_eq_convergents'\n\n\ntheorem convergents_succ (n : \u2115) :\n    (of v).convergents (n + 1) = \u230av\u230b + 1 / (of (Int.fract v)\u207b\u00b9).convergents n := by\n  rw [of_convergents_eq_convergents', convergents'_succ, of_convergents_eq_convergents']\n#align generalized_continued_fraction.convergents_succ GeneralizedContinuedFraction.convergents_succ\n\nsection Convergence\n\n\n\n\nvariable [Archimedean K]\n\nopen Nat\n\n"}
{"name": "jacobiSymNat.zero_left128", "split": "test", "formal_statement": "theorem jacobiSymNat.zero_left (b : \u2115) (hb : Nat.beq (b / 2) 0 = false) : jacobiSymNat 0 b = 0 := by", "header": "\nimport Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol\n\n#align_import number_theory.legendre_symbol.norm_num from \"leanprover-community/mathlib\"@\"e2621d935895abe70071ab828a4ee6e26a52afe4\"\n\n\n\n\nsection Lemmas\n\nnamespace Mathlib.Meta.NormNum\n\n\ndef jacobiSymNat (a b : \u2115) : \u2124 :=\n  jacobiSym a b\n#align norm_num.jacobi_sym_nat Mathlib.Meta.NormNum.jacobiSymNat\n\n\n\n\n\ntheorem jacobiSymNat.zero_right (a : \u2115) : jacobiSymNat a 0 = 1 := by\n  rw [jacobiSymNat, jacobiSym.zero_right]\n#align norm_num.jacobi_sym_nat.zero_right Mathlib.Meta.NormNum.jacobiSymNat.zero_right\n\ntheorem jacobiSymNat.one_right (a : \u2115) : jacobiSymNat a 1 = 1 := by\n  rw [jacobiSymNat, jacobiSym.one_right]\n#align norm_num.jacobi_sym_nat.one_right Mathlib.Meta.NormNum.jacobiSymNat.one_right\n\n"}
{"name": "pNilradical_eq_bot129", "split": "test", "formal_statement": "theorem pNilradical_eq_bot {R : Type*} [CommSemiring R] {p : \u2115} (hp : \u00ac 1 < p) :\n    pNilradical R p = \u22a5 := by", "header": "\nimport Mathlib.FieldTheory.PurelyInseparable\nimport Mathlib.FieldTheory.PerfectClosure\n\n\n\nopen scoped Classical Polynomial\n\nopen FiniteDimensional Polynomial IntermediateField Field\n\nnoncomputable section\n\n\ndef pNilradical (R : Type*) [CommSemiring R] (p : \u2115) : Ideal R := if 1 < p then nilradical R else \u22a5\n\ntheorem pNilradical_le_nilradical {R : Type*} [CommSemiring R] {p : \u2115} :\n    pNilradical R p \u2264 nilradical R := by\n  by_cases hp : 1 < p\n  \u00b7 rw [pNilradical, if_pos hp]\n  simp_rw [pNilradical, if_neg hp, bot_le]\n\ntheorem pNilradical_eq_nilradical {R : Type*} [CommSemiring R] {p : \u2115} (hp : 1 < p) :\n    pNilradical R p = nilradical R := by rw [pNilradical, if_pos hp]\n\n"}
{"name": "isFixedPt_newtonMap_of_isUnit_iff130", "split": "test", "formal_statement": "theorem isFixedPt_newtonMap_of_isUnit_iff (h : IsUnit <| aeval x (derivative P)) :\n    IsFixedPt P.newtonMap x \u2194 aeval x P = 0 := by", "header": "\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Identities\nimport Mathlib.RingTheory.Nilpotent.Lemmas\nimport Mathlib.RingTheory.Polynomial.Nilpotent\nimport Mathlib.RingTheory.Polynomial.Tower\n\n\n\nopen Set Function\n\nnoncomputable section\n\nnamespace Polynomial\n\nvariable {R S : Type*} [CommRing R] [CommRing S] [Algebra R S] (P : R[X]) {x : S}\n\n\ndef newtonMap (x : S) : S :=\n  x - (Ring.inverse <| aeval x (derivative P)) * aeval x P\n\ntheorem newtonMap_apply :\n    P.newtonMap x = x - (Ring.inverse <| aeval x (derivative P)) * (aeval x P) :=\n  rfl\n\nvariable {P}\n\ntheorem newtonMap_apply_of_isUnit (h : IsUnit <| aeval x (derivative P)) :\n    P.newtonMap x = x - h.unit\u207b\u00b9 * aeval x P := by\n  simp [newtonMap_apply, Ring.inverse, h]\n\ntheorem newtonMap_apply_of_not_isUnit (h : \u00ac (IsUnit <| aeval x (derivative P))) :\n    P.newtonMap x = x := by\n  simp [newtonMap_apply, Ring.inverse, h]\n\ntheorem isNilpotent_iterate_newtonMap_sub_of_isNilpotent (h : IsNilpotent <| aeval x P) (n : \u2115) :\n    IsNilpotent <| P.newtonMap^[n] x - x := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [iterate_succ', comp_apply, newtonMap_apply, sub_right_comm]\n    refine (Commute.all _ _).isNilpotent_sub ih <| (Commute.all _ _).isNilpotent_mul_right ?_\n    simpa using Commute.isNilpotent_add (Commute.all _ _)\n      (isNilpotent_aeval_sub_of_isNilpotent_sub P ih) h\n\ntheorem isFixedPt_newtonMap_of_aeval_eq_zero (h : aeval x P = 0) :\n    IsFixedPt P.newtonMap x := by\n  rw [IsFixedPt, newtonMap_apply, h, mul_zero, sub_zero]\n\n"}
{"name": "teichmuller_zero131", "split": "test", "formal_statement": "theorem teichmuller_zero : teichmuller p (0 : R) = 0 := by", "header": "\nimport Mathlib.RingTheory.WittVector.Basic\n\n#align_import ring_theory.witt_vector.teichmuller from \"leanprover-community/mathlib\"@\"c0a51cf2de54089d69301befc4c73bbc2f5c7342\"\n\n\n\n\nnamespace WittVector\n\nopen MvPolynomial\n\nvariable (p : \u2115) {R S : Type*} [hp : Fact p.Prime] [CommRing R] [CommRing S]\n\nlocal notation \"\ud835\udd4e\" => WittVector p -- type as `\\bbW`\n\n\ndef teichmullerFun (r : R) : \ud835\udd4e R :=\n  \u27e8fun n => if n = 0 then r else 0\u27e9\n#align witt_vector.teichmuller_fun WittVector.teichmullerFun\n\n\n\n\nprivate theorem ghostComponent_teichmullerFun (r : R) (n : \u2115) :\n    ghostComponent n (teichmullerFun p r) = r ^ p ^ n := by\n  rw [ghostComponent_apply, aeval_wittPolynomial, Finset.sum_eq_single 0, pow_zero, one_mul,\n    tsub_zero]\n  \u00b7 rfl\n  \u00b7 intro i _ h0\n    simp [teichmullerFun, h0, hp.1.ne_zero]\n  \u00b7 rw [Finset.mem_range]; intro h; exact (h (Nat.succ_pos n)).elim\n\nprivate theorem map_teichmullerFun (f : R \u2192+* S) (r : R) :\n    map f (teichmullerFun p r) = teichmullerFun p (f r) := by\n  ext n; cases n\n  \u00b7 rfl\n  \u00b7 exact f.map_zero\n\nprivate theorem teichmuller_mul_aux\u2081 (x y : MvPolynomial R \u211a) :\n    teichmullerFun p (x * y) = teichmullerFun p x * teichmullerFun p y := by\n  apply (ghostMap.bijective_of_invertible p (MvPolynomial R \u211a)).1\n  rw [RingHom.map_mul]\n  ext1 n\n  simp only [Pi.mul_apply, ghostMap_apply, ghostComponent_teichmullerFun, mul_pow]\n\nprivate theorem teichmuller_mul_aux\u2082 (x y : MvPolynomial R \u2124) :\n    teichmullerFun p (x * y) = teichmullerFun p x * teichmullerFun p y := by\n  refine map_injective (MvPolynomial.map (Int.castRingHom \u211a))\n    (MvPolynomial.map_injective _ Int.cast_injective) ?_\n  simp only [teichmuller_mul_aux\u2081, map_teichmullerFun, RingHom.map_mul]\n\n\ndef teichmuller : R \u2192* \ud835\udd4e R where\n  toFun := teichmullerFun p\n  map_one' := by\n    ext \u27e8\u27e9\n    \u00b7 rw [one_coeff_zero]; rfl\n    \u00b7 rw [one_coeff_eq_of_pos _ _ _ (Nat.succ_pos _)]; rfl\n  map_mul' := by\n    intro x y\n    rcases counit_surjective R x with \u27e8x, rfl\u27e9\n    rcases counit_surjective R y with \u27e8y, rfl\u27e9\n    simp only [\u2190 map_teichmullerFun, \u2190 RingHom.map_mul, teichmuller_mul_aux\u2082]\n#align witt_vector.teichmuller WittVector.teichmuller\n\n@[simp]\ntheorem teichmuller_coeff_zero (r : R) : (teichmuller p r).coeff 0 = r :=\n  rfl\n#align witt_vector.teichmuller_coeff_zero WittVector.teichmuller_coeff_zero\n\n@[simp]\ntheorem teichmuller_coeff_pos (r : R) : \u2200 (n : \u2115) (_ : 0 < n), (teichmuller p r).coeff n = 0\n  | _ + 1, _ => rfl\n#align witt_vector.teichmuller_coeff_pos WittVector.teichmuller_coeff_pos\n\n@[simp]\n"}
{"name": "map_mul132", "split": "test", "formal_statement": "theorem map_mul : (I * J).map g = I.map g * J.map g := by", "header": "\nimport Mathlib.RingTheory.IntegralClosure\nimport Mathlib.RingTheory.FractionalIdeal.Basic\n\n#align_import ring_theory.fractional_ideal from \"leanprover-community/mathlib\"@\"ed90a7d327c3a5caf65a6faf7e8a0d63c4605df7\"\n\n\n\n\nopen IsLocalization Pointwise nonZeroDivisors\n\nnamespace FractionalIdeal\n\nopen Set Submodule\n\nvariable {R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]\nvariable [Algebra R P] [loc : IsLocalization S P]\n\nsection\n\nvariable {P' : Type*} [CommRing P'] [Algebra R P'] [loc' : IsLocalization S P']\nvariable {P'' : Type*} [CommRing P''] [Algebra R P''] [loc'' : IsLocalization S P'']\n\ntheorem _root_.IsFractional.map (g : P \u2192\u2090[R] P') {I : Submodule R P} :\n    IsFractional S I \u2192 IsFractional S (Submodule.map g.toLinearMap I)\n  | \u27e8a, a_nonzero, hI\u27e9 =>\n    \u27e8a, a_nonzero, fun b hb => by\n      obtain \u27e8b', b'_mem, hb'\u27e9 := Submodule.mem_map.mp hb\n      rw [AlgHom.toLinearMap_apply] at hb'\n      obtain \u27e8x, hx\u27e9 := hI b' b'_mem\n      use x\n      rw [\u2190 g.commutes, hx, g.map_smul, hb']\u27e9\n#align is_fractional.map IsFractional.map\n\n\ndef map (g : P \u2192\u2090[R] P') : FractionalIdeal S P \u2192 FractionalIdeal S P' := fun I =>\n  \u27e8Submodule.map g.toLinearMap I, I.isFractional.map g\u27e9\n#align fractional_ideal.map FractionalIdeal.map\n\n@[simp, norm_cast]\ntheorem coe_map (g : P \u2192\u2090[R] P') (I : FractionalIdeal S P) :\n    \u2191(map g I) = Submodule.map g.toLinearMap I :=\n  rfl\n#align fractional_ideal.coe_map FractionalIdeal.coe_map\n\n@[simp]\ntheorem mem_map {I : FractionalIdeal S P} {g : P \u2192\u2090[R] P'} {y : P'} :\n    y \u2208 I.map g \u2194 \u2203 x, x \u2208 I \u2227 g x = y :=\n  Submodule.mem_map\n#align fractional_ideal.mem_map FractionalIdeal.mem_map\n\nvariable (I J : FractionalIdeal S P) (g : P \u2192\u2090[R] P')\n\n@[simp]\ntheorem map_id : I.map (AlgHom.id _ _) = I :=\n  coeToSubmodule_injective (Submodule.map_id (I : Submodule R P))\n#align fractional_ideal.map_id FractionalIdeal.map_id\n\n@[simp]\ntheorem map_comp (g' : P' \u2192\u2090[R] P'') : I.map (g'.comp g) = (I.map g).map g' :=\n  coeToSubmodule_injective (Submodule.map_comp g.toLinearMap g'.toLinearMap I)\n#align fractional_ideal.map_comp FractionalIdeal.map_comp\n\n@[simp, norm_cast]\ntheorem map_coeIdeal (I : Ideal R) : (I : FractionalIdeal S P).map g = I := by\n  ext x\n  simp only [mem_coeIdeal]\n  constructor\n  \u00b7 rintro \u27e8_, \u27e8y, hy, rfl\u27e9, rfl\u27e9\n    exact \u27e8y, hy, (g.commutes y).symm\u27e9\n  \u00b7 rintro \u27e8y, hy, rfl\u27e9\n    exact \u27e8_, \u27e8y, hy, rfl\u27e9, g.commutes y\u27e9\n#align fractional_ideal.map_coe_ideal FractionalIdeal.map_coeIdeal\n\n@[simp]\ntheorem map_one : (1 : FractionalIdeal S P).map g = 1 :=\n  map_coeIdeal g \u22a4\n#align fractional_ideal.map_one FractionalIdeal.map_one\n\n@[simp]\ntheorem map_zero : (0 : FractionalIdeal S P).map g = 0 :=\n  map_coeIdeal g 0\n#align fractional_ideal.map_zero FractionalIdeal.map_zero\n\n@[simp]\ntheorem map_add : (I + J).map g = I.map g + J.map g :=\n  coeToSubmodule_injective (Submodule.map_sup _ _ _)\n#align fractional_ideal.map_add FractionalIdeal.map_add\n\n@[simp]\n"}
{"name": "min_eq_left133", "split": "test", "formal_statement": "theorem min_eq_left {a b : \u03b1} (h : a \u2264 b) : min a b = a := by", "header": "\nimport Mathlib.Init.Order.Defs\n\n#align_import init.algebra.functions from \"leanprover-community/lean\"@\"c2bcdbcbe741ed37c361a30d38e179182b989f76\"\n\n\n\nuniverse u\n\nsection\n\nopen Decidable\n\nvariable {\u03b1 : Type u} [LinearOrder \u03b1]\n\ntheorem min_def (a b : \u03b1) : min a b = if a \u2264 b then a else b := by\n  rw [LinearOrder.min_def a]\n#align min_def min_def\n\ntheorem max_def (a b : \u03b1) : max a b = if a \u2264 b then b else a := by\n  rw [LinearOrder.max_def a]\n#align max_def max_def\n\ntheorem min_le_left (a b : \u03b1) : min a b \u2264 a := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h, le_refl]\n  else simp [min_def, if_neg h]; exact le_of_not_le h\n#align min_le_left min_le_left\n\ntheorem min_le_right (a b : \u03b1) : min a b \u2264 b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h]; exact h\n  else simp [min_def, if_neg h, le_refl]\n#align min_le_right min_le_right\n\ntheorem le_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) : c \u2264 min a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h]; exact h\u2081\n  else simp [min_def, if_neg h]; exact h\u2082\n#align le_min le_min\n\ntheorem le_max_left (a b : \u03b1) : a \u2264 max a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h]; exact h\n  else simp [max_def, if_neg h, le_refl]\n#align le_max_left le_max_left\n\ntheorem le_max_right (a b : \u03b1) : b \u2264 max a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h, le_refl]\n  else simp [max_def, if_neg h]; exact le_of_not_le h\n#align le_max_right le_max_right\n\ntheorem max_le {a b c : \u03b1} (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : max a b \u2264 c := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h]; exact h\u2082\n  else simp [max_def, if_neg h]; exact h\u2081\n#align max_le max_le\n\ntheorem eq_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) (h\u2083 : \u2200 {d}, d \u2264 a \u2192 d \u2264 b \u2192 d \u2264 c) :\n    c = min a b :=\n  le_antisymm (le_min h\u2081 h\u2082) (h\u2083 (min_le_left a b) (min_le_right a b))\n#align eq_min eq_min\n\ntheorem min_comm (a b : \u03b1) : min a b = min b a :=\n  eq_min (min_le_right a b) (min_le_left a b) fun h\u2081 h\u2082 => le_min h\u2082 h\u2081\n#align min_comm min_comm\n\ntheorem min_assoc (a b c : \u03b1) : min (min a b) c = min a (min b c) := by\n  apply eq_min\n  \u00b7 apply le_trans; apply min_le_left; apply min_le_left\n  \u00b7 apply le_min; apply le_trans; apply min_le_left; apply min_le_right; apply min_le_right\n  \u00b7 intro d h\u2081 h\u2082; apply le_min; apply le_min h\u2081; apply le_trans h\u2082; apply min_le_left\n    apply le_trans h\u2082; apply min_le_right\n#align min_assoc min_assoc\n\ntheorem min_left_comm : \u2200 a b c : \u03b1, min a (min b c) = min b (min a c) :=\n  left_comm (@min \u03b1 _) (@min_comm \u03b1 _) (@min_assoc \u03b1 _)\n#align min_left_comm min_left_comm\n\n@[simp]\ntheorem min_self (a : \u03b1) : min a a = a := by simp [min_def]\n#align min_self min_self\n\n"}
{"name": "coherentTopology.mem_sieves_of_hasEffectiveEpiFamily134", "split": "test", "formal_statement": "theorem coherentTopology.mem_sieves_of_hasEffectiveEpiFamily (S : Sieve X) :\n    (\u2203 (\u03b1 : Type) (_ : Finite \u03b1) (Y : \u03b1 \u2192 C) (\u03c0 : (a : \u03b1) \u2192 (Y a \u27f6 X)),\n      EffectiveEpiFamily Y \u03c0 \u2227 (\u2200 a : \u03b1, (S.arrows) (\u03c0 a)) ) \u2192\n        (S \u2208 GrothendieckTopology.sieves (coherentTopology C) X) := by", "header": "\nimport Mathlib.CategoryTheory.Sites.Coherent.CoherentSheaves\n\n\nnamespace CategoryTheory\n\nvariable {C : Type*} [Category C] [Precoherent C] {X : C}\n\n\n"}
{"name": "infEdist_inv_inv135", "split": "test", "formal_statement": "theorem infEdist_inv_inv (x : E) (s : Set E) : infEdist x\u207b\u00b9 s\u207b\u00b9 = infEdist x s := by", "header": "\nimport Mathlib.Analysis.Normed.Group.Basic\nimport Mathlib.Topology.MetricSpace.Thickening\nimport Mathlib.Topology.MetricSpace.IsometricSMul\n\n#align_import analysis.normed.group.pointwise from \"leanprover-community/mathlib\"@\"c8f305514e0d47dfaa710f5a52f0d21b588e6328\"\n\n\n\n\nopen Metric Set Pointwise Topology\n\nvariable {E : Type*}\n\nsection SeminormedCommGroup\n\nvariable [SeminormedCommGroup E] {\u03b5 \u03b4 : \u211d} {s t : Set E} {x y : E}\n\nsection EMetric\n\nopen EMetric\n\n@[to_additive (attr := simp)]\n"}
{"name": "isEulerian_iff136", "split": "test", "formal_statement": "theorem isEulerian_iff {u v : V} (p : G.Walk u v) :\n    p.IsEulerian \u2194 p.IsTrail \u2227 \u2200 e, e \u2208 G.edgeSet \u2192 e \u2208 p.edges := by", "header": "\nimport Mathlib.Algebra.Ring.Parity\nimport Mathlib.Combinatorics.SimpleGraph.Connectivity\n\n#align_import combinatorics.simple_graph.trails from \"leanprover-community/mathlib\"@\"edaaaa4a5774e6623e0ddd919b2f2db49c65add4\"\n\n\n\n\nnamespace SimpleGraph\n\nvariable {V : Type*} {G : SimpleGraph V}\n\nnamespace Walk\n\n\nabbrev IsTrail.edgesFinset {u v : V} {p : G.Walk u v} (h : p.IsTrail) : Finset (Sym2 V) :=\n  \u27e8p.edges, h.edges_nodup\u27e9\n#align simple_graph.walk.is_trail.edges_finset SimpleGraph.Walk.IsTrail.edgesFinset\n\nvariable [DecidableEq V]\n\ntheorem IsTrail.even_countP_edges_iff {u v : V} {p : G.Walk u v} (ht : p.IsTrail) (x : V) :\n    Even (p.edges.countP fun e => x \u2208 e) \u2194 u \u2260 v \u2192 x \u2260 u \u2227 x \u2260 v := by\n  induction' p with u u v w huv p ih\n  \u00b7 simp\n  \u00b7 rw [cons_isTrail_iff] at ht\n    specialize ih ht.1\n    simp only [List.countP_cons, Ne, edges_cons, Sym2.mem_iff]\n    split_ifs with h\n    \u00b7 rw [decide_eq_true_eq] at h\n      obtain (rfl | rfl) := h\n      \u00b7 rw [Nat.even_add_one, ih]\n        simp only [huv.ne, imp_false, Ne, not_false_iff, true_and_iff, not_forall,\n          Classical.not_not, exists_prop, eq_self_iff_true, not_true, false_and_iff,\n          and_iff_right_iff_imp]\n        rintro rfl rfl\n        exact G.loopless _ huv\n      \u00b7 rw [Nat.even_add_one, ih, \u2190 not_iff_not]\n        simp only [huv.ne.symm, Ne, eq_self_iff_true, not_true, false_and_iff, not_forall,\n          not_false_iff, exists_prop, and_true_iff, Classical.not_not, true_and_iff, iff_and_self]\n        rintro rfl\n        exact huv.ne\n    \u00b7 rw [decide_eq_true_eq, not_or] at h\n      simp only [h.1, h.2, not_false_iff, true_and_iff, add_zero, Ne] at ih \u22a2\n      rw [ih]\n      constructor <;>\n        \u00b7 rintro h' h'' rfl\n          simp only [imp_false, eq_self_iff_true, not_true, Classical.not_not] at h'\n          cases h'\n          simp only [not_true, and_false, false_and] at h\n#align simple_graph.walk.is_trail.even_countp_edges_iff SimpleGraph.Walk.IsTrail.even_countP_edges_iff\n\n\ndef IsEulerian {u v : V} (p : G.Walk u v) : Prop :=\n  \u2200 e, e \u2208 G.edgeSet \u2192 p.edges.count e = 1\n#align simple_graph.walk.is_eulerian SimpleGraph.Walk.IsEulerian\n\ntheorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail := by\n  rw [isTrail_def, List.nodup_iff_count_le_one]\n  intro e\n  by_cases he : e \u2208 p.edges\n  \u00b7 exact (h e (edges_subset_edgeSet _ he)).le\n  \u00b7 simp [he]\n#align simple_graph.walk.is_eulerian.is_trail SimpleGraph.Walk.IsEulerian.isTrail\n\ntheorem IsEulerian.mem_edges_iff {u v : V} {p : G.Walk u v} (h : p.IsEulerian) {e : Sym2 V} :\n    e \u2208 p.edges \u2194 e \u2208 G.edgeSet :=\n  \u27e8 fun h => p.edges_subset_edgeSet h\n  , fun he => by simpa [Nat.succ_le] using (h e he).ge \u27e9\n#align simple_graph.walk.is_eulerian.mem_edges_iff SimpleGraph.Walk.IsEulerian.mem_edges_iff\n\n\ndef IsEulerian.fintypeEdgeSet {u v : V} {p : G.Walk u v} (h : p.IsEulerian) :\n    Fintype G.edgeSet :=\n  Fintype.ofFinset h.isTrail.edgesFinset fun e => by\n    simp only [Finset.mem_mk, Multiset.mem_coe, h.mem_edges_iff]\n#align simple_graph.walk.is_eulerian.fintype_edge_set SimpleGraph.Walk.IsEulerian.fintypeEdgeSet\n\ntheorem IsTrail.isEulerian_of_forall_mem {u v : V} {p : G.Walk u v} (h : p.IsTrail)\n    (hc : \u2200 e, e \u2208 G.edgeSet \u2192 e \u2208 p.edges) : p.IsEulerian := fun e he =>\n  List.count_eq_one_of_mem h.edges_nodup (hc e he)\n#align simple_graph.walk.is_trail.is_eulerian_of_forall_mem SimpleGraph.Walk.IsTrail.isEulerian_of_forall_mem\n\n"}
{"name": "Collinear.sbtw_of_dist_eq_of_dist_lt137", "split": "test", "formal_statement": "theorem Collinear.sbtw_of_dist_eq_of_dist_lt {p p\u2081 p\u2082 p\u2083 : P} {r : \u211d}\n    (h : Collinear \u211d ({p\u2081, p\u2082, p\u2083} : Set P)) (hp\u2081 : dist p\u2081 p = r) (hp\u2082 : dist p\u2082 p < r)\n    (hp\u2083 : dist p\u2083 p = r) (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) : Sbtw \u211d p\u2081 p\u2082 p\u2083 := by", "header": "\nimport Mathlib.Analysis.Convex.Between\nimport Mathlib.Analysis.Convex.StrictConvexSpace\nimport Mathlib.Analysis.NormedSpace.AffineIsometry\n\n#align_import analysis.convex.strict_convex_between from \"leanprover-community/mathlib\"@\"e1730698f86560a342271c0471e4cb72d021aabf\"\n\n\n\nopen Metric\nopen scoped Convex\n\nvariable {V P : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\nvariable [StrictConvexSpace \u211d V]\n\nsection PseudoMetricSpace\nvariable [PseudoMetricSpace P] [NormedAddTorsor V P]\n\ntheorem Sbtw.dist_lt_max_dist (p : P) {p\u2081 p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) :\n    dist p\u2082 p < max (dist p\u2081 p) (dist p\u2083 p) := by\n  have hp\u2081p\u2083 : p\u2081 -\u1d65 p \u2260 p\u2083 -\u1d65 p := by simpa using h.left_ne_right\n  rw [Sbtw, \u2190 wbtw_vsub_const_iff p, Wbtw, affineSegment_eq_segment, \u2190 insert_endpoints_openSegment,\n    Set.mem_insert_iff, Set.mem_insert_iff] at h\n  rcases h with \u27e8h | h | h, hp\u2082p\u2081, hp\u2082p\u2083\u27e9\n  \u00b7 rw [vsub_left_cancel_iff] at h\n    exact False.elim (hp\u2082p\u2081 h)\n  \u00b7 rw [vsub_left_cancel_iff] at h\n    exact False.elim (hp\u2082p\u2083 h)\n  \u00b7 rw [openSegment_eq_image, Set.mem_image] at h\n    rcases h with \u27e8r, \u27e8hr0, hr1\u27e9, hr\u27e9\n    simp_rw [@dist_eq_norm_vsub V, \u2190 hr]\n    exact\n      norm_combo_lt_of_ne (le_max_left _ _) (le_max_right _ _) hp\u2081p\u2083 (sub_pos.2 hr1) hr0 (by abel)\n#align sbtw.dist_lt_max_dist Sbtw.dist_lt_max_dist\n\ntheorem Wbtw.dist_le_max_dist (p : P) {p\u2081 p\u2082 p\u2083 : P} (h : Wbtw \u211d p\u2081 p\u2082 p\u2083) :\n    dist p\u2082 p \u2264 max (dist p\u2081 p) (dist p\u2083 p) := by\n  by_cases hp\u2081 : p\u2082 = p\u2081; \u00b7 simp [hp\u2081]\n  by_cases hp\u2083 : p\u2082 = p\u2083; \u00b7 simp [hp\u2083]\n  have hs : Sbtw \u211d p\u2081 p\u2082 p\u2083 := \u27e8h, hp\u2081, hp\u2083\u27e9\n  exact (hs.dist_lt_max_dist _).le\n#align wbtw.dist_le_max_dist Wbtw.dist_le_max_dist\n\n\ntheorem Collinear.wbtw_of_dist_eq_of_dist_le {p p\u2081 p\u2082 p\u2083 : P} {r : \u211d}\n    (h : Collinear \u211d ({p\u2081, p\u2082, p\u2083} : Set P)) (hp\u2081 : dist p\u2081 p = r) (hp\u2082 : dist p\u2082 p \u2264 r)\n    (hp\u2083 : dist p\u2083 p = r) (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) : Wbtw \u211d p\u2081 p\u2082 p\u2083 := by\n  rcases h.wbtw_or_wbtw_or_wbtw with (hw | hw | hw)\n  \u00b7 exact hw\n  \u00b7 by_cases hp\u2083p\u2082 : p\u2083 = p\u2082\n    \u00b7 simp [hp\u2083p\u2082]\n    have hs : Sbtw \u211d p\u2082 p\u2083 p\u2081 := \u27e8hw, hp\u2083p\u2082, hp\u2081p\u2083.symm\u27e9\n    have hs' := hs.dist_lt_max_dist p\n    rw [hp\u2081, hp\u2083, lt_max_iff, lt_self_iff_false, or_false_iff] at hs'\n    exact False.elim (hp\u2082.not_lt hs')\n  \u00b7 by_cases hp\u2081p\u2082 : p\u2081 = p\u2082\n    \u00b7 simp [hp\u2081p\u2082]\n    have hs : Sbtw \u211d p\u2083 p\u2081 p\u2082 := \u27e8hw, hp\u2081p\u2083, hp\u2081p\u2082\u27e9\n    have hs' := hs.dist_lt_max_dist p\n    rw [hp\u2081, hp\u2083, lt_max_iff, lt_self_iff_false, false_or_iff] at hs'\n    exact False.elim (hp\u2082.not_lt hs')\n#align collinear.wbtw_of_dist_eq_of_dist_le Collinear.wbtw_of_dist_eq_of_dist_le\n\n\n"}
{"name": "dvd_of_mem_factors138", "split": "test", "formal_statement": "theorem dvd_of_mem_factors {n p : \u2115} (h : p \u2208 n.factors) : p \u2223 n := by", "header": "\nimport Mathlib.Algebra.BigOperators.Ring.List\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.List.Prime\nimport Mathlib.Data.List.Sort\nimport Mathlib.Data.List.Chain\n\n#align_import data.nat.factors from \"leanprover-community/mathlib\"@\"008205aa645b3f194c1da47025c5f110c8406eab\"\n\n\n\nopen Bool Subtype\n\nopen Nat\n\nnamespace Nat\n\nattribute [instance 0] instBEqNat\n\n\ndef factors : \u2115 \u2192 List \u2115\n  | 0 => []\n  | 1 => []\n  | k + 2 =>\n    let m := minFac (k + 2)\n    m :: factors ((k + 2) / m)\ndecreasing_by show (k + 2) / m < (k + 2); exact factors_lemma\n#align nat.factors Nat.factors\n\n@[simp]\ntheorem factors_zero : factors 0 = [] := by rw [factors]\n#align nat.factors_zero Nat.factors_zero\n\n@[simp]\ntheorem factors_one : factors 1 = [] := by rw [factors]\n#align nat.factors_one Nat.factors_one\n\n@[simp]\ntheorem factors_two : factors 2 = [2] := by simp [factors]\n\ntheorem prime_of_mem_factors {n : \u2115} : \u2200 {p : \u2115}, (h : p \u2208 factors n) \u2192 Prime p := by\n  match n with\n  | 0 => simp\n  | 1 => simp\n  | k + 2 =>\n      intro p h\n      let m := minFac (k + 2)\n      have : (k + 2) / m < (k + 2) := factors_lemma\n      have h\u2081 : p = m \u2228 p \u2208 factors ((k + 2) / m) :=\n        List.mem_cons.1 (by rwa [factors] at h)\n      exact Or.casesOn h\u2081 (fun h\u2082 => h\u2082.symm \u25b8 minFac_prime (by simp)) prime_of_mem_factors\n#align nat.prime_of_mem_factors Nat.prime_of_mem_factors\n\ntheorem pos_of_mem_factors {n p : \u2115} (h : p \u2208 factors n) : 0 < p :=\n  Prime.pos (prime_of_mem_factors h)\n#align nat.pos_of_mem_factors Nat.pos_of_mem_factors\n\ntheorem prod_factors : \u2200 {n}, n \u2260 0 \u2192 List.prod (factors n) = n\n  | 0 => by simp\n  | 1 => by simp\n  | k + 2 => fun _ =>\n    let m := minFac (k + 2)\n    have : (k + 2) / m < (k + 2) := factors_lemma\n    show (factors (k + 2)).prod = (k + 2) by\n      have h\u2081 : (k + 2) / m \u2260 0 := fun h => by\n        have : (k + 2) = 0 * m := (Nat.div_eq_iff_eq_mul_left (minFac_pos _) (minFac_dvd _)).1 h\n        rw [zero_mul] at this; exact (show k + 2 \u2260 0 by simp) this\n      rw [factors, List.prod_cons, prod_factors h\u2081, Nat.mul_div_cancel' (minFac_dvd _)]\n#align nat.prod_factors Nat.prod_factors\n\ntheorem factors_prime {p : \u2115} (hp : Nat.Prime p) : p.factors = [p] := by\n  have : p = p - 2 + 2 := (tsub_eq_iff_eq_add_of_le hp.two_le).mp rfl\n  rw [this, Nat.factors]\n  simp only [Eq.symm this]\n  have : Nat.minFac p = p := (Nat.prime_def_minFac.mp hp).2\n  simp only [this, Nat.factors, Nat.div_self (Nat.Prime.pos hp)]\n#align nat.factors_prime Nat.factors_prime\n\ntheorem factors_chain {n : \u2115} :\n    \u2200 {a}, (\u2200 p, Prime p \u2192 p \u2223 n \u2192 a \u2264 p) \u2192 List.Chain (\u00b7 \u2264 \u00b7) a (factors n) := by\n  match n with\n  | 0 => simp\n  | 1 => simp\n  | k + 2 =>\n      intro a h\n      let m := minFac (k + 2)\n      have : (k + 2) / m < (k + 2) := factors_lemma\n      rw [factors]\n      refine List.Chain.cons ((le_minFac.2 h).resolve_left (by simp)) (factors_chain ?_)\n      exact fun p pp d => minFac_le_of_dvd pp.two_le (d.trans <| div_dvd_of_dvd <| minFac_dvd _)\n#align nat.factors_chain Nat.factors_chain\n\ntheorem factors_chain_2 (n) : List.Chain (\u00b7 \u2264 \u00b7) 2 (factors n) :=\n  factors_chain fun _ pp _ => pp.two_le\n#align nat.factors_chain_2 Nat.factors_chain_2\n\ntheorem factors_chain' (n) : List.Chain' (\u00b7 \u2264 \u00b7) (factors n) :=\n  @List.Chain'.tail _ _ (_ :: _) (factors_chain_2 _)\n#align nat.factors_chain' Nat.factors_chain'\n\ntheorem factors_sorted (n : \u2115) : List.Sorted (\u00b7 \u2264 \u00b7) (factors n) :=\n  List.chain'_iff_pairwise.1 (factors_chain' _)\n#align nat.factors_sorted Nat.factors_sorted\n\n\ntheorem factors_add_two (n : \u2115) :\n    factors (n + 2) = minFac (n + 2) :: factors ((n + 2) / minFac (n + 2)) := by rw [factors]\n#align nat.factors_add_two Nat.factors_add_two\n\n@[simp]\ntheorem factors_eq_nil (n : \u2115) : n.factors = [] \u2194 n = 0 \u2228 n = 1 := by\n  constructor <;> intro h\n  \u00b7 rcases n with (_ | _ | n)\n    \u00b7 exact Or.inl rfl\n    \u00b7 exact Or.inr rfl\n    \u00b7 rw [factors] at h\n      injection h\n  \u00b7 rcases h with (rfl | rfl)\n    \u00b7 exact factors_zero\n    \u00b7 exact factors_one\n#align nat.factors_eq_nil Nat.factors_eq_nil\n\nopen scoped List in\ntheorem eq_of_perm_factors {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0) (h : a.factors ~ b.factors) :\n    a = b := by simpa [prod_factors ha, prod_factors hb] using List.Perm.prod_eq h\n#align nat.eq_of_perm_factors Nat.eq_of_perm_factors\n\nsection\n\nopen List\n\ntheorem mem_factors_iff_dvd {n p : \u2115} (hn : n \u2260 0) (hp : Prime p) : p \u2208 factors n \u2194 p \u2223 n :=\n  \u27e8fun h => prod_factors hn \u25b8 List.dvd_prod h, fun h =>\n    mem_list_primes_of_dvd_prod (prime_iff.mp hp) (fun _ h => prime_iff.mp (prime_of_mem_factors h))\n      ((prod_factors hn).symm \u25b8 h)\u27e9\n#align nat.mem_factors_iff_dvd Nat.mem_factors_iff_dvd\n\n"}
{"name": "homothety_one_half139", "split": "test", "formal_statement": "theorem homothety_one_half {k : Type*} {V P : Type*} [Field k] [CharZero k] [AddCommGroup V]\n    [Module k V] [AddTorsor V P] (a b : P) : homothety a (1 / 2 : k) b = midpoint k a b := by", "header": "\nimport Mathlib.Algebra.CharP.Invertible\nimport Mathlib.LinearAlgebra.AffineSpace.Midpoint\n\n#align_import linear_algebra.affine_space.midpoint_zero from \"leanprover-community/mathlib\"@\"78261225eb5cedc61c5c74ecb44e5b385d13b733\"\n\n\n\n\nopen AffineMap AffineEquiv\n\ntheorem lineMap_inv_two {R : Type*} {V P : Type*} [DivisionRing R] [CharZero R] [AddCommGroup V]\n    [Module R V] [AddTorsor V P] (a b : P) : lineMap a b (2\u207b\u00b9 : R) = midpoint R a b :=\n  rfl\n#align line_map_inv_two lineMap_inv_two\n\ntheorem lineMap_one_half {R : Type*} {V P : Type*} [DivisionRing R] [CharZero R] [AddCommGroup V]\n    [Module R V] [AddTorsor V P] (a b : P) : lineMap a b (1 / 2 : R) = midpoint R a b := by\n  rw [one_div, lineMap_inv_two]\n#align line_map_one_half lineMap_one_half\n\ntheorem homothety_invOf_two {R : Type*} {V P : Type*} [CommRing R] [Invertible (2 : R)]\n    [AddCommGroup V] [Module R V] [AddTorsor V P] (a b : P) :\n    homothety a (\u215f 2 : R) b = midpoint R a b :=\n  rfl\n#align homothety_inv_of_two homothety_invOf_two\n\ntheorem homothety_inv_two {k : Type*} {V P : Type*} [Field k] [CharZero k] [AddCommGroup V]\n    [Module k V] [AddTorsor V P] (a b : P) : homothety a (2\u207b\u00b9 : k) b = midpoint k a b :=\n  rfl\n#align homothety_inv_two homothety_inv_two\n\n"}
{"name": "maybeNormalize_eq_normalize140", "split": "test", "formal_statement": "theorem maybeNormalize_eq_normalize {num : Int} {den g : Nat} (den_nz reduced)\n    (hn : \u2191g \u2223 num) (hd : g \u2223 den) :\n    maybeNormalize num den g den_nz reduced = normalize num den (mt (by simp [\u00b7]) den_nz) := by", "header": "\nimport Batteries.Data.Rat.Basic\nimport Batteries.Tactic.SeqFocus\n\n\n\nnamespace Rat\n\ntheorem ext : {p q : Rat} \u2192 p.num = q.num \u2192 p.den = q.den \u2192 p = q\n  | \u27e8_,_,_,_\u27e9, \u27e8_,_,_,_\u27e9, rfl, rfl => rfl\n\n@[simp] theorem mk_den_one {r : Int} :\n    \u27e8r, 1, Nat.one_ne_zero, (Nat.coprime_one_right _)\u27e9 = (r : Rat) := rfl\n\n@[simp] theorem zero_num : (0 : Rat).num = 0 := rfl\n@[simp] theorem zero_den : (0 : Rat).den = 1 := rfl\n@[simp] theorem one_num : (1 : Rat).num = 1 := rfl\n@[simp] theorem one_den : (1 : Rat).den = 1 := rfl\n\n@[simp] theorem maybeNormalize_eq {num den g} (den_nz reduced) :\n    maybeNormalize num den g den_nz reduced =\n    { num := num.div g, den := den / g, den_nz, reduced } := by\n  unfold maybeNormalize; split\n  \u00b7 subst g; simp\n  \u00b7 rfl\n\ntheorem normalize.reduced' {num : Int} {den g : Nat} (den_nz : den \u2260 0)\n    (e : g = num.natAbs.gcd den) : (num / g).natAbs.Coprime (den / g) := by\n  rw [\u2190 Int.div_eq_ediv_of_dvd (e \u25b8 Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n  exact normalize.reduced den_nz e\n\ntheorem normalize_eq {num den} (den_nz) : normalize num den den_nz =\n    { num := num / num.natAbs.gcd den\n      den := den / num.natAbs.gcd den\n      den_nz := normalize.den_nz den_nz rfl\n      reduced := normalize.reduced' den_nz rfl } := by\n  simp only [normalize, maybeNormalize_eq,\n    Int.div_eq_ediv_of_dvd (Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n\n@[simp] theorem normalize_zero (nz) : normalize 0 d nz = 0 := by\n  simp [normalize, Int.zero_div, Int.natAbs_zero, Nat.div_self (Nat.pos_of_ne_zero nz)]; rfl\n\ntheorem mk_eq_normalize (num den nz c) : \u27e8num, den, nz, c\u27e9 = normalize num den nz := by\n  simp [normalize_eq, c.gcd_eq_one]\n\ntheorem normalize_self (r : Rat) : normalize r.num r.den r.den_nz = r := (mk_eq_normalize ..).symm\n\ntheorem normalize_mul_left {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (\u2191a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0 := by\n  simp [normalize_eq, mk'.injEq, Int.natAbs_mul, Nat.gcd_mul_left,\n    Nat.mul_div_mul_left _ _ (Nat.pos_of_ne_zero a0), Int.ofNat_mul,\n    Int.mul_ediv_mul_of_pos _ _ (Int.ofNat_pos.2 <| Nat.pos_of_ne_zero a0)]\n\ntheorem normalize_mul_right {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0 := by\n  rw [\u2190 normalize_mul_left (d0 := d0) a0]; congr 1 <;> [apply Int.mul_comm; apply Nat.mul_comm]\n\ntheorem normalize_eq_iff (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    normalize n\u2081 d\u2081 z\u2081 = normalize n\u2082 d\u2082 z\u2082 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081 := by\n  constructor <;> intro h\n  \u00b7 simp only [normalize_eq, mk'.injEq] at h\n    have' hn\u2081 := Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left n\u2081.natAbs d\u2081\n    have' hn\u2082 := Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left n\u2082.natAbs d\u2082\n    have' hd\u2081 := Int.ofNat_dvd.2 <| Nat.gcd_dvd_right n\u2081.natAbs d\u2081\n    have' hd\u2082 := Int.ofNat_dvd.2 <| Nat.gcd_dvd_right n\u2082.natAbs d\u2082\n    rw [\u2190 Int.ediv_mul_cancel (Int.dvd_trans hd\u2082 (Int.dvd_mul_left ..)),\n      Int.mul_ediv_assoc _ hd\u2082, \u2190 Int.ofNat_ediv, \u2190 h.2, Int.ofNat_ediv,\n      \u2190 Int.mul_ediv_assoc _ hd\u2081, Int.mul_ediv_assoc' _ hn\u2081,\n      Int.mul_right_comm, h.1, Int.ediv_mul_cancel hn\u2082]\n  \u00b7 rw [\u2190 normalize_mul_right _ z\u2082, \u2190 normalize_mul_left z\u2082 z\u2081, Int.mul_comm d\u2081, h]\n\n"}
{"name": "card_edgeFinset_le_card_choose_two141", "split": "test", "formal_statement": "theorem card_edgeFinset_le_card_choose_two : G.edgeFinset.card \u2264 (Fintype.card V).choose 2 := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Combinatorics.SimpleGraph.Basic\nimport Mathlib.Data.Sym.Card\n\n\n\n\nopen Finset Function\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V) {e : Sym2 V}\n\nsection EdgeFinset\n\nvariable {G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]\n\n\nabbrev edgeFinset : Finset (Sym2 V) :=\n  Set.toFinset G.edgeSet\n#align simple_graph.edge_finset SimpleGraph.edgeFinset\n\n@[norm_cast]\ntheorem coe_edgeFinset : (G.edgeFinset : Set (Sym2 V)) = G.edgeSet :=\n  Set.coe_toFinset _\n#align simple_graph.coe_edge_finset SimpleGraph.coe_edgeFinset\n\nvariable {G}\n\ntheorem mem_edgeFinset : e \u2208 G.edgeFinset \u2194 e \u2208 G.edgeSet :=\n  Set.mem_toFinset\n#align simple_graph.mem_edge_finset SimpleGraph.mem_edgeFinset\n\ntheorem not_isDiag_of_mem_edgeFinset : e \u2208 G.edgeFinset \u2192 \u00ace.IsDiag :=\n  not_isDiag_of_mem_edgeSet _ \u2218 mem_edgeFinset.1\n#align simple_graph.not_is_diag_of_mem_edge_finset SimpleGraph.not_isDiag_of_mem_edgeFinset\n\ntheorem edgeFinset_inj : G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082 := by simp\n#align simple_graph.edge_finset_inj SimpleGraph.edgeFinset_inj\n\ntheorem edgeFinset_subset_edgeFinset : G\u2081.edgeFinset \u2286 G\u2082.edgeFinset \u2194 G\u2081 \u2264 G\u2082 := by simp\n#align simple_graph.edge_finset_subset_edge_finset SimpleGraph.edgeFinset_subset_edgeFinset\n\ntheorem edgeFinset_ssubset_edgeFinset : G\u2081.edgeFinset \u2282 G\u2082.edgeFinset \u2194 G\u2081 < G\u2082 := by simp\n#align simple_graph.edge_finset_ssubset_edge_finset SimpleGraph.edgeFinset_ssubset_edgeFinset\n\n@[gcongr] alias \u27e8_, edgeFinset_mono\u27e9 := edgeFinset_subset_edgeFinset\n#align simple_graph.edge_finset_mono SimpleGraph.edgeFinset_mono\n\nalias \u27e8_, edgeFinset_strict_mono\u27e9 := edgeFinset_ssubset_edgeFinset\n#align simple_graph.edge_finset_strict_mono SimpleGraph.edgeFinset_strict_mono\n\nattribute [mono] edgeFinset_mono edgeFinset_strict_mono\n\n@[simp]\ntheorem edgeFinset_bot : (\u22a5 : SimpleGraph V).edgeFinset = \u2205 := by simp [edgeFinset]\n#align simple_graph.edge_finset_bot SimpleGraph.edgeFinset_bot\n\n@[simp]\ntheorem edgeFinset_sup [Fintype (edgeSet (G\u2081 \u2294 G\u2082))] [DecidableEq V] :\n    (G\u2081 \u2294 G\u2082).edgeFinset = G\u2081.edgeFinset \u222a G\u2082.edgeFinset := by simp [edgeFinset]\n#align simple_graph.edge_finset_sup SimpleGraph.edgeFinset_sup\n\n@[simp]\ntheorem edgeFinset_inf [DecidableEq V] : (G\u2081 \u2293 G\u2082).edgeFinset = G\u2081.edgeFinset \u2229 G\u2082.edgeFinset := by\n  simp [edgeFinset]\n#align simple_graph.edge_finset_inf SimpleGraph.edgeFinset_inf\n\n@[simp]\ntheorem edgeFinset_sdiff [DecidableEq V] :\n    (G\u2081 \\ G\u2082).edgeFinset = G\u2081.edgeFinset \\ G\u2082.edgeFinset := by simp [edgeFinset]\n#align simple_graph.edge_finset_sdiff SimpleGraph.edgeFinset_sdiff\n\ntheorem edgeFinset_card : G.edgeFinset.card = Fintype.card G.edgeSet :=\n  Set.toFinset_card _\n#align simple_graph.edge_finset_card SimpleGraph.edgeFinset_card\n\n@[simp]\ntheorem edgeSet_univ_card : (univ : Finset G.edgeSet).card = G.edgeFinset.card :=\n  Fintype.card_of_subtype G.edgeFinset fun _ => mem_edgeFinset\n#align simple_graph.edge_set_univ_card SimpleGraph.edgeSet_univ_card\n\nvariable [Fintype V]\n\n@[simp]\ntheorem edgeFinset_top [DecidableEq V] :\n    (\u22a4 : SimpleGraph V).edgeFinset = univ.filter fun e => \u00ace.IsDiag := by\n  rw [\u2190 coe_inj]; simp\n\n\ntheorem card_edgeFinset_top_eq_card_choose_two [DecidableEq V] :\n    (\u22a4 : SimpleGraph V).edgeFinset.card = (Fintype.card V).choose 2 := by\n  simp_rw [Set.toFinset_card, edgeSet_top, Set.coe_setOf, \u2190 Sym2.card_subtype_not_diag]\n\n\n"}
{"name": "MonovaryOn.sum_smul_sum_le_card_smul_sum142", "split": "test", "formal_statement": "theorem MonovaryOn.sum_smul_sum_le_card_smul_sum (hfg : MonovaryOn f g s) :\n    ((\u2211 i \u2208 s, f i) \u2022 \u2211 i \u2208 s, g i) \u2264 s.card \u2022 \u2211 i \u2208 s, f i \u2022 g i := by", "header": "\nimport Mathlib.Algebra.Order.BigOperators.Group.Finset\nimport Mathlib.Algebra.Order.Group.Basic\nimport Mathlib.Algebra.Order.Rearrangement\nimport Mathlib.Algebra.Order.Ring.Basic\nimport Mathlib.GroupTheory.Perm.Cycle.Basic\n\n#align_import algebra.order.chebyshev from \"leanprover-community/mathlib\"@\"b7399344324326918d65d0c74e9571e3a8cb9199\"\n\n\n\n\nopen Equiv Equiv.Perm Finset Function OrderDual\n\nvariable {\u03b9 \u03b1 \u03b2 : Type*}\n\n\n\n\nsection SMul\n\nvariable [LinearOrderedRing \u03b1] [LinearOrderedAddCommGroup \u03b2] [Module \u03b1 \u03b2] [OrderedSMul \u03b1 \u03b2]\n  {s : Finset \u03b9} {\u03c3 : Perm \u03b9} {f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 \u03b2}\n\n\n"}
{"name": "tan_arctan143", "split": "test", "formal_statement": "theorem tan_arctan {z : \u2102} (h\u2081 : z \u2260 I) (h\u2082 : z \u2260 -I) : tan (arctan z) = z := by", "header": "\nimport Mathlib.Analysis.SpecialFunctions.Complex.LogBounds\n\n\n\n\nnamespace Complex\n\nopen scoped Real\n\n\nnoncomputable def arctan (z : \u2102) : \u2102 := -I / 2 * log ((1 + z * I) / (1 - z * I))\n\n"}
{"name": "one_right144", "split": "test", "formal_statement": "theorem one_right (a : M) : SemiconjBy a 1 1 := by", "header": "\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Init.Logic\nimport Mathlib.Tactic.Cases\n\n#align_import algebra.group.semiconj from \"leanprover-community/mathlib\"@\"a148d797a1094ab554ad4183a4ad6f130358ef64\"\n\n\n\nassert_not_exists MonoidWithZero\nassert_not_exists DenselyOrdered\n\nvariable {S M G : Type*}\n\n\n@[to_additive \"`x` is additive semiconjugate to `y` by `a` if `a + x = y + a`\"]\ndef SemiconjBy [Mul M] (a x y : M) : Prop :=\n  a * x = y * a\n#align semiconj_by SemiconjBy\n#align add_semiconj_by AddSemiconjBy\n\nnamespace SemiconjBy\n\n\n@[to_additive \"Equality behind `AddSemiconjBy a x y`; useful for rewriting.\"]\nprotected theorem eq [Mul S] {a x y : S} (h : SemiconjBy a x y) : a * x = y * a :=\n  h\n#align semiconj_by.eq SemiconjBy.eq\n#align add_semiconj_by.eq AddSemiconjBy.eq\n\nsection MulOneClass\n\nvariable [MulOneClass M]\n\n\n@[to_additive (attr := simp) \"Any element semiconjugates `0` to `0`.\"]\n"}
{"name": "eq_one_of_lt_two145", "split": "test", "formal_statement": "theorem eq_one_of_lt_two {n : \u2115+} : n < 2 \u2192 n = 1 := by", "header": "\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.prime from \"leanprover-community/mathlib\"@\"09597669f02422ed388036273d8848119699c22f\"\n\n\n\n\nnamespace PNat\n\nopen Nat\n\n\ndef gcd (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.gcd (n : \u2115) (m : \u2115), Nat.gcd_pos_of_pos_left (m : \u2115) n.pos\u27e9\n#align pnat.gcd PNat.gcd\n\n\ndef lcm (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.lcm (n : \u2115) (m : \u2115), by\n    let h := mul_pos n.pos m.pos\n    rw [\u2190 gcd_mul_lcm (n : \u2115) (m : \u2115), mul_comm] at h\n    exact pos_of_dvd_of_pos (Dvd.intro (Nat.gcd (n : \u2115) (m : \u2115)) rfl) h\u27e9\n#align pnat.lcm PNat.lcm\n\n@[simp, norm_cast]\ntheorem gcd_coe (n m : \u2115+) : (gcd n m : \u2115) = Nat.gcd n m :=\n  rfl\n#align pnat.gcd_coe PNat.gcd_coe\n\n@[simp, norm_cast]\ntheorem lcm_coe (n m : \u2115+) : (lcm n m : \u2115) = Nat.lcm n m :=\n  rfl\n#align pnat.lcm_coe PNat.lcm_coe\n\ntheorem gcd_dvd_left (n m : \u2115+) : gcd n m \u2223 n :=\n  dvd_iff.2 (Nat.gcd_dvd_left (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_left PNat.gcd_dvd_left\n\ntheorem gcd_dvd_right (n m : \u2115+) : gcd n m \u2223 m :=\n  dvd_iff.2 (Nat.gcd_dvd_right (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_right PNat.gcd_dvd_right\n\ntheorem dvd_gcd {m n k : \u2115+} (hm : k \u2223 m) (hn : k \u2223 n) : k \u2223 gcd m n :=\n  dvd_iff.2 (Nat.dvd_gcd (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.dvd_gcd PNat.dvd_gcd\n\ntheorem dvd_lcm_left (n m : \u2115+) : n \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_left (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_left PNat.dvd_lcm_left\n\ntheorem dvd_lcm_right (n m : \u2115+) : m \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_right (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_right PNat.dvd_lcm_right\n\ntheorem lcm_dvd {m n k : \u2115+} (hm : m \u2223 k) (hn : n \u2223 k) : lcm m n \u2223 k :=\n  dvd_iff.2 (@Nat.lcm_dvd (m : \u2115) (n : \u2115) (k : \u2115) (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.lcm_dvd PNat.lcm_dvd\n\ntheorem gcd_mul_lcm (n m : \u2115+) : gcd n m * lcm n m = n * m :=\n  Subtype.eq (Nat.gcd_mul_lcm (n : \u2115) (m : \u2115))\n#align pnat.gcd_mul_lcm PNat.gcd_mul_lcm\n\n"}
{"name": "IsLocalization.AtPrime.discreteValuationRing_of_dedekind_domain146", "split": "test", "formal_statement": "theorem IsLocalization.AtPrime.discreteValuationRing_of_dedekind_domain [IsDedekindDomain A]\n    {P : Ideal A} (hP : P \u2260 \u22a5) [pP : P.IsPrime] (A\u2098 : Type*) [CommRing A\u2098] [IsDomain A\u2098]\n    [Algebra A A\u2098] [IsLocalization.AtPrime A\u2098 P] : DiscreteValuationRing A\u2098 := by", "header": "\nimport Mathlib.RingTheory.Localization.LocalizationLocalization\nimport Mathlib.RingTheory.Localization.Submodule\nimport Mathlib.RingTheory.DiscreteValuationRing.TFAE\n\n#align_import ring_theory.dedekind_domain.dvr from \"leanprover-community/mathlib\"@\"f0c8bf9245297a541f468be517f1bde6195105e9\"\n\n\n\n\nvariable (R A K : Type*) [CommRing R] [CommRing A] [IsDomain A] [Field K]\n\nopen scoped nonZeroDivisors Polynomial\n\n\nstructure IsDedekindDomainDvr : Prop where\n  isNoetherianRing : IsNoetherianRing A\n  is_dvr_at_nonzero_prime : \u2200 P \u2260 (\u22a5 : Ideal A), \u2200 _ : P.IsPrime,\n    DiscreteValuationRing (Localization.AtPrime P)\n#align is_dedekind_domain_dvr IsDedekindDomainDvr\n\n\ntheorem Ring.DimensionLEOne.localization {R : Type*} (R\u2098 : Type*) [CommRing R] [IsDomain R]\n    [CommRing R\u2098] [Algebra R R\u2098] {M : Submonoid R} [IsLocalization M R\u2098] (hM : M \u2264 R\u2070)\n    [h : Ring.DimensionLEOne R] : Ring.DimensionLEOne R\u2098 := \u27e8by\n  intro p hp0 hpp\n  refine Ideal.isMaximal_def.mpr \u27e8hpp.ne_top, Ideal.maximal_of_no_maximal fun P hpP hPm => ?_\u27e9\n  have hpP' : (\u27e8p, hpp\u27e9 : { p : Ideal R\u2098 // p.IsPrime }) < \u27e8P, hPm.isPrime\u27e9 := hpP\n  rw [\u2190 (IsLocalization.orderIsoOfPrime M R\u2098).lt_iff_lt] at hpP'\n  haveI : Ideal.IsPrime (Ideal.comap (algebraMap R R\u2098) p) :=\n    ((IsLocalization.orderIsoOfPrime M R\u2098) \u27e8p, hpp\u27e9).2.1\n  haveI : Ideal.IsPrime (Ideal.comap (algebraMap R R\u2098) P) :=\n    ((IsLocalization.orderIsoOfPrime M R\u2098) \u27e8P, hPm.isPrime\u27e9).2.1\n  have hlt : Ideal.comap (algebraMap R R\u2098) p < Ideal.comap (algebraMap R R\u2098) P := hpP'\n  refine h.not_lt_lt \u22a5 (Ideal.comap _ _) (Ideal.comap _ _) \u27e8?_, hlt\u27e9\n  exact IsLocalization.bot_lt_comap_prime _ _ hM _ hp0\u27e9\n#align ring.dimension_le_one.localization Ring.DimensionLEOne.localization\n\n\ntheorem IsLocalization.isDedekindDomain [IsDedekindDomain A] {M : Submonoid A} (hM : M \u2264 A\u2070)\n    (A\u2098 : Type*) [CommRing A\u2098] [IsDomain A\u2098] [Algebra A A\u2098] [IsLocalization M A\u2098] :\n    IsDedekindDomain A\u2098 := by\n  have h : \u2200 y : M, IsUnit (algebraMap A (FractionRing A) y) := by\n    rintro \u27e8y, hy\u27e9\n    exact IsUnit.mk0 _ (mt IsFractionRing.to_map_eq_zero_iff.mp (nonZeroDivisors.ne_zero (hM hy)))\n  letI : Algebra A\u2098 (FractionRing A) := RingHom.toAlgebra (IsLocalization.lift h)\n  haveI : IsScalarTower A A\u2098 (FractionRing A) :=\n    IsScalarTower.of_algebraMap_eq fun x => (IsLocalization.lift_eq h x).symm\n  haveI : IsFractionRing A\u2098 (FractionRing A) :=\n    IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M _ _\n  refine (isDedekindDomain_iff _ (FractionRing A)).mpr \u27e8?_, ?_, ?_, ?_\u27e9\n  \u00b7 infer_instance\n  \u00b7 exact IsLocalization.isNoetherianRing M _ (by infer_instance)\n  \u00b7 exact Ring.DimensionLEOne.localization A\u2098 hM\n  \u00b7 intro x hx\n    obtain \u27e8\u27e8y, y_mem\u27e9, hy\u27e9 := hx.exists_multiple_integral_of_isLocalization M _\n    obtain \u27e8z, hz\u27e9 := (isIntegrallyClosed_iff _).mp IsDedekindRing.toIsIntegralClosure hy\n    refine \u27e8IsLocalization.mk' A\u2098 z \u27e8y, y_mem\u27e9, (IsLocalization.lift_mk'_spec _ _ _ _).mpr ?_\u27e9\n    rw [hz, \u2190 Algebra.smul_def]\n    rfl\n#align is_localization.is_dedekind_domain IsLocalization.isDedekindDomain\n\n\ntheorem IsLocalization.AtPrime.isDedekindDomain [IsDedekindDomain A] (P : Ideal A) [P.IsPrime]\n    (A\u2098 : Type*) [CommRing A\u2098] [IsDomain A\u2098] [Algebra A A\u2098] [IsLocalization.AtPrime A\u2098 P] :\n    IsDedekindDomain A\u2098 :=\n  IsLocalization.isDedekindDomain A P.primeCompl_le_nonZeroDivisors A\u2098\n#align is_localization.at_prime.is_dedekind_domain IsLocalization.AtPrime.isDedekindDomain\n\ntheorem IsLocalization.AtPrime.not_isField {P : Ideal A} (hP : P \u2260 \u22a5) [pP : P.IsPrime] (A\u2098 : Type*)\n    [CommRing A\u2098] [Algebra A A\u2098] [IsLocalization.AtPrime A\u2098 P] : \u00acIsField A\u2098 := by\n  intro h\n  letI := h.toField\n  obtain \u27e8x, x_mem, x_ne\u27e9 := P.ne_bot_iff.mp hP\n  exact\n    (LocalRing.maximalIdeal.isMaximal _).ne_top\n      (Ideal.eq_top_of_isUnit_mem _\n        ((IsLocalization.AtPrime.to_map_mem_maximal_iff A\u2098 P _).mpr x_mem)\n        (isUnit_iff_ne_zero.mpr\n          ((map_ne_zero_iff (algebraMap A A\u2098)\n                (IsLocalization.injective A\u2098 P.primeCompl_le_nonZeroDivisors)).mpr\n            x_ne)))\n#align is_localization.at_prime.not_is_field IsLocalization.AtPrime.not_isField\n\n\n"}
{"name": "snd_invApp_t_app'147", "split": "test", "formal_statement": "theorem snd_invApp_t_app' (i j k : D.J) (U : Opens (pullback (D.f i j) (D.f i k)).carrier) :\n    \u2203 eq,\n      (\u03c0\u2082\u207b\u00b9 i, j, k) U \u226b (D.t k i).c.app _ \u226b (D.V (k, i)).presheaf.map (eqToHom eq) =\n        (D.t' k i j).c.app _ \u226b (\u03c0\u2081\u207b\u00b9 k, j, i) (unop _) := by", "header": "\nimport Mathlib.Topology.Gluing\nimport Mathlib.Geometry.RingedSpace.OpenImmersion\nimport Mathlib.Geometry.RingedSpace.LocallyRingedSpace.HasColimits\n\n#align_import algebraic_geometry.presheafed_space.gluing from \"leanprover-community/mathlib\"@\"533f62f4dd62a5aad24a04326e6e787c8f7e98b1\"\n\n\n\nset_option linter.uppercaseLean3 false\n\nnoncomputable section\n\nopen TopologicalSpace CategoryTheory Opposite\n\nopen CategoryTheory.Limits AlgebraicGeometry.PresheafedSpace\n\nopen CategoryTheory.GlueData\n\nnamespace AlgebraicGeometry\n\nuniverse v u\n\nvariable (C : Type u) [Category.{v} C]\n\nnamespace PresheafedSpace\n\n\n-- Porting note(#5171): this linter isn't ported yet.\n-- @[nolint has_nonempty_instance]\nstructure GlueData extends GlueData (PresheafedSpace.{u, v, v} C) where\n  f_open : \u2200 i j, IsOpenImmersion (f i j)\n#align algebraic_geometry.PresheafedSpace.glue_data AlgebraicGeometry.PresheafedSpace.GlueData\n\nattribute [instance] GlueData.f_open\n\nnamespace GlueData\n\nvariable {C}\nvariable (D : GlueData.{v, u} C)\n\nlocal notation \"\ud835\udda3\" => D.toGlueData\n\nlocal notation \"\u03c0\u2081 \" i \", \" j \", \" k => @pullback.fst _ _ _ _ _ (D.f i j) (D.f i k) _\n\nlocal notation \"\u03c0\u2082 \" i \", \" j \", \" k => @pullback.snd _ _ _ _ _ (D.f i j) (D.f i k) _\n\nset_option quotPrecheck false\nlocal notation \"\u03c0\u2081\u207b\u00b9 \" i \", \" j \", \" k =>\n  (PresheafedSpace.IsOpenImmersion.pullbackFstOfRight (D.f i j) (D.f i k)).invApp\n\nset_option quotPrecheck false\nlocal notation \"\u03c0\u2082\u207b\u00b9 \" i \", \" j \", \" k =>\n  (PresheafedSpace.IsOpenImmersion.pullbackSndOfLeft (D.f i j) (D.f i k)).invApp\n\n\nabbrev toTopGlueData : TopCat.GlueData :=\n  { f_open := fun i j => (D.f_open i j).base_open\n    toGlueData := \ud835\udda3.mapGlueData (forget C) }\n#align algebraic_geometry.PresheafedSpace.glue_data.to_Top_glue_data AlgebraicGeometry.PresheafedSpace.GlueData.toTopGlueData\n\ntheorem \u03b9_openEmbedding [HasLimits C] (i : D.J) : OpenEmbedding (\ud835\udda3.\u03b9 i).base := by\n  rw [\u2190 show _ = (\ud835\udda3.\u03b9 i).base from \ud835\udda3.\u03b9_gluedIso_inv (PresheafedSpace.forget _) _]\n  -- Porting note: added this erewrite\n  erw [coe_comp]\n  refine\n    OpenEmbedding.comp\n      (TopCat.homeoOfIso (\ud835\udda3.gluedIso (PresheafedSpace.forget _)).symm).openEmbedding\n      (D.toTopGlueData.\u03b9_openEmbedding i)\n#align algebraic_geometry.PresheafedSpace.glue_data.\u03b9_open_embedding AlgebraicGeometry.PresheafedSpace.GlueData.\u03b9_openEmbedding\n\ntheorem pullback_base (i j k : D.J) (S : Set (D.V (i, j)).carrier) :\n    (\u03c0\u2082 i, j, k) '' ((\u03c0\u2081 i, j, k) \u207b\u00b9' S) = D.f i k \u207b\u00b9' (D.f i j '' S) := by\n  have eq\u2081 : _ = (\u03c0\u2081 i, j, k).base := PreservesPullback.iso_hom_fst (forget C) _ _\n  have eq\u2082 : _ = (\u03c0\u2082 i, j, k).base := PreservesPullback.iso_hom_snd (forget C) _ _\n  rw [\u2190 eq\u2081, \u2190 eq\u2082]\n  -- Porting note: `rw` to `erw` on `coe_comp`\n  erw [coe_comp]\n  rw [Set.image_comp]\n  -- Porting note: `rw` to `erw` on `coe_comp`\n  erw [coe_comp]\n  erw [Set.preimage_comp, Set.image_preimage_eq, TopCat.pullback_snd_image_fst_preimage]\n   -- now `erw` after #13170\n  \u00b7 rfl\n  erw [\u2190 TopCat.epi_iff_surjective] -- now `erw` after #13170\n  infer_instance\n#align algebraic_geometry.PresheafedSpace.glue_data.pullback_base AlgebraicGeometry.PresheafedSpace.GlueData.pullback_base\n\n\n@[simp, reassoc]\ntheorem f_invApp_f_app (i j k : D.J) (U : Opens (D.V (i, j)).carrier) :\n    (D.f_open i j).invApp U \u226b (D.f i k).c.app _ =\n      (\u03c0\u2081 i, j, k).c.app (op U) \u226b\n        (\u03c0\u2082\u207b\u00b9 i, j, k) (unop _) \u226b\n          (D.V _).presheaf.map\n            (eqToHom\n              (by\n                delta IsOpenImmersion.openFunctor\n                dsimp only [Functor.op, IsOpenMap.functor, Opens.map, unop_op]\n                congr\n                apply pullback_base)) := by\n  have := PresheafedSpace.congr_app (@pullback.condition _ _ _ _ _ (D.f i j) (D.f i k) _)\n  dsimp only [comp_c_app] at this\n  rw [\u2190 cancel_epi (inv ((D.f_open i j).invApp U)), IsIso.inv_hom_id_assoc,\n    IsOpenImmersion.inv_invApp]\n  simp_rw [Category.assoc]\n  erw [(\u03c0\u2081 i, j, k).c.naturality_assoc, reassoc_of% this, \u2190 Functor.map_comp_assoc,\n    IsOpenImmersion.inv_naturality_assoc, IsOpenImmersion.app_invApp_assoc, \u2190\n    (D.V (i, k)).presheaf.map_comp, \u2190 (D.V (i, k)).presheaf.map_comp]\n  -- Porting note: need to provide an explicit argument, otherwise Lean does not know which\n  -- category we are talking about\n  convert (Category.comp_id ((f D.toGlueData i k).c.app _)).symm\n  erw [(D.V (i, k)).presheaf.map_id]\n  rfl\n#align algebraic_geometry.PresheafedSpace.glue_data.f_inv_app_f_app AlgebraicGeometry.PresheafedSpace.GlueData.f_invApp_f_app\n\nset_option backward.isDefEq.lazyWhnfCore false in -- See https://github.com/leanprover-community/mathlib4/issues/12534\n\n"}
{"name": "effectiveEpiFamily_tfae148", "split": "test", "formal_statement": "theorem effectiveEpiFamily_tfae\n    {\u03b1 : Type} [Finite \u03b1] {B : CompHaus.{u}}\n    (X : \u03b1 \u2192 CompHaus.{u}) (\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B)) :\n    TFAE\n    [ EffectiveEpiFamily X \u03c0\n    , Epi (Sigma.desc \u03c0)\n    , \u2200 b : B, \u2203 (a : \u03b1) (x : X a), \u03c0 a x = b\n    ] := by", "header": "\nimport Mathlib.CategoryTheory.Sites.Coherent.Comparison\nimport Mathlib.Topology.Category.CompHaus.Limits\n\n\nuniverse u\n\n\nattribute [local instance] CategoryTheory.ConcreteCategory.instFunLike\n\nopen CategoryTheory Limits\n\nnamespace CompHaus\n\n\nnoncomputable\ndef struct {B X : CompHaus.{u}} (\u03c0 : X \u27f6 B) (h\u03c0 : Function.Surjective \u03c0) :\n    EffectiveEpiStruct \u03c0 where\n  desc e h := (QuotientMap.of_surjective_continuous h\u03c0 \u03c0.continuous).lift e fun a b hab \u21a6\n    DFunLike.congr_fun (h \u27e8fun _ \u21a6 a, continuous_const\u27e9 \u27e8fun _ \u21a6 b, continuous_const\u27e9\n    (by ext; exact hab)) a\n  fac e h := ((QuotientMap.of_surjective_continuous h\u03c0 \u03c0.continuous).lift_comp e\n    fun a b hab \u21a6 DFunLike.congr_fun (h \u27e8fun _ \u21a6 a, continuous_const\u27e9 \u27e8fun _ \u21a6 b, continuous_const\u27e9\n    (by ext; exact hab)) a)\n  uniq e h g hm := by\n    suffices g = (QuotientMap.of_surjective_continuous h\u03c0 \u03c0.continuous).liftEquiv \u27e8e,\n      fun a b hab \u21a6 DFunLike.congr_fun\n        (h \u27e8fun _ \u21a6 a, continuous_const\u27e9 \u27e8fun _ \u21a6 b, continuous_const\u27e9 (by ext; exact hab))\n        a\u27e9 by assumption\n    rw [\u2190 Equiv.symm_apply_eq (QuotientMap.of_surjective_continuous h\u03c0 \u03c0.continuous).liftEquiv]\n    ext\n    simp only [QuotientMap.liftEquiv_symm_apply_coe, ContinuousMap.comp_apply, \u2190 hm]\n    rfl\n\nopen List in\ntheorem effectiveEpi_tfae\n    {B X : CompHaus.{u}} (\u03c0 : X \u27f6 B) :\n    TFAE\n    [ EffectiveEpi \u03c0\n    , Epi \u03c0\n    , Function.Surjective \u03c0\n    ] := by\n  tfae_have 1 \u2192 2\n  \u00b7 intro; infer_instance\n  tfae_have 2 \u2194 3\n  \u00b7 exact epi_iff_surjective \u03c0\n  tfae_have 3 \u2192 1\n  \u00b7 exact fun h\u03c0 \u21a6 \u27e8\u27e8struct \u03c0 h\u03c0\u27e9\u27e9\n  tfae_finish\n\ninstance : Preregular CompHaus where\n  exists_fac := by\n    intro X Y Z f \u03c0 h\u03c0\n    refine \u27e8pullback f \u03c0, pullback.fst f \u03c0, ?_, pullback.snd f \u03c0, (pullback.condition _ _).symm\u27e9\n    have := fun X Y (f : X \u27f6 Y) \u21a6 (effectiveEpi_tfae f).out 0 2\n    rw [this] at h\u03c0 \u22a2\n    intro y\n    obtain \u27e8z,hz\u27e9 := h\u03c0 (f y)\n    exact \u27e8\u27e8(y, z), hz.symm\u27e9, rfl\u27e9\n\n-- Was an `example`, but that made the linter complain about unused imports\ninstance : Precoherent CompHaus.{u} := inferInstance\n\n-- TODO: prove this for `Type*`\nopen List in\n"}
{"name": "IsPrimePow.dvd149", "split": "test", "formal_statement": "theorem IsPrimePow.dvd {n m : \u2115} (hn : IsPrimePow n) (hm : m \u2223 n) (hm\u2081 : m \u2260 1) : IsPrimePow m := by", "header": "\nimport Mathlib.Algebra.Associated\nimport Mathlib.NumberTheory.Divisors\n\n#align_import algebra.is_prime_pow from \"leanprover-community/mathlib\"@\"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c\"\n\n\n\n\nvariable {R : Type*} [CommMonoidWithZero R] (n p : R) (k : \u2115)\n\n\ndef IsPrimePow : Prop :=\n  \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n\n#align is_prime_pow IsPrimePow\n\ntheorem isPrimePow_def : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n :=\n  Iff.rfl\n#align is_prime_pow_def isPrimePow_def\n\n\ntheorem isPrimePow_iff_pow_succ : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 p ^ (k + 1) = n :=\n  (isPrimePow_def _).trans\n    \u27e8fun \u27e8p, k, hp, hk, hn\u27e9 => \u27e8_, _, hp, by rwa [Nat.sub_add_cancel hk]\u27e9, fun \u27e8p, k, hp, hn\u27e9 =>\n      \u27e8_, _, hp, Nat.succ_pos', hn\u27e9\u27e9\n#align is_prime_pow_iff_pow_succ isPrimePow_iff_pow_succ\n\ntheorem not_isPrimePow_zero [NoZeroDivisors R] : \u00acIsPrimePow (0 : R) := by\n  simp only [isPrimePow_def, not_exists, not_and', and_imp]\n  intro x n _hn hx\n  rw [pow_eq_zero hx]\n  simp\n#align not_is_prime_pow_zero not_isPrimePow_zero\n\ntheorem IsPrimePow.not_unit {n : R} (h : IsPrimePow n) : \u00acIsUnit n :=\n  let \u27e8_p, _k, hp, hk, hn\u27e9 := h\n  hn \u25b8 (isUnit_pow_iff hk.ne').not.mpr hp.not_unit\n#align is_prime_pow.not_unit IsPrimePow.not_unit\n\ntheorem IsUnit.not_isPrimePow {n : R} (h : IsUnit n) : \u00acIsPrimePow n := fun h' => h'.not_unit h\n#align is_unit.not_is_prime_pow IsUnit.not_isPrimePow\n\ntheorem not_isPrimePow_one : \u00acIsPrimePow (1 : R) :=\n  isUnit_one.not_isPrimePow\n#align not_is_prime_pow_one not_isPrimePow_one\n\ntheorem Prime.isPrimePow {p : R} (hp : Prime p) : IsPrimePow p :=\n  \u27e8p, 1, hp, zero_lt_one, by simp\u27e9\n#align prime.is_prime_pow Prime.isPrimePow\n\ntheorem IsPrimePow.pow {n : R} (hn : IsPrimePow n) {k : \u2115} (hk : k \u2260 0) : IsPrimePow (n ^ k) :=\n  let \u27e8p, k', hp, hk', hn\u27e9 := hn\n  \u27e8p, k * k', hp, mul_pos hk.bot_lt hk', by rw [pow_mul', hn]\u27e9\n#align is_prime_pow.pow IsPrimePow.pow\n\ntheorem IsPrimePow.ne_zero [NoZeroDivisors R] {n : R} (h : IsPrimePow n) : n \u2260 0 := fun t =>\n  not_isPrimePow_zero (t \u25b8 h)\n#align is_prime_pow.ne_zero IsPrimePow.ne_zero\n\ntheorem IsPrimePow.ne_one {n : R} (h : IsPrimePow n) : n \u2260 1 := fun t =>\n  not_isPrimePow_one (t \u25b8 h)\n#align is_prime_pow.ne_one IsPrimePow.ne_one\n\nsection Nat\n\ntheorem isPrimePow_nat_iff (n : \u2115) : IsPrimePow n \u2194 \u2203 p k : \u2115, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n := by\n  simp only [isPrimePow_def, Nat.prime_iff]\n#align is_prime_pow_nat_iff isPrimePow_nat_iff\n\ntheorem Nat.Prime.isPrimePow {p : \u2115} (hp : p.Prime) : IsPrimePow p :=\n  _root_.Prime.isPrimePow (prime_iff.mp hp)\n#align nat.prime.is_prime_pow Nat.Prime.isPrimePow\n\ntheorem isPrimePow_nat_iff_bounded (n : \u2115) :\n    IsPrimePow n \u2194 \u2203 p : \u2115, p \u2264 n \u2227 \u2203 k : \u2115, k \u2264 n \u2227 p.Prime \u2227 0 < k \u2227 p ^ k = n := by\n  rw [isPrimePow_nat_iff]\n  refine Iff.symm \u27e8fun \u27e8p, _, k, _, hp, hk, hn\u27e9 => \u27e8p, k, hp, hk, hn\u27e9, ?_\u27e9\n  rintro \u27e8p, k, hp, hk, rfl\u27e9\n  refine \u27e8p, ?_, k, (Nat.lt_pow_self hp.one_lt _).le, hp, hk, rfl\u27e9\n  conv => { lhs; rw [\u2190 (pow_one p)] }\n  exact Nat.pow_le_pow_right hp.one_lt.le hk\n#align is_prime_pow_nat_iff_bounded isPrimePow_nat_iff_bounded\n\ninstance {n : \u2115} : Decidable (IsPrimePow n) :=\n  decidable_of_iff' _ (isPrimePow_nat_iff_bounded n)\n\n"}
{"name": "isPrimePow_nat_iff_bounded150", "split": "test", "formal_statement": "theorem isPrimePow_nat_iff_bounded (n : \u2115) :\n    IsPrimePow n \u2194 \u2203 p : \u2115, p \u2264 n \u2227 \u2203 k : \u2115, k \u2264 n \u2227 p.Prime \u2227 0 < k \u2227 p ^ k = n := by", "header": "\nimport Mathlib.Algebra.Associated\nimport Mathlib.NumberTheory.Divisors\n\n#align_import algebra.is_prime_pow from \"leanprover-community/mathlib\"@\"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c\"\n\n\n\n\nvariable {R : Type*} [CommMonoidWithZero R] (n p : R) (k : \u2115)\n\n\ndef IsPrimePow : Prop :=\n  \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n\n#align is_prime_pow IsPrimePow\n\ntheorem isPrimePow_def : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 0 < k \u2227 p ^ k = n :=\n  Iff.rfl\n#align is_prime_pow_def isPrimePow_def\n\n\ntheorem isPrimePow_iff_pow_succ : IsPrimePow n \u2194 \u2203 (p : R) (k : \u2115), Prime p \u2227 p ^ (k + 1) = n :=\n  (isPrimePow_def _).trans\n    \u27e8fun \u27e8p, k, hp, hk, hn\u27e9 => \u27e8_, _, hp, by rwa [Nat.sub_add_cancel hk]\u27e9, fun \u27e8p, k, hp, hn\u27e9 =>\n      \u27e8_, _, hp, Nat.succ_pos', hn\u27e9\u27e9\n#align is_prime_pow_iff_pow_succ isPrimePow_iff_pow_succ\n\ntheorem not_isPrimePow_zero [NoZeroDivisors R] : \u00acIsPrimePow (0 : R) := by\n  simp only [isPrimePow_def, not_exists, not_and', and_imp]\n  intro x n _hn hx\n  rw [pow_eq_zero hx]\n  simp\n#align not_is_prime_pow_zero not_isPrimePow_zero\n\ntheorem IsPrimePow.not_unit {n : R} (h : IsPrimePow n) : \u00acIsUnit n :=\n  let \u27e8_p, _k, hp, hk, hn\u27e9 := h\n  hn \u25b8 (isUnit_pow_iff hk.ne').not.mpr hp.not_unit\n#align is_prime_pow.not_unit IsPrimePow.not_unit\n\ntheorem IsUnit.not_isPrimePow {n : R} (h : IsUnit n) : \u00acIsPrimePow n := fun h' => h'.not_unit h\n#align is_unit.not_is_prime_pow IsUnit.not_isPrimePow\n\ntheorem not_isPrimePow_one : \u00acIsPrimePow (1 : R) :=\n  isUnit_one.not_isPrimePow\n#align not_is_prime_pow_one not_isPrimePow_one\n\ntheorem Prime.isPrimePow {p : R} (hp : Prime p) : IsPrimePow p :=\n  \u27e8p, 1, hp, zero_lt_one, by simp\u27e9\n#align prime.is_prime_pow Prime.isPrimePow\n\ntheorem IsPrimePow.pow {n : R} (hn : IsPrimePow n) {k : \u2115} (hk : k \u2260 0) : IsPrimePow (n ^ k) :=\n  let \u27e8p, k', hp, hk', hn\u27e9 := hn\n  \u27e8p, k * k', hp, mul_pos hk.bot_lt hk', by rw [pow_mul', hn]\u27e9\n#align is_prime_pow.pow IsPrimePow.pow\n\ntheorem IsPrimePow.ne_zero [NoZeroDivisors R] {n : R} (h : IsPrimePow n) : n \u2260 0 := fun t =>\n  not_isPrimePow_zero (t \u25b8 h)\n#align is_prime_pow.ne_zero IsPrimePow.ne_zero\n\ntheorem IsPrimePow.ne_one {n : R} (h : IsPrimePow n) : n \u2260 1 := fun t =>\n  not_isPrimePow_one (t \u25b8 h)\n#align is_prime_pow.ne_one IsPrimePow.ne_one\n\nsection Nat\n\ntheorem isPrimePow_nat_iff (n : \u2115) : IsPrimePow n \u2194 \u2203 p k : \u2115, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n := by\n  simp only [isPrimePow_def, Nat.prime_iff]\n#align is_prime_pow_nat_iff isPrimePow_nat_iff\n\ntheorem Nat.Prime.isPrimePow {p : \u2115} (hp : p.Prime) : IsPrimePow p :=\n  _root_.Prime.isPrimePow (prime_iff.mp hp)\n#align nat.prime.is_prime_pow Nat.Prime.isPrimePow\n\n"}
{"name": "LinearMap.continuous_on_pi151", "split": "test", "formal_statement": "theorem LinearMap.continuous_on_pi {\u03b9 : Type*} {R : Type*} {M : Type*} [Finite \u03b9] [Semiring R]\n    [TopologicalSpace R] [AddCommMonoid M] [Module R M] [TopologicalSpace M] [ContinuousAdd M]\n    [ContinuousSMul R M] (f : (\u03b9 \u2192 R) \u2192\u2097[R] M) : Continuous f := by", "header": "\nimport Mathlib.Topology.Algebra.Ring.Basic\nimport Mathlib.Topology.Algebra.MulAction\nimport Mathlib.Topology.Algebra.UniformGroup\nimport Mathlib.Topology.ContinuousFunction.Basic\nimport Mathlib.Topology.UniformSpace.UniformEmbedding\nimport Mathlib.Algebra.Algebra.Defs\nimport Mathlib.LinearAlgebra.Projection\nimport Mathlib.LinearAlgebra.Pi\nimport Mathlib.LinearAlgebra.Finsupp\n\n#align_import topology.algebra.module.basic from \"leanprover-community/mathlib\"@\"6285167a053ad0990fc88e56c48ccd9fae6550eb\"\n\n\n\nopen LinearMap (ker range)\nopen Topology Filter Pointwise\n\nuniverse u v w u'\n\nsection\n\nvariable {R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]\n  [AddCommGroup M] [Module R M]\n\ntheorem ContinuousSMul.of_nhds_zero [TopologicalRing R] [TopologicalAddGroup M]\n    (hmul : Tendsto (fun p : R \u00d7 M => p.1 \u2022 p.2) (\ud835\udcdd 0 \u00d7\u02e2 \ud835\udcdd 0) (\ud835\udcdd 0))\n    (hmulleft : \u2200 m : M, Tendsto (fun a : R => a \u2022 m) (\ud835\udcdd 0) (\ud835\udcdd 0))\n    (hmulright : \u2200 a : R, Tendsto (fun m : M => a \u2022 m) (\ud835\udcdd 0) (\ud835\udcdd 0)) : ContinuousSMul R M where\n  continuous_smul := by\n    refine continuous_of_continuousAt_zero\u2082 (AddMonoidHom.smul : R \u2192+ M \u2192+ M) ?_ ?_ ?_ <;>\n      simpa [ContinuousAt, nhds_prod_eq]\n#align has_continuous_smul.of_nhds_zero ContinuousSMul.of_nhds_zero\n\nend\n\nsection\n\nvariable {R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]\n  [AddCommGroup M] [ContinuousAdd M] [Module R M] [ContinuousSMul R M]\n\n\ntheorem Submodule.eq_top_of_nonempty_interior' [NeBot (\ud835\udcdd[{ x : R | IsUnit x }] 0)]\n    (s : Submodule R M) (hs : (interior (s : Set M)).Nonempty) : s = \u22a4 := by\n  rcases hs with \u27e8y, hy\u27e9\n  refine Submodule.eq_top_iff'.2 fun x => ?_\n  rw [mem_interior_iff_mem_nhds] at hy\n  have : Tendsto (fun c : R => y + c \u2022 x) (\ud835\udcdd[{ x : R | IsUnit x }] 0) (\ud835\udcdd (y + (0 : R) \u2022 x)) :=\n    tendsto_const_nhds.add ((tendsto_nhdsWithin_of_tendsto_nhds tendsto_id).smul tendsto_const_nhds)\n  rw [zero_smul, add_zero] at this\n  obtain \u27e8_, hu : y + _ \u2022 _ \u2208 s, u, rfl\u27e9 :=\n    nonempty_of_mem (inter_mem (Filter.mem_map.1 (this hy)) self_mem_nhdsWithin)\n  have hy' : y \u2208 \u2191s := mem_of_mem_nhds hy\n  rwa [s.add_mem_iff_right hy', \u2190 Units.smul_def, s.smul_mem_iff' u] at hu\n#align submodule.eq_top_of_nonempty_interior' Submodule.eq_top_of_nonempty_interior'\n\nvariable (R M)\n\n\ntheorem Module.punctured_nhds_neBot [Nontrivial M] [NeBot (\ud835\udcdd[\u2260] (0 : R))] [NoZeroSMulDivisors R M]\n    (x : M) : NeBot (\ud835\udcdd[\u2260] x) := by\n  rcases exists_ne (0 : M) with \u27e8y, hy\u27e9\n  suffices Tendsto (fun c : R => x + c \u2022 y) (\ud835\udcdd[\u2260] 0) (\ud835\udcdd[\u2260] x) from this.neBot\n  refine Tendsto.inf ?_ (tendsto_principal_principal.2 <| ?_)\n  \u00b7 convert tendsto_const_nhds.add ((@tendsto_id R _).smul_const y)\n    rw [zero_smul, add_zero]\n  \u00b7 intro c hc\n    simpa [hy] using hc\n#align module.punctured_nhds_ne_bot Module.punctured_nhds_neBot\n\nend\n\n\nlemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]\n    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]\n    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :\n    IsSeparable (Submodule.span R s : Set M) := by\n  rw [span_eq_iUnion_nat]\n  refine .iUnion fun n \u21a6 .image ?_ ?_\n  \u00b7 have : IsSeparable {f : Fin n \u2192 R \u00d7 M | \u2200 (i : Fin n), f i \u2208 Set.univ \u00d7\u02e2 s} := by\n      apply isSeparable_pi (fun i \u21a6 .prod (.of_separableSpace Set.univ) hs)\n    rwa [Set.univ_prod] at this\n  \u00b7 apply continuous_finset_sum _ (fun i _ \u21a6 ?_)\n    exact (continuous_fst.comp (continuous_apply i)).smul (continuous_snd.comp (continuous_apply i))\n\nsection Pi\n\n"}
{"name": "exists_isNilpotent_isSemisimple152", "split": "test", "formal_statement": "theorem exists_isNilpotent_isSemisimple [PerfectField K] :\n    \u2203\u1d49 (n \u2208 adjoin K {f}) (s \u2208 adjoin K {f}), IsNilpotent n \u2227 IsSemisimple s \u2227 f = n + s := by", "header": "\nimport Mathlib.Dynamics.Newton\nimport Mathlib.LinearAlgebra.Semisimple\n\n\n\nopen Algebra Polynomial\n\nnamespace Module.End\n\nvariable {K V : Type*} [Field K] [AddCommGroup V] [Module K V] [FiniteDimensional K V] {f : End K V}\n\ntheorem exists_isNilpotent_isSemisimple_of_separable_of_dvd_pow {P : K[X]} {k : \u2115}\n    (sep : P.Separable) (nil : minpoly K f \u2223 P ^ k) :\n    \u2203\u1d49 (n \u2208 adjoin K {f}) (s \u2208 adjoin K {f}), IsNilpotent n \u2227 IsSemisimple s \u2227 f = n + s := by\n  set ff : adjoin K {f} := \u27e8f, self_mem_adjoin_singleton K f\u27e9\n  set P' := derivative P\n  have nil' : IsNilpotent (aeval ff P) := by\n    use k\n    obtain \u27e8q, hq\u27e9 := nil\n    rw [\u2190 AlgHom.map_pow, Subtype.ext_iff]\n    simp [ff, hq]\n  have sep' : IsUnit (aeval ff P') := by\n    obtain \u27e8a, b, h\u27e9 : IsCoprime (P ^ k) P' := sep.pow_left\n    replace h : (aeval f b) * (aeval f P') = 1 := by\n      simpa only [map_add, map_mul, map_one, minpoly.dvd_iff.mp nil, mul_zero, zero_add]\n        using (aeval f).congr_arg h\n    refine isUnit_of_mul_eq_one_right (aeval ff b) _ (Subtype.ext_iff.mpr ?_)\n    simpa [ff, coe_aeval_mk_apply] using h\n  obtain \u27e8\u27e8s, mem\u27e9, \u27e8\u27e8k, hk\u27e9, hss\u27e9, -\u27e9 := exists_unique_nilpotent_sub_and_aeval_eq_zero nil' sep'\n  refine \u27e8f - s, ?_, s, mem, \u27e8k, ?_\u27e9, ?_, (sub_add_cancel f s).symm\u27e9\n  \u00b7 exact sub_mem (self_mem_adjoin_singleton K f) mem\n  \u00b7 rw [Subtype.ext_iff] at hk\n    simpa using hk\n  \u00b7 replace hss : aeval s P = 0 := by rwa [Subtype.ext_iff, coe_aeval_mk_apply] at hss\n    exact isSemisimple_of_squarefree_aeval_eq_zero sep.squarefree hss\n\n\n"}
{"name": "inf_sdiff_self_left153", "split": "test", "formal_statement": "theorem inf_sdiff_self_left : y \\ x \u2293 x = \u22a5 := by", "header": "\nimport Mathlib.Order.Heyting.Basic\n\n#align_import order.boolean_algebra from \"leanprover-community/mathlib\"@\"9ac7c0c8c4d7a535ec3e5b34b8859aab9233b2f4\"\n\n\n\n\nopen Function OrderDual\n\nuniverse u v\n\nvariable {\u03b1 : Type u} {\u03b2 : Type*} {w x y z : \u03b1}\n\n\n\n\n\nclass GeneralizedBooleanAlgebra (\u03b1 : Type u) extends DistribLattice \u03b1, SDiff \u03b1, Bot \u03b1 where\n  \n  sup_inf_sdiff : \u2200 a b : \u03b1, a \u2293 b \u2294 a \\ b = a\n  \n  inf_inf_sdiff : \u2200 a b : \u03b1, a \u2293 b \u2293 a \\ b = \u22a5\n#align generalized_boolean_algebra GeneralizedBooleanAlgebra\n\n-- We might want an `IsCompl_of` predicate (for relative complements) generalizing `IsCompl`,\n-- however we'd need another type class for lattices with bot, and all the API for that.\nsection GeneralizedBooleanAlgebra\n\nvariable [GeneralizedBooleanAlgebra \u03b1]\n\n@[simp]\ntheorem sup_inf_sdiff (x y : \u03b1) : x \u2293 y \u2294 x \\ y = x :=\n  GeneralizedBooleanAlgebra.sup_inf_sdiff _ _\n#align sup_inf_sdiff sup_inf_sdiff\n\n@[simp]\ntheorem inf_inf_sdiff (x y : \u03b1) : x \u2293 y \u2293 x \\ y = \u22a5 :=\n  GeneralizedBooleanAlgebra.inf_inf_sdiff _ _\n#align inf_inf_sdiff inf_inf_sdiff\n\n@[simp]\ntheorem sup_sdiff_inf (x y : \u03b1) : x \\ y \u2294 x \u2293 y = x := by rw [sup_comm, sup_inf_sdiff]\n#align sup_sdiff_inf sup_sdiff_inf\n\n@[simp]\ntheorem inf_sdiff_inf (x y : \u03b1) : x \\ y \u2293 (x \u2293 y) = \u22a5 := by rw [inf_comm, inf_inf_sdiff]\n#align inf_sdiff_inf inf_sdiff_inf\n\n-- see Note [lower instance priority]\ninstance (priority := 100) GeneralizedBooleanAlgebra.toOrderBot : OrderBot \u03b1 where\n  __ := GeneralizedBooleanAlgebra.toBot\n  bot_le a := by\n    rw [\u2190 inf_inf_sdiff a a, inf_assoc]\n    exact inf_le_left\n#align generalized_boolean_algebra.to_order_bot GeneralizedBooleanAlgebra.toOrderBot\n\ntheorem disjoint_inf_sdiff : Disjoint (x \u2293 y) (x \\ y) :=\n  disjoint_iff_inf_le.mpr (inf_inf_sdiff x y).le\n#align disjoint_inf_sdiff disjoint_inf_sdiff\n\n-- TODO: in distributive lattices, relative complements are unique when they exist\ntheorem sdiff_unique (s : x \u2293 y \u2294 z = x) (i : x \u2293 y \u2293 z = \u22a5) : x \\ y = z := by\n  conv_rhs at s => rw [\u2190 sup_inf_sdiff x y, sup_comm]\n  rw [sup_comm] at s\n  conv_rhs at i => rw [\u2190 inf_inf_sdiff x y, inf_comm]\n  rw [inf_comm] at i\n  exact (eq_of_inf_eq_sup_eq i s).symm\n#align sdiff_unique sdiff_unique\n\n-- Use `sdiff_le`\nprivate theorem sdiff_le' : x \\ y \u2264 x :=\n  calc\n    x \\ y \u2264 x \u2293 y \u2294 x \\ y := le_sup_right\n    _ = x := sup_inf_sdiff x y\n\n-- Use `sdiff_sup_self`\nprivate theorem sdiff_sup_self' : y \\ x \u2294 x = y \u2294 x :=\n  calc\n    y \\ x \u2294 x = y \\ x \u2294 (x \u2294 x \u2293 y) := by rw [sup_inf_self]\n    _ = y \u2293 x \u2294 y \\ x \u2294 x := by ac_rfl\n    _ = y \u2294 x := by rw [sup_inf_sdiff]\n\n@[simp]\ntheorem sdiff_inf_sdiff : x \\ y \u2293 y \\ x = \u22a5 :=\n  Eq.symm <|\n    calc\n      \u22a5 = x \u2293 y \u2293 x \\ y := by rw [inf_inf_sdiff]\n      _ = x \u2293 (y \u2293 x \u2294 y \\ x) \u2293 x \\ y := by rw [sup_inf_sdiff]\n      _ = (x \u2293 (y \u2293 x) \u2294 x \u2293 y \\ x) \u2293 x \\ y := by rw [inf_sup_left]\n      _ = (y \u2293 (x \u2293 x) \u2294 x \u2293 y \\ x) \u2293 x \\ y := by ac_rfl\n      _ = (y \u2293 x \u2294 x \u2293 y \\ x) \u2293 x \\ y := by rw [inf_idem]\n      _ = x \u2293 y \u2293 x \\ y \u2294 x \u2293 y \\ x \u2293 x \\ y := by rw [inf_sup_right, inf_comm x y]\n      _ = x \u2293 y \\ x \u2293 x \\ y := by rw [inf_inf_sdiff, bot_sup_eq]\n      _ = x \u2293 x \\ y \u2293 y \\ x := by ac_rfl\n      _ = x \\ y \u2293 y \\ x := by rw [inf_of_le_right sdiff_le']\n#align sdiff_inf_sdiff sdiff_inf_sdiff\n\ntheorem disjoint_sdiff_sdiff : Disjoint (x \\ y) (y \\ x) :=\n  disjoint_iff_inf_le.mpr sdiff_inf_sdiff.le\n#align disjoint_sdiff_sdiff disjoint_sdiff_sdiff\n\n@[simp]\ntheorem inf_sdiff_self_right : x \u2293 y \\ x = \u22a5 :=\n  calc\n    x \u2293 y \\ x = (x \u2293 y \u2294 x \\ y) \u2293 y \\ x := by rw [sup_inf_sdiff]\n    _ = x \u2293 y \u2293 y \\ x \u2294 x \\ y \u2293 y \\ x := by rw [inf_sup_right]\n    _ = \u22a5 := by rw [inf_comm x y, inf_inf_sdiff, sdiff_inf_sdiff, bot_sup_eq]\n#align inf_sdiff_self_right inf_sdiff_self_right\n\n@[simp]\n"}
{"name": "cgf_const'154", "split": "test", "formal_statement": "theorem cgf_const' [IsFiniteMeasure \u03bc] (h\u03bc : \u03bc \u2260 0) (c : \u211d) :\n    cgf (fun _ => c) \u03bc t = log (\u03bc Set.univ).toReal + t * c := by", "header": "\nimport Mathlib.Probability.Variance\n\n#align_import probability.moments from \"leanprover-community/mathlib\"@\"85453a2a14be8da64caf15ca50930cf4c6e5d8de\"\n\n\n\n\nopen MeasureTheory Filter Finset Real\n\nnoncomputable section\n\nopen scoped MeasureTheory ProbabilityTheory ENNReal NNReal\n\nnamespace ProbabilityTheory\n\nvariable {\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}\n\n\ndef moment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d :=\n  \u03bc[X ^ p]\n#align probability_theory.moment ProbabilityTheory.moment\n\n\ndef centralMoment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d := by\n  have m := fun (x : \u03a9) => \u03bc[X] -- Porting note: Lean deems `\u03bc[(X - fun x => \u03bc[X]) ^ p]` ambiguous\n  exact \u03bc[(X - m) ^ p]\n#align probability_theory.central_moment ProbabilityTheory.centralMoment\n\n@[simp]\ntheorem moment_zero (hp : p \u2260 0) : moment 0 p \u03bc = 0 := by\n  simp only [moment, hp, zero_pow, Ne, not_false_iff, Pi.zero_apply, integral_const,\n    smul_eq_mul, mul_zero, integral_zero]\n#align probability_theory.moment_zero ProbabilityTheory.moment_zero\n\n@[simp]\ntheorem centralMoment_zero (hp : p \u2260 0) : centralMoment 0 p \u03bc = 0 := by\n  simp only [centralMoment, hp, Pi.zero_apply, integral_const, smul_eq_mul,\n    mul_zero, zero_sub, Pi.pow_apply, Pi.neg_apply, neg_zero, zero_pow, Ne, not_false_iff]\n#align probability_theory.central_moment_zero ProbabilityTheory.centralMoment_zero\n\ntheorem centralMoment_one' [IsFiniteMeasure \u03bc] (h_int : Integrable X \u03bc) :\n    centralMoment X 1 \u03bc = (1 - (\u03bc Set.univ).toReal) * \u03bc[X] := by\n  simp only [centralMoment, Pi.sub_apply, pow_one]\n  rw [integral_sub h_int (integrable_const _)]\n  simp only [sub_mul, integral_const, smul_eq_mul, one_mul]\n#align probability_theory.central_moment_one' ProbabilityTheory.centralMoment_one'\n\n@[simp]\ntheorem centralMoment_one [IsProbabilityMeasure \u03bc] : centralMoment X 1 \u03bc = 0 := by\n  by_cases h_int : Integrable X \u03bc\n  \u00b7 rw [centralMoment_one' h_int]\n    simp only [measure_univ, ENNReal.one_toReal, sub_self, zero_mul]\n  \u00b7 simp only [centralMoment, Pi.sub_apply, pow_one]\n    have : \u00acIntegrable (fun x => X x - integral \u03bc X) \u03bc := by\n      refine fun h_sub => h_int ?_\n      have h_add : X = (fun x => X x - integral \u03bc X) + fun _ => integral \u03bc X := by ext1 x; simp\n      rw [h_add]\n      exact h_sub.add (integrable_const _)\n    rw [integral_undef this]\n#align probability_theory.central_moment_one ProbabilityTheory.centralMoment_one\n\ntheorem centralMoment_two_eq_variance [IsFiniteMeasure \u03bc] (hX : Mem\u2112p X 2 \u03bc) :\n    centralMoment X 2 \u03bc = variance X \u03bc := by rw [hX.variance_eq]; rfl\n#align probability_theory.central_moment_two_eq_variance ProbabilityTheory.centralMoment_two_eq_variance\n\nsection MomentGeneratingFunction\n\nvariable {t : \u211d}\n\n\ndef mgf (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) (t : \u211d) : \u211d :=\n  \u03bc[fun \u03c9 => exp (t * X \u03c9)]\n#align probability_theory.mgf ProbabilityTheory.mgf\n\n\ndef cgf (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) (t : \u211d) : \u211d :=\n  log (mgf X \u03bc t)\n#align probability_theory.cgf ProbabilityTheory.cgf\n\n@[simp]\ntheorem mgf_zero_fun : mgf 0 \u03bc t = (\u03bc Set.univ).toReal := by\n  simp only [mgf, Pi.zero_apply, mul_zero, exp_zero, integral_const, smul_eq_mul, mul_one]\n#align probability_theory.mgf_zero_fun ProbabilityTheory.mgf_zero_fun\n\n@[simp]\ntheorem cgf_zero_fun : cgf 0 \u03bc t = log (\u03bc Set.univ).toReal := by simp only [cgf, mgf_zero_fun]\n#align probability_theory.cgf_zero_fun ProbabilityTheory.cgf_zero_fun\n\n@[simp]\ntheorem mgf_zero_measure : mgf X (0 : Measure \u03a9) t = 0 := by simp only [mgf, integral_zero_measure]\n#align probability_theory.mgf_zero_measure ProbabilityTheory.mgf_zero_measure\n\n@[simp]\ntheorem cgf_zero_measure : cgf X (0 : Measure \u03a9) t = 0 := by\n  simp only [cgf, log_zero, mgf_zero_measure]\n#align probability_theory.cgf_zero_measure ProbabilityTheory.cgf_zero_measure\n\n@[simp]\ntheorem mgf_const' (c : \u211d) : mgf (fun _ => c) \u03bc t = (\u03bc Set.univ).toReal * exp (t * c) := by\n  simp only [mgf, integral_const, smul_eq_mul]\n#align probability_theory.mgf_const' ProbabilityTheory.mgf_const'\n\n-- @[simp] -- Porting note: `simp only` already proves this\ntheorem mgf_const (c : \u211d) [IsProbabilityMeasure \u03bc] : mgf (fun _ => c) \u03bc t = exp (t * c) := by\n  simp only [mgf_const', measure_univ, ENNReal.one_toReal, one_mul]\n#align probability_theory.mgf_const ProbabilityTheory.mgf_const\n\n@[simp]\n"}
{"name": "mem_uniformity'155", "split": "test", "formal_statement": "theorem mem_uniformity' {s : Set (CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1)} :\n    s \u2208 \ud835\udce4 (CauchyFilter \u03b1) \u2194 \u2203 t \u2208 \ud835\udce4 \u03b1, \u2200 f g : CauchyFilter \u03b1, t \u2208 f.1 \u00d7\u02e2 g.1 \u2192 (f, g) \u2208 s := by", "header": "\nimport Mathlib.Topology.UniformSpace.AbstractCompletion\n\n#align_import topology.uniform_space.completion from \"leanprover-community/mathlib\"@\"dc6c365e751e34d100e80fe6e314c3c3e0fd2988\"\n\n\n\n\nnoncomputable section\n\nopen Filter Set\n\nuniverse u v w x\n\nopen scoped Classical\nopen Uniformity Topology Filter\n\n\ndef CauchyFilter (\u03b1 : Type u) [UniformSpace \u03b1] : Type u :=\n  { f : Filter \u03b1 // Cauchy f }\nset_option linter.uppercaseLean3 false in\n#align Cauchy CauchyFilter\n\nnamespace CauchyFilter\n\nsection\n\nvariable {\u03b1 : Type u} [UniformSpace \u03b1]\nvariable {\u03b2 : Type v} {\u03b3 : Type w}\nvariable [UniformSpace \u03b2] [UniformSpace \u03b3]\n\ninstance (f : CauchyFilter \u03b1) : NeBot f.1 := f.2.1\n\n\ndef gen (s : Set (\u03b1 \u00d7 \u03b1)) : Set (CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1) :=\n  { p | s \u2208 p.1.val \u00d7\u02e2 p.2.val }\nset_option linter.uppercaseLean3 false in\n#align Cauchy.gen CauchyFilter.gen\n\ntheorem monotone_gen : Monotone (gen : Set (\u03b1 \u00d7 \u03b1) \u2192 _) :=\n  monotone_setOf fun p => @Filter.monotone_mem _ (p.1.val \u00d7\u02e2 p.2.val)\nset_option linter.uppercaseLean3 false in\n#align Cauchy.monotone_gen CauchyFilter.monotone_gen\n\n-- Porting note: this was a calc proof, but I could not make it work\nprivate theorem symm_gen : map Prod.swap ((\ud835\udce4 \u03b1).lift' gen) \u2264 (\ud835\udce4 \u03b1).lift' gen := by\n  let f := fun s : Set (\u03b1 \u00d7 \u03b1) =>\n        { p : CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1 | s \u2208 (p.2.val \u00d7\u02e2 p.1.val : Filter (\u03b1 \u00d7 \u03b1)) }\n  have h\u2081 : map Prod.swap ((\ud835\udce4 \u03b1).lift' gen) = (\ud835\udce4 \u03b1).lift' f := by\n    delta gen\n    simp [map_lift'_eq, monotone_setOf, Filter.monotone_mem, Function.comp,\n      image_swap_eq_preimage_swap]\n  have h\u2082 : (\ud835\udce4 \u03b1).lift' f \u2264 (\ud835\udce4 \u03b1).lift' gen :=\n    uniformity_lift_le_swap\n      (monotone_principal.comp\n        (monotone_setOf fun p => @Filter.monotone_mem _ (p.2.val \u00d7\u02e2 p.1.val)))\n      (by\n        have h := fun p : CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1 => @Filter.prod_comm _ _ p.2.val p.1.val\n        simp [f, Function.comp, h, mem_map']\n        exact le_rfl)\n  exact h\u2081.trans_le h\u2082\n\nprivate theorem compRel_gen_gen_subset_gen_compRel {s t : Set (\u03b1 \u00d7 \u03b1)} :\n    compRel (gen s) (gen t) \u2286 (gen (compRel s t) : Set (CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1)) :=\n  fun \u27e8f, g\u27e9 \u27e8h, h\u2081, h\u2082\u27e9 =>\n  let \u27e8t\u2081, (ht\u2081 : t\u2081 \u2208 f.val), t\u2082, (ht\u2082 : t\u2082 \u2208 h.val), (h\u2081 : t\u2081 \u00d7\u02e2 t\u2082 \u2286 s)\u27e9 := mem_prod_iff.mp h\u2081\n  let \u27e8t\u2083, (ht\u2083 : t\u2083 \u2208 h.val), t\u2084, (ht\u2084 : t\u2084 \u2208 g.val), (h\u2082 : t\u2083 \u00d7\u02e2 t\u2084 \u2286 t)\u27e9 := mem_prod_iff.mp h\u2082\n  have : t\u2082 \u2229 t\u2083 \u2208 h.val := inter_mem ht\u2082 ht\u2083\n  let \u27e8x, xt\u2082, xt\u2083\u27e9 := h.property.left.nonempty_of_mem this\n  (f.val \u00d7\u02e2 g.val).sets_of_superset (prod_mem_prod ht\u2081 ht\u2084)\n    fun \u27e8a, b\u27e9 \u27e8(ha : a \u2208 t\u2081), (hb : b \u2208 t\u2084)\u27e9 =>\n    \u27e8x, h\u2081 (show (a, x) \u2208 t\u2081 \u00d7\u02e2 t\u2082 from \u27e8ha, xt\u2082\u27e9), h\u2082 (show (x, b) \u2208 t\u2083 \u00d7\u02e2 t\u2084 from \u27e8xt\u2083, hb\u27e9)\u27e9\n\nprivate theorem comp_gen : (((\ud835\udce4 \u03b1).lift' gen).lift' fun s => compRel s s) \u2264 (\ud835\udce4 \u03b1).lift' gen :=\n  calc\n    (((\ud835\udce4 \u03b1).lift' gen).lift' fun s => compRel s s) =\n        (\ud835\udce4 \u03b1).lift' fun s => compRel (gen s) (gen s) := by\n      rw [lift'_lift'_assoc]\n      \u00b7 exact monotone_gen\n      \u00b7 exact monotone_id.compRel monotone_id\n    _ \u2264 (\ud835\udce4 \u03b1).lift' fun s => gen <| compRel s s :=\n      lift'_mono' fun s _hs => compRel_gen_gen_subset_gen_compRel\n    _ = ((\ud835\udce4 \u03b1).lift' fun s : Set (\u03b1 \u00d7 \u03b1) => compRel s s).lift' gen := by\n      rw [lift'_lift'_assoc]\n      \u00b7 exact monotone_id.compRel monotone_id\n      \u00b7 exact monotone_gen\n    _ \u2264 (\ud835\udce4 \u03b1).lift' gen := lift'_mono comp_le_uniformity le_rfl\n\ninstance : UniformSpace (CauchyFilter \u03b1) :=\n  UniformSpace.ofCore\n    { uniformity := (\ud835\udce4 \u03b1).lift' gen\n      refl := principal_le_lift'.2 fun _s hs \u27e8a, b\u27e9 =>\n        fun (a_eq_b : a = b) => a_eq_b \u25b8 a.property.right hs\n      symm := symm_gen\n      comp := comp_gen }\n\ntheorem mem_uniformity {s : Set (CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1)} :\n    s \u2208 \ud835\udce4 (CauchyFilter \u03b1) \u2194 \u2203 t \u2208 \ud835\udce4 \u03b1, gen t \u2286 s :=\n  mem_lift'_sets monotone_gen\nset_option linter.uppercaseLean3 false in\n#align Cauchy.mem_uniformity CauchyFilter.mem_uniformity\n\ntheorem basis_uniformity {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)} (h : (\ud835\udce4 \u03b1).HasBasis p s) :\n    (\ud835\udce4 (CauchyFilter \u03b1)).HasBasis p (gen \u2218 s) :=\n  h.lift' monotone_gen\n\n"}
{"name": "holderOnWith_singleton156", "split": "test", "formal_statement": "theorem holderOnWith_singleton (C r : \u211d\u22650) (f : X \u2192 Y) (x : X) : HolderOnWith C r f {x} := by", "header": "\nimport Mathlib.Topology.MetricSpace.Lipschitz\nimport Mathlib.Analysis.SpecialFunctions.Pow.Continuity\n\n#align_import topology.metric_space.holder from \"leanprover-community/mathlib\"@\"0b9eaaa7686280fad8cce467f5c3c57ee6ce77f8\"\n\n\n\n\nvariable {X Y Z : Type*}\n\nopen Filter Set\n\nopen NNReal ENNReal Topology\n\nsection Emetric\n\nvariable [PseudoEMetricSpace X] [PseudoEMetricSpace Y] [PseudoEMetricSpace Z]\n\n\ndef HolderWith (C r : \u211d\u22650) (f : X \u2192 Y) : Prop :=\n  \u2200 x y, edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * edist x y ^ (r : \u211d)\n#align holder_with HolderWith\n\n\ndef HolderOnWith (C r : \u211d\u22650) (f : X \u2192 Y) (s : Set X) : Prop :=\n  \u2200 x \u2208 s, \u2200 y \u2208 s, edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * edist x y ^ (r : \u211d)\n#align holder_on_with HolderOnWith\n\n@[simp]\ntheorem holderOnWith_empty (C r : \u211d\u22650) (f : X \u2192 Y) : HolderOnWith C r f \u2205 := fun _ hx => hx.elim\n#align holder_on_with_empty holderOnWith_empty\n\n@[simp]\n"}
{"name": "noncommFoldr_coe157", "split": "test", "formal_statement": "theorem noncommFoldr_coe (l : List \u03b1) (comm) (b : \u03b2) :\n    noncommFoldr f (l : Multiset \u03b1) comm b = l.foldr f b := by", "header": "\nimport Mathlib.Algebra.BigOperators.Group.Finset\nimport Mathlib.Algebra.Group.Commute.Hom\nimport Mathlib.Data.Fintype.Card\n\n#align_import data.finset.noncomm_prod from \"leanprover-community/mathlib\"@\"509de852e1de55e1efa8eacfa11df0823f26f226\"\n\n\n\nvariable {F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n\nnamespace Multiset\n\n\ndef noncommFoldr (s : Multiset \u03b1)\n    (comm : { x | x \u2208 s }.Pairwise fun x y => \u2200 b, f x (f y b) = f y (f x b)) (b : \u03b2) : \u03b2 :=\n  s.attach.foldr (f \u2218 Subtype.val)\n    (fun \u27e8_, hx\u27e9 \u27e8_, hy\u27e9 =>\n      haveI : IsRefl \u03b1 fun x y => \u2200 b, f x (f y b) = f y (f x b) := \u27e8fun _ _ => rfl\u27e9\n      comm.of_refl hx hy)\n    b\n#align multiset.noncomm_foldr Multiset.noncommFoldr\n\n@[simp]\n"}
{"name": "min_cases158", "split": "test", "formal_statement": "theorem min_cases (a b : \u03b1) : min a b = a \u2227 a \u2264 b \u2228 min a b = b \u2227 b < a := by", "header": "\nimport Mathlib.Order.Lattice\n\n#align_import order.min_max from \"leanprover-community/mathlib\"@\"70d50ecfd4900dd6d328da39ab7ebd516abe4025\"\n\n\n\n\nuniverse u v\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v}\n\nattribute [simp] max_eq_left max_eq_right min_eq_left min_eq_right\n\nsection\n\nvariable [LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a b c d : \u03b1}\n\n-- translate from lattices to linear orders (sup \u2192 max, inf \u2192 min)\n@[simp]\ntheorem le_min_iff : c \u2264 min a b \u2194 c \u2264 a \u2227 c \u2264 b :=\n  le_inf_iff\n#align le_min_iff le_min_iff\n\n@[simp]\ntheorem le_max_iff : a \u2264 max b c \u2194 a \u2264 b \u2228 a \u2264 c :=\n  le_sup_iff\n#align le_max_iff le_max_iff\n\n@[simp]\ntheorem min_le_iff : min a b \u2264 c \u2194 a \u2264 c \u2228 b \u2264 c :=\n  inf_le_iff\n#align min_le_iff min_le_iff\n\n@[simp]\ntheorem max_le_iff : max a b \u2264 c \u2194 a \u2264 c \u2227 b \u2264 c :=\n  sup_le_iff\n#align max_le_iff max_le_iff\n\n@[simp]\ntheorem lt_min_iff : a < min b c \u2194 a < b \u2227 a < c :=\n  lt_inf_iff\n#align lt_min_iff lt_min_iff\n\n@[simp]\ntheorem lt_max_iff : a < max b c \u2194 a < b \u2228 a < c :=\n  lt_sup_iff\n#align lt_max_iff lt_max_iff\n\n@[simp]\ntheorem min_lt_iff : min a b < c \u2194 a < c \u2228 b < c :=\n  inf_lt_iff\n#align min_lt_iff min_lt_iff\n\n@[simp]\ntheorem max_lt_iff : max a b < c \u2194 a < c \u2227 b < c :=\n  sup_lt_iff\n#align max_lt_iff max_lt_iff\n\n@[gcongr]\ntheorem max_le_max : a \u2264 c \u2192 b \u2264 d \u2192 max a b \u2264 max c d :=\n  sup_le_sup\n#align max_le_max max_le_max\n\n@[gcongr] theorem max_le_max_left (c) (h : a \u2264 b) : max c a \u2264 max c b := sup_le_sup_left h c\n\n@[gcongr] theorem max_le_max_right (c) (h : a \u2264 b) : max a c \u2264 max b c := sup_le_sup_right h c\n\n@[gcongr]\ntheorem min_le_min : a \u2264 c \u2192 b \u2264 d \u2192 min a b \u2264 min c d :=\n  inf_le_inf\n#align min_le_min min_le_min\n\n@[gcongr] theorem min_le_min_left (c) (h : a \u2264 b) : min c a \u2264 min c b := inf_le_inf_left c h\n\n@[gcongr] theorem min_le_min_right (c) (h : a \u2264 b) : min a c \u2264 min b c := inf_le_inf_right c h\n\ntheorem le_max_of_le_left : a \u2264 b \u2192 a \u2264 max b c :=\n  le_sup_of_le_left\n#align le_max_of_le_left le_max_of_le_left\n\ntheorem le_max_of_le_right : a \u2264 c \u2192 a \u2264 max b c :=\n  le_sup_of_le_right\n#align le_max_of_le_right le_max_of_le_right\n\ntheorem lt_max_of_lt_left (h : a < b) : a < max b c :=\n  h.trans_le (le_max_left b c)\n#align lt_max_of_lt_left lt_max_of_lt_left\n\ntheorem lt_max_of_lt_right (h : a < c) : a < max b c :=\n  h.trans_le (le_max_right b c)\n#align lt_max_of_lt_right lt_max_of_lt_right\n\ntheorem min_le_of_left_le : a \u2264 c \u2192 min a b \u2264 c :=\n  inf_le_of_left_le\n#align min_le_of_left_le min_le_of_left_le\n\ntheorem min_le_of_right_le : b \u2264 c \u2192 min a b \u2264 c :=\n  inf_le_of_right_le\n#align min_le_of_right_le min_le_of_right_le\n\ntheorem min_lt_of_left_lt (h : a < c) : min a b < c :=\n  (min_le_left a b).trans_lt h\n#align min_lt_of_left_lt min_lt_of_left_lt\n\ntheorem min_lt_of_right_lt (h : b < c) : min a b < c :=\n  (min_le_right a b).trans_lt h\n#align min_lt_of_right_lt min_lt_of_right_lt\n\nlemma max_min_distrib_left (a b c : \u03b1) : max a (min b c) = min (max a b) (max a c) :=\n  sup_inf_left _ _ _\n#align max_min_distrib_left max_min_distrib_left\n\nlemma max_min_distrib_right (a b c : \u03b1) : max (min a b) c = min (max a c) (max b c) :=\n  sup_inf_right _ _ _\n#align max_min_distrib_right max_min_distrib_right\n\nlemma min_max_distrib_left (a b c : \u03b1) : min a (max b c) = max (min a b) (min a c) :=\n  inf_sup_left _ _ _\n#align min_max_distrib_left min_max_distrib_left\n\nlemma min_max_distrib_right (a b c : \u03b1) : min (max a b) c = max (min a c) (min b c) :=\n  inf_sup_right _ _ _\n#align min_max_distrib_right min_max_distrib_right\n\ntheorem min_le_max : min a b \u2264 max a b :=\n  le_trans (min_le_left a b) (le_max_left a b)\n#align min_le_max min_le_max\n\n@[simp]\ntheorem min_eq_left_iff : min a b = a \u2194 a \u2264 b :=\n  inf_eq_left\n#align min_eq_left_iff min_eq_left_iff\n\n@[simp]\ntheorem min_eq_right_iff : min a b = b \u2194 b \u2264 a :=\n  inf_eq_right\n#align min_eq_right_iff min_eq_right_iff\n\n@[simp]\ntheorem max_eq_left_iff : max a b = a \u2194 b \u2264 a :=\n  sup_eq_left\n#align max_eq_left_iff max_eq_left_iff\n\n@[simp]\ntheorem max_eq_right_iff : max a b = b \u2194 a \u2264 b :=\n  sup_eq_right\n#align max_eq_right_iff max_eq_right_iff\n\n\n"}
{"name": "map_id159", "split": "test", "formal_statement": "theorem map_id (P : PresheafOfModules R) (X : C\u1d52\u1d56) :\n    P.map (\ud835\udfd9 X) = LinearMap.id' := by", "header": "\nimport Mathlib.Algebra.Category.ModuleCat.ChangeOfRings\nimport Mathlib.Algebra.Category.Ring.Basic\n\n\n\nuniverse v v\u2081 u\u2081 u\n\nopen CategoryTheory LinearMap Opposite\n\nvariable {C : Type u\u2081} [Category.{v\u2081} C]\n\n\nstructure PresheafOfModules (R : C\u1d52\u1d56 \u2964 RingCat.{u}) where\n  presheaf : C\u1d52\u1d56 \u2964 AddCommGroupCat.{v}\n  module : \u2200 X : C\u1d52\u1d56, Module (R.obj X) (presheaf.obj X) := by infer_instance\n  map_smul : \u2200 {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) (r : R.obj X) (x : presheaf.obj X),\n    presheaf.map f (r \u2022 x) = R.map f r \u2022 presheaf.map f x := by aesop_cat\n\nvariable {R : C\u1d52\u1d56 \u2964 RingCat.{u}}\n\nnamespace PresheafOfModules\n\nattribute [instance] PresheafOfModules.module\n\n\ndef obj (P : PresheafOfModules R) (X : C\u1d52\u1d56) : ModuleCat (R.obj X) :=\n  ModuleCat.of _ (P.presheaf.obj X)\n\n\ndef map (P : PresheafOfModules R) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) :\n    P.obj X \u2192\u209b\u2097[R.map f] P.obj Y :=\n  { toAddHom := (P.presheaf.map f).toAddHom,\n    map_smul' := P.map_smul f, }\n\ntheorem map_apply (P : PresheafOfModules R) {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) (x) :\n    P.map f x = (P.presheaf.map f) x :=\n  rfl\n\ninstance (X : C\u1d52\u1d56) : RingHomId (R.map (\ud835\udfd9 X)) where\n  eq_id := R.map_id X\n\ninstance {X Y Z : C\u1d52\u1d56} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    RingHomCompTriple (R.map f) (R.map g) (R.map (f \u226b g)) where\n  comp_eq := (R.map_comp f g).symm\n\n@[simp]\n"}
{"name": "comp_orderIso160", "split": "test", "formal_statement": "theorem comp_orderIso [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : IsOrderRightAdjoint f g) (e : \u03b3 \u2243o \u03b1) : IsOrderRightAdjoint (f \u2218 e) (e.symm \u2218 g) := by", "header": "\nimport Mathlib.Algebra.Group.Units.Equiv\nimport Mathlib.Logic.Function.Conjugate\nimport Mathlib.Order.Bounds.OrderIso\nimport Mathlib.Order.ConditionallyCompleteLattice.Basic\nimport Mathlib.Order.OrdContinuous\nimport Mathlib.Order.RelIso.Group\n\n#align_import order.semiconj_Sup from \"leanprover-community/mathlib\"@\"422e70f7ce183d2900c586a8cda8381e788a0c62\"\n\n\n\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*}\n\nopen Set\n\n\ndef IsOrderRightAdjoint [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :=\n  \u2200 y, IsLUB { x | f x \u2264 y } (g y)\n#align is_order_right_adjoint IsOrderRightAdjoint\n\ntheorem isOrderRightAdjoint_sSup [CompleteLattice \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    IsOrderRightAdjoint f fun y => sSup { x | f x \u2264 y } := fun _ => isLUB_sSup _\n#align is_order_right_adjoint_Sup isOrderRightAdjoint_sSup\n\ntheorem isOrderRightAdjoint_csSup [ConditionallyCompleteLattice \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hne : \u2200 y, \u2203 x, f x \u2264 y) (hbdd : \u2200 y, BddAbove { x | f x \u2264 y }) :\n    IsOrderRightAdjoint f fun y => sSup { x | f x \u2264 y } := fun y => isLUB_csSup (hne y) (hbdd y)\n#align is_order_right_adjoint_cSup isOrderRightAdjoint_csSup\n\nnamespace IsOrderRightAdjoint\n\nprotected theorem unique [PartialOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {g\u2081 g\u2082 : \u03b2 \u2192 \u03b1}\n    (h\u2081 : IsOrderRightAdjoint f g\u2081) (h\u2082 : IsOrderRightAdjoint f g\u2082) : g\u2081 = g\u2082 :=\n  funext fun y => (h\u2081 y).unique (h\u2082 y)\n#align is_order_right_adjoint.unique IsOrderRightAdjoint.unique\n\ntheorem right_mono [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : IsOrderRightAdjoint f g) :\n    Monotone g := fun y\u2081 y\u2082 hy => ((h y\u2081).mono (h y\u2082)) fun _ hx => le_trans hx hy\n#align is_order_right_adjoint.right_mono IsOrderRightAdjoint.right_mono\n\ntheorem orderIso_comp [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : IsOrderRightAdjoint f g) (e : \u03b2 \u2243o \u03b3) : IsOrderRightAdjoint (e \u2218 f) (g \u2218 e.symm) :=\n  fun y => by simpa [e.le_symm_apply] using h (e.symm y)\n#align is_order_right_adjoint.order_iso_comp IsOrderRightAdjoint.orderIso_comp\n\n"}
{"name": "tendsto_measure_cthickening161", "split": "test", "formal_statement": "theorem tendsto_measure_cthickening {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc (closure s))) := by", "header": "\nimport Mathlib.Topology.MetricSpace.Thickening\nimport Mathlib.MeasureTheory.Constructions.BorelSpace.Real\n\n#align_import measure_theory.constructions.borel_space.basic from \"leanprover-community/mathlib\"@\"9f55d0d4363ae59948c33864cbc52e0b12e0e8ce\"\n\n\n\nopen Set Filter MeasureTheory MeasurableSpace TopologicalSpace\n\nopen scoped Classical Topology NNReal ENNReal MeasureTheory\n\nuniverse u v w x y\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}\n\nsection PseudoEMetricSpace\n\nvariable [PseudoEMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]\nvariable [MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d\u22650\u221e}\n\nopen EMetric\n\n@[measurability]\ntheorem measurableSet_eball : MeasurableSet (EMetric.ball x \u03b5) :=\n  EMetric.isOpen_ball.measurableSet\n#align measurable_set_eball measurableSet_eball\n\n@[measurability]\ntheorem measurable_edist_right : Measurable (edist x) :=\n  (continuous_const.edist continuous_id).measurable\n#align measurable_edist_right measurable_edist_right\n\n@[measurability]\ntheorem measurable_edist_left : Measurable fun y => edist y x :=\n  (continuous_id.edist continuous_const).measurable\n#align measurable_edist_left measurable_edist_left\n\n@[measurability]\ntheorem measurable_infEdist {s : Set \u03b1} : Measurable fun x => infEdist x s :=\n  continuous_infEdist.measurable\n#align measurable_inf_edist measurable_infEdist\n\n@[measurability]\ntheorem Measurable.infEdist {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} :\n    Measurable fun x => infEdist (f x) s :=\n  measurable_infEdist.comp hf\n#align measurable.inf_edist Measurable.infEdist\n\nopen Metric EMetric\n\n\n"}
{"name": "not_supIrred162", "split": "test", "formal_statement": "theorem not_supIrred : \u00acSupIrred a \u2194 IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b < a \u2227 c < a := by", "header": "\nimport Mathlib.Data.Finset.Lattice\n\n#align_import order.irreducible from \"leanprover-community/mathlib\"@\"bf2428c9486c407ca38b5b3fb10b87dad0bc99fa\"\n\n\n\n\nopen Finset OrderDual\n\nvariable {\u03b9 \u03b1 : Type*}\n\n\n\n\nsection SemilatticeSup\n\nvariable [SemilatticeSup \u03b1] {a b c : \u03b1}\n\n\ndef SupIrred (a : \u03b1) : Prop :=\n  \u00acIsMin a \u2227 \u2200 \u2983b c\u2984, b \u2294 c = a \u2192 b = a \u2228 c = a\n#align sup_irred SupIrred\n\n\ndef SupPrime (a : \u03b1) : Prop :=\n  \u00acIsMin a \u2227 \u2200 \u2983b c\u2984, a \u2264 b \u2294 c \u2192 a \u2264 b \u2228 a \u2264 c\n#align sup_prime SupPrime\n\ntheorem SupIrred.not_isMin (ha : SupIrred a) : \u00acIsMin a :=\n  ha.1\n#align sup_irred.not_is_min SupIrred.not_isMin\n\ntheorem SupPrime.not_isMin (ha : SupPrime a) : \u00acIsMin a :=\n  ha.1\n#align sup_prime.not_is_min SupPrime.not_isMin\n\ntheorem IsMin.not_supIrred (ha : IsMin a) : \u00acSupIrred a := fun h => h.1 ha\n#align is_min.not_sup_irred IsMin.not_supIrred\n\ntheorem IsMin.not_supPrime (ha : IsMin a) : \u00acSupPrime a := fun h => h.1 ha\n#align is_min.not_sup_prime IsMin.not_supPrime\n\n@[simp]\n"}
{"name": "get_replicate163", "split": "test", "formal_statement": "theorem get_replicate (a : \u03b1) (i : Fin n) : (Vector.replicate n a).get i = a := by", "header": "\nimport Mathlib.Algebra.BigOperators.Group.List\nimport Mathlib.Data.Vector.Defs\nimport Mathlib.Data.List.Nodup\nimport Mathlib.Data.List.OfFn\nimport Mathlib.Data.List.InsertNth\nimport Mathlib.Control.Applicative\nimport Mathlib.Control.Traversable.Basic\n\n#align_import data.vector.basic from \"leanprover-community/mathlib\"@\"f694c7dead66f5d4c80f446c796a5aad14707f0e\"\n\n\n\nset_option autoImplicit true\n\n\nuniverse u\n\nvariable {n : \u2115}\n\nnamespace Vector\n\nvariable {\u03b1 : Type*}\n\n@[inherit_doc]\ninfixr:67 \" ::\u1d65 \" => Vector.cons\n\nattribute [simp] head_cons tail_cons\n\ninstance [Inhabited \u03b1] : Inhabited (Vector \u03b1 n) :=\n  \u27e8ofFn default\u27e9\n\ntheorem toList_injective : Function.Injective (@toList \u03b1 n) :=\n  Subtype.val_injective\n#align vector.to_list_injective Vector.toList_injective\n\n\n@[ext]\ntheorem ext : \u2200 {v w : Vector \u03b1 n} (_ : \u2200 m : Fin n, Vector.get v m = Vector.get w m), v = w\n  | \u27e8v, hv\u27e9, \u27e8w, hw\u27e9, h =>\n    Subtype.eq (List.ext_get (by rw [hv, hw]) fun m hm _ => h \u27e8m, hv \u25b8 hm\u27e9)\n#align vector.ext Vector.ext\n\n\ninstance zero_subsingleton : Subsingleton (Vector \u03b1 0) :=\n  \u27e8fun _ _ => Vector.ext fun m => Fin.elim0 m\u27e9\n#align vector.zero_subsingleton Vector.zero_subsingleton\n\n@[simp]\ntheorem cons_val (a : \u03b1) : \u2200 v : Vector \u03b1 n, (a ::\u1d65 v).val = a :: v.val\n  | \u27e8_, _\u27e9 => rfl\n#align vector.cons_val Vector.cons_val\n\n#align vector.cons_head Vector.head_cons\n#align vector.cons_tail Vector.tail_cons\n\ntheorem eq_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v = a ::\u1d65 v' \u2194 v.head = a \u2227 v.tail = v' :=\n  \u27e8fun h => h.symm \u25b8 \u27e8head_cons a v', tail_cons a v'\u27e9, fun h =>\n    _root_.trans (cons_head_tail v).symm (by rw [h.1, h.2])\u27e9\n#align vector.eq_cons_iff Vector.eq_cons_iff\n\ntheorem ne_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v \u2260 a ::\u1d65 v' \u2194 v.head \u2260 a \u2228 v.tail \u2260 v' := by rw [Ne, eq_cons_iff a v v', not_and_or]\n#align vector.ne_cons_iff Vector.ne_cons_iff\n\ntheorem exists_eq_cons (v : Vector \u03b1 n.succ) : \u2203 (a : \u03b1) (as : Vector \u03b1 n), v = a ::\u1d65 as :=\n  \u27e8v.head, v.tail, (eq_cons_iff v.head v v.tail).2 \u27e8rfl, rfl\u27e9\u27e9\n#align vector.exists_eq_cons Vector.exists_eq_cons\n\n@[simp]\ntheorem toList_ofFn : \u2200 {n} (f : Fin n \u2192 \u03b1), toList (ofFn f) = List.ofFn f\n  | 0, f => by rw [ofFn, List.ofFn_zero, toList, nil]\n  | n + 1, f => by rw [ofFn, List.ofFn_succ, toList_cons, toList_ofFn]\n#align vector.to_list_of_fn Vector.toList_ofFn\n\n@[simp]\ntheorem mk_toList : \u2200 (v : Vector \u03b1 n) (h), (\u27e8toList v, h\u27e9 : Vector \u03b1 n) = v\n  | \u27e8_, _\u27e9, _ => rfl\n#align vector.mk_to_list Vector.mk_toList\n\n\n@[simp] theorem length_val (v : Vector \u03b1 n) : v.val.length = n := v.2\n\n-- Porting note: not used in mathlib and coercions done differently in Lean 4\n-- @[simp]\n-- theorem length_coe (v : Vector \u03b1 n) :\n--     ((coe : { l : List \u03b1 // l.length = n } \u2192 List \u03b1) v).length = n :=\n--   v.2\n#noalign vector.length_coe\n\n@[simp]\ntheorem toList_map {\u03b2 : Type*} (v : Vector \u03b1 n) (f : \u03b1 \u2192 \u03b2) :\n    (v.map f).toList = v.toList.map f := by cases v; rfl\n#align vector.to_list_map Vector.toList_map\n\n@[simp]\ntheorem head_map {\u03b2 : Type*} (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) : (v.map f).head = f v.head := by\n  obtain \u27e8a, v', h\u27e9 := Vector.exists_eq_cons v\n  rw [h, map_cons, head_cons, head_cons]\n#align vector.head_map Vector.head_map\n\n@[simp]\ntheorem tail_map {\u03b2 : Type*} (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) :\n    (v.map f).tail = v.tail.map f := by\n  obtain \u27e8a, v', h\u27e9 := Vector.exists_eq_cons v\n  rw [h, map_cons, tail_cons, tail_cons]\n#align vector.tail_map Vector.tail_map\n\ntheorem get_eq_get (v : Vector \u03b1 n) (i : Fin n) :\n    v.get i = v.toList.get (Fin.cast v.toList_length.symm i) :=\n  rfl\n#align vector.nth_eq_nth_le Vector.get_eq_get\u2093\n\n@[simp]\n"}
{"name": "invOf_add_invOf164", "split": "test", "formal_statement": "theorem invOf_add_invOf [Semiring \u03b1] (a b : \u03b1) [Invertible a] [Invertible b] :\n    \u215fa + \u215fb = \u215fa * (a + b) * \u215fb:= by", "header": "\nimport Mathlib.Algebra.GroupWithZero.Invertible\nimport Mathlib.Algebra.Ring.Defs\n\n#align_import algebra.invertible from \"leanprover-community/mathlib\"@\"722b3b152ddd5e0cf21c0a29787c76596cb6b422\"\n\n\nuniverse u\n\nvariable {\u03b1 : Type u}\n\n\ndef invertibleNeg [Mul \u03b1] [One \u03b1] [HasDistribNeg \u03b1] (a : \u03b1) [Invertible a] : Invertible (-a) :=\n  \u27e8-\u215f a, by simp, by simp\u27e9\n#align invertible_neg invertibleNeg\n\n@[simp]\ntheorem invOf_neg [Monoid \u03b1] [HasDistribNeg \u03b1] (a : \u03b1) [Invertible a] [Invertible (-a)] :\n    \u215f (-a) = -\u215f a :=\n  invOf_eq_right_inv (by simp)\n#align inv_of_neg invOf_neg\n\n@[simp]\ntheorem one_sub_invOf_two [Ring \u03b1] [Invertible (2 : \u03b1)] : 1 - (\u215f 2 : \u03b1) = \u215f 2 :=\n  (isUnit_of_invertible (2 : \u03b1)).mul_right_inj.1 <| by\n    rw [mul_sub, mul_invOf_self, mul_one, \u2190 one_add_one_eq_two, add_sub_cancel_right]\n#align one_sub_inv_of_two one_sub_invOf_two\n\n@[simp]\ntheorem invOf_two_add_invOf_two [NonAssocSemiring \u03b1] [Invertible (2 : \u03b1)] :\n    (\u215f 2 : \u03b1) + (\u215f 2 : \u03b1) = 1 := by rw [\u2190 two_mul, mul_invOf_self]\n#align inv_of_two_add_inv_of_two invOf_two_add_invOf_two\n\ntheorem pos_of_invertible_cast [Semiring \u03b1] [Nontrivial \u03b1] (n : \u2115) [Invertible (n : \u03b1)] : 0 < n :=\n  Nat.zero_lt_of_ne_zero fun h => nonzero_of_invertible (n : \u03b1) (h \u25b8 Nat.cast_zero)\n\n"}
{"name": "algebraMap_star_comm165", "split": "test", "formal_statement": "theorem algebraMap_star_comm (r : R) : algebraMap R A (star r) = star (algebraMap R A r) := by", "header": "\nimport Mathlib.Algebra.Star.SelfAdjoint\nimport Mathlib.Algebra.Module.Equiv\nimport Mathlib.LinearAlgebra.Prod\n\n#align_import algebra.star.module from \"leanprover-community/mathlib\"@\"aa6669832974f87406a3d9d70fc5707a60546207\"\n\n\n\n\n\n@[simps]\ndef starLinearEquiv (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] : A \u2243\u2097\u22c6[R] A :=\n  { starAddEquiv with\n    toFun := star\n    map_smul' := star_smul }\n#align star_linear_equiv starLinearEquiv\n\nsection algebraMap\n\nvariable {R A : Type*} [CommSemiring R] [StarRing R] [Semiring A]\nvariable [StarMul A] [Algebra R A] [StarModule R A]\n\n@[simp]\n"}
{"name": "factors_eq_nil166", "split": "test", "formal_statement": "theorem factors_eq_nil (n : \u2115) : n.factors = [] \u2194 n = 0 \u2228 n = 1 := by", "header": "\nimport Mathlib.Algebra.BigOperators.Ring.List\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.List.Prime\nimport Mathlib.Data.List.Sort\nimport Mathlib.Data.List.Chain\n\n#align_import data.nat.factors from \"leanprover-community/mathlib\"@\"008205aa645b3f194c1da47025c5f110c8406eab\"\n\n\n\nopen Bool Subtype\n\nopen Nat\n\nnamespace Nat\n\nattribute [instance 0] instBEqNat\n\n\ndef factors : \u2115 \u2192 List \u2115\n  | 0 => []\n  | 1 => []\n  | k + 2 =>\n    let m := minFac (k + 2)\n    m :: factors ((k + 2) / m)\ndecreasing_by show (k + 2) / m < (k + 2); exact factors_lemma\n#align nat.factors Nat.factors\n\n@[simp]\ntheorem factors_zero : factors 0 = [] := by rw [factors]\n#align nat.factors_zero Nat.factors_zero\n\n@[simp]\ntheorem factors_one : factors 1 = [] := by rw [factors]\n#align nat.factors_one Nat.factors_one\n\n@[simp]\ntheorem factors_two : factors 2 = [2] := by simp [factors]\n\ntheorem prime_of_mem_factors {n : \u2115} : \u2200 {p : \u2115}, (h : p \u2208 factors n) \u2192 Prime p := by\n  match n with\n  | 0 => simp\n  | 1 => simp\n  | k + 2 =>\n      intro p h\n      let m := minFac (k + 2)\n      have : (k + 2) / m < (k + 2) := factors_lemma\n      have h\u2081 : p = m \u2228 p \u2208 factors ((k + 2) / m) :=\n        List.mem_cons.1 (by rwa [factors] at h)\n      exact Or.casesOn h\u2081 (fun h\u2082 => h\u2082.symm \u25b8 minFac_prime (by simp)) prime_of_mem_factors\n#align nat.prime_of_mem_factors Nat.prime_of_mem_factors\n\ntheorem pos_of_mem_factors {n p : \u2115} (h : p \u2208 factors n) : 0 < p :=\n  Prime.pos (prime_of_mem_factors h)\n#align nat.pos_of_mem_factors Nat.pos_of_mem_factors\n\ntheorem prod_factors : \u2200 {n}, n \u2260 0 \u2192 List.prod (factors n) = n\n  | 0 => by simp\n  | 1 => by simp\n  | k + 2 => fun _ =>\n    let m := minFac (k + 2)\n    have : (k + 2) / m < (k + 2) := factors_lemma\n    show (factors (k + 2)).prod = (k + 2) by\n      have h\u2081 : (k + 2) / m \u2260 0 := fun h => by\n        have : (k + 2) = 0 * m := (Nat.div_eq_iff_eq_mul_left (minFac_pos _) (minFac_dvd _)).1 h\n        rw [zero_mul] at this; exact (show k + 2 \u2260 0 by simp) this\n      rw [factors, List.prod_cons, prod_factors h\u2081, Nat.mul_div_cancel' (minFac_dvd _)]\n#align nat.prod_factors Nat.prod_factors\n\ntheorem factors_prime {p : \u2115} (hp : Nat.Prime p) : p.factors = [p] := by\n  have : p = p - 2 + 2 := (tsub_eq_iff_eq_add_of_le hp.two_le).mp rfl\n  rw [this, Nat.factors]\n  simp only [Eq.symm this]\n  have : Nat.minFac p = p := (Nat.prime_def_minFac.mp hp).2\n  simp only [this, Nat.factors, Nat.div_self (Nat.Prime.pos hp)]\n#align nat.factors_prime Nat.factors_prime\n\ntheorem factors_chain {n : \u2115} :\n    \u2200 {a}, (\u2200 p, Prime p \u2192 p \u2223 n \u2192 a \u2264 p) \u2192 List.Chain (\u00b7 \u2264 \u00b7) a (factors n) := by\n  match n with\n  | 0 => simp\n  | 1 => simp\n  | k + 2 =>\n      intro a h\n      let m := minFac (k + 2)\n      have : (k + 2) / m < (k + 2) := factors_lemma\n      rw [factors]\n      refine List.Chain.cons ((le_minFac.2 h).resolve_left (by simp)) (factors_chain ?_)\n      exact fun p pp d => minFac_le_of_dvd pp.two_le (d.trans <| div_dvd_of_dvd <| minFac_dvd _)\n#align nat.factors_chain Nat.factors_chain\n\ntheorem factors_chain_2 (n) : List.Chain (\u00b7 \u2264 \u00b7) 2 (factors n) :=\n  factors_chain fun _ pp _ => pp.two_le\n#align nat.factors_chain_2 Nat.factors_chain_2\n\ntheorem factors_chain' (n) : List.Chain' (\u00b7 \u2264 \u00b7) (factors n) :=\n  @List.Chain'.tail _ _ (_ :: _) (factors_chain_2 _)\n#align nat.factors_chain' Nat.factors_chain'\n\ntheorem factors_sorted (n : \u2115) : List.Sorted (\u00b7 \u2264 \u00b7) (factors n) :=\n  List.chain'_iff_pairwise.1 (factors_chain' _)\n#align nat.factors_sorted Nat.factors_sorted\n\n\ntheorem factors_add_two (n : \u2115) :\n    factors (n + 2) = minFac (n + 2) :: factors ((n + 2) / minFac (n + 2)) := by rw [factors]\n#align nat.factors_add_two Nat.factors_add_two\n\n@[simp]\n"}
{"name": "noncommFold_eq_fold167", "split": "test", "formal_statement": "theorem noncommFold_eq_fold (s : Multiset \u03b1) [Std.Commutative op] (a : \u03b1) :\n    noncommFold op s (fun x _ y _ _ => Std.Commutative.comm x y) a = fold op a s := by", "header": "\nimport Mathlib.Algebra.BigOperators.Group.Finset\nimport Mathlib.Algebra.Group.Commute.Hom\nimport Mathlib.Data.Fintype.Card\n\n#align_import data.finset.noncomm_prod from \"leanprover-community/mathlib\"@\"509de852e1de55e1efa8eacfa11df0823f26f226\"\n\n\n\nvariable {F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n\nnamespace Multiset\n\n\ndef noncommFoldr (s : Multiset \u03b1)\n    (comm : { x | x \u2208 s }.Pairwise fun x y => \u2200 b, f x (f y b) = f y (f x b)) (b : \u03b2) : \u03b2 :=\n  s.attach.foldr (f \u2218 Subtype.val)\n    (fun \u27e8_, hx\u27e9 \u27e8_, hy\u27e9 =>\n      haveI : IsRefl \u03b1 fun x y => \u2200 b, f x (f y b) = f y (f x b) := \u27e8fun _ _ => rfl\u27e9\n      comm.of_refl hx hy)\n    b\n#align multiset.noncomm_foldr Multiset.noncommFoldr\n\n@[simp]\ntheorem noncommFoldr_coe (l : List \u03b1) (comm) (b : \u03b2) :\n    noncommFoldr f (l : Multiset \u03b1) comm b = l.foldr f b := by\n  simp only [noncommFoldr, coe_foldr, coe_attach, List.attach, List.attachWith, Function.comp]\n  rw [\u2190 List.foldr_map]\n  simp [List.map_pmap]\n#align multiset.noncomm_foldr_coe Multiset.noncommFoldr_coe\n\n@[simp]\ntheorem noncommFoldr_empty (h) (b : \u03b2) : noncommFoldr f (0 : Multiset \u03b1) h b = b :=\n  rfl\n#align multiset.noncomm_foldr_empty Multiset.noncommFoldr_empty\n\ntheorem noncommFoldr_cons (s : Multiset \u03b1) (a : \u03b1) (h h') (b : \u03b2) :\n    noncommFoldr f (a ::\u2098 s) h b = f a (noncommFoldr f s h' b) := by\n  induction s using Quotient.inductionOn\n  simp\n#align multiset.noncomm_foldr_cons Multiset.noncommFoldr_cons\n\ntheorem noncommFoldr_eq_foldr (s : Multiset \u03b1) (h : LeftCommutative f) (b : \u03b2) :\n    noncommFoldr f s (fun x _ y _ _ => h x y) b = foldr f h b s := by\n  induction s using Quotient.inductionOn\n  simp\n#align multiset.noncomm_foldr_eq_foldr Multiset.noncommFoldr_eq_foldr\n\nsection assoc\n\nvariable [assoc : Std.Associative op]\n\n\ndef noncommFold (s : Multiset \u03b1) (comm : { x | x \u2208 s }.Pairwise fun x y => op x y = op y x) :\n    \u03b1 \u2192 \u03b1 :=\n  noncommFoldr op s fun x hx y hy h b => by rw [\u2190 assoc.assoc, comm hx hy h, assoc.assoc]\n#align multiset.noncomm_fold Multiset.noncommFold\n\n@[simp]\ntheorem noncommFold_coe (l : List \u03b1) (comm) (a : \u03b1) :\n    noncommFold op (l : Multiset \u03b1) comm a = l.foldr op a := by simp [noncommFold]\n#align multiset.noncomm_fold_coe Multiset.noncommFold_coe\n\n@[simp]\ntheorem noncommFold_empty (h) (a : \u03b1) : noncommFold op (0 : Multiset \u03b1) h a = a :=\n  rfl\n#align multiset.noncomm_fold_empty Multiset.noncommFold_empty\n\ntheorem noncommFold_cons (s : Multiset \u03b1) (a : \u03b1) (h h') (x : \u03b1) :\n    noncommFold op (a ::\u2098 s) h x = op a (noncommFold op s h' x) := by\n  induction s using Quotient.inductionOn\n  simp\n#align multiset.noncomm_fold_cons Multiset.noncommFold_cons\n\n"}
{"name": "mulIndicator_eq_self_of_superset168", "split": "test", "formal_statement": "theorem mulIndicator_eq_self_of_superset (h1 : s.mulIndicator f = f) (h2 : s \u2286 t) :\n    t.mulIndicator f = f := by", "header": "\nimport Mathlib.Algebra.Group.Pi.Lemmas\nimport Mathlib.Algebra.Group.Support\n\n#align_import algebra.indicator_function from \"leanprover-community/mathlib\"@\"2445c98ae4b87eabebdde552593519b9b6dc350c\"\n\n\n\nassert_not_exists MonoidWithZero\n\nopen Function\n\nvariable {\u03b1 \u03b2 \u03b9 M N : Type*}\n\nnamespace Set\n\nsection One\n\nvariable [One M] [One N] {s t : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1}\n\n\n@[to_additive \"`Set.indicator s f a` is `f a` if `a \u2208 s`, `0` otherwise.\"]\nnoncomputable def mulIndicator (s : Set \u03b1) (f : \u03b1 \u2192 M) (x : \u03b1) : M :=\n  haveI := Classical.decPred (\u00b7 \u2208 s)\n  if x \u2208 s then f x else 1\n#align set.mul_indicator Set.mulIndicator\n\n@[to_additive (attr := simp)]\ntheorem piecewise_eq_mulIndicator [DecidablePred (\u00b7 \u2208 s)] : s.piecewise f 1 = s.mulIndicator f :=\n  funext fun _ => @if_congr _ _ _ _ (id _) _ _ _ _ Iff.rfl rfl rfl\n#align set.piecewise_eq_mul_indicator Set.piecewise_eq_mulIndicator\n#align set.piecewise_eq_indicator Set.piecewise_eq_indicator\n\n-- Porting note: needed unfold for mulIndicator\n@[to_additive]\ntheorem mulIndicator_apply (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) [Decidable (a \u2208 s)] :\n    mulIndicator s f a = if a \u2208 s then f a else 1 := by\n  unfold mulIndicator\n  congr\n#align set.mul_indicator_apply Set.mulIndicator_apply\n#align set.indicator_apply Set.indicator_apply\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_of_mem (h : a \u2208 s) (f : \u03b1 \u2192 M) : mulIndicator s f a = f a :=\n  if_pos h\n#align set.mul_indicator_of_mem Set.mulIndicator_of_mem\n#align set.indicator_of_mem Set.indicator_of_mem\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_of_not_mem (h : a \u2209 s) (f : \u03b1 \u2192 M) : mulIndicator s f a = 1 :=\n  if_neg h\n#align set.mul_indicator_of_not_mem Set.mulIndicator_of_not_mem\n#align set.indicator_of_not_mem Set.indicator_of_not_mem\n\n@[to_additive]\ntheorem mulIndicator_eq_one_or_self (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a := by\n  by_cases h : a \u2208 s\n  \u00b7 exact Or.inr (mulIndicator_of_mem h f)\n  \u00b7 exact Or.inl (mulIndicator_of_not_mem h f)\n#align set.mul_indicator_eq_one_or_self Set.mulIndicator_eq_one_or_self\n#align set.indicator_eq_zero_or_self Set.indicator_eq_zero_or_self\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_self : s.mulIndicator f a = f a \u2194 a \u2209 s \u2192 f a = 1 :=\n  letI := Classical.dec (a \u2208 s)\n  ite_eq_left_iff.trans (by rw [@eq_comm _ (f a)])\n#align set.mul_indicator_apply_eq_self Set.mulIndicator_apply_eq_self\n#align set.indicator_apply_eq_self Set.indicator_apply_eq_self\n\n@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_self : s.mulIndicator f = f \u2194 mulSupport f \u2286 s := by\n  simp only [funext_iff, subset_def, mem_mulSupport, mulIndicator_apply_eq_self, not_imp_comm]\n#align set.mul_indicator_eq_self Set.mulIndicator_eq_self\n#align set.indicator_eq_self Set.indicator_eq_self\n\n@[to_additive]\n"}
{"name": "range_eq_map169", "split": "test", "formal_statement": "theorem range_eq_map [RingHomSurjective \u03c4\u2081\u2082] (f : F) : range f = map f \u22a4 := by", "header": "\nimport Mathlib.Algebra.Module.Submodule.Ker\n\n#align_import linear_algebra.basic from \"leanprover-community/mathlib\"@\"9d684a893c52e1d6692a504a118bfccbae04feeb\"\n\n\n\nopen Function\n\nvariable {R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}\nvariable {K : Type*} {K\u2082 : Type*}\nvariable {M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}\nvariable {V : Type*} {V\u2082 : Type*}\n\nnamespace LinearMap\n\nsection AddCommMonoid\n\nvariable [Semiring R] [Semiring R\u2082] [Semiring R\u2083]\nvariable [AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]\nvariable {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083}\nvariable [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]\nvariable [Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]\n\nopen Submodule\n\nvariable {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} {\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}\nvariable [RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]\n\nsection\n\nvariable {F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]\n\n\ndef range [RingHomSurjective \u03c4\u2081\u2082] (f : F) : Submodule R\u2082 M\u2082 :=\n  (map f \u22a4).copy (Set.range f) Set.image_univ.symm\n#align linear_map.range LinearMap.range\n\ntheorem range_coe [RingHomSurjective \u03c4\u2081\u2082] (f : F) : (range f : Set M\u2082) = Set.range f :=\n  rfl\n#align linear_map.range_coe LinearMap.range_coe\n\ntheorem range_toAddSubmonoid [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) :\n    f.range.toAddSubmonoid = AddMonoidHom.mrange f :=\n  rfl\n#align linear_map.range_to_add_submonoid LinearMap.range_toAddSubmonoid\n\n@[simp]\ntheorem mem_range [RingHomSurjective \u03c4\u2081\u2082] {f : F} {x} : x \u2208 range f \u2194 \u2203 y, f y = x :=\n  Iff.rfl\n#align linear_map.mem_range LinearMap.mem_range\n\n"}
{"name": "Convex.combo_closure_interior_subset_interior170", "split": "test", "formal_statement": "theorem Convex.combo_closure_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) : a \u2022 closure s + b \u2022 interior s \u2286 interior s := by", "header": "\nimport Mathlib.Analysis.Convex.Combination\nimport Mathlib.Analysis.Convex.Strict\nimport Mathlib.Topology.Connected.PathConnected\nimport Mathlib.Topology.Algebra.Affine\nimport Mathlib.Topology.Algebra.Module.Basic\n\n#align_import analysis.convex.topology from \"leanprover-community/mathlib\"@\"0e3aacdc98d25e0afe035c452d876d28cbffaa7e\"\n\n\n\nassert_not_exists Norm\n\nopen Metric Bornology Set Pointwise Convex\n\nvariable {\u03b9 \ud835\udd5c E : Type*}\n\ntheorem Real.convex_iff_isPreconnected {s : Set \u211d} : Convex \u211d s \u2194 IsPreconnected s :=\n  convex_iff_ordConnected.trans isPreconnected_iff_ordConnected.symm\n#align real.convex_iff_is_preconnected Real.convex_iff_isPreconnected\n\nalias \u27e8_, IsPreconnected.convex\u27e9 := Real.convex_iff_isPreconnected\n#align is_preconnected.convex IsPreconnected.convex\n\n\n\n\n\nsection ContinuousConstSMul\n\nvariable [LinearOrderedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]\n  [TopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]\n\n\ntheorem Convex.combo_interior_closure_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) : a \u2022 interior s + b \u2022 closure s \u2286 interior s :=\n  interior_smul\u2080 ha.ne' s \u25b8\n    calc\n      interior (a \u2022 s) + b \u2022 closure s \u2286 interior (a \u2022 s) + closure (b \u2022 s) :=\n        add_subset_add Subset.rfl (smul_closure_subset b s)\n      _ = interior (a \u2022 s) + b \u2022 s := by rw [isOpen_interior.add_closure (b \u2022 s)]\n      _ \u2286 interior (a \u2022 s + b \u2022 s) := subset_interior_add_left\n      _ \u2286 interior s := interior_mono <| hs.set_combo_subset ha.le hb hab\n\n#align convex.combo_interior_closure_subset_interior Convex.combo_interior_closure_subset_interior\n\n\ntheorem Convex.combo_interior_self_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) : a \u2022 interior s + b \u2022 s \u2286 interior s :=\n  calc\n    a \u2022 interior s + b \u2022 s \u2286 a \u2022 interior s + b \u2022 closure s :=\n      add_subset_add Subset.rfl <| image_subset _ subset_closure\n    _ \u2286 interior s := hs.combo_interior_closure_subset_interior ha hb hab\n\n#align convex.combo_interior_self_subset_interior Convex.combo_interior_self_subset_interior\n\n\n"}
{"name": "noncommFoldr_eq_foldr171", "split": "test", "formal_statement": "theorem noncommFoldr_eq_foldr (s : Multiset \u03b1) (h : LeftCommutative f) (b : \u03b2) :\n    noncommFoldr f s (fun x _ y _ _ => h x y) b = foldr f h b s := by", "header": "\nimport Mathlib.Algebra.BigOperators.Group.Finset\nimport Mathlib.Algebra.Group.Commute.Hom\nimport Mathlib.Data.Fintype.Card\n\n#align_import data.finset.noncomm_prod from \"leanprover-community/mathlib\"@\"509de852e1de55e1efa8eacfa11df0823f26f226\"\n\n\n\nvariable {F \u03b9 \u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n\nnamespace Multiset\n\n\ndef noncommFoldr (s : Multiset \u03b1)\n    (comm : { x | x \u2208 s }.Pairwise fun x y => \u2200 b, f x (f y b) = f y (f x b)) (b : \u03b2) : \u03b2 :=\n  s.attach.foldr (f \u2218 Subtype.val)\n    (fun \u27e8_, hx\u27e9 \u27e8_, hy\u27e9 =>\n      haveI : IsRefl \u03b1 fun x y => \u2200 b, f x (f y b) = f y (f x b) := \u27e8fun _ _ => rfl\u27e9\n      comm.of_refl hx hy)\n    b\n#align multiset.noncomm_foldr Multiset.noncommFoldr\n\n@[simp]\ntheorem noncommFoldr_coe (l : List \u03b1) (comm) (b : \u03b2) :\n    noncommFoldr f (l : Multiset \u03b1) comm b = l.foldr f b := by\n  simp only [noncommFoldr, coe_foldr, coe_attach, List.attach, List.attachWith, Function.comp]\n  rw [\u2190 List.foldr_map]\n  simp [List.map_pmap]\n#align multiset.noncomm_foldr_coe Multiset.noncommFoldr_coe\n\n@[simp]\ntheorem noncommFoldr_empty (h) (b : \u03b2) : noncommFoldr f (0 : Multiset \u03b1) h b = b :=\n  rfl\n#align multiset.noncomm_foldr_empty Multiset.noncommFoldr_empty\n\ntheorem noncommFoldr_cons (s : Multiset \u03b1) (a : \u03b1) (h h') (b : \u03b2) :\n    noncommFoldr f (a ::\u2098 s) h b = f a (noncommFoldr f s h' b) := by\n  induction s using Quotient.inductionOn\n  simp\n#align multiset.noncomm_foldr_cons Multiset.noncommFoldr_cons\n\n"}
{"name": "sup_sdiff_inf172", "split": "test", "formal_statement": "theorem sup_sdiff_inf (x y : \u03b1) : x \\ y \u2294 x \u2293 y = x := by", "header": "\nimport Mathlib.Order.Heyting.Basic\n\n#align_import order.boolean_algebra from \"leanprover-community/mathlib\"@\"9ac7c0c8c4d7a535ec3e5b34b8859aab9233b2f4\"\n\n\n\n\nopen Function OrderDual\n\nuniverse u v\n\nvariable {\u03b1 : Type u} {\u03b2 : Type*} {w x y z : \u03b1}\n\n\n\n\n\nclass GeneralizedBooleanAlgebra (\u03b1 : Type u) extends DistribLattice \u03b1, SDiff \u03b1, Bot \u03b1 where\n  \n  sup_inf_sdiff : \u2200 a b : \u03b1, a \u2293 b \u2294 a \\ b = a\n  \n  inf_inf_sdiff : \u2200 a b : \u03b1, a \u2293 b \u2293 a \\ b = \u22a5\n#align generalized_boolean_algebra GeneralizedBooleanAlgebra\n\n-- We might want an `IsCompl_of` predicate (for relative complements) generalizing `IsCompl`,\n-- however we'd need another type class for lattices with bot, and all the API for that.\nsection GeneralizedBooleanAlgebra\n\nvariable [GeneralizedBooleanAlgebra \u03b1]\n\n@[simp]\ntheorem sup_inf_sdiff (x y : \u03b1) : x \u2293 y \u2294 x \\ y = x :=\n  GeneralizedBooleanAlgebra.sup_inf_sdiff _ _\n#align sup_inf_sdiff sup_inf_sdiff\n\n@[simp]\ntheorem inf_inf_sdiff (x y : \u03b1) : x \u2293 y \u2293 x \\ y = \u22a5 :=\n  GeneralizedBooleanAlgebra.inf_inf_sdiff _ _\n#align inf_inf_sdiff inf_inf_sdiff\n\n@[simp]\n"}
{"name": "cgf_zero_fun173", "split": "test", "formal_statement": "theorem cgf_zero_fun : cgf 0 \u03bc t = log (\u03bc Set.univ).toReal := by", "header": "\nimport Mathlib.Probability.Variance\n\n#align_import probability.moments from \"leanprover-community/mathlib\"@\"85453a2a14be8da64caf15ca50930cf4c6e5d8de\"\n\n\n\n\nopen MeasureTheory Filter Finset Real\n\nnoncomputable section\n\nopen scoped MeasureTheory ProbabilityTheory ENNReal NNReal\n\nnamespace ProbabilityTheory\n\nvariable {\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}\n\n\ndef moment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d :=\n  \u03bc[X ^ p]\n#align probability_theory.moment ProbabilityTheory.moment\n\n\ndef centralMoment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d := by\n  have m := fun (x : \u03a9) => \u03bc[X] -- Porting note: Lean deems `\u03bc[(X - fun x => \u03bc[X]) ^ p]` ambiguous\n  exact \u03bc[(X - m) ^ p]\n#align probability_theory.central_moment ProbabilityTheory.centralMoment\n\n@[simp]\ntheorem moment_zero (hp : p \u2260 0) : moment 0 p \u03bc = 0 := by\n  simp only [moment, hp, zero_pow, Ne, not_false_iff, Pi.zero_apply, integral_const,\n    smul_eq_mul, mul_zero, integral_zero]\n#align probability_theory.moment_zero ProbabilityTheory.moment_zero\n\n@[simp]\ntheorem centralMoment_zero (hp : p \u2260 0) : centralMoment 0 p \u03bc = 0 := by\n  simp only [centralMoment, hp, Pi.zero_apply, integral_const, smul_eq_mul,\n    mul_zero, zero_sub, Pi.pow_apply, Pi.neg_apply, neg_zero, zero_pow, Ne, not_false_iff]\n#align probability_theory.central_moment_zero ProbabilityTheory.centralMoment_zero\n\ntheorem centralMoment_one' [IsFiniteMeasure \u03bc] (h_int : Integrable X \u03bc) :\n    centralMoment X 1 \u03bc = (1 - (\u03bc Set.univ).toReal) * \u03bc[X] := by\n  simp only [centralMoment, Pi.sub_apply, pow_one]\n  rw [integral_sub h_int (integrable_const _)]\n  simp only [sub_mul, integral_const, smul_eq_mul, one_mul]\n#align probability_theory.central_moment_one' ProbabilityTheory.centralMoment_one'\n\n@[simp]\ntheorem centralMoment_one [IsProbabilityMeasure \u03bc] : centralMoment X 1 \u03bc = 0 := by\n  by_cases h_int : Integrable X \u03bc\n  \u00b7 rw [centralMoment_one' h_int]\n    simp only [measure_univ, ENNReal.one_toReal, sub_self, zero_mul]\n  \u00b7 simp only [centralMoment, Pi.sub_apply, pow_one]\n    have : \u00acIntegrable (fun x => X x - integral \u03bc X) \u03bc := by\n      refine fun h_sub => h_int ?_\n      have h_add : X = (fun x => X x - integral \u03bc X) + fun _ => integral \u03bc X := by ext1 x; simp\n      rw [h_add]\n      exact h_sub.add (integrable_const _)\n    rw [integral_undef this]\n#align probability_theory.central_moment_one ProbabilityTheory.centralMoment_one\n\ntheorem centralMoment_two_eq_variance [IsFiniteMeasure \u03bc] (hX : Mem\u2112p X 2 \u03bc) :\n    centralMoment X 2 \u03bc = variance X \u03bc := by rw [hX.variance_eq]; rfl\n#align probability_theory.central_moment_two_eq_variance ProbabilityTheory.centralMoment_two_eq_variance\n\nsection MomentGeneratingFunction\n\nvariable {t : \u211d}\n\n\ndef mgf (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) (t : \u211d) : \u211d :=\n  \u03bc[fun \u03c9 => exp (t * X \u03c9)]\n#align probability_theory.mgf ProbabilityTheory.mgf\n\n\ndef cgf (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) (t : \u211d) : \u211d :=\n  log (mgf X \u03bc t)\n#align probability_theory.cgf ProbabilityTheory.cgf\n\n@[simp]\ntheorem mgf_zero_fun : mgf 0 \u03bc t = (\u03bc Set.univ).toReal := by\n  simp only [mgf, Pi.zero_apply, mul_zero, exp_zero, integral_const, smul_eq_mul, mul_one]\n#align probability_theory.mgf_zero_fun ProbabilityTheory.mgf_zero_fun\n\n@[simp]\n"}
{"name": "subgroups_basis174", "split": "test", "formal_statement": "theorem subgroups_basis : RingSubgroupsBasis fun \u03b3 : \u0393\u2080\u02e3 => (v.ltAddSubgroup \u03b3 : AddSubgroup R) :=\n  { inter := by", "header": "\nimport Mathlib.Topology.Algebra.Nonarchimedean.Bases\nimport Mathlib.Topology.Algebra.UniformFilterBasis\nimport Mathlib.RingTheory.Valuation.ValuationSubring\n\n#align_import topology.algebra.valuation from \"leanprover-community/mathlib\"@\"f2ce6086713c78a7f880485f7917ea547a215982\"\n\n\n\n\nopen scoped Classical\nopen Topology uniformity\n\nopen Set Valuation\n\nnoncomputable section\n\nuniverse v u\n\nvariable {R : Type u} [Ring R] {\u0393\u2080 : Type v} [LinearOrderedCommGroupWithZero \u0393\u2080]\n\nnamespace Valuation\n\nvariable (v : Valuation R \u0393\u2080)\n\n\n"}
{"name": "dist_birkhoffSum_apply_birkhoffSum175", "split": "test", "formal_statement": "theorem dist_birkhoffSum_apply_birkhoffSum (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x : \u03b1) :\n    dist (birkhoffSum f g n (f x)) (birkhoffSum f g n x) = dist (g (f^[n] x)) (g x) := by", "header": "\nimport Mathlib.Analysis.RCLike.Basic\nimport Mathlib.Dynamics.BirkhoffSum.Average\n\n\n\nopen Function Set Filter\nopen scoped Topology ENNReal Uniformity\n\nsection\n\nvariable {\u03b1 E : Type*}\n\n\ntheorem Function.IsFixedPt.tendsto_birkhoffAverage\n    (R : Type*) [DivisionSemiring R] [CharZero R]\n    [AddCommMonoid E] [TopologicalSpace E] [Module R E]\n    {f : \u03b1 \u2192 \u03b1} {x : \u03b1} (h : f.IsFixedPt x) (g : \u03b1 \u2192 E) :\n    Tendsto (birkhoffAverage R f g \u00b7 x) atTop (\ud835\udcdd (g x)) :=\n  tendsto_const_nhds.congr' <| (eventually_ne_atTop 0).mono fun _n hn \u21a6\n    (h.birkhoffAverage_eq R g hn).symm\n\nvariable [NormedAddCommGroup E]\n\n"}
{"name": "surj''176", "split": "test", "formal_statement": "theorem surj'' (z : S) : \u2203 (r : R) (m : M), z = r \u2022 (toInvSubmonoid M S m : S) := by", "header": "\nimport Mathlib.GroupTheory.Submonoid.Inverses\nimport Mathlib.RingTheory.FiniteType\nimport Mathlib.RingTheory.Localization.Basic\n\n#align_import ring_theory.localization.inv_submonoid from \"leanprover-community/mathlib\"@\"6e7ca692c98bbf8a64868f61a67fb9c33b10770d\"\n\n\n\n\nvariable {R : Type*} [CommRing R] (M : Submonoid R) (S : Type*) [CommRing S]\nvariable [Algebra R S] {P : Type*} [CommRing P]\n\nopen Function\n\nnamespace IsLocalization\n\nsection InvSubmonoid\n\n\ndef invSubmonoid : Submonoid S :=\n  (M.map (algebraMap R S)).leftInv\n#align is_localization.inv_submonoid IsLocalization.invSubmonoid\n\nvariable [IsLocalization M S]\n\ntheorem submonoid_map_le_is_unit : M.map (algebraMap R S) \u2264 IsUnit.submonoid S := by\n  rintro _ \u27e8a, ha, rfl\u27e9\n  exact IsLocalization.map_units S \u27e8_, ha\u27e9\n#align is_localization.submonoid_map_le_is_unit IsLocalization.submonoid_map_le_is_unit\n\n\nnoncomputable abbrev equivInvSubmonoid : M.map (algebraMap R S) \u2243* invSubmonoid M S :=\n  ((M.map (algebraMap R S)).leftInvEquiv (submonoid_map_le_is_unit M S)).symm\n#align is_localization.equiv_inv_submonoid IsLocalization.equivInvSubmonoid\n\n\nnoncomputable def toInvSubmonoid : M \u2192* invSubmonoid M S :=\n  (equivInvSubmonoid M S).toMonoidHom.comp ((algebraMap R S : R \u2192* S).submonoidMap M)\n#align is_localization.to_inv_submonoid IsLocalization.toInvSubmonoid\n\ntheorem toInvSubmonoid_surjective : Function.Surjective (toInvSubmonoid M S) :=\n  Function.Surjective.comp (\u03b2 := M.map (algebraMap R S))\n    (Equiv.surjective (equivInvSubmonoid _ _).toEquiv) (MonoidHom.submonoidMap_surjective _ _)\n#align is_localization.to_inv_submonoid_surjective IsLocalization.toInvSubmonoid_surjective\n\n@[simp]\ntheorem toInvSubmonoid_mul (m : M) : (toInvSubmonoid M S m : S) * algebraMap R S m = 1 :=\n  Submonoid.leftInvEquiv_symm_mul _ (submonoid_map_le_is_unit _ _) _\n#align is_localization.to_inv_submonoid_mul IsLocalization.toInvSubmonoid_mul\n\n@[simp]\ntheorem mul_toInvSubmonoid (m : M) : algebraMap R S m * (toInvSubmonoid M S m : S) = 1 :=\n  Submonoid.mul_leftInvEquiv_symm _ (submonoid_map_le_is_unit _ _) \u27e8_, _\u27e9\n#align is_localization.mul_to_inv_submonoid IsLocalization.mul_toInvSubmonoid\n\n@[simp]\ntheorem smul_toInvSubmonoid (m : M) : m \u2022 (toInvSubmonoid M S m : S) = 1 := by\n  convert mul_toInvSubmonoid M S m\n  ext\n  rw [\u2190 Algebra.smul_def]\n  rfl\n#align is_localization.smul_to_inv_submonoid IsLocalization.smul_toInvSubmonoid\n\nvariable {S}\n\n-- Porting note: `surj'` was taken, so use `surj''` instead\n"}
{"name": "condexp_stopping_time_ae_eq_restrict_eq_const177", "split": "test", "formal_statement": "theorem condexp_stopping_time_ae_eq_restrict_eq_const\n    [(Filter.atTop : Filter \u03b9).IsCountablyGenerated] (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) [SigmaFinite (\u03bc.trim h\u03c4.measurableSpace_le)] (hin : i \u2264 n) :\n    \u03bc[f n|h\u03c4.measurableSpace] =\u1d50[\u03bc.restrict {x | \u03c4 x = i}] f i := by", "header": "\nimport Mathlib.Order.SuccPred.LinearLocallyFinite\nimport Mathlib.Probability.Martingale.Basic\n\n#align_import probability.martingale.optional_sampling from \"leanprover-community/mathlib\"@\"ba074af83b6cf54c3104e59402b39410ddbd6dca\"\n\n\n\n\nopen scoped MeasureTheory ENNReal\n\nopen TopologicalSpace\n\nnamespace MeasureTheory\n\nnamespace Martingale\n\nvariable {\u03a9 E : Type*} {m : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} [NormedAddCommGroup E]\n  [NormedSpace \u211d E] [CompleteSpace E]\n\nsection FirstCountableTopology\n\nvariable {\u03b9 : Type*} [LinearOrder \u03b9] [TopologicalSpace \u03b9] [OrderTopology \u03b9]\n  [FirstCountableTopology \u03b9] {\u2131 : Filtration \u03b9 m} [SigmaFiniteFiltration \u03bc \u2131] {\u03c4 \u03c3 : \u03a9 \u2192 \u03b9}\n  {f : \u03b9 \u2192 \u03a9 \u2192 E} {i n : \u03b9}\n\n"}
{"name": "taylor_mem_nonZeroDivisors178", "split": "test", "formal_statement": "theorem taylor_mem_nonZeroDivisors (hp : p \u2208 R[X]\u2070) : taylor r p \u2208 R[X]\u2070 := by", "header": "\nimport Mathlib.Algebra.Polynomial.Taylor\nimport Mathlib.FieldTheory.RatFunc.AsPolynomial\n\n#align_import field_theory.laurent from \"leanprover-community/mathlib\"@\"70fd9563a21e7b963887c9360bd29b2393e6225a\"\n\n\n\n\nuniverse u\n\nnamespace RatFunc\n\nnoncomputable section\n\nopen Polynomial\n\nopen scoped Classical nonZeroDivisors Polynomial\n\nvariable {R : Type u} [CommRing R] [hdomain : IsDomain R] (r s : R) (p q : R[X]) (f : RatFunc R)\n\n"}
{"name": "integral_diff179", "split": "test", "formal_statement": "theorem integral_diff (ht : MeasurableSet t) (hfs : IntegrableOn f s \u03bc) (hts : t \u2286 s) :\n    \u222b x in s \\ t, f x \u2202\u03bc = \u222b x in s, f x \u2202\u03bc - \u222b x in t, f x \u2202\u03bc := by", "header": "\nimport Mathlib.MeasureTheory.Integral.IntegrableOn\nimport Mathlib.MeasureTheory.Integral.Bochner\nimport Mathlib.MeasureTheory.Function.LocallyIntegrable\nimport Mathlib.Topology.MetricSpace.ThickenedIndicator\nimport Mathlib.Topology.ContinuousFunction.Compact\nimport Mathlib.Analysis.NormedSpace.HahnBanach.SeparatingDual\n\n#align_import measure_theory.integral.setIntegral from \"leanprover-community/mathlib\"@\"24e0c85412ff6adbeca08022c25ba4876eedf37a\"\n\n\n\n\nassert_not_exists InnerProductSpace\n\nnoncomputable section\n\nopen Set Filter TopologicalSpace MeasureTheory Function RCLike\n\nopen scoped Classical Topology ENNReal NNReal\n\nvariable {X Y E F : Type*} [MeasurableSpace X]\n\nnamespace MeasureTheory\n\nsection NormedAddCommGroup\n\nvariable [NormedAddCommGroup E] [NormedSpace \u211d E]\n  {f g : X \u2192 E} {s t : Set X} {\u03bc \u03bd : Measure X} {l l' : Filter X}\n\ntheorem setIntegral_congr_ae\u2080 (hs : NullMeasurableSet s \u03bc) (h : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x = g x) :\n    \u222b x in s, f x \u2202\u03bc = \u222b x in s, g x \u2202\u03bc :=\n  integral_congr_ae ((ae_restrict_iff'\u2080 hs).2 h)\n#align measure_theory.set_integral_congr_ae\u2080 MeasureTheory.setIntegral_congr_ae\u2080\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr_ae\u2080 := setIntegral_congr_ae\u2080\n\ntheorem setIntegral_congr_ae (hs : MeasurableSet s) (h : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x = g x) :\n    \u222b x in s, f x \u2202\u03bc = \u222b x in s, g x \u2202\u03bc :=\n  integral_congr_ae ((ae_restrict_iff' hs).2 h)\n#align measure_theory.set_integral_congr_ae MeasureTheory.setIntegral_congr_ae\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr_ae := setIntegral_congr_ae\n\ntheorem setIntegral_congr\u2080 (hs : NullMeasurableSet s \u03bc) (h : EqOn f g s) :\n    \u222b x in s, f x \u2202\u03bc = \u222b x in s, g x \u2202\u03bc :=\n  setIntegral_congr_ae\u2080 hs <| eventually_of_forall h\n#align measure_theory.set_integral_congr\u2080 MeasureTheory.setIntegral_congr\u2080\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr\u2080 := setIntegral_congr\u2080\n\ntheorem setIntegral_congr (hs : MeasurableSet s) (h : EqOn f g s) :\n    \u222b x in s, f x \u2202\u03bc = \u222b x in s, g x \u2202\u03bc :=\n  setIntegral_congr_ae hs <| eventually_of_forall h\n#align measure_theory.set_integral_congr MeasureTheory.setIntegral_congr\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr := setIntegral_congr\n\ntheorem setIntegral_congr_set_ae (hst : s =\u1d50[\u03bc] t) : \u222b x in s, f x \u2202\u03bc = \u222b x in t, f x \u2202\u03bc := by\n  rw [Measure.restrict_congr_set hst]\n#align measure_theory.set_integral_congr_set_ae MeasureTheory.setIntegral_congr_set_ae\n\n@[deprecated (since := \"2024-04-17\")]\nalias set_integral_congr_set_ae := setIntegral_congr_set_ae\n\ntheorem integral_union_ae (hst : AEDisjoint \u03bc s t) (ht : NullMeasurableSet t \u03bc)\n    (hfs : IntegrableOn f s \u03bc) (hft : IntegrableOn f t \u03bc) :\n    \u222b x in s \u222a t, f x \u2202\u03bc = \u222b x in s, f x \u2202\u03bc + \u222b x in t, f x \u2202\u03bc := by\n  simp only [IntegrableOn, Measure.restrict_union\u2080 hst ht, integral_add_measure hfs hft]\n#align measure_theory.integral_union_ae MeasureTheory.integral_union_ae\n\ntheorem integral_union (hst : Disjoint s t) (ht : MeasurableSet t) (hfs : IntegrableOn f s \u03bc)\n    (hft : IntegrableOn f t \u03bc) : \u222b x in s \u222a t, f x \u2202\u03bc = \u222b x in s, f x \u2202\u03bc + \u222b x in t, f x \u2202\u03bc :=\n  integral_union_ae hst.aedisjoint ht.nullMeasurableSet hfs hft\n#align measure_theory.integral_union MeasureTheory.integral_union\n\n"}
{"name": "min_self180", "split": "test", "formal_statement": "theorem min_self (a : \u03b1) : min a a = a := by", "header": "\nimport Mathlib.Init.Order.Defs\n\n#align_import init.algebra.functions from \"leanprover-community/lean\"@\"c2bcdbcbe741ed37c361a30d38e179182b989f76\"\n\n\n\nuniverse u\n\nsection\n\nopen Decidable\n\nvariable {\u03b1 : Type u} [LinearOrder \u03b1]\n\ntheorem min_def (a b : \u03b1) : min a b = if a \u2264 b then a else b := by\n  rw [LinearOrder.min_def a]\n#align min_def min_def\n\ntheorem max_def (a b : \u03b1) : max a b = if a \u2264 b then b else a := by\n  rw [LinearOrder.max_def a]\n#align max_def max_def\n\ntheorem min_le_left (a b : \u03b1) : min a b \u2264 a := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h, le_refl]\n  else simp [min_def, if_neg h]; exact le_of_not_le h\n#align min_le_left min_le_left\n\ntheorem min_le_right (a b : \u03b1) : min a b \u2264 b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h]; exact h\n  else simp [min_def, if_neg h, le_refl]\n#align min_le_right min_le_right\n\ntheorem le_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) : c \u2264 min a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h]; exact h\u2081\n  else simp [min_def, if_neg h]; exact h\u2082\n#align le_min le_min\n\ntheorem le_max_left (a b : \u03b1) : a \u2264 max a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h]; exact h\n  else simp [max_def, if_neg h, le_refl]\n#align le_max_left le_max_left\n\ntheorem le_max_right (a b : \u03b1) : b \u2264 max a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h, le_refl]\n  else simp [max_def, if_neg h]; exact le_of_not_le h\n#align le_max_right le_max_right\n\ntheorem max_le {a b c : \u03b1} (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : max a b \u2264 c := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h]; exact h\u2082\n  else simp [max_def, if_neg h]; exact h\u2081\n#align max_le max_le\n\ntheorem eq_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) (h\u2083 : \u2200 {d}, d \u2264 a \u2192 d \u2264 b \u2192 d \u2264 c) :\n    c = min a b :=\n  le_antisymm (le_min h\u2081 h\u2082) (h\u2083 (min_le_left a b) (min_le_right a b))\n#align eq_min eq_min\n\ntheorem min_comm (a b : \u03b1) : min a b = min b a :=\n  eq_min (min_le_right a b) (min_le_left a b) fun h\u2081 h\u2082 => le_min h\u2082 h\u2081\n#align min_comm min_comm\n\ntheorem min_assoc (a b c : \u03b1) : min (min a b) c = min a (min b c) := by\n  apply eq_min\n  \u00b7 apply le_trans; apply min_le_left; apply min_le_left\n  \u00b7 apply le_min; apply le_trans; apply min_le_left; apply min_le_right; apply min_le_right\n  \u00b7 intro d h\u2081 h\u2082; apply le_min; apply le_min h\u2081; apply le_trans h\u2082; apply min_le_left\n    apply le_trans h\u2082; apply min_le_right\n#align min_assoc min_assoc\n\ntheorem min_left_comm : \u2200 a b c : \u03b1, min a (min b c) = min b (min a c) :=\n  left_comm (@min \u03b1 _) (@min_comm \u03b1 _) (@min_assoc \u03b1 _)\n#align min_left_comm min_left_comm\n\n@[simp]\n"}
{"name": "angle_comm181", "split": "test", "formal_statement": "theorem angle_comm (x y : V) : angle x y = angle y x := by", "header": "\nimport Mathlib.Analysis.InnerProductSpace.Basic\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Inverse\n\n#align_import geometry.euclidean.angle.unoriented.basic from \"leanprover-community/mathlib\"@\"46b633fd842bef9469441c0209906f6dddd2b4f5\"\n\n\n\n\nassert_not_exists HasFDerivAt\n\nassert_not_exists ConformalAt\n\nnoncomputable section\n\nopen Real Set\n\nopen Real\n\nopen RealInnerProductSpace\n\nnamespace InnerProductGeometry\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] {x y : V}\n\n\ndef angle (x y : V) : \u211d :=\n  Real.arccos (\u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016))\n#align inner_product_geometry.angle InnerProductGeometry.angle\n\ntheorem continuousAt_angle {x : V \u00d7 V} (hx1 : x.1 \u2260 0) (hx2 : x.2 \u2260 0) :\n    ContinuousAt (fun y : V \u00d7 V => angle y.1 y.2) x :=\n  Real.continuous_arccos.continuousAt.comp <|\n    continuous_inner.continuousAt.div\n      ((continuous_norm.comp continuous_fst).mul (continuous_norm.comp continuous_snd)).continuousAt\n      (by simp [hx1, hx2])\n#align inner_product_geometry.continuous_at_angle InnerProductGeometry.continuousAt_angle\n\ntheorem angle_smul_smul {c : \u211d} (hc : c \u2260 0) (x y : V) : angle (c \u2022 x) (c \u2022 y) = angle x y := by\n  have : c * c \u2260 0 := mul_ne_zero hc hc\n  rw [angle, angle, real_inner_smul_left, inner_smul_right, norm_smul, norm_smul, Real.norm_eq_abs,\n    mul_mul_mul_comm _ \u2016x\u2016, abs_mul_abs_self, \u2190 mul_assoc c c, mul_div_mul_left _ _ this]\n#align inner_product_geometry.angle_smul_smul InnerProductGeometry.angle_smul_smul\n\n@[simp]\ntheorem _root_.LinearIsometry.angle_map {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F]\n    [InnerProductSpace \u211d E] [InnerProductSpace \u211d F] (f : E \u2192\u2097\u1d62[\u211d] F) (u v : E) :\n    angle (f u) (f v) = angle u v := by\n  rw [angle, angle, f.inner_map_map, f.norm_map, f.norm_map]\n#align linear_isometry.angle_map LinearIsometry.angle_map\n\n@[simp, norm_cast]\ntheorem _root_.Submodule.angle_coe {s : Submodule \u211d V} (x y : s) :\n    angle (x : V) (y : V) = angle x y :=\n  s.subtype\u2097\u1d62.angle_map x y\n#align submodule.angle_coe Submodule.angle_coe\n\n\ntheorem cos_angle (x y : V) : Real.cos (angle x y) = \u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016) :=\n  Real.cos_arccos (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).1\n    (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2\n#align inner_product_geometry.cos_angle InnerProductGeometry.cos_angle\n\n\n"}
{"name": "range_neg182", "split": "test", "formal_statement": "theorem range_neg {R : Type*} {R\u2082 : Type*} {M : Type*} {M\u2082 : Type*} [Semiring R] [Ring R\u2082]\n    [AddCommMonoid M] [AddCommGroup M\u2082] [Module R M] [Module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082}\n    [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : LinearMap.range (-f) = LinearMap.range f := by", "header": "\nimport Mathlib.Algebra.Module.Submodule.Ker\n\n#align_import linear_algebra.basic from \"leanprover-community/mathlib\"@\"9d684a893c52e1d6692a504a118bfccbae04feeb\"\n\n\n\nopen Function\n\nvariable {R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}\nvariable {K : Type*} {K\u2082 : Type*}\nvariable {M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}\nvariable {V : Type*} {V\u2082 : Type*}\n\nnamespace LinearMap\n\nsection AddCommMonoid\n\nvariable [Semiring R] [Semiring R\u2082] [Semiring R\u2083]\nvariable [AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]\nvariable {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083}\nvariable [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]\nvariable [Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]\n\nopen Submodule\n\nvariable {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} {\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}\nvariable [RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]\n\nsection\n\nvariable {F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]\n\n\ndef range [RingHomSurjective \u03c4\u2081\u2082] (f : F) : Submodule R\u2082 M\u2082 :=\n  (map f \u22a4).copy (Set.range f) Set.image_univ.symm\n#align linear_map.range LinearMap.range\n\ntheorem range_coe [RingHomSurjective \u03c4\u2081\u2082] (f : F) : (range f : Set M\u2082) = Set.range f :=\n  rfl\n#align linear_map.range_coe LinearMap.range_coe\n\ntheorem range_toAddSubmonoid [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) :\n    f.range.toAddSubmonoid = AddMonoidHom.mrange f :=\n  rfl\n#align linear_map.range_to_add_submonoid LinearMap.range_toAddSubmonoid\n\n@[simp]\ntheorem mem_range [RingHomSurjective \u03c4\u2081\u2082] {f : F} {x} : x \u2208 range f \u2194 \u2203 y, f y = x :=\n  Iff.rfl\n#align linear_map.mem_range LinearMap.mem_range\n\ntheorem range_eq_map [RingHomSurjective \u03c4\u2081\u2082] (f : F) : range f = map f \u22a4 := by\n  ext\n  simp\n#align linear_map.range_eq_map LinearMap.range_eq_map\n\ntheorem mem_range_self [RingHomSurjective \u03c4\u2081\u2082] (f : F) (x : M) : f x \u2208 range f :=\n  \u27e8x, rfl\u27e9\n#align linear_map.mem_range_self LinearMap.mem_range_self\n\n@[simp]\ntheorem range_id : range (LinearMap.id : M \u2192\u2097[R] M) = \u22a4 :=\n  SetLike.coe_injective Set.range_id\n#align linear_map.range_id LinearMap.range_id\n\ntheorem range_comp [RingHomSurjective \u03c4\u2081\u2082] [RingHomSurjective \u03c4\u2082\u2083] [RingHomSurjective \u03c4\u2081\u2083]\n    (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) : range (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) = map g (range f) :=\n  SetLike.coe_injective (Set.range_comp g f)\n#align linear_map.range_comp LinearMap.range_comp\n\ntheorem range_comp_le_range [RingHomSurjective \u03c4\u2082\u2083] [RingHomSurjective \u03c4\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082)\n    (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) : range (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) \u2264 range g :=\n  SetLike.coe_mono (Set.range_comp_subset_range f g)\n#align linear_map.range_comp_le_range LinearMap.range_comp_le_range\n\ntheorem range_eq_top [RingHomSurjective \u03c4\u2081\u2082] {f : F} : range f = \u22a4 \u2194 Surjective f := by\n  rw [SetLike.ext'_iff, range_coe, top_coe, Set.range_iff_surjective]\n#align linear_map.range_eq_top LinearMap.range_eq_top\n\ntheorem range_le_iff_comap [RingHomSurjective \u03c4\u2081\u2082] {f : F} {p : Submodule R\u2082 M\u2082} :\n    range f \u2264 p \u2194 comap f p = \u22a4 := by rw [range_eq_map, map_le_iff_le_comap, eq_top_iff]\n#align linear_map.range_le_iff_comap LinearMap.range_le_iff_comap\n\ntheorem map_le_range [RingHomSurjective \u03c4\u2081\u2082] {f : F} {p : Submodule R M} : map f p \u2264 range f :=\n  SetLike.coe_mono (Set.image_subset_range f p)\n#align linear_map.map_le_range LinearMap.map_le_range\n\n@[simp]\n"}
{"name": "normalize_num_den'183", "split": "test", "formal_statement": "theorem normalize_num_den' (num den nz) : \u2203 d : Nat, d \u2260 0 \u2227\n    num = (normalize num den nz).num * d \u2227 den = (normalize num den nz).den * d := by", "header": "\nimport Batteries.Data.Rat.Basic\nimport Batteries.Tactic.SeqFocus\n\n\n\nnamespace Rat\n\ntheorem ext : {p q : Rat} \u2192 p.num = q.num \u2192 p.den = q.den \u2192 p = q\n  | \u27e8_,_,_,_\u27e9, \u27e8_,_,_,_\u27e9, rfl, rfl => rfl\n\n@[simp] theorem mk_den_one {r : Int} :\n    \u27e8r, 1, Nat.one_ne_zero, (Nat.coprime_one_right _)\u27e9 = (r : Rat) := rfl\n\n@[simp] theorem zero_num : (0 : Rat).num = 0 := rfl\n@[simp] theorem zero_den : (0 : Rat).den = 1 := rfl\n@[simp] theorem one_num : (1 : Rat).num = 1 := rfl\n@[simp] theorem one_den : (1 : Rat).den = 1 := rfl\n\n@[simp] theorem maybeNormalize_eq {num den g} (den_nz reduced) :\n    maybeNormalize num den g den_nz reduced =\n    { num := num.div g, den := den / g, den_nz, reduced } := by\n  unfold maybeNormalize; split\n  \u00b7 subst g; simp\n  \u00b7 rfl\n\ntheorem normalize.reduced' {num : Int} {den g : Nat} (den_nz : den \u2260 0)\n    (e : g = num.natAbs.gcd den) : (num / g).natAbs.Coprime (den / g) := by\n  rw [\u2190 Int.div_eq_ediv_of_dvd (e \u25b8 Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n  exact normalize.reduced den_nz e\n\ntheorem normalize_eq {num den} (den_nz) : normalize num den den_nz =\n    { num := num / num.natAbs.gcd den\n      den := den / num.natAbs.gcd den\n      den_nz := normalize.den_nz den_nz rfl\n      reduced := normalize.reduced' den_nz rfl } := by\n  simp only [normalize, maybeNormalize_eq,\n    Int.div_eq_ediv_of_dvd (Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n\n@[simp] theorem normalize_zero (nz) : normalize 0 d nz = 0 := by\n  simp [normalize, Int.zero_div, Int.natAbs_zero, Nat.div_self (Nat.pos_of_ne_zero nz)]; rfl\n\ntheorem mk_eq_normalize (num den nz c) : \u27e8num, den, nz, c\u27e9 = normalize num den nz := by\n  simp [normalize_eq, c.gcd_eq_one]\n\ntheorem normalize_self (r : Rat) : normalize r.num r.den r.den_nz = r := (mk_eq_normalize ..).symm\n\ntheorem normalize_mul_left {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (\u2191a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0 := by\n  simp [normalize_eq, mk'.injEq, Int.natAbs_mul, Nat.gcd_mul_left,\n    Nat.mul_div_mul_left _ _ (Nat.pos_of_ne_zero a0), Int.ofNat_mul,\n    Int.mul_ediv_mul_of_pos _ _ (Int.ofNat_pos.2 <| Nat.pos_of_ne_zero a0)]\n\ntheorem normalize_mul_right {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0 := by\n  rw [\u2190 normalize_mul_left (d0 := d0) a0]; congr 1 <;> [apply Int.mul_comm; apply Nat.mul_comm]\n\ntheorem normalize_eq_iff (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    normalize n\u2081 d\u2081 z\u2081 = normalize n\u2082 d\u2082 z\u2082 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081 := by\n  constructor <;> intro h\n  \u00b7 simp only [normalize_eq, mk'.injEq] at h\n    have' hn\u2081 := Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left n\u2081.natAbs d\u2081\n    have' hn\u2082 := Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left n\u2082.natAbs d\u2082\n    have' hd\u2081 := Int.ofNat_dvd.2 <| Nat.gcd_dvd_right n\u2081.natAbs d\u2081\n    have' hd\u2082 := Int.ofNat_dvd.2 <| Nat.gcd_dvd_right n\u2082.natAbs d\u2082\n    rw [\u2190 Int.ediv_mul_cancel (Int.dvd_trans hd\u2082 (Int.dvd_mul_left ..)),\n      Int.mul_ediv_assoc _ hd\u2082, \u2190 Int.ofNat_ediv, \u2190 h.2, Int.ofNat_ediv,\n      \u2190 Int.mul_ediv_assoc _ hd\u2081, Int.mul_ediv_assoc' _ hn\u2081,\n      Int.mul_right_comm, h.1, Int.ediv_mul_cancel hn\u2082]\n  \u00b7 rw [\u2190 normalize_mul_right _ z\u2082, \u2190 normalize_mul_left z\u2082 z\u2081, Int.mul_comm d\u2081, h]\n\ntheorem maybeNormalize_eq_normalize {num : Int} {den g : Nat} (den_nz reduced)\n    (hn : \u2191g \u2223 num) (hd : g \u2223 den) :\n    maybeNormalize num den g den_nz reduced = normalize num den (mt (by simp [\u00b7]) den_nz) := by\n  simp only [maybeNormalize_eq, mk_eq_normalize, Int.div_eq_ediv_of_dvd hn]\n  have : g \u2260 0 := mt (by simp [\u00b7]) den_nz\n  rw [\u2190 normalize_mul_right _ this, Int.ediv_mul_cancel hn]\n  congr 1; exact Nat.div_mul_cancel hd\n\n@[simp] theorem normalize_eq_zero (d0 : d \u2260 0) : normalize n d d0 = 0 \u2194 n = 0 := by\n  have' := normalize_eq_iff d0 Nat.one_ne_zero\n  rw [normalize_zero (d := 1)] at this; rw [this]; simp\n\n"}
{"name": "coprime_coe184", "split": "test", "formal_statement": "theorem coprime_coe {m n : \u2115+} : Nat.Coprime \u2191m \u2191n \u2194 m.Coprime n := by", "header": "\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.prime from \"leanprover-community/mathlib\"@\"09597669f02422ed388036273d8848119699c22f\"\n\n\n\n\nnamespace PNat\n\nopen Nat\n\n\ndef gcd (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.gcd (n : \u2115) (m : \u2115), Nat.gcd_pos_of_pos_left (m : \u2115) n.pos\u27e9\n#align pnat.gcd PNat.gcd\n\n\ndef lcm (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.lcm (n : \u2115) (m : \u2115), by\n    let h := mul_pos n.pos m.pos\n    rw [\u2190 gcd_mul_lcm (n : \u2115) (m : \u2115), mul_comm] at h\n    exact pos_of_dvd_of_pos (Dvd.intro (Nat.gcd (n : \u2115) (m : \u2115)) rfl) h\u27e9\n#align pnat.lcm PNat.lcm\n\n@[simp, norm_cast]\ntheorem gcd_coe (n m : \u2115+) : (gcd n m : \u2115) = Nat.gcd n m :=\n  rfl\n#align pnat.gcd_coe PNat.gcd_coe\n\n@[simp, norm_cast]\ntheorem lcm_coe (n m : \u2115+) : (lcm n m : \u2115) = Nat.lcm n m :=\n  rfl\n#align pnat.lcm_coe PNat.lcm_coe\n\ntheorem gcd_dvd_left (n m : \u2115+) : gcd n m \u2223 n :=\n  dvd_iff.2 (Nat.gcd_dvd_left (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_left PNat.gcd_dvd_left\n\ntheorem gcd_dvd_right (n m : \u2115+) : gcd n m \u2223 m :=\n  dvd_iff.2 (Nat.gcd_dvd_right (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_right PNat.gcd_dvd_right\n\ntheorem dvd_gcd {m n k : \u2115+} (hm : k \u2223 m) (hn : k \u2223 n) : k \u2223 gcd m n :=\n  dvd_iff.2 (Nat.dvd_gcd (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.dvd_gcd PNat.dvd_gcd\n\ntheorem dvd_lcm_left (n m : \u2115+) : n \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_left (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_left PNat.dvd_lcm_left\n\ntheorem dvd_lcm_right (n m : \u2115+) : m \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_right (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_right PNat.dvd_lcm_right\n\ntheorem lcm_dvd {m n k : \u2115+} (hm : m \u2223 k) (hn : n \u2223 k) : lcm m n \u2223 k :=\n  dvd_iff.2 (@Nat.lcm_dvd (m : \u2115) (n : \u2115) (k : \u2115) (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.lcm_dvd PNat.lcm_dvd\n\ntheorem gcd_mul_lcm (n m : \u2115+) : gcd n m * lcm n m = n * m :=\n  Subtype.eq (Nat.gcd_mul_lcm (n : \u2115) (m : \u2115))\n#align pnat.gcd_mul_lcm PNat.gcd_mul_lcm\n\ntheorem eq_one_of_lt_two {n : \u2115+} : n < 2 \u2192 n = 1 := by\n  intro h; apply le_antisymm; swap\n  \u00b7 apply PNat.one_le\n  \u00b7 exact PNat.lt_add_one_iff.1 h\n#align pnat.eq_one_of_lt_two PNat.eq_one_of_lt_two\n\nsection Coprime\n\n\n\n\n\ndef Coprime (m n : \u2115+) : Prop :=\n  m.gcd n = 1\n#align pnat.coprime PNat.Coprime\n\n@[simp, norm_cast]\n"}
{"name": "toSingle\u2080CokernelAtZeroIso_hom_eq185", "split": "test", "formal_statement": "theorem toSingle\u2080CokernelAtZeroIso_hom_eq [hf : QuasiIso' f] :\n    f.toSingle\u2080CokernelAtZeroIso.hom =\n      cokernel.desc (X.d 1 0) (f.f 0) (by rw [\u2190 f.2 1 0 rfl]; exact comp_zero) := by", "header": "\nimport Mathlib.Algebra.Homology.Homotopy\nimport Mathlib.Algebra.Homology.SingleHomology\nimport Mathlib.CategoryTheory.Abelian.Homology\n\n#align_import algebra.homology.quasi_iso from \"leanprover-community/mathlib\"@\"956af7c76589f444f2e1313911bad16366ea476d\"\n\n\n\n\nopen CategoryTheory Limits\n\nuniverse v u\n\nvariable {\u03b9 : Type*}\n\nsection\n\nvariable {V : Type u} [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]\nvariable [HasEqualizers V] [HasImages V] [HasImageMaps V] [HasCokernels V]\nvariable {c : ComplexShape \u03b9} {C D E : HomologicalComplex V c}\n\n\nclass QuasiIso' (f : C \u27f6 D) : Prop where\n  isIso : \u2200 i, IsIso ((homology'Functor V c i).map f)\n#align quasi_iso QuasiIso'\n\nattribute [instance] QuasiIso'.isIso\n\ninstance (priority := 100) quasiIso'_of_iso (f : C \u27f6 D) [IsIso f] : QuasiIso' f where\n  isIso i := by\n    change IsIso ((homology'Functor V c i).mapIso (asIso f)).hom\n    infer_instance\n#align quasi_iso_of_iso quasiIso'_of_iso\n\ninstance quasiIso'_comp (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' g] :\n    QuasiIso' (f \u226b g) where\n  isIso i := by\n    rw [Functor.map_comp]\n    infer_instance\n#align quasi_iso_comp quasiIso'_comp\n\ntheorem quasiIso'_of_comp_left (f : C \u27f6 D) [QuasiIso' f] (g : D \u27f6 E) [QuasiIso' (f \u226b g)] :\n    QuasiIso' g :=\n  { isIso := fun i => IsIso.of_isIso_fac_left ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_left quasiIso'_of_comp_left\n\ntheorem quasiIso'_of_comp_right (f : C \u27f6 D) (g : D \u27f6 E) [QuasiIso' g] [QuasiIso' (f \u226b g)] :\n    QuasiIso' f :=\n  { isIso := fun i => IsIso.of_isIso_fac_right ((homology'Functor V c i).map_comp f g).symm }\n#align quasi_iso_of_comp_right quasiIso'_of_comp_right\n\nnamespace HomologicalComplex.Hom\n\nsection ToSingle\u2080\n\nvariable {W : Type*} [Category W] [Abelian W]\n\nsection\n\nvariable {X : ChainComplex W \u2115} {Y : W} (f : X \u27f6 (ChainComplex.single\u2080 _).obj Y) [hf : QuasiIso' f]\n\n\nnoncomputable def toSingle\u2080CokernelAtZeroIso : cokernel (X.d 1 0) \u2245 Y :=\n  X.homology'ZeroIso.symm.trans\n    ((@asIso _ _ _ _ _ (hf.1 0)).trans ((ChainComplex.homology'Functor0Single\u2080 W).app Y))\n#align homological_complex.hom.to_single\u2080_cokernel_at_zero_iso HomologicalComplex.Hom.toSingle\u2080CokernelAtZeroIso\n\n"}
{"name": "curry_uncurry186", "split": "test", "formal_statement": "theorem curry_uncurry (f : Function.FromTypes p \u03c4) : curry (uncurry f) = f := by", "header": "\nimport Mathlib.Data.Fin.Tuple.Basic\nimport Mathlib.Logic.Equiv.Fin\nimport Mathlib.Logic.Function.OfArity\n\n\n\nuniverse u v w w'\n\nnamespace Function.FromTypes\n\nopen Matrix (vecCons vecHead vecTail vecEmpty)\n\n\ndef uncurry : {n : \u2115} \u2192 {p : Fin n \u2192 Type u} \u2192 {\u03c4 : Type u} \u2192\n    (f : Function.FromTypes p \u03c4) \u2192 ((i : Fin n) \u2192 p i) \u2192 \u03c4\n  | 0    , _, _, f => fun _    => f\n  | _ + 1, _, _, f => fun args => (f (args 0)).uncurry (args \u2218' Fin.succ)\n\n\ndef curry : {n : \u2115} \u2192 {p : Fin n \u2192 Type u} \u2192 {\u03c4 : Type u} \u2192\n    (((i : Fin n) \u2192 p i) \u2192 \u03c4) \u2192 Function.FromTypes p \u03c4\n  | 0    , _, _, f => f isEmptyElim\n  | _ + 1, _, _, f => fun a => curry (fun args => f (Fin.cons a args))\n\n@[simp]\ntheorem uncurry_apply_cons {n : \u2115} {\u03b1} {p : Fin n \u2192 Type u} {\u03c4 : Type u}\n    (f : Function.FromTypes (vecCons \u03b1 p) \u03c4) (a : \u03b1) (args : (i : Fin n) \u2192 p i) :\n    uncurry f (Fin.cons a args) = @uncurry _ p _ (f a) args := rfl\n\n@[simp low]\ntheorem uncurry_apply_succ {n : \u2115} {p : Fin (n + 1) \u2192 Type u} {\u03c4 : Type u}\n    (f : Function.FromTypes p \u03c4) (args : (i : Fin (n + 1)) \u2192 p i) :\n    uncurry f args = uncurry (f (args 0)) (Fin.tail args) :=\n  @uncurry_apply_cons n (p 0) (vecTail p) \u03c4 f (args 0) (Fin.tail args)\n\n@[simp]\ntheorem curry_apply_cons {n : \u2115} {\u03b1} {p : Fin n \u2192 Type u} {\u03c4 : Type u}\n    (f : ((i : Fin (n + 1)) \u2192 (vecCons \u03b1 p) i) \u2192 \u03c4) (a : \u03b1) :\n    curry f a = @curry _ p _ (f \u2218' Fin.cons a) := rfl\n\n@[simp low]\ntheorem curry_apply_succ {n : \u2115} {p : Fin (n + 1) \u2192 Type u} {\u03c4 : Type u}\n    (f : ((i : Fin (n + 1)) \u2192 p i) \u2192 \u03c4) (a : p 0) :\n    curry f a = curry (f \u2218 Fin.cons a) := rfl\n\nvariable {n : \u2115} {p : Fin n \u2192 Type u} {\u03c4 : Type u}\n\n@[simp]\n"}
{"name": "conjugate'187", "split": "test", "formal_statement": "theorem conjugate' {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (star z * x * z) := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Basic\nimport Mathlib.Algebra.Module.Defs\nimport Mathlib.Algebra.Star.Pi\n\n#align_import algebra.star.self_adjoint from \"leanprover-community/mathlib\"@\"a6ece35404f60597c651689c1b46ead86de5ac1b\"\n\n\n\nopen Function\n\nvariable {R A : Type*}\n\n\ndef IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x\n#align is_self_adjoint IsSelfAdjoint\n\n\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x\n#align is_star_normal IsStarNormal\n\nexport IsStarNormal (star_comm_self)\n\ntheorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n#align star_comm_self' star_comm_self'\n\nnamespace IsSelfAdjoint\n\n-- named to match `Commute.all\u2093`\n\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n#align is_self_adjoint.all IsSelfAdjoint.all\n\ntheorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n#align is_self_adjoint.star_eq IsSelfAdjoint.star_eq\n\ntheorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x :=\n  Iff.rfl\n#align is_self_adjoint_iff isSelfAdjoint_iff\n\n@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n#align is_self_adjoint.star_iff IsSelfAdjoint.star_iff\n\n@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint, star_mul, star_star]\n#align is_self_adjoint.star_mul_self IsSelfAdjoint.star_mul_self\n\n@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n#align is_self_adjoint.mul_star_self IsSelfAdjoint.mul_star_self\n\n\nlemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n\n\ntheorem starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S] [StarHomClass F R S]\n    {x : R} (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x) :=\n  show star (f x) = f x from map_star f x \u25b8 congr_arg f hx\n#align is_self_adjoint.star_hom_apply IsSelfAdjoint.starHom_apply\n\n\ntheorem _root_.isSelfAdjoint_starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S]\n    [StarHomClass F R S] [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x) :=\n  (IsSelfAdjoint.all x).starHom_apply f\n\nsection Semigroup\n\nvariable [Semigroup R] [StarMul R]\n\ntheorem conjugate {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (z * x * star z) := by\n  simp only [isSelfAdjoint_iff, star_mul, star_star, mul_assoc, hx.star_eq]\n#align is_self_adjoint.conjugate IsSelfAdjoint.conjugate\n\n"}
{"name": "isPrime_carrier188", "split": "test", "formal_statement": "theorem isPrime_carrier : Ideal.IsPrime (carrier x) := by", "header": "\nimport Mathlib.AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf\nimport Mathlib.AlgebraicGeometry.GammaSpecAdjunction\nimport Mathlib.RingTheory.GradedAlgebra.Radical\n\n#align_import algebraic_geometry.projective_spectrum.scheme from \"leanprover-community/mathlib\"@\"d39590fc8728fbf6743249802486f8c91ffe07bc\"\n\n\n\n\nnoncomputable section\n\nset_option linter.uppercaseLean3 false\n\nnamespace AlgebraicGeometry\n\nopen scoped DirectSum Pointwise\n\nopen DirectSum SetLike.GradedMonoid Localization\n\nopen Finset hiding mk_zero\n\nvariable {R A : Type*}\nvariable [CommRing R] [CommRing A] [Algebra R A]\nvariable (\ud835\udc9c : \u2115 \u2192 Submodule R A)\nvariable [GradedAlgebra \ud835\udc9c]\n\nopen TopCat TopologicalSpace\n\nopen CategoryTheory Opposite\n\nopen ProjectiveSpectrum.StructureSheaf\n\n-- Porting note: currently require lack of hygiene to use in variable declarations\n-- maybe all make into notation3?\nset_option hygiene false\n\nlocal notation3 \"Proj\" => Proj.toLocallyRingedSpace \ud835\udc9c\n\n\nlocal notation3 \"Proj.T\" => PresheafedSpace.carrier <| SheafedSpace.toPresheafedSpace\n  <| LocallyRingedSpace.toSheafedSpace <| Proj.toLocallyRingedSpace \ud835\udc9c\n\n\nmacro \"Proj| \" U:term : term =>\n  `((Proj.toLocallyRingedSpace \ud835\udc9c).restrict (Opens.openEmbedding (X := Proj.T) ($U : Opens Proj.T)))\n\n\nlocal notation \"Proj.T| \" U => PresheafedSpace.carrier <| SheafedSpace.toPresheafedSpace\n  <| LocallyRingedSpace.toSheafedSpace\n    <| (LocallyRingedSpace.restrict Proj (Opens.openEmbedding (X := Proj.T) (U : Opens Proj.T)))\n\n\nlocal notation \"pbo \" x => ProjectiveSpectrum.basicOpen \ud835\udc9c x\n\n\nlocal notation \"sbo \" f => PrimeSpectrum.basicOpen f\n\n\nlocal notation3 \"Spec \" ring => Spec.locallyRingedSpaceObj (CommRingCat.of ring)\n\n\nlocal notation \"Spec.T \" ring =>\n  (Spec.locallyRingedSpaceObj (CommRingCat.of ring)).toSheafedSpace.toPresheafedSpace.1\n\nlocal notation3 \"A\u2070_ \" f => HomogeneousLocalization.Away \ud835\udc9c f\n\nnamespace ProjIsoSpecTopComponent\n\n\nnamespace ToSpec\n\nopen Ideal\n\n-- This section is to construct the forward direction :\n-- So for any `x` in `Proj| (pbo f)`, we need some point in `Spec A\u2070_f`, i.e. a prime ideal,\n-- and we need this correspondence to be continuous in their Zariski topology.\nvariable {\ud835\udc9c} {f : A} {m : \u2115} (f_deg : f \u2208 \ud835\udc9c m) (x : Proj| (pbo f))\n\n\ndef carrier : Ideal (A\u2070_ f) :=\n  Ideal.comap (algebraMap (A\u2070_ f) (Away f))\n    (x.val.asHomogeneousIdeal.toIdeal.map (algebraMap A (Away f)))\n#align algebraic_geometry.Proj_iso_Spec_Top_component.to_Spec.carrier AlgebraicGeometry.ProjIsoSpecTopComponent.ToSpec.carrier\n\n@[simp]\ntheorem mk_mem_carrier (z : HomogeneousLocalization.NumDenSameDeg \ud835\udc9c (.powers f)) :\n    HomogeneousLocalization.mk z \u2208 carrier x \u2194 z.num.1 \u2208 x.1.asHomogeneousIdeal := by\n  rw [carrier, Ideal.mem_comap, HomogeneousLocalization.algebraMap_apply,\n    HomogeneousLocalization.val_mk, Localization.mk_eq_mk', IsLocalization.mk'_eq_mul_mk'_one,\n    mul_comm, Ideal.unit_mul_mem_iff_mem, \u2190 Ideal.mem_comap,\n    IsLocalization.comap_map_of_isPrime_disjoint (.powers f)]\n  \u00b7 rfl\n  \u00b7 infer_instance\n  \u00b7 exact (disjoint_powers_iff_not_mem _ (Ideal.IsPrime.isRadical inferInstance)).mpr x.2\n  \u00b7 exact isUnit_of_invertible _\n\n"}
{"name": "unop_left_comp_underlyingIso_hom_unop189", "split": "test", "formal_statement": "theorem unop_left_comp_underlyingIso_hom_unop {A : CostructuredArrow S T}\n    {P : (CostructuredArrow S T)\u1d52\u1d56} (f : P \u27f6 op A) [Mono f.unop.left.op] :\n    f.unop.left \u226b (Subobject.underlyingIso f.unop.left.op).hom.unop =\n      (Subobject.mk f.unop.left.op).arrow.unop := by", "header": "\nimport Mathlib.CategoryTheory.Subobject.WellPowered\nimport Mathlib.CategoryTheory.Limits.Preserves.Finite\nimport Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits\n\n#align_import category_theory.subobject.comma from \"leanprover-community/mathlib\"@\"70fd9563a21e7b963887c9360bd29b2393e6225a\"\n\n\n\nnoncomputable section\n\nopen CategoryTheory.Limits Opposite\n\nuniverse v u\u2081 u\u2082\n\nnamespace CategoryTheory\n\nvariable {C : Type u\u2081} [Category.{v} C] {D : Type u\u2082} [Category.{v} D]\n\nnamespace CostructuredArrow\n\nvariable {S : C \u2964 D} {T : D}\n\n\ndef projectQuotient [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T} :\n    Subobject (op A) \u2192 Subobject (op A.left) := by\n  refine Subobject.lift (fun P f hf => Subobject.mk f.unop.left.op) ?_\n  intro P Q f g hf hg i hi\n  refine Subobject.mk_eq_mk_of_comm _ _ ((proj S T).mapIso i.unop).op (Quiver.Hom.unop_inj ?_)\n  have := congr_arg Quiver.Hom.unop hi\n  simpa using congr_arg CommaMorphism.left this\n#align category_theory.costructured_arrow.project_quotient CategoryTheory.CostructuredArrow.projectQuotient\n\n@[simp]\ntheorem projectQuotient_mk [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T}\n    {P : (CostructuredArrow S T)\u1d52\u1d56} (f : P \u27f6 op A) [Mono f] :\n    projectQuotient (Subobject.mk f) = Subobject.mk f.unop.left.op :=\n  rfl\n#align category_theory.costructured_arrow.project_quotient_mk CategoryTheory.CostructuredArrow.projectQuotient_mk\n\ntheorem projectQuotient_factors [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T} :\n    \u2200 P : Subobject (op A), \u2203 q, S.map (projectQuotient P).arrow.unop \u226b q = A.hom :=\n  Subobject.ind _ fun P f hf =>\n    \u27e8S.map (Subobject.underlyingIso _).unop.inv \u226b P.unop.hom, by\n      dsimp\n      rw [\u2190 Category.assoc, \u2190 S.map_comp, \u2190 unop_comp]\n      simp\u27e9\n#align category_theory.costructured_arrow.project_quotient_factors CategoryTheory.CostructuredArrow.projectQuotient_factors\n\n\n@[simp]\ndef liftQuotient {A : CostructuredArrow S T} (P : Subobject (op A.left)) {q}\n    (hq : S.map P.arrow.unop \u226b q = A.hom) : Subobject (op A) :=\n  Subobject.mk (homMk P.arrow.unop hq : A \u27f6 mk q).op\n#align category_theory.costructured_arrow.lift_quotient CategoryTheory.CostructuredArrow.liftQuotient\n\n\n@[simp]\n"}
{"name": "sum_measure190", "split": "test", "formal_statement": "theorem sum_measure [Countable \u03b9] {\u03bc : \u03b9 \u2192 Measure \u03b1} (h : \u2200 i, AEMeasurable f (\u03bc i)) :\n    AEMeasurable f (sum \u03bc) := by", "header": "\nimport Mathlib.MeasureTheory.Measure.Trim\nimport Mathlib.MeasureTheory.MeasurableSpace.CountablyGenerated\n\n#align_import measure_theory.measure.ae_measurable from \"leanprover-community/mathlib\"@\"3310acfa9787aa171db6d4cba3945f6f275fe9f2\"\n\n\n\nopen scoped Classical\nopen MeasureTheory MeasureTheory.Measure Filter Set Function ENNReal\n\nvariable {\u03b9 \u03b1 \u03b2 \u03b3 \u03b4 R : Type*} {m0 : MeasurableSpace \u03b1} [MeasurableSpace \u03b2] [MeasurableSpace \u03b3]\n  [MeasurableSpace \u03b4] {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}\n\nsection\n\n@[nontriviality, measurability]\ntheorem Subsingleton.aemeasurable [Subsingleton \u03b1] : AEMeasurable f \u03bc :=\n  Subsingleton.measurable.aemeasurable\n#align subsingleton.ae_measurable Subsingleton.aemeasurable\n\n@[nontriviality, measurability]\ntheorem aemeasurable_of_subsingleton_codomain [Subsingleton \u03b2] : AEMeasurable f \u03bc :=\n  (measurable_of_subsingleton_codomain f).aemeasurable\n#align ae_measurable_of_subsingleton_codomain aemeasurable_of_subsingleton_codomain\n\n@[simp, measurability]\ntheorem aemeasurable_zero_measure : AEMeasurable f (0 : Measure \u03b1) := by\n  nontriviality \u03b1; inhabit \u03b1\n  exact \u27e8fun _ => f default, measurable_const, rfl\u27e9\n#align ae_measurable_zero_measure aemeasurable_zero_measure\n\ntheorem aemeasurable_id'' (\u03bc : Measure \u03b1) {m : MeasurableSpace \u03b1} (hm : m \u2264 m0) :\n    @AEMeasurable \u03b1 \u03b1 m m0 id \u03bc :=\n  @Measurable.aemeasurable \u03b1 \u03b1 m0 m id \u03bc (measurable_id'' hm)\n#align probability_theory.ae_measurable_id'' aemeasurable_id''\n\nlemma aemeasurable_of_map_neZero {m\u03b2 : MeasurableSpace \u03b2} {\u03bc : Measure \u03b1}\n    {f : \u03b1 \u2192 \u03b2} (h : NeZero (\u03bc.map f)) :\n    AEMeasurable f \u03bc := by\n  by_contra h'\n  simp [h'] at h\n\nnamespace AEMeasurable\n\nlemma mono_ac (hf : AEMeasurable f \u03bd) (h\u03bc\u03bd : \u03bc \u226a \u03bd) : AEMeasurable f \u03bc :=\n  \u27e8hf.mk f, hf.measurable_mk, h\u03bc\u03bd.ae_le hf.ae_eq_mk\u27e9\n\ntheorem mono_measure (h : AEMeasurable f \u03bc) (h' : \u03bd \u2264 \u03bc) : AEMeasurable f \u03bd :=\n  mono_ac h h'.absolutelyContinuous\n#align ae_measurable.mono_measure AEMeasurable.mono_measure\n\ntheorem mono_set {s t} (h : s \u2286 t) (ht : AEMeasurable f (\u03bc.restrict t)) :\n    AEMeasurable f (\u03bc.restrict s) :=\n  ht.mono_measure (restrict_mono h le_rfl)\n#align ae_measurable.mono_set AEMeasurable.mono_set\n\nprotected theorem mono' (h : AEMeasurable f \u03bc) (h' : \u03bd \u226a \u03bc) : AEMeasurable f \u03bd :=\n  \u27e8h.mk f, h.measurable_mk, h' h.ae_eq_mk\u27e9\n#align ae_measurable.mono' AEMeasurable.mono'\n\ntheorem ae_mem_imp_eq_mk {s} (h : AEMeasurable f (\u03bc.restrict s)) :\n    \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x = h.mk f x :=\n  ae_imp_of_ae_restrict h.ae_eq_mk\n#align ae_measurable.ae_mem_imp_eq_mk AEMeasurable.ae_mem_imp_eq_mk\n\ntheorem ae_inf_principal_eq_mk {s} (h : AEMeasurable f (\u03bc.restrict s)) : f =\u1da0[ae \u03bc \u2293 \ud835\udcdf s] h.mk f :=\n  le_ae_restrict h.ae_eq_mk\n#align ae_measurable.ae_inf_principal_eq_mk AEMeasurable.ae_inf_principal_eq_mk\n\n@[measurability]\n"}
{"name": "Sbtw.dist_lt_max_dist191", "split": "test", "formal_statement": "theorem Sbtw.dist_lt_max_dist (p : P) {p\u2081 p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) :\n    dist p\u2082 p < max (dist p\u2081 p) (dist p\u2083 p) := by", "header": "\nimport Mathlib.Analysis.Convex.Between\nimport Mathlib.Analysis.Convex.StrictConvexSpace\nimport Mathlib.Analysis.NormedSpace.AffineIsometry\n\n#align_import analysis.convex.strict_convex_between from \"leanprover-community/mathlib\"@\"e1730698f86560a342271c0471e4cb72d021aabf\"\n\n\n\nopen Metric\nopen scoped Convex\n\nvariable {V P : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\nvariable [StrictConvexSpace \u211d V]\n\nsection PseudoMetricSpace\nvariable [PseudoMetricSpace P] [NormedAddTorsor V P]\n\n"}
{"name": "IsG\u03b4.biInter192", "split": "test", "formal_statement": "theorem IsG\u03b4.biInter {s : Set \u03b9} (hs : s.Countable) {t : \u2200 i \u2208 s, Set X}\n    (ht : \u2200 (i) (hi : i \u2208 s), IsG\u03b4 (t i hi)) : IsG\u03b4 (\u22c2 i \u2208 s, t i \u2039_\u203a) := by", "header": "\nimport Mathlib.Topology.UniformSpace.Basic\nimport Mathlib.Topology.Separation\nimport Mathlib.Order.Filter.CountableInter\n\n#align_import topology.G_delta from \"leanprover-community/mathlib\"@\"b9e46fe101fc897fb2e7edaf0bf1f09ea49eb81a\"\n\n\n\n\nnoncomputable section\n\nopen Topology TopologicalSpace Filter Encodable Set\nopen scoped Uniformity\n\nvariable {X Y \u03b9 : Type*} {\u03b9' : Sort*}\n\nset_option linter.uppercaseLean3 false\n\nsection IsG\u03b4\n\nvariable [TopologicalSpace X]\n\n\ndef IsG\u03b4 (s : Set X) : Prop :=\n  \u2203 T : Set (Set X), (\u2200 t \u2208 T, IsOpen t) \u2227 T.Countable \u2227 s = \u22c2\u2080 T\n#align is_G\u03b4 IsG\u03b4\n\n\ntheorem IsOpen.isG\u03b4 {s : Set X} (h : IsOpen s) : IsG\u03b4 s :=\n  \u27e8{s}, by simp [h], countable_singleton _, (Set.sInter_singleton _).symm\u27e9\n#align is_open.is_G\u03b4 IsOpen.isG\u03b4\n\n@[simp]\nprotected theorem IsG\u03b4.empty : IsG\u03b4 (\u2205 : Set X) :=\n  isOpen_empty.isG\u03b4\n#align is_G\u03b4_empty IsG\u03b4.empty\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_empty := IsG\u03b4.empty\n\n@[simp]\nprotected theorem IsG\u03b4.univ : IsG\u03b4 (univ : Set X) :=\n  isOpen_univ.isG\u03b4\n#align is_G\u03b4_univ IsG\u03b4.univ\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_univ := IsG\u03b4.univ\n\ntheorem IsG\u03b4.biInter_of_isOpen {I : Set \u03b9} (hI : I.Countable) {f : \u03b9 \u2192 Set X}\n    (hf : \u2200 i \u2208 I, IsOpen (f i)) : IsG\u03b4 (\u22c2 i \u2208 I, f i) :=\n  \u27e8f '' I, by rwa [forall_mem_image], hI.image _, by rw [sInter_image]\u27e9\n#align is_G\u03b4_bInter_of_open IsG\u03b4.biInter_of_isOpen\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_biInter_of_isOpen := IsG\u03b4.biInter_of_isOpen\n\ntheorem IsG\u03b4.iInter_of_isOpen [Countable \u03b9'] {f : \u03b9' \u2192 Set X} (hf : \u2200 i, IsOpen (f i)) :\n    IsG\u03b4 (\u22c2 i, f i) :=\n  \u27e8range f, by rwa [forall_mem_range], countable_range _, by rw [sInter_range]\u27e9\n#align is_G\u03b4_Inter_of_open IsG\u03b4.iInter_of_isOpen\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_iInter_of_isOpen := IsG\u03b4.iInter_of_isOpen\n\nlemma isG\u03b4_iff_eq_iInter_nat {s : Set X} :\n    IsG\u03b4 s \u2194 \u2203 (f : \u2115 \u2192 Set X), (\u2200 n, IsOpen (f n)) \u2227 s = \u22c2 n, f n := by\n  refine \u27e8?_, ?_\u27e9\n  \u00b7 rintro \u27e8T, hT, T_count, rfl\u27e9\n    rcases Set.eq_empty_or_nonempty T with rfl|hT\n    \u00b7 exact \u27e8fun _n \u21a6 univ, fun _n \u21a6 isOpen_univ, by simp\u27e9\n    \u00b7 obtain \u27e8f, hf\u27e9 : \u2203 (f : \u2115 \u2192 Set X), T = range f := Countable.exists_eq_range T_count hT\n      exact \u27e8f, by aesop, by simp [hf]\u27e9\n  \u00b7 rintro \u27e8f, hf, rfl\u27e9\n    exact .iInter_of_isOpen hf\n\nalias \u27e8IsG\u03b4.eq_iInter_nat, _\u27e9 := isG\u03b4_iff_eq_iInter_nat\n\n\nprotected theorem IsG\u03b4.iInter [Countable \u03b9'] {s : \u03b9' \u2192 Set X} (hs : \u2200 i, IsG\u03b4 (s i)) :\n    IsG\u03b4 (\u22c2 i, s i) := by\n  choose T hTo hTc hTs using hs\n  obtain rfl : s = fun i => \u22c2\u2080 T i := funext hTs\n  refine \u27e8\u22c3 i, T i, ?_, countable_iUnion hTc, (sInter_iUnion _).symm\u27e9\n  simpa [@forall_swap \u03b9'] using hTo\n#align is_G\u03b4_Inter IsG\u03b4.iInter\n\n@[deprecated] alias isG\u03b4_iInter := IsG\u03b4.iInter\n\n"}
{"name": "pow193", "split": "test", "formal_statement": "theorem pow {x : R} (hx : IsSelfAdjoint x) (n : \u2115) : IsSelfAdjoint (x ^ n) := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Basic\nimport Mathlib.Algebra.Module.Defs\nimport Mathlib.Algebra.Star.Pi\n\n#align_import algebra.star.self_adjoint from \"leanprover-community/mathlib\"@\"a6ece35404f60597c651689c1b46ead86de5ac1b\"\n\n\n\nopen Function\n\nvariable {R A : Type*}\n\n\ndef IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x\n#align is_self_adjoint IsSelfAdjoint\n\n\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x\n#align is_star_normal IsStarNormal\n\nexport IsStarNormal (star_comm_self)\n\ntheorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n#align star_comm_self' star_comm_self'\n\nnamespace IsSelfAdjoint\n\n-- named to match `Commute.all\u2093`\n\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n#align is_self_adjoint.all IsSelfAdjoint.all\n\ntheorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n#align is_self_adjoint.star_eq IsSelfAdjoint.star_eq\n\ntheorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x :=\n  Iff.rfl\n#align is_self_adjoint_iff isSelfAdjoint_iff\n\n@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n#align is_self_adjoint.star_iff IsSelfAdjoint.star_iff\n\n@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint, star_mul, star_star]\n#align is_self_adjoint.star_mul_self IsSelfAdjoint.star_mul_self\n\n@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n#align is_self_adjoint.mul_star_self IsSelfAdjoint.mul_star_self\n\n\nlemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n\n\ntheorem starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S] [StarHomClass F R S]\n    {x : R} (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x) :=\n  show star (f x) = f x from map_star f x \u25b8 congr_arg f hx\n#align is_self_adjoint.star_hom_apply IsSelfAdjoint.starHom_apply\n\n\ntheorem _root_.isSelfAdjoint_starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S]\n    [StarHomClass F R S] [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x) :=\n  (IsSelfAdjoint.all x).starHom_apply f\n\nsection Monoid\n\nvariable [Monoid R] [StarMul R]\n\n"}
{"name": "abs_lt_one_iff194", "split": "test", "formal_statement": "theorem abs_lt_one_iff {a : \u2124} : |a| < 1 \u2194 a = 0 := by", "header": "\nimport Mathlib.Algebra.Group.Int\nimport Mathlib.Algebra.Order.Group.Abs\n\n#align_import data.int.order.basic from \"leanprover-community/mathlib\"@\"e8638a0fcaf73e4500469f368ef9494e495099b3\"\n\n\n\n-- We should need only a minimal development of sets in order to get here.\nassert_not_exists Set.Subsingleton\n\nassert_not_exists Ring\n\nopen Function Nat\n\nnamespace Int\n\ntheorem natCast_strictMono : StrictMono (\u00b7 : \u2115 \u2192 \u2124) := fun _ _ \u21a6 Int.ofNat_lt.2\n#align int.coe_nat_strict_mono Int.natCast_strictMono\n\n@[deprecated (since := \"2024-05-25\")] alias coe_nat_strictMono := natCast_strictMono\n\ninstance linearOrderedAddCommGroup : LinearOrderedAddCommGroup \u2124 where\n  __ := instLinearOrder\n  __ := instAddCommGroup\n  add_le_add_left _ _ := Int.add_le_add_left\n\n\n\ntheorem abs_eq_natAbs : \u2200 a : \u2124, |a| = natAbs a\n  | (n : \u2115) => abs_of_nonneg <| ofNat_zero_le _\n  | -[_+1] => abs_of_nonpos <| le_of_lt <| negSucc_lt_zero _\n#align int.abs_eq_nat_abs Int.abs_eq_natAbs\n\n@[simp, norm_cast] lemma natCast_natAbs (n : \u2124) : (n.natAbs : \u2124) = |n| := n.abs_eq_natAbs.symm\n#align int.coe_nat_abs Int.natCast_natAbs\n\ntheorem natAbs_abs (a : \u2124) : natAbs |a| = natAbs a := by rw [abs_eq_natAbs]; rfl\n#align int.nat_abs_abs Int.natAbs_abs\n\ntheorem sign_mul_abs (a : \u2124) : sign a * |a| = a := by\n  rw [abs_eq_natAbs, sign_mul_natAbs a]\n#align int.sign_mul_abs Int.sign_mul_abs\n\nlemma natAbs_le_self_sq (a : \u2124) : (Int.natAbs a : \u2124) \u2264 a ^ 2 := by\n  rw [\u2190 Int.natAbs_sq a, sq]\n  norm_cast\n  apply Nat.le_mul_self\n#align int.abs_le_self_sq Int.natAbs_le_self_sq\n\nalias natAbs_le_self_pow_two := natAbs_le_self_sq\n\nlemma le_self_sq (b : \u2124) : b \u2264 b ^ 2 := le_trans le_natAbs (natAbs_le_self_sq _)\n#align int.le_self_sq Int.le_self_sq\n\nalias le_self_pow_two := le_self_sq\n#align int.le_self_pow_two Int.le_self_pow_two\n\n@[norm_cast] lemma abs_natCast (n : \u2115) : |(n : \u2124)| = n := abs_of_nonneg (natCast_nonneg n)\n#align int.abs_coe_nat Int.abs_natCast\n\ntheorem natAbs_sub_pos_iff {i j : \u2124} : 0 < natAbs (i - j) \u2194 i \u2260 j := by\n  rw [natAbs_pos, ne_eq, sub_eq_zero]\n\ntheorem natAbs_sub_ne_zero_iff {i j : \u2124} : natAbs (i - j) \u2260 0 \u2194 i \u2260 j :=\n  Nat.ne_zero_iff_zero_lt.trans natAbs_sub_pos_iff\n\n@[simp]\n"}
{"name": "SupIrred.ne_bot195", "split": "test", "formal_statement": "theorem SupIrred.ne_bot (ha : SupIrred a) : a \u2260 \u22a5 := by", "header": "\nimport Mathlib.Data.Finset.Lattice\n\n#align_import order.irreducible from \"leanprover-community/mathlib\"@\"bf2428c9486c407ca38b5b3fb10b87dad0bc99fa\"\n\n\n\n\nopen Finset OrderDual\n\nvariable {\u03b9 \u03b1 : Type*}\n\n\n\n\nsection SemilatticeSup\n\nvariable [SemilatticeSup \u03b1] {a b c : \u03b1}\n\n\ndef SupIrred (a : \u03b1) : Prop :=\n  \u00acIsMin a \u2227 \u2200 \u2983b c\u2984, b \u2294 c = a \u2192 b = a \u2228 c = a\n#align sup_irred SupIrred\n\n\ndef SupPrime (a : \u03b1) : Prop :=\n  \u00acIsMin a \u2227 \u2200 \u2983b c\u2984, a \u2264 b \u2294 c \u2192 a \u2264 b \u2228 a \u2264 c\n#align sup_prime SupPrime\n\ntheorem SupIrred.not_isMin (ha : SupIrred a) : \u00acIsMin a :=\n  ha.1\n#align sup_irred.not_is_min SupIrred.not_isMin\n\ntheorem SupPrime.not_isMin (ha : SupPrime a) : \u00acIsMin a :=\n  ha.1\n#align sup_prime.not_is_min SupPrime.not_isMin\n\ntheorem IsMin.not_supIrred (ha : IsMin a) : \u00acSupIrred a := fun h => h.1 ha\n#align is_min.not_sup_irred IsMin.not_supIrred\n\ntheorem IsMin.not_supPrime (ha : IsMin a) : \u00acSupPrime a := fun h => h.1 ha\n#align is_min.not_sup_prime IsMin.not_supPrime\n\n@[simp]\ntheorem not_supIrred : \u00acSupIrred a \u2194 IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b < a \u2227 c < a := by\n  rw [SupIrred, not_and_or]\n  push_neg\n  rw [exists\u2082_congr]\n  simp (config := { contextual := true }) [@eq_comm _ _ a]\n#align not_sup_irred not_supIrred\n\n@[simp]\ntheorem not_supPrime : \u00acSupPrime a \u2194 IsMin a \u2228 \u2203 b c, a \u2264 b \u2294 c \u2227 \u00aca \u2264 b \u2227 \u00aca \u2264 c := by\n  rw [SupPrime, not_and_or]; push_neg; rfl\n#align not_sup_prime not_supPrime\n\nprotected theorem SupPrime.supIrred : SupPrime a \u2192 SupIrred a :=\n  And.imp_right fun h b c ha => by simpa [\u2190 ha] using h ha.ge\n#align sup_prime.sup_irred SupPrime.supIrred\n\ntheorem SupPrime.le_sup (ha : SupPrime a) : a \u2264 b \u2294 c \u2194 a \u2264 b \u2228 a \u2264 c :=\n  \u27e8fun h => ha.2 h, fun h => h.elim le_sup_of_le_left le_sup_of_le_right\u27e9\n#align sup_prime.le_sup SupPrime.le_sup\n\nvariable [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}\n\n@[simp]\ntheorem not_supIrred_bot : \u00acSupIrred (\u22a5 : \u03b1) :=\n  isMin_bot.not_supIrred\n#align not_sup_irred_bot not_supIrred_bot\n\n@[simp]\ntheorem not_supPrime_bot : \u00acSupPrime (\u22a5 : \u03b1) :=\n  isMin_bot.not_supPrime\n#align not_sup_prime_bot not_supPrime_bot\n\n"}
{"name": "extend_partialOrder196", "split": "test", "formal_statement": "theorem extend_partialOrder {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsPartialOrder \u03b1 r] :\n    \u2203 s : \u03b1 \u2192 \u03b1 \u2192 Prop, IsLinearOrder \u03b1 s \u2227 r \u2264 s := by", "header": "\nimport Mathlib.Order.Zorn\n\n#align_import order.extension.linear from \"leanprover-community/mathlib\"@\"9830a300340708eaa85d477c3fb96dd25f9468a5\"\n\n\n\n\nuniverse u\n\nopen Set Classical\n\nopen scoped Classical\n\n\n"}
{"name": "map_traverse'197", "split": "test", "formal_statement": "theorem map_traverse' (g : \u03b1 \u2192 G \u03b2) (h : \u03b2 \u2192 \u03b3) :\n    traverse (map h \u2218 g) = (map (map h) \u2218 traverse g : t \u03b1 \u2192 G (t \u03b3)) := by", "header": "\nimport Mathlib.Control.Applicative\nimport Mathlib.Control.Traversable.Basic\n\n#align_import control.traversable.lemmas from \"leanprover-community/mathlib\"@\"3342d1b2178381196f818146ff79bc0e7ccd9e2d\"\n\n\n\n\nuniverse u\n\nopen LawfulTraversable\n\nopen Function hiding comp\n\nopen Functor\n\nattribute [functor_norm] LawfulTraversable.naturality\n\nattribute [simp] LawfulTraversable.id_traverse\n\nnamespace Traversable\n\nvariable {t : Type u \u2192 Type u}\nvariable [Traversable t] [LawfulTraversable t]\nvariable (F G : Type u \u2192 Type u)\nvariable [Applicative F] [LawfulApplicative F]\nvariable [Applicative G] [LawfulApplicative G]\nvariable {\u03b1 \u03b2 \u03b3 : Type u}\nvariable (g : \u03b1 \u2192 F \u03b2)\nvariable (h : \u03b2 \u2192 G \u03b3)\nvariable (f : \u03b2 \u2192 \u03b3)\n\n\ndef PureTransformation :\n    ApplicativeTransformation Id F where\n  app := @pure F _\n  preserves_pure' x := rfl\n  preserves_seq' f x := by\n    simp only [map_pure, seq_pure]\n    rfl\n#align traversable.pure_transformation Traversable.PureTransformation\n\n@[simp]\ntheorem pureTransformation_apply {\u03b1} (x : id \u03b1) : PureTransformation F x = pure x :=\n  rfl\n#align traversable.pure_transformation_apply Traversable.pureTransformation_apply\n\nvariable {F G} (x : t \u03b2)\n\n-- Porting note: need to specify `m/F/G := Id` because `id` no longer has a `Monad` instance\ntheorem map_eq_traverse_id : map (f := t) f = traverse (m := Id) (pure \u2218 f) :=\n  funext fun y => (traverse_eq_map_id f y).symm\n#align traversable.map_eq_traverse_id Traversable.map_eq_traverse_id\n\ntheorem map_traverse (x : t \u03b1) : map f <$> traverse g x = traverse (map f \u2218 g) x := by\n  rw [map_eq_traverse_id f]\n  refine (comp_traverse (pure \u2218 f) g x).symm.trans ?_\n  congr; apply Comp.applicative_comp_id\n#align traversable.map_traverse Traversable.map_traverse\n\ntheorem traverse_map (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 \u03b2) (x : t \u03b1) :\n    traverse f (g <$> x) = traverse (f \u2218 g) x := by\n  rw [@map_eq_traverse_id t _ _ _ _ g]\n  refine (comp_traverse (G := Id) f (pure \u2218 g) x).symm.trans ?_\n  congr; apply Comp.applicative_id_comp\n#align traversable.traverse_map Traversable.traverse_map\n\ntheorem pure_traverse (x : t \u03b1) : traverse pure x = (pure x : F (t \u03b1)) := by\n  have : traverse pure x = pure (traverse (m := Id) pure x) :=\n      (naturality (PureTransformation F) pure x).symm\n  rwa [id_traverse] at this\n#align traversable.pure_traverse Traversable.pure_traverse\n\ntheorem id_sequence (x : t \u03b1) : sequence (f := Id) (pure <$> x) = pure x := by\n  simp [sequence, traverse_map, id_traverse]\n#align traversable.id_sequence Traversable.id_sequence\n\ntheorem comp_sequence (x : t (F (G \u03b1))) :\n    sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x) := by\n  simp only [sequence, traverse_map, id_comp]; rw [\u2190 comp_traverse]; simp [map_id]\n#align traversable.comp_sequence Traversable.comp_sequence\n\ntheorem naturality' (\u03b7 : ApplicativeTransformation F G) (x : t (F \u03b1)) :\n    \u03b7 (sequence x) = sequence (@\u03b7 _ <$> x) := by simp [sequence, naturality, traverse_map]\n#align traversable.naturality' Traversable.naturality'\n\n@[functor_norm]\ntheorem traverse_id : traverse pure = (pure : t \u03b1 \u2192 Id (t \u03b1)) := by\n  ext\n  exact id_traverse _\n#align traversable.traverse_id Traversable.traverse_id\n\n@[functor_norm]\ntheorem traverse_comp (g : \u03b1 \u2192 F \u03b2) (h : \u03b2 \u2192 G \u03b3) :\n    traverse (Comp.mk \u2218 map h \u2218 g) =\n      (Comp.mk \u2218 map (traverse h) \u2218 traverse g : t \u03b1 \u2192 Comp F G (t \u03b3)) := by\n  ext\n  exact comp_traverse _ _ _\n#align traversable.traverse_comp Traversable.traverse_comp\n\ntheorem traverse_eq_map_id' (f : \u03b2 \u2192 \u03b3) :\n    traverse (m := Id) (pure \u2218 f) = pure \u2218 (map f : t \u03b2 \u2192 t \u03b3) := by\n  ext\n  exact traverse_eq_map_id _ _\n#align traversable.traverse_eq_map_id' Traversable.traverse_eq_map_id'\n\n-- @[functor_norm]\ntheorem traverse_map' (g : \u03b1 \u2192 \u03b2) (h : \u03b2 \u2192 G \u03b3) :\n    traverse (h \u2218 g) = (traverse h \u2218 map g : t \u03b1 \u2192 G (t \u03b3)) := by\n  ext\n  rw [comp_apply, traverse_map]\n#align traversable.traverse_map' Traversable.traverse_map'\n\n"}
{"name": "Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax198", "split": "test", "formal_statement": "theorem Complex.norm_eventually_eq_of_mdifferentiableAt_of_isLocalMax {f : M \u2192 F} {c : M}\n    (hd : \u2200\u1da0 z in \ud835\udcdd c, MDifferentiableAt I \ud835\udcd8(\u2102, F) f z) (hc : IsLocalMax (norm \u2218 f) c) :\n    \u2200\u1da0 y in \ud835\udcdd c, \u2016f y\u2016 = \u2016f c\u2016 := by", "header": "\nimport Mathlib.Analysis.Complex.AbsMax\nimport Mathlib.Analysis.LocallyConvex.WithSeminorms\nimport Mathlib.Geometry.Manifold.MFDeriv.Basic\nimport Mathlib.Topology.LocallyConstant.Basic\n\n#align_import geometry.manifold.complex from \"leanprover-community/mathlib\"@\"f2ce6086713c78a7f880485f7917ea547a215982\"\n\n\n\nopen scoped Manifold Topology Filter\nopen Function Set Filter Complex\n\nvariable {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]\nvariable {F : Type*} [NormedAddCommGroup F] [NormedSpace \u2102 F]\nvariable {H : Type*} [TopologicalSpace H] {I : ModelWithCorners \u2102 E H} [I.Boundaryless]\nvariable {M : Type*} [TopologicalSpace M] [CompactSpace M] [ChartedSpace H M]\n  [SmoothManifoldWithCorners I M]\n\n\n"}
{"name": "denomsClearable_C_mul_X_pow199", "split": "test", "formal_statement": "theorem denomsClearable_C_mul_X_pow {N : \u2115} (a : R) (bu : bi * i b = 1) {n : \u2115} (r : R)\n    (nN : n \u2264 N) : DenomsClearable a b N (C r * X ^ n) i := by", "header": "\nimport Mathlib.Algebra.Polynomial.EraseLead\nimport Mathlib.Algebra.Polynomial.Eval\n\n#align_import data.polynomial.denoms_clearable from \"leanprover-community/mathlib\"@\"85d9f2189d9489f9983c0d01536575b0233bd305\"\n\n\n\n\nopen Polynomial Finset\n\nopen Polynomial\n\nsection DenomsClearable\n\nvariable {R K : Type*} [Semiring R] [CommSemiring K] {i : R \u2192+* K}\nvariable {a b : R} {bi : K}\n\n-- TODO: use hypothesis (ub : IsUnit (i b)) to work with localizations.\n\ndef DenomsClearable (a b : R) (N : \u2115) (f : R[X]) (i : R \u2192+* K) : Prop :=\n  \u2203 (D : R) (bi : K), bi * i b = 1 \u2227 i D = i b ^ N * eval (i a * bi) (f.map i)\n#align denoms_clearable DenomsClearable\n\ntheorem denomsClearable_zero (N : \u2115) (a : R) (bu : bi * i b = 1) : DenomsClearable a b N 0 i :=\n  \u27e80, bi, bu, by\n    simp only [eval_zero, RingHom.map_zero, mul_zero, Polynomial.map_zero]\u27e9\n#align denoms_clearable_zero denomsClearable_zero\n\n"}
{"name": "SupPrime.ne_bot200", "split": "test", "formal_statement": "theorem SupPrime.ne_bot (ha : SupPrime a) : a \u2260 \u22a5 := by", "header": "\nimport Mathlib.Data.Finset.Lattice\n\n#align_import order.irreducible from \"leanprover-community/mathlib\"@\"bf2428c9486c407ca38b5b3fb10b87dad0bc99fa\"\n\n\n\n\nopen Finset OrderDual\n\nvariable {\u03b9 \u03b1 : Type*}\n\n\n\n\nsection SemilatticeSup\n\nvariable [SemilatticeSup \u03b1] {a b c : \u03b1}\n\n\ndef SupIrred (a : \u03b1) : Prop :=\n  \u00acIsMin a \u2227 \u2200 \u2983b c\u2984, b \u2294 c = a \u2192 b = a \u2228 c = a\n#align sup_irred SupIrred\n\n\ndef SupPrime (a : \u03b1) : Prop :=\n  \u00acIsMin a \u2227 \u2200 \u2983b c\u2984, a \u2264 b \u2294 c \u2192 a \u2264 b \u2228 a \u2264 c\n#align sup_prime SupPrime\n\ntheorem SupIrred.not_isMin (ha : SupIrred a) : \u00acIsMin a :=\n  ha.1\n#align sup_irred.not_is_min SupIrred.not_isMin\n\ntheorem SupPrime.not_isMin (ha : SupPrime a) : \u00acIsMin a :=\n  ha.1\n#align sup_prime.not_is_min SupPrime.not_isMin\n\ntheorem IsMin.not_supIrred (ha : IsMin a) : \u00acSupIrred a := fun h => h.1 ha\n#align is_min.not_sup_irred IsMin.not_supIrred\n\ntheorem IsMin.not_supPrime (ha : IsMin a) : \u00acSupPrime a := fun h => h.1 ha\n#align is_min.not_sup_prime IsMin.not_supPrime\n\n@[simp]\ntheorem not_supIrred : \u00acSupIrred a \u2194 IsMin a \u2228 \u2203 b c, b \u2294 c = a \u2227 b < a \u2227 c < a := by\n  rw [SupIrred, not_and_or]\n  push_neg\n  rw [exists\u2082_congr]\n  simp (config := { contextual := true }) [@eq_comm _ _ a]\n#align not_sup_irred not_supIrred\n\n@[simp]\ntheorem not_supPrime : \u00acSupPrime a \u2194 IsMin a \u2228 \u2203 b c, a \u2264 b \u2294 c \u2227 \u00aca \u2264 b \u2227 \u00aca \u2264 c := by\n  rw [SupPrime, not_and_or]; push_neg; rfl\n#align not_sup_prime not_supPrime\n\nprotected theorem SupPrime.supIrred : SupPrime a \u2192 SupIrred a :=\n  And.imp_right fun h b c ha => by simpa [\u2190 ha] using h ha.ge\n#align sup_prime.sup_irred SupPrime.supIrred\n\ntheorem SupPrime.le_sup (ha : SupPrime a) : a \u2264 b \u2294 c \u2194 a \u2264 b \u2228 a \u2264 c :=\n  \u27e8fun h => ha.2 h, fun h => h.elim le_sup_of_le_left le_sup_of_le_right\u27e9\n#align sup_prime.le_sup SupPrime.le_sup\n\nvariable [OrderBot \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}\n\n@[simp]\ntheorem not_supIrred_bot : \u00acSupIrred (\u22a5 : \u03b1) :=\n  isMin_bot.not_supIrred\n#align not_sup_irred_bot not_supIrred_bot\n\n@[simp]\ntheorem not_supPrime_bot : \u00acSupPrime (\u22a5 : \u03b1) :=\n  isMin_bot.not_supPrime\n#align not_sup_prime_bot not_supPrime_bot\n\ntheorem SupIrred.ne_bot (ha : SupIrred a) : a \u2260 \u22a5 := by rintro rfl; exact not_supIrred_bot ha\n#align sup_irred.ne_bot SupIrred.ne_bot\n\n"}
{"name": "nadd_le_nadd_left201", "split": "test", "formal_statement": "theorem nadd_le_nadd_left (h : b \u2264 c) (a) : a \u266f b \u2264 a \u266f c := by", "header": "\nimport Mathlib.SetTheory.Ordinal.Arithmetic\nimport Mathlib.Tactic.Abel\n\n#align_import set_theory.ordinal.natural_ops from \"leanprover-community/mathlib\"@\"31b269b60935483943542d547a6dd83a66b37dc7\"\n\n\n\nset_option autoImplicit true\n\n\nuniverse u v\n\nopen Function Order\n\nnoncomputable section\n\n\n\n\ndef NatOrdinal : Type _ :=\n  -- Porting note: used to derive LinearOrder & SuccOrder but need to manually define\n  Ordinal deriving Zero, Inhabited, One, WellFoundedRelation\n#align nat_ordinal NatOrdinal\n\ninstance NatOrdinal.linearOrder : LinearOrder NatOrdinal := {Ordinal.linearOrder with}\n\ninstance NatOrdinal.succOrder : SuccOrder NatOrdinal := {Ordinal.succOrder with}\n\n\n@[match_pattern]\ndef Ordinal.toNatOrdinal : Ordinal \u2243o NatOrdinal :=\n  OrderIso.refl _\n#align ordinal.to_nat_ordinal Ordinal.toNatOrdinal\n\n\n@[match_pattern]\ndef NatOrdinal.toOrdinal : NatOrdinal \u2243o Ordinal :=\n  OrderIso.refl _\n#align nat_ordinal.to_ordinal NatOrdinal.toOrdinal\n\nnamespace Ordinal\n\nvariable {a b c : Ordinal.{u}}\n\n@[simp]\ntheorem toNatOrdinal_symm_eq : toNatOrdinal.symm = NatOrdinal.toOrdinal :=\n  rfl\n#align ordinal.to_nat_ordinal_symm_eq Ordinal.toNatOrdinal_symm_eq\n\n@[simp]\ntheorem toNatOrdinal_toOrdinal (a : Ordinal) :  NatOrdinal.toOrdinal (toNatOrdinal a) = a :=\n  rfl\n#align ordinal.to_nat_ordinal_to_ordinal Ordinal.toNatOrdinal_toOrdinal\n\n@[simp]\ntheorem toNatOrdinal_zero : toNatOrdinal 0 = 0 :=\n  rfl\n#align ordinal.to_nat_ordinal_zero Ordinal.toNatOrdinal_zero\n\n@[simp]\ntheorem toNatOrdinal_one : toNatOrdinal 1 = 1 :=\n  rfl\n#align ordinal.to_nat_ordinal_one Ordinal.toNatOrdinal_one\n\n@[simp]\ntheorem toNatOrdinal_eq_zero (a) : toNatOrdinal a = 0 \u2194 a = 0 :=\n  Iff.rfl\n#align ordinal.to_nat_ordinal_eq_zero Ordinal.toNatOrdinal_eq_zero\n\n@[simp]\ntheorem toNatOrdinal_eq_one (a) : toNatOrdinal a = 1 \u2194 a = 1 :=\n  Iff.rfl\n#align ordinal.to_nat_ordinal_eq_one Ordinal.toNatOrdinal_eq_one\n\n@[simp]\ntheorem toNatOrdinal_max (a b : Ordinal) :\n    toNatOrdinal (max a b) = max (toNatOrdinal a) (toNatOrdinal b) :=\n  rfl\n#align ordinal.to_nat_ordinal_max Ordinal.toNatOrdinal_max\n\n@[simp]\ntheorem toNatOrdinal_min (a b : Ordinal) :\n    toNatOrdinal (linearOrder.min a b) = linearOrder.min (toNatOrdinal a) (toNatOrdinal b) :=\n  rfl\n#align ordinal.to_nat_ordinal_min Ordinal.toNatOrdinal_min\n\n\n\n\nnoncomputable def nadd : Ordinal \u2192 Ordinal \u2192 Ordinal\n  | a, b =>\n    max (blsub.{u, u} a fun a' _ => nadd a' b) (blsub.{u, u} b fun b' _ => nadd a b')\n  termination_by o\u2081 o\u2082 => (o\u2081, o\u2082)\n#align ordinal.nadd Ordinal.nadd\n\n@[inherit_doc]\nscoped[NaturalOps] infixl:65 \" \u266f \" => Ordinal.nadd\n\nopen NaturalOps\n\n\nnoncomputable def nmul : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\n  | a, b => sInf {c | \u2200 a' < a, \u2200 b' < b, nmul a' b \u266f nmul a b' < c \u266f nmul a' b'}\ntermination_by a b => (a, b)\n#align ordinal.nmul Ordinal.nmul\n\n@[inherit_doc]\nscoped[NaturalOps] infixl:70 \" \u2a33 \" => Ordinal.nmul\n\n\n\ntheorem nadd_def (a b : Ordinal) :\n    a \u266f b = max (blsub.{u, u} a fun a' _ => a' \u266f b) (blsub.{u, u} b fun b' _ => a \u266f b') := by\n  rw [nadd]\n#align ordinal.nadd_def Ordinal.nadd_def\n\ntheorem lt_nadd_iff : a < b \u266f c \u2194 (\u2203 b' < b, a \u2264 b' \u266f c) \u2228 \u2203 c' < c, a \u2264 b \u266f c' := by\n  rw [nadd_def]\n  simp [lt_blsub_iff]\n#align ordinal.lt_nadd_iff Ordinal.lt_nadd_iff\n\ntheorem nadd_le_iff : b \u266f c \u2264 a \u2194 (\u2200 b' < b, b' \u266f c < a) \u2227 \u2200 c' < c, b \u266f c' < a := by\n  rw [nadd_def]\n  simp [blsub_le_iff]\n#align ordinal.nadd_le_iff Ordinal.nadd_le_iff\n\ntheorem nadd_lt_nadd_left (h : b < c) (a) : a \u266f b < a \u266f c :=\n  lt_nadd_iff.2 (Or.inr \u27e8b, h, le_rfl\u27e9)\n#align ordinal.nadd_lt_nadd_left Ordinal.nadd_lt_nadd_left\n\ntheorem nadd_lt_nadd_right (h : b < c) (a) : b \u266f a < c \u266f a :=\n  lt_nadd_iff.2 (Or.inl \u27e8b, h, le_rfl\u27e9)\n#align ordinal.nadd_lt_nadd_right Ordinal.nadd_lt_nadd_right\n\n"}
{"name": "support_eq_symm_image202", "split": "test", "formal_statement": "theorem support_eq_symm_image :\n    support f = (extChartAt I c).symm '' (ball (extChartAt I c c) f.rOut \u2229 range I) := by", "header": "\nimport Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension\nimport Mathlib.Geometry.Manifold.ContMDiff.Atlas\nimport Mathlib.Geometry.Manifold.ContMDiff.NormedSpace\n\n#align_import geometry.manifold.bump_function from \"leanprover-community/mathlib\"@\"b018406ad2f2a73223a3a9e198ccae61e6f05318\"\n\n\n\nuniverse uE uF uH uM\n\nvariable {E : Type uE} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\n  {H : Type uH} [TopologicalSpace H] (I : ModelWithCorners \u211d E H) {M : Type uM} [TopologicalSpace M]\n  [ChartedSpace H M] [SmoothManifoldWithCorners I M]\n\nopen Function Filter FiniteDimensional Set Metric\n\nopen scoped Topology Manifold Classical Filter\n\nnoncomputable section\n\n\n\n\nstructure SmoothBumpFunction (c : M) extends ContDiffBump (extChartAt I c c) where\n  closedBall_subset : closedBall (extChartAt I c c) rOut \u2229 range I \u2286 (extChartAt I c).target\n#align smooth_bump_function SmoothBumpFunction\n\nnamespace SmoothBumpFunction\n\nvariable {c : M} (f : SmoothBumpFunction I c) {x : M} {I}\n\n\n@[coe] def toFun : M \u2192 \u211d :=\n  indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c)\n#align smooth_bump_function.to_fun SmoothBumpFunction.toFun\n\ninstance : CoeFun (SmoothBumpFunction I c) fun _ => M \u2192 \u211d :=\n  \u27e8toFun\u27e9\n\ntheorem coe_def : \u21d1f = indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c) :=\n  rfl\n#align smooth_bump_function.coe_def SmoothBumpFunction.coe_def\n\ntheorem rOut_pos : 0 < f.rOut :=\n  f.toContDiffBump.rOut_pos\nset_option linter.uppercaseLean3 false in\n#align smooth_bump_function.R_pos SmoothBumpFunction.rOut_pos\n\ntheorem ball_subset : ball (extChartAt I c c) f.rOut \u2229 range I \u2286 (extChartAt I c).target :=\n  Subset.trans (inter_subset_inter_left _ ball_subset_closedBall) f.closedBall_subset\n#align smooth_bump_function.ball_subset SmoothBumpFunction.ball_subset\n\ntheorem ball_inter_range_eq_ball_inter_target :\n    ball (extChartAt I c c) f.rOut \u2229 range I =\n      ball (extChartAt I c c) f.rOut \u2229 (extChartAt I c).target :=\n  (subset_inter inter_subset_left f.ball_subset).antisymm <| inter_subset_inter_right _ <|\n    extChartAt_target_subset_range _ _\n\ntheorem eqOn_source : EqOn f (f.toContDiffBump \u2218 extChartAt I c) (chartAt H c).source :=\n  eqOn_indicator\n#align smooth_bump_function.eq_on_source SmoothBumpFunction.eqOn_source\n\ntheorem eventuallyEq_of_mem_source (hx : x \u2208 (chartAt H c).source) :\n    f =\u1da0[\ud835\udcdd x] f.toContDiffBump \u2218 extChartAt I c :=\n  f.eqOn_source.eventuallyEq_of_mem <| (chartAt H c).open_source.mem_nhds hx\n#align smooth_bump_function.eventually_eq_of_mem_source SmoothBumpFunction.eventuallyEq_of_mem_source\n\ntheorem one_of_dist_le (hs : x \u2208 (chartAt H c).source)\n    (hd : dist (extChartAt I c x) (extChartAt I c c) \u2264 f.rIn) : f x = 1 := by\n  simp only [f.eqOn_source hs, (\u00b7 \u2218 \u00b7), f.one_of_mem_closedBall hd]\n#align smooth_bump_function.one_of_dist_le SmoothBumpFunction.one_of_dist_le\n\ntheorem support_eq_inter_preimage :\n    support f = (chartAt H c).source \u2229 extChartAt I c \u207b\u00b9' ball (extChartAt I c c) f.rOut := by\n  rw [coe_def, support_indicator, support_comp_eq_preimage, \u2190 extChartAt_source I,\n    \u2190 (extChartAt I c).symm_image_target_inter_eq', \u2190 (extChartAt I c).symm_image_target_inter_eq',\n    f.support_eq]\n#align smooth_bump_function.support_eq_inter_preimage SmoothBumpFunction.support_eq_inter_preimage\n\ntheorem isOpen_support : IsOpen (support f) := by\n  rw [support_eq_inter_preimage]\n  exact isOpen_extChartAt_preimage I c isOpen_ball\n#align smooth_bump_function.is_open_support SmoothBumpFunction.isOpen_support\n\n"}
{"name": "le_infEdist203", "split": "test", "formal_statement": "theorem le_infEdist {d} : d \u2264 infEdist x s \u2194 \u2200 y \u2208 s, d \u2264 edist x y := by", "header": "\nimport Mathlib.Analysis.SpecificLimits.Basic\nimport Mathlib.Topology.MetricSpace.IsometricSMul\n\n#align_import topology.metric_space.hausdorff_distance from \"leanprover-community/mathlib\"@\"bc91ed7093bf098d253401e69df601fc33dde156\"\n\n\n\n\nnoncomputable section\n\nopen NNReal ENNReal Topology Set Filter Pointwise Bornology\n\nuniverse u v w\n\nvariable {\u03b9 : Sort*} {\u03b1 : Type u} {\u03b2 : Type v}\n\nnamespace EMetric\n\nsection InfEdist\n\nvariable [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {x y : \u03b1} {s t : Set \u03b1} {\u03a6 : \u03b1 \u2192 \u03b2}\n\n\n\n\ndef infEdist (x : \u03b1) (s : Set \u03b1) : \u211d\u22650\u221e :=\n  \u2a05 y \u2208 s, edist x y\n#align emetric.inf_edist EMetric.infEdist\n\n@[simp]\ntheorem infEdist_empty : infEdist x \u2205 = \u221e :=\n  iInf_emptyset\n#align emetric.inf_edist_empty EMetric.infEdist_empty\n\n"}
{"name": "condexp_stoppedValue_stopping_time_ae_eq_restrict_le204", "split": "test", "formal_statement": "theorem condexp_stoppedValue_stopping_time_ae_eq_restrict_le (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c3 : IsStoppingTime \u2131 \u03c3) [SigmaFinite (\u03bc.trim h\u03c3.measurableSpace_le)]\n    (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n) :\n    \u03bc[stoppedValue f \u03c4|h\u03c3.measurableSpace] =\u1d50[\u03bc.restrict {x : \u03a9 | \u03c4 x \u2264 \u03c3 x}] stoppedValue f \u03c4 := by", "header": "\nimport Mathlib.Order.SuccPred.LinearLocallyFinite\nimport Mathlib.Probability.Martingale.Basic\n\n#align_import probability.martingale.optional_sampling from \"leanprover-community/mathlib\"@\"ba074af83b6cf54c3104e59402b39410ddbd6dca\"\n\n\n\n\nopen scoped MeasureTheory ENNReal\n\nopen TopologicalSpace\n\nnamespace MeasureTheory\n\nnamespace Martingale\n\nvariable {\u03a9 E : Type*} {m : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} [NormedAddCommGroup E]\n  [NormedSpace \u211d E] [CompleteSpace E]\n\nsection SubsetOfNat\n\n\n\n\nvariable {\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrder \u03b9] [OrderBot \u03b9] [TopologicalSpace \u03b9]\n  [DiscreteTopology \u03b9] [MeasurableSpace \u03b9] [BorelSpace \u03b9] [MeasurableSpace E] [BorelSpace E]\n  [SecondCountableTopology E] {\u2131 : Filtration \u03b9 m} {\u03c4 \u03c3 : \u03a9 \u2192 \u03b9} {f : \u03b9 \u2192 \u03a9 \u2192 E} {i n : \u03b9}\n\n"}
{"name": "isPeriodicPt_mul_iff_pow_eq_one205", "split": "test", "formal_statement": "theorem isPeriodicPt_mul_iff_pow_eq_one (x : G) : IsPeriodicPt (x * \u00b7) n 1 \u2194 x ^ n = 1 := by", "header": "\nimport Mathlib.Algebra.CharP.Defs\nimport Mathlib.Algebra.GroupPower.IterateHom\nimport Mathlib.Algebra.GroupWithZero.Divisibility\nimport Mathlib.Data.Int.ModEq\nimport Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.Dynamics.PeriodicPts\nimport Mathlib.GroupTheory.Index\nimport Mathlib.Order.Interval.Finset.Nat\nimport Mathlib.Order.Interval.Set.Infinite\n\n#align_import group_theory.order_of_element from \"leanprover-community/mathlib\"@\"d07245fd37786daa997af4f1a73a49fa3b748408\"\n\n\n\nopen Function Fintype Nat Pointwise Subgroup Submonoid\n\nvariable {G H A \u03b1 \u03b2 : Type*}\n\nsection Monoid\nvariable [Monoid G] {a b x y : G} {n m : \u2115}\n\nsection IsOfFinOrder\n\n-- Porting note(#12129): additional beta reduction needed\n@[to_additive]\n"}
{"name": "min_le_left206", "split": "test", "formal_statement": "theorem min_le_left (a b : \u03b1) : min a b \u2264 a := by", "header": "\nimport Mathlib.Init.Order.Defs\n\n#align_import init.algebra.functions from \"leanprover-community/lean\"@\"c2bcdbcbe741ed37c361a30d38e179182b989f76\"\n\n\n\nuniverse u\n\nsection\n\nopen Decidable\n\nvariable {\u03b1 : Type u} [LinearOrder \u03b1]\n\ntheorem min_def (a b : \u03b1) : min a b = if a \u2264 b then a else b := by\n  rw [LinearOrder.min_def a]\n#align min_def min_def\n\ntheorem max_def (a b : \u03b1) : max a b = if a \u2264 b then b else a := by\n  rw [LinearOrder.max_def a]\n#align max_def max_def\n\n"}
{"name": "dist_birkhoffAverage_apply_birkhoffAverage207", "split": "test", "formal_statement": "theorem dist_birkhoffAverage_apply_birkhoffAverage (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x : \u03b1) :\n    dist (birkhoffAverage \ud835\udd5c f g n (f x)) (birkhoffAverage \ud835\udd5c f g n x) =\n      dist (g (f^[n] x)) (g x) / n := by", "header": "\nimport Mathlib.Analysis.RCLike.Basic\nimport Mathlib.Dynamics.BirkhoffSum.Average\n\n\n\nopen Function Set Filter\nopen scoped Topology ENNReal Uniformity\n\nsection\n\nvariable {\u03b1 E : Type*}\n\n\ntheorem Function.IsFixedPt.tendsto_birkhoffAverage\n    (R : Type*) [DivisionSemiring R] [CharZero R]\n    [AddCommMonoid E] [TopologicalSpace E] [Module R E]\n    {f : \u03b1 \u2192 \u03b1} {x : \u03b1} (h : f.IsFixedPt x) (g : \u03b1 \u2192 E) :\n    Tendsto (birkhoffAverage R f g \u00b7 x) atTop (\ud835\udcdd (g x)) :=\n  tendsto_const_nhds.congr' <| (eventually_ne_atTop 0).mono fun _n hn \u21a6\n    (h.birkhoffAverage_eq R g hn).symm\n\nvariable [NormedAddCommGroup E]\n\ntheorem dist_birkhoffSum_apply_birkhoffSum (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x : \u03b1) :\n    dist (birkhoffSum f g n (f x)) (birkhoffSum f g n x) = dist (g (f^[n] x)) (g x) := by\n  simp only [dist_eq_norm, birkhoffSum_apply_sub_birkhoffSum]\n\ntheorem dist_birkhoffSum_birkhoffSum_le (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x y : \u03b1) :\n    dist (birkhoffSum f g n x) (birkhoffSum f g n y) \u2264\n      \u2211 k \u2208 Finset.range n, dist (g (f^[k] x)) (g (f^[k] y)) :=\n  dist_sum_sum_le _ _ _\n\nvariable (\ud835\udd5c : Type*) [RCLike \ud835\udd5c] [Module \ud835\udd5c E] [BoundedSMul \ud835\udd5c E]\n\ntheorem dist_birkhoffAverage_birkhoffAverage (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x y : \u03b1) :\n    dist (birkhoffAverage \ud835\udd5c f g n x) (birkhoffAverage \ud835\udd5c f g n y) =\n      dist (birkhoffSum f g n x) (birkhoffSum f g n y) / n := by\n  simp [birkhoffAverage, dist_smul\u2080, div_eq_inv_mul]\n\ntheorem dist_birkhoffAverage_birkhoffAverage_le (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x y : \u03b1) :\n    dist (birkhoffAverage \ud835\udd5c f g n x) (birkhoffAverage \ud835\udd5c f g n y) \u2264\n      (\u2211 k \u2208 Finset.range n, dist (g (f^[k] x)) (g (f^[k] y))) / n :=\n  (dist_birkhoffAverage_birkhoffAverage _ _ _ _ _ _).trans_le <| by\n    gcongr; apply dist_birkhoffSum_birkhoffSum_le\n\n"}
{"name": "whiskerLeft_naturality_naturality208", "split": "test", "formal_statement": "theorem whiskerLeft_naturality_naturality (f : a' \u27f6 G.obj a) {g h : a \u27f6 b} (\u03b2 : g \u27f6 h) :\n    f \u25c1 G.map\u2082 \u03b2 \u25b7 \u03b8.app b \u226b f \u25c1 \u03b8.naturality h =\n      f \u25c1 \u03b8.naturality g \u226b f \u25c1 \u03b8.app a \u25c1 H.map\u2082 \u03b2 := by", "header": "\nimport Mathlib.CategoryTheory.Bicategory.Functor.Oplax\n\n#align_import category_theory.bicategory.natural_transformation from \"leanprover-community/mathlib\"@\"4ff75f5b8502275a4c2eb2d2f02bdf84d7fb8993\"\n\n\n\nnamespace CategoryTheory\n\nopen Category Bicategory\n\nopen scoped Bicategory\n\nuniverse w\u2081 w\u2082 v\u2081 v\u2082 u\u2081 u\u2082\n\nvariable {B : Type u\u2081} [Bicategory.{w\u2081, v\u2081} B] {C : Type u\u2082} [Bicategory.{w\u2082, v\u2082} C]\n\n\nstructure OplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a \u27f6 G.obj a\n  naturality {a b : B} (f : a \u27f6 b) : F.map f \u226b app b \u27f6 app a \u226b G.map f\n  naturality_naturality :\n    \u2200 {a b : B} {f g : a \u27f6 b} (\u03b7 : f \u27f6 g),\n      F.map\u2082 \u03b7 \u25b7 app b \u226b naturality g = naturality f \u226b app a \u25c1 G.map\u2082 \u03b7 := by\n    aesop_cat\n  naturality_id :\n    \u2200 a : B,\n      naturality (\ud835\udfd9 a) \u226b app a \u25c1 G.mapId a =\n        F.mapId a \u25b7 app a \u226b (\u03bb_ (app a)).hom \u226b (\u03c1_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    \u2200 {a b c : B} (f : a \u27f6 b) (g : b \u27f6 c),\n      naturality (f \u226b g) \u226b app a \u25c1 G.mapComp f g =\n        F.mapComp f g \u25b7 app c \u226b\n          (\u03b1_ _ _ _).hom \u226b\n            F.map f \u25c1 naturality g \u226b (\u03b1_ _ _ _).inv \u226b naturality f \u25b7 G.map g \u226b (\u03b1_ _ _ _).hom := by\n    aesop_cat\n#align category_theory.oplax_nat_trans CategoryTheory.OplaxNatTrans\n#align category_theory.oplax_nat_trans.app CategoryTheory.OplaxNatTrans.app\n#align category_theory.oplax_nat_trans.naturality CategoryTheory.OplaxNatTrans.naturality\n#align category_theory.oplax_nat_trans.naturality_naturality' CategoryTheory.OplaxNatTrans.naturality_naturality\n#align category_theory.oplax_nat_trans.naturality_naturality CategoryTheory.OplaxNatTrans.naturality_naturality\n#align category_theory.oplax_nat_trans.naturality_id' CategoryTheory.OplaxNatTrans.naturality_id\n#align category_theory.oplax_nat_trans.naturality_id CategoryTheory.OplaxNatTrans.naturality_id\n#align category_theory.oplax_nat_trans.naturality_comp' CategoryTheory.OplaxNatTrans.naturality_comp\n#align category_theory.oplax_nat_trans.naturality_comp CategoryTheory.OplaxNatTrans.naturality_comp\n\nattribute [nolint docBlame] CategoryTheory.OplaxNatTrans.app\n  CategoryTheory.OplaxNatTrans.naturality\n  CategoryTheory.OplaxNatTrans.naturality_naturality\n  CategoryTheory.OplaxNatTrans.naturality_id\n  CategoryTheory.OplaxNatTrans.naturality_comp\n\nattribute [reassoc (attr := simp)] OplaxNatTrans.naturality_naturality OplaxNatTrans.naturality_id\n  OplaxNatTrans.naturality_comp\n\nnamespace OplaxNatTrans\n\nsection\n\nvariable (F : OplaxFunctor B C)\n\n\n@[simps]\ndef id : OplaxNatTrans F F where\n  app a := \ud835\udfd9 (F.obj a)\n  naturality {a b} f := (\u03c1_ (F.map f)).hom \u226b (\u03bb_ (F.map f)).inv\n#align category_theory.oplax_nat_trans.id CategoryTheory.OplaxNatTrans.id\n\ninstance : Inhabited (OplaxNatTrans F F) :=\n  \u27e8id F\u27e9\n\nvariable {F} {G H : OplaxFunctor B C} (\u03b7 : OplaxNatTrans F G) (\u03b8 : OplaxNatTrans G H)\n\nsection\n\nvariable {a b c : B} {a' : C}\n\n@[reassoc (attr := simp)]\n"}
{"name": "mem_posTangentConeAt_of_segment_subset209", "split": "test", "formal_statement": "theorem mem_posTangentConeAt_of_segment_subset {s : Set E} {x y : E} (h : segment \u211d x y \u2286 s) :\n    y - x \u2208 posTangentConeAt s x := by", "header": "\nimport Mathlib.Analysis.Calculus.Deriv.Add\n\n#align_import analysis.calculus.local_extr from \"leanprover-community/mathlib\"@\"3bce8d800a6f2b8f63fe1e588fd76a9ff4adcebe\"\n\n\n\n\nuniverse u v\n\nopen Filter Set\n\nopen scoped Topology Classical\n\nsection Module\n\nvariable {E : Type u} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {a : E} {f' : E \u2192L[\u211d] \u211d}\n\n\n\n\ndef posTangentConeAt (s : Set E) (x : E) : Set E :=\n  { y : E | \u2203 (c : \u2115 \u2192 \u211d) (d : \u2115 \u2192 E), (\u2200\u1da0 n in atTop, x + d n \u2208 s) \u2227\n    Tendsto c atTop atTop \u2227 Tendsto (fun n => c n \u2022 d n) atTop (\ud835\udcdd y) }\n#align pos_tangent_cone_at posTangentConeAt\n\ntheorem posTangentConeAt_mono : Monotone fun s => posTangentConeAt s a := by\n  rintro s t hst y \u27e8c, d, hd, hc, hcd\u27e9\n  exact \u27e8c, d, mem_of_superset hd fun h hn => hst hn, hc, hcd\u27e9\n#align pos_tangent_cone_at_mono posTangentConeAt_mono\n\n"}
{"name": "conj_mk210", "split": "test", "formal_statement": "theorem conj_mk (a x : G) : SemiconjBy a x (a * x * a\u207b\u00b9) := by", "header": "\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Init.Logic\nimport Mathlib.Tactic.Cases\n\n#align_import algebra.group.semiconj from \"leanprover-community/mathlib\"@\"a148d797a1094ab554ad4183a4ad6f130358ef64\"\n\n\n\nassert_not_exists MonoidWithZero\nassert_not_exists DenselyOrdered\n\nvariable {S M G : Type*}\n\n\n@[to_additive \"`x` is additive semiconjugate to `y` by `a` if `a + x = y + a`\"]\ndef SemiconjBy [Mul M] (a x y : M) : Prop :=\n  a * x = y * a\n#align semiconj_by SemiconjBy\n#align add_semiconj_by AddSemiconjBy\n\nnamespace SemiconjBy\n\n\n@[to_additive \"Equality behind `AddSemiconjBy a x y`; useful for rewriting.\"]\nprotected theorem eq [Mul S] {a x y : S} (h : SemiconjBy a x y) : a * x = y * a :=\n  h\n#align semiconj_by.eq SemiconjBy.eq\n#align add_semiconj_by.eq AddSemiconjBy.eq\n\nsection Group\n\nvariable [Group G] {a x y : G}\n\n\n@[to_additive \"`a` semiconjugates `x` to `a + x + -a`.\"]\n"}
{"name": "tail_map211", "split": "test", "formal_statement": "theorem tail_map {\u03b2 : Type*} (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) :\n    (v.map f).tail = v.tail.map f := by", "header": "\nimport Mathlib.Algebra.BigOperators.Group.List\nimport Mathlib.Data.Vector.Defs\nimport Mathlib.Data.List.Nodup\nimport Mathlib.Data.List.OfFn\nimport Mathlib.Data.List.InsertNth\nimport Mathlib.Control.Applicative\nimport Mathlib.Control.Traversable.Basic\n\n#align_import data.vector.basic from \"leanprover-community/mathlib\"@\"f694c7dead66f5d4c80f446c796a5aad14707f0e\"\n\n\n\nset_option autoImplicit true\n\n\nuniverse u\n\nvariable {n : \u2115}\n\nnamespace Vector\n\nvariable {\u03b1 : Type*}\n\n@[inherit_doc]\ninfixr:67 \" ::\u1d65 \" => Vector.cons\n\nattribute [simp] head_cons tail_cons\n\ninstance [Inhabited \u03b1] : Inhabited (Vector \u03b1 n) :=\n  \u27e8ofFn default\u27e9\n\ntheorem toList_injective : Function.Injective (@toList \u03b1 n) :=\n  Subtype.val_injective\n#align vector.to_list_injective Vector.toList_injective\n\n\n@[ext]\ntheorem ext : \u2200 {v w : Vector \u03b1 n} (_ : \u2200 m : Fin n, Vector.get v m = Vector.get w m), v = w\n  | \u27e8v, hv\u27e9, \u27e8w, hw\u27e9, h =>\n    Subtype.eq (List.ext_get (by rw [hv, hw]) fun m hm _ => h \u27e8m, hv \u25b8 hm\u27e9)\n#align vector.ext Vector.ext\n\n\ninstance zero_subsingleton : Subsingleton (Vector \u03b1 0) :=\n  \u27e8fun _ _ => Vector.ext fun m => Fin.elim0 m\u27e9\n#align vector.zero_subsingleton Vector.zero_subsingleton\n\n@[simp]\ntheorem cons_val (a : \u03b1) : \u2200 v : Vector \u03b1 n, (a ::\u1d65 v).val = a :: v.val\n  | \u27e8_, _\u27e9 => rfl\n#align vector.cons_val Vector.cons_val\n\n#align vector.cons_head Vector.head_cons\n#align vector.cons_tail Vector.tail_cons\n\ntheorem eq_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v = a ::\u1d65 v' \u2194 v.head = a \u2227 v.tail = v' :=\n  \u27e8fun h => h.symm \u25b8 \u27e8head_cons a v', tail_cons a v'\u27e9, fun h =>\n    _root_.trans (cons_head_tail v).symm (by rw [h.1, h.2])\u27e9\n#align vector.eq_cons_iff Vector.eq_cons_iff\n\ntheorem ne_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v \u2260 a ::\u1d65 v' \u2194 v.head \u2260 a \u2228 v.tail \u2260 v' := by rw [Ne, eq_cons_iff a v v', not_and_or]\n#align vector.ne_cons_iff Vector.ne_cons_iff\n\ntheorem exists_eq_cons (v : Vector \u03b1 n.succ) : \u2203 (a : \u03b1) (as : Vector \u03b1 n), v = a ::\u1d65 as :=\n  \u27e8v.head, v.tail, (eq_cons_iff v.head v v.tail).2 \u27e8rfl, rfl\u27e9\u27e9\n#align vector.exists_eq_cons Vector.exists_eq_cons\n\n@[simp]\ntheorem toList_ofFn : \u2200 {n} (f : Fin n \u2192 \u03b1), toList (ofFn f) = List.ofFn f\n  | 0, f => by rw [ofFn, List.ofFn_zero, toList, nil]\n  | n + 1, f => by rw [ofFn, List.ofFn_succ, toList_cons, toList_ofFn]\n#align vector.to_list_of_fn Vector.toList_ofFn\n\n@[simp]\ntheorem mk_toList : \u2200 (v : Vector \u03b1 n) (h), (\u27e8toList v, h\u27e9 : Vector \u03b1 n) = v\n  | \u27e8_, _\u27e9, _ => rfl\n#align vector.mk_to_list Vector.mk_toList\n\n\n@[simp] theorem length_val (v : Vector \u03b1 n) : v.val.length = n := v.2\n\n-- Porting note: not used in mathlib and coercions done differently in Lean 4\n-- @[simp]\n-- theorem length_coe (v : Vector \u03b1 n) :\n--     ((coe : { l : List \u03b1 // l.length = n } \u2192 List \u03b1) v).length = n :=\n--   v.2\n#noalign vector.length_coe\n\n@[simp]\ntheorem toList_map {\u03b2 : Type*} (v : Vector \u03b1 n) (f : \u03b1 \u2192 \u03b2) :\n    (v.map f).toList = v.toList.map f := by cases v; rfl\n#align vector.to_list_map Vector.toList_map\n\n@[simp]\ntheorem head_map {\u03b2 : Type*} (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) : (v.map f).head = f v.head := by\n  obtain \u27e8a, v', h\u27e9 := Vector.exists_eq_cons v\n  rw [h, map_cons, head_cons, head_cons]\n#align vector.head_map Vector.head_map\n\n@[simp]\n"}
{"name": "map_coeIdeal212", "split": "test", "formal_statement": "theorem map_coeIdeal (I : Ideal R) : (I : FractionalIdeal S P).map g = I := by", "header": "\nimport Mathlib.RingTheory.IntegralClosure\nimport Mathlib.RingTheory.FractionalIdeal.Basic\n\n#align_import ring_theory.fractional_ideal from \"leanprover-community/mathlib\"@\"ed90a7d327c3a5caf65a6faf7e8a0d63c4605df7\"\n\n\n\n\nopen IsLocalization Pointwise nonZeroDivisors\n\nnamespace FractionalIdeal\n\nopen Set Submodule\n\nvariable {R : Type*} [CommRing R] {S : Submonoid R} {P : Type*} [CommRing P]\nvariable [Algebra R P] [loc : IsLocalization S P]\n\nsection\n\nvariable {P' : Type*} [CommRing P'] [Algebra R P'] [loc' : IsLocalization S P']\nvariable {P'' : Type*} [CommRing P''] [Algebra R P''] [loc'' : IsLocalization S P'']\n\ntheorem _root_.IsFractional.map (g : P \u2192\u2090[R] P') {I : Submodule R P} :\n    IsFractional S I \u2192 IsFractional S (Submodule.map g.toLinearMap I)\n  | \u27e8a, a_nonzero, hI\u27e9 =>\n    \u27e8a, a_nonzero, fun b hb => by\n      obtain \u27e8b', b'_mem, hb'\u27e9 := Submodule.mem_map.mp hb\n      rw [AlgHom.toLinearMap_apply] at hb'\n      obtain \u27e8x, hx\u27e9 := hI b' b'_mem\n      use x\n      rw [\u2190 g.commutes, hx, g.map_smul, hb']\u27e9\n#align is_fractional.map IsFractional.map\n\n\ndef map (g : P \u2192\u2090[R] P') : FractionalIdeal S P \u2192 FractionalIdeal S P' := fun I =>\n  \u27e8Submodule.map g.toLinearMap I, I.isFractional.map g\u27e9\n#align fractional_ideal.map FractionalIdeal.map\n\n@[simp, norm_cast]\ntheorem coe_map (g : P \u2192\u2090[R] P') (I : FractionalIdeal S P) :\n    \u2191(map g I) = Submodule.map g.toLinearMap I :=\n  rfl\n#align fractional_ideal.coe_map FractionalIdeal.coe_map\n\n@[simp]\ntheorem mem_map {I : FractionalIdeal S P} {g : P \u2192\u2090[R] P'} {y : P'} :\n    y \u2208 I.map g \u2194 \u2203 x, x \u2208 I \u2227 g x = y :=\n  Submodule.mem_map\n#align fractional_ideal.mem_map FractionalIdeal.mem_map\n\nvariable (I J : FractionalIdeal S P) (g : P \u2192\u2090[R] P')\n\n@[simp]\ntheorem map_id : I.map (AlgHom.id _ _) = I :=\n  coeToSubmodule_injective (Submodule.map_id (I : Submodule R P))\n#align fractional_ideal.map_id FractionalIdeal.map_id\n\n@[simp]\ntheorem map_comp (g' : P' \u2192\u2090[R] P'') : I.map (g'.comp g) = (I.map g).map g' :=\n  coeToSubmodule_injective (Submodule.map_comp g.toLinearMap g'.toLinearMap I)\n#align fractional_ideal.map_comp FractionalIdeal.map_comp\n\n@[simp, norm_cast]\n"}
{"name": "find_comp_succ213", "split": "test", "formal_statement": "theorem find_comp_succ (h : \u2203 n, p n) (h\u2082 : \u2203 n, p (n + 1)) (h1 : \u00acp 1) :\n    PNat.find h = PNat.find h\u2082 + 1 := by", "header": "\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.find from \"leanprover-community/mathlib\"@\"207cfac9fcd06138865b5d04f7091e46d9320432\"\n\n\n\n\nnamespace PNat\n\nvariable {p q : \u2115+ \u2192 Prop} [DecidablePred p] [DecidablePred q] (h : \u2203 n, p n)\n\ninstance decidablePredExistsNat : DecidablePred fun n' : \u2115 => \u2203 (n : \u2115+) (_ : n' = n), p n :=\n  fun n' =>\n  decidable_of_iff' (\u2203 h : 0 < n', p \u27e8n', h\u27e9) <|\n    Subtype.exists.trans <| by\n      simp_rw [mk_coe, @exists_comm (_ < _) (_ = _), exists_prop, exists_eq_left']\n#align pnat.decidable_pred_exists_nat PNat.decidablePredExistsNat\n\n\nprotected def findX : { n // p n \u2227 \u2200 m : \u2115+, m < n \u2192 \u00acp m } := by\n  have : \u2203 (n' : \u2115) (n : \u2115+) (_ : n' = n), p n := Exists.elim h fun n hn => \u27e8n, n, rfl, hn\u27e9\n  have n := Nat.findX this\n  refine \u27e8\u27e8n, ?_\u27e9, ?_, fun m hm pm => ?_\u27e9\n  \u00b7 obtain \u27e8n', hn', -\u27e9 := n.prop.1\n    rw [hn']\n    exact n'.prop\n  \u00b7 obtain \u27e8n', hn', pn'\u27e9 := n.prop.1\n    simpa [hn', Subtype.coe_eta] using pn'\n  \u00b7 exact n.prop.2 m hm \u27e8m, rfl, pm\u27e9\n#align pnat.find_x PNat.findX\n\n\nprotected def find : \u2115+ :=\n  PNat.findX h\n#align pnat.find PNat.find\n\nprotected theorem find_spec : p (PNat.find h) :=\n  (PNat.findX h).prop.left\n#align pnat.find_spec PNat.find_spec\n\nprotected theorem find_min : \u2200 {m : \u2115+}, m < PNat.find h \u2192 \u00acp m :=\n  @(PNat.findX h).prop.right\n#align pnat.find_min PNat.find_min\n\nprotected theorem find_min' {m : \u2115+} (hm : p m) : PNat.find h \u2264 m :=\n  le_of_not_lt fun l => PNat.find_min h l hm\n#align pnat.find_min' PNat.find_min'\n\nvariable {n m : \u2115+}\n\ntheorem find_eq_iff : PNat.find h = m \u2194 p m \u2227 \u2200 n < m, \u00acp n := by\n  constructor\n  \u00b7 rintro rfl\n    exact \u27e8PNat.find_spec h, fun _ => PNat.find_min h\u27e9\n  \u00b7 rintro \u27e8hm, hlt\u27e9\n    exact le_antisymm (PNat.find_min' h hm) (not_lt.1 <| imp_not_comm.1 (hlt _) <| PNat.find_spec h)\n#align pnat.find_eq_iff PNat.find_eq_iff\n\n@[simp]\ntheorem find_lt_iff (n : \u2115+) : PNat.find h < n \u2194 \u2203 m < n, p m :=\n  \u27e8fun h2 => \u27e8PNat.find h, h2, PNat.find_spec h\u27e9, fun \u27e8_, hmn, hm\u27e9 =>\n    (PNat.find_min' h hm).trans_lt hmn\u27e9\n#align pnat.find_lt_iff PNat.find_lt_iff\n\n@[simp]\ntheorem find_le_iff (n : \u2115+) : PNat.find h \u2264 n \u2194 \u2203 m \u2264 n, p m := by\n  simp only [exists_prop, \u2190 lt_add_one_iff, find_lt_iff]\n#align pnat.find_le_iff PNat.find_le_iff\n\n@[simp]\ntheorem le_find_iff (n : \u2115+) : n \u2264 PNat.find h \u2194 \u2200 m < n, \u00acp m := by\n  simp only [\u2190 not_lt, find_lt_iff, not_exists, not_and]\n#align pnat.le_find_iff PNat.le_find_iff\n\n@[simp]\ntheorem lt_find_iff (n : \u2115+) : n < PNat.find h \u2194 \u2200 m \u2264 n, \u00acp m := by\n  simp only [\u2190 add_one_le_iff, le_find_iff, add_le_add_iff_right]\n#align pnat.lt_find_iff PNat.lt_find_iff\n\n@[simp]\ntheorem find_eq_one : PNat.find h = 1 \u2194 p 1 := by simp [find_eq_iff]\n#align pnat.find_eq_one PNat.find_eq_one\n\n-- Porting note: deleted `@[simp]` to satisfy the linter because `le_find_iff` is more general\ntheorem one_le_find : 1 < PNat.find h \u2194 \u00acp 1 :=\n  not_iff_not.mp <| by simp\n#align pnat.one_le_find PNat.one_le_find\n\ntheorem find_mono (h : \u2200 n, q n \u2192 p n) {hp : \u2203 n, p n} {hq : \u2203 n, q n} :\n    PNat.find hp \u2264 PNat.find hq :=\n  PNat.find_min' _ (h _ (PNat.find_spec hq))\n#align pnat.find_mono PNat.find_mono\n\ntheorem find_le {h : \u2203 n, p n} (hn : p n) : PNat.find h \u2264 n :=\n  (PNat.find_le_iff _ _).2 \u27e8n, le_rfl, hn\u27e9\n#align pnat.find_le PNat.find_le\n\n"}
{"name": "sub214", "split": "test", "formal_statement": "theorem sub {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x - y) := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Basic\nimport Mathlib.Algebra.Module.Defs\nimport Mathlib.Algebra.Star.Pi\n\n#align_import algebra.star.self_adjoint from \"leanprover-community/mathlib\"@\"a6ece35404f60597c651689c1b46ead86de5ac1b\"\n\n\n\nopen Function\n\nvariable {R A : Type*}\n\n\ndef IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x\n#align is_self_adjoint IsSelfAdjoint\n\n\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x\n#align is_star_normal IsStarNormal\n\nexport IsStarNormal (star_comm_self)\n\ntheorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n#align star_comm_self' star_comm_self'\n\nnamespace IsSelfAdjoint\n\n-- named to match `Commute.all\u2093`\n\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n#align is_self_adjoint.all IsSelfAdjoint.all\n\ntheorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n#align is_self_adjoint.star_eq IsSelfAdjoint.star_eq\n\ntheorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x :=\n  Iff.rfl\n#align is_self_adjoint_iff isSelfAdjoint_iff\n\n@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n#align is_self_adjoint.star_iff IsSelfAdjoint.star_iff\n\n@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint, star_mul, star_star]\n#align is_self_adjoint.star_mul_self IsSelfAdjoint.star_mul_self\n\n@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n#align is_self_adjoint.mul_star_self IsSelfAdjoint.mul_star_self\n\n\nlemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n\n\ntheorem starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S] [StarHomClass F R S]\n    {x : R} (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x) :=\n  show star (f x) = f x from map_star f x \u25b8 congr_arg f hx\n#align is_self_adjoint.star_hom_apply IsSelfAdjoint.starHom_apply\n\n\ntheorem _root_.isSelfAdjoint_starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S]\n    [StarHomClass F R S] [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x) :=\n  (IsSelfAdjoint.all x).starHom_apply f\n\nsection AddGroup\n\nvariable [AddGroup R] [StarAddMonoid R]\n\ntheorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) := by\n  simp only [isSelfAdjoint_iff, star_neg, hx.star_eq]\n#align is_self_adjoint.neg IsSelfAdjoint.neg\n\n"}
{"name": "fract_zspan_add215", "split": "test", "formal_statement": "theorem fract_zspan_add (m : E) {v : E} (h : v \u2208 span \u2124 (Set.range b)) :\n    fract b (v + m) = fract b m := by", "header": "\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n\n\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\ntheorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by simp [span_span_of_tower]\n\n\ndef fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}\n#align zspan.fundamental_domain Zspan.fundamentalDomain\n\n@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1 := Iff.rfl\n#align zspan.mem_fundamental_domain Zspan.mem_fundamentalDomain\n\ntheorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by\n  ext x\n  rw [mem_fundamentalDomain, Basis.map_repr, LinearEquiv.trans_apply, \u2190 mem_fundamentalDomain,\n    show f.symm x = f.toEquiv.symm x by rfl, \u2190 Set.mem_image_equiv]\n  rfl\n\n@[simp]\ntheorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]\n\nlemma fundamentalDomain_pi_basisFun [Fintype \u03b9] :\n    fundamentalDomain (Pi.basisFun \u211d \u03b9) = Set.pi Set.univ fun _ : \u03b9 \u21a6 Set.Ico (0 : \u211d) 1 := by\n  ext; simp\n\nvariable [FloorRing K]\n\nsection Fintype\n\nvariable [Fintype \u03b9]\n\n\ndef floor (m : E) : span \u2124 (Set.range b) := \u2211 i, \u230ab.repr m i\u230b \u2022 b.restrictScalars \u2124 i\n#align zspan.floor Zspan.floor\n\n\ndef ceil (m : E) : span \u2124 (Set.range b) := \u2211 i, \u2308b.repr m i\u2309 \u2022 b.restrictScalars \u2124 i\n#align zspan.ceil Zspan.ceil\n\n@[simp]\ntheorem repr_floor_apply (m : E) (i : \u03b9) : b.repr (floor b m) i = \u230ab.repr m i\u230b := by\n  classical simp only [floor, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_floor_apply Zspan.repr_floor_apply\n\n@[simp]\ntheorem repr_ceil_apply (m : E) (i : \u03b9) : b.repr (ceil b m) i = \u2308b.repr m i\u2309 := by\n  classical simp only [ceil, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_ceil_apply Zspan.repr_ceil_apply\n\n@[simp]\ntheorem floor_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (floor b m : E) = m := by\n  apply b.ext_elem\n  simp_rw [repr_floor_apply b]\n  intro i\n  obtain \u27e8z, hz\u27e9 := (b.mem_span_iff_repr_mem \u2124 _).mp h i\n  rw [\u2190 hz]\n  exact congr_arg (Int.cast : \u2124 \u2192 K) (Int.floor_intCast z)\n#align zspan.floor_eq_self_of_mem Zspan.floor_eq_self_of_mem\n\n@[simp]\ntheorem ceil_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (ceil b m : E) = m := by\n  apply b.ext_elem\n  simp_rw [repr_ceil_apply b]\n  intro i\n  obtain \u27e8z, hz\u27e9 := (b.mem_span_iff_repr_mem \u2124 _).mp h i\n  rw [\u2190 hz]\n  exact congr_arg (Int.cast : \u2124 \u2192 K) (Int.ceil_intCast z)\n#align zspan.ceil_eq_self_of_mem Zspan.ceil_eq_self_of_mem\n\n\ndef fract (m : E) : E := m - floor b m\n#align zspan.fract Zspan.fract\n\ntheorem fract_apply (m : E) : fract b m = m - floor b m := rfl\n#align zspan.fract_apply Zspan.fract_apply\n\n@[simp]\ntheorem repr_fract_apply (m : E) (i : \u03b9) : b.repr (fract b m) i = Int.fract (b.repr m i) := by\n  rw [fract, map_sub, Finsupp.coe_sub, Pi.sub_apply, repr_floor_apply, Int.fract]\n#align zspan.repr_fract_apply Zspan.repr_fract_apply\n\n@[simp]\ntheorem fract_fract (m : E) : fract b (fract b m) = fract b m :=\n  Basis.ext_elem b fun _ => by classical simp only [repr_fract_apply, Int.fract_fract]\n#align zspan.fract_fract Zspan.fract_fract\n\n@[simp]\n"}
{"name": "repr_floor_apply216", "split": "test", "formal_statement": "theorem repr_floor_apply (m : E) (i : \u03b9) : b.repr (floor b m) i = \u230ab.repr m i\u230b := by", "header": "\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n\n\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\ntheorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by simp [span_span_of_tower]\n\n\ndef fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}\n#align zspan.fundamental_domain Zspan.fundamentalDomain\n\n@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1 := Iff.rfl\n#align zspan.mem_fundamental_domain Zspan.mem_fundamentalDomain\n\ntheorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by\n  ext x\n  rw [mem_fundamentalDomain, Basis.map_repr, LinearEquiv.trans_apply, \u2190 mem_fundamentalDomain,\n    show f.symm x = f.toEquiv.symm x by rfl, \u2190 Set.mem_image_equiv]\n  rfl\n\n@[simp]\ntheorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]\n\nlemma fundamentalDomain_pi_basisFun [Fintype \u03b9] :\n    fundamentalDomain (Pi.basisFun \u211d \u03b9) = Set.pi Set.univ fun _ : \u03b9 \u21a6 Set.Ico (0 : \u211d) 1 := by\n  ext; simp\n\nvariable [FloorRing K]\n\nsection Fintype\n\nvariable [Fintype \u03b9]\n\n\ndef floor (m : E) : span \u2124 (Set.range b) := \u2211 i, \u230ab.repr m i\u230b \u2022 b.restrictScalars \u2124 i\n#align zspan.floor Zspan.floor\n\n\ndef ceil (m : E) : span \u2124 (Set.range b) := \u2211 i, \u2308b.repr m i\u2309 \u2022 b.restrictScalars \u2124 i\n#align zspan.ceil Zspan.ceil\n\n@[simp]\n"}
{"name": "laurent_C217", "split": "test", "formal_statement": "theorem laurent_C (x : R) : laurent r (C x) = C x := by", "header": "\nimport Mathlib.Algebra.Polynomial.Taylor\nimport Mathlib.FieldTheory.RatFunc.AsPolynomial\n\n#align_import field_theory.laurent from \"leanprover-community/mathlib\"@\"70fd9563a21e7b963887c9360bd29b2393e6225a\"\n\n\n\n\nuniverse u\n\nnamespace RatFunc\n\nnoncomputable section\n\nopen Polynomial\n\nopen scoped Classical nonZeroDivisors Polynomial\n\nvariable {R : Type u} [CommRing R] [hdomain : IsDomain R] (r s : R) (p q : R[X]) (f : RatFunc R)\n\ntheorem taylor_mem_nonZeroDivisors (hp : p \u2208 R[X]\u2070) : taylor r p \u2208 R[X]\u2070 := by\n  rw [mem_nonZeroDivisors_iff]\n  intro x hx\n  have : x = taylor (r - r) x := by simp\n  rwa [this, sub_eq_add_neg, \u2190 taylor_taylor, \u2190 taylor_mul,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _), mul_right_mem_nonZeroDivisors_eq_zero_iff hp,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _)] at hx\n#align ratfunc.taylor_mem_non_zero_divisors RatFunc.taylor_mem_nonZeroDivisors\n\n\ndef laurentAux : RatFunc R \u2192+* RatFunc R :=\n  RatFunc.mapRingHom\n    ( { toFun := taylor r\n        map_add' := map_add (taylor r)\n        map_mul' := taylor_mul _\n        map_zero' := map_zero (taylor r)\n        map_one' := taylor_one r } : R[X] \u2192+* R[X])\n    (taylor_mem_nonZeroDivisors _)\n#align ratfunc.laurent_aux RatFunc.laurentAux\n\ntheorem laurentAux_ofFractionRing_mk (q : R[X]\u2070) :\n    laurentAux r (ofFractionRing (Localization.mk p q)) =\n      ofFractionRing (.mk (taylor r p) \u27e8taylor r q, taylor_mem_nonZeroDivisors r q q.prop\u27e9) :=\n  map_apply_ofFractionRing_mk _ _ _ _\n#align ratfunc.laurent_aux_of_fraction_ring_mk RatFunc.laurentAux_ofFractionRing_mk\n\ntheorem laurentAux_div :\n    laurentAux r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q) :=\n  -- Porting note: added `by exact taylor_mem_nonZeroDivisors r`\n  map_apply_div _ (by exact taylor_mem_nonZeroDivisors r) _ _\n#align ratfunc.laurent_aux_div RatFunc.laurentAux_div\n\n@[simp]\ntheorem laurentAux_algebraMap : laurentAux r (algebraMap _ _ p) = algebraMap _ _ (taylor r p) := by\n  rw [\u2190 mk_one, \u2190 mk_one, mk_eq_div, laurentAux_div, mk_eq_div, taylor_one, map_one, map_one]\n#align ratfunc.laurent_aux_algebra_map RatFunc.laurentAux_algebraMap\n\n\ndef laurent : RatFunc R \u2192\u2090[R] RatFunc R :=\n  RatFunc.mapAlgHom (.ofLinearMap (taylor r) (taylor_one _) (taylor_mul _))\n    (taylor_mem_nonZeroDivisors _)\n#align ratfunc.laurent RatFunc.laurent\n\ntheorem laurent_div :\n    laurent r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q) :=\n  laurentAux_div r p q\n#align ratfunc.laurent_div RatFunc.laurent_div\n\n@[simp]\ntheorem laurent_algebraMap : laurent r (algebraMap _ _ p) = algebraMap _ _ (taylor r p) :=\n  laurentAux_algebraMap _ _\n#align ratfunc.laurent_algebra_map RatFunc.laurent_algebraMap\n\n@[simp]\ntheorem laurent_X : laurent r X = X + C r := by\n  rw [\u2190 algebraMap_X, laurent_algebraMap, taylor_X, _root_.map_add, algebraMap_C]\nset_option linter.uppercaseLean3 false in\n#align ratfunc.laurent_X RatFunc.laurent_X\n\n@[simp]\n"}
{"name": "dotProduct_stdBasis_one218", "split": "test", "formal_statement": "theorem dotProduct_stdBasis_one [DecidableEq n] (v : n \u2192 R) (i : n) :\n    dotProduct v (LinearMap.stdBasis R (fun _ => R) i 1) = v i := by", "header": "\nimport Mathlib.Algebra.Star.Order\nimport Mathlib.Data.Matrix.Basic\nimport Mathlib.LinearAlgebra.StdBasis\n\n#align_import linear_algebra.matrix.dot_product from \"leanprover-community/mathlib\"@\"31c24aa72e7b3e5ed97a8412470e904f82b81004\"\n\n\n\n\nvariable {m n p R : Type*}\n\nnamespace Matrix\n\nsection Semiring\n\nvariable [Semiring R] [Fintype n]\n\n@[simp]\ntheorem dotProduct_stdBasis_eq_mul [DecidableEq n] (v : n \u2192 R) (c : R) (i : n) :\n    dotProduct v (LinearMap.stdBasis R (fun _ => R) i c) = v i * c := by\n  rw [dotProduct, Finset.sum_eq_single i, LinearMap.stdBasis_same]\n  \u00b7 exact fun _ _ hb => by rw [LinearMap.stdBasis_ne _ _ _ _ hb, mul_zero]\n  \u00b7 exact fun hi => False.elim (hi <| Finset.mem_univ _)\n#align matrix.dot_product_std_basis_eq_mul Matrix.dotProduct_stdBasis_eq_mul\n\n-- @[simp] -- Porting note (#10618): simp can prove this\n"}
{"name": "prod_bool219", "split": "test", "formal_statement": "theorem prod_bool [CommMonoid \u03b1] (f : Bool \u2192 \u03b1) : \u220f b, f b = f true * f false := by", "header": "\nimport Mathlib.Data.Fintype.Option\nimport Mathlib.Data.Fintype.Sigma\nimport Mathlib.Data.Fintype.Sum\nimport Mathlib.Data.Fintype.Prod\nimport Mathlib.Data.Fintype.Vector\nimport Mathlib.Algebra.BigOperators.Option\n\n#align_import data.fintype.big_operators from \"leanprover-community/mathlib\"@\"2445c98ae4b87eabebdde552593519b9b6dc350c\"\n\n\n\nassert_not_exists MulAction\n\nuniverse u v\n\nvariable {\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}\n\nnamespace Fintype\n\n@[to_additive]\n"}
{"name": "laurent_X220", "split": "test", "formal_statement": "theorem laurent_X : laurent r X = X + C r := by", "header": "\nimport Mathlib.Algebra.Polynomial.Taylor\nimport Mathlib.FieldTheory.RatFunc.AsPolynomial\n\n#align_import field_theory.laurent from \"leanprover-community/mathlib\"@\"70fd9563a21e7b963887c9360bd29b2393e6225a\"\n\n\n\n\nuniverse u\n\nnamespace RatFunc\n\nnoncomputable section\n\nopen Polynomial\n\nopen scoped Classical nonZeroDivisors Polynomial\n\nvariable {R : Type u} [CommRing R] [hdomain : IsDomain R] (r s : R) (p q : R[X]) (f : RatFunc R)\n\ntheorem taylor_mem_nonZeroDivisors (hp : p \u2208 R[X]\u2070) : taylor r p \u2208 R[X]\u2070 := by\n  rw [mem_nonZeroDivisors_iff]\n  intro x hx\n  have : x = taylor (r - r) x := by simp\n  rwa [this, sub_eq_add_neg, \u2190 taylor_taylor, \u2190 taylor_mul,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _), mul_right_mem_nonZeroDivisors_eq_zero_iff hp,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _)] at hx\n#align ratfunc.taylor_mem_non_zero_divisors RatFunc.taylor_mem_nonZeroDivisors\n\n\ndef laurentAux : RatFunc R \u2192+* RatFunc R :=\n  RatFunc.mapRingHom\n    ( { toFun := taylor r\n        map_add' := map_add (taylor r)\n        map_mul' := taylor_mul _\n        map_zero' := map_zero (taylor r)\n        map_one' := taylor_one r } : R[X] \u2192+* R[X])\n    (taylor_mem_nonZeroDivisors _)\n#align ratfunc.laurent_aux RatFunc.laurentAux\n\ntheorem laurentAux_ofFractionRing_mk (q : R[X]\u2070) :\n    laurentAux r (ofFractionRing (Localization.mk p q)) =\n      ofFractionRing (.mk (taylor r p) \u27e8taylor r q, taylor_mem_nonZeroDivisors r q q.prop\u27e9) :=\n  map_apply_ofFractionRing_mk _ _ _ _\n#align ratfunc.laurent_aux_of_fraction_ring_mk RatFunc.laurentAux_ofFractionRing_mk\n\ntheorem laurentAux_div :\n    laurentAux r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q) :=\n  -- Porting note: added `by exact taylor_mem_nonZeroDivisors r`\n  map_apply_div _ (by exact taylor_mem_nonZeroDivisors r) _ _\n#align ratfunc.laurent_aux_div RatFunc.laurentAux_div\n\n@[simp]\ntheorem laurentAux_algebraMap : laurentAux r (algebraMap _ _ p) = algebraMap _ _ (taylor r p) := by\n  rw [\u2190 mk_one, \u2190 mk_one, mk_eq_div, laurentAux_div, mk_eq_div, taylor_one, map_one, map_one]\n#align ratfunc.laurent_aux_algebra_map RatFunc.laurentAux_algebraMap\n\n\ndef laurent : RatFunc R \u2192\u2090[R] RatFunc R :=\n  RatFunc.mapAlgHom (.ofLinearMap (taylor r) (taylor_one _) (taylor_mul _))\n    (taylor_mem_nonZeroDivisors _)\n#align ratfunc.laurent RatFunc.laurent\n\ntheorem laurent_div :\n    laurent r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q) :=\n  laurentAux_div r p q\n#align ratfunc.laurent_div RatFunc.laurent_div\n\n@[simp]\ntheorem laurent_algebraMap : laurent r (algebraMap _ _ p) = algebraMap _ _ (taylor r p) :=\n  laurentAux_algebraMap _ _\n#align ratfunc.laurent_algebra_map RatFunc.laurent_algebraMap\n\n@[simp]\n"}
{"name": "pullback_snd_eq221", "split": "test", "formal_statement": "theorem pullback_snd_eq :\n    Profinite.pullback.snd f g = (pullbackIsoPullback f g).hom \u226b Limits.pullback.snd := by", "header": "\nimport Mathlib.Topology.Category.Profinite.Basic\nimport Mathlib.CategoryTheory.Limits.Shapes.Pullbacks\nimport Mathlib.Topology.Category.CompHaus.Limits\n\n\n\nnamespace Profinite\n\nuniverse u w\n\n\nattribute [local instance] CategoryTheory.ConcreteCategory.instFunLike\n\nopen CategoryTheory Limits\n\nsection Pullbacks\n\nvariable {X Y B : Profinite.{u}} (f : X \u27f6 B) (g : Y \u27f6 B)\n\n\ndef pullback : Profinite.{u} :=\n  letI set := { xy : X \u00d7 Y | f xy.fst = g xy.snd }\n  haveI : CompactSpace set := isCompact_iff_compactSpace.mp\n    (isClosed_eq (f.continuous.comp continuous_fst) (g.continuous.comp continuous_snd)).isCompact\n  Profinite.of set\n\n\ndef pullback.fst : pullback f g \u27f6 X where\n  toFun := fun \u27e8\u27e8x, _\u27e9, _\u27e9 => x\n  continuous_toFun := Continuous.comp continuous_fst continuous_subtype_val\n\n\ndef pullback.snd : pullback f g \u27f6 Y where\n  toFun := fun \u27e8\u27e8_, y\u27e9, _\u27e9 => y\n  continuous_toFun := Continuous.comp continuous_snd continuous_subtype_val\n\n@[reassoc]\nlemma pullback.condition : pullback.fst f g \u226b f = pullback.snd f g \u226b g := by\n  ext \u27e8_, h\u27e9\n  exact h\n\n\ndef pullback.lift {Z : Profinite.{u}} (a : Z \u27f6 X) (b : Z \u27f6 Y) (w : a \u226b f = b \u226b g) :\n    Z \u27f6 pullback f g where\n  toFun := fun z => \u27e8\u27e8a z, b z\u27e9, by apply_fun (\u00b7 z) at w; exact w\u27e9\n  continuous_toFun := by\n    apply Continuous.subtype_mk\n    rw [continuous_prod_mk]\n    exact \u27e8a.continuous, b.continuous\u27e9\n\n@[reassoc (attr := simp)]\nlemma pullback.lift_fst {Z : Profinite.{u}} (a : Z \u27f6 X) (b : Z \u27f6 Y) (w : a \u226b f = b \u226b g) :\n    pullback.lift f g a b w \u226b pullback.fst f g = a := rfl\n\n@[reassoc (attr := simp)]\nlemma pullback.lift_snd {Z : Profinite.{u}} (a : Z \u27f6 X) (b : Z \u27f6 Y) (w : a \u226b f = b \u226b g) :\n    pullback.lift f g a b w \u226b pullback.snd f g = b := rfl\n\nlemma pullback.hom_ext {Z : Profinite.{u}} (a b : Z \u27f6 pullback f g)\n    (hfst : a \u226b pullback.fst f g = b \u226b pullback.fst f g)\n    (hsnd : a \u226b pullback.snd f g = b \u226b pullback.snd f g) : a = b := by\n  ext z\n  apply_fun (\u00b7 z) at hfst hsnd\n  apply Subtype.ext\n  apply Prod.ext\n  \u00b7 exact hfst\n  \u00b7 exact hsnd\n\n\n@[simps! pt \u03c0]\ndef pullback.cone : Limits.PullbackCone f g :=\n  Limits.PullbackCone.mk (pullback.fst f g) (pullback.snd f g) (pullback.condition f g)\n\n\n@[simps! lift]\ndef pullback.isLimit : Limits.IsLimit (pullback.cone f g) :=\n  Limits.PullbackCone.isLimitAux _\n    (fun s => pullback.lift f g s.fst s.snd s.condition)\n    (fun _ => pullback.lift_fst _ _ _ _ _)\n    (fun _ => pullback.lift_snd _ _ _ _ _)\n    (fun _ _ hm => pullback.hom_ext _ _ _ _ (hm .left) (hm .right))\n\nsection Isos\n\n\nnoncomputable\ndef pullbackIsoPullback : Profinite.pullback f g \u2245 Limits.pullback f g :=\nLimits.IsLimit.conePointUniqueUpToIso (pullback.isLimit f g) (Limits.limit.isLimit _)\n\n\nnoncomputable\ndef pullbackHomeoPullback : (Profinite.pullback f g).toCompHaus \u2243\u209c\n    (Limits.pullback f g).toCompHaus :=\nProfinite.homeoOfIso (pullbackIsoPullback f g)\n\ntheorem pullback_fst_eq :\n    Profinite.pullback.fst f g = (pullbackIsoPullback f g).hom \u226b Limits.pullback.fst := by\n  dsimp [pullbackIsoPullback]\n  simp only [Limits.limit.conePointUniqueUpToIso_hom_comp, pullback.cone_pt, pullback.cone_\u03c0]\n\n"}
{"name": "mul222", "split": "test", "formal_statement": "theorem mul {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x * y) := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Basic\nimport Mathlib.Algebra.Module.Defs\nimport Mathlib.Algebra.Star.Pi\n\n#align_import algebra.star.self_adjoint from \"leanprover-community/mathlib\"@\"a6ece35404f60597c651689c1b46ead86de5ac1b\"\n\n\n\nopen Function\n\nvariable {R A : Type*}\n\n\ndef IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x\n#align is_self_adjoint IsSelfAdjoint\n\n\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x\n#align is_star_normal IsStarNormal\n\nexport IsStarNormal (star_comm_self)\n\ntheorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n#align star_comm_self' star_comm_self'\n\nnamespace IsSelfAdjoint\n\n-- named to match `Commute.all\u2093`\n\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n#align is_self_adjoint.all IsSelfAdjoint.all\n\ntheorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n#align is_self_adjoint.star_eq IsSelfAdjoint.star_eq\n\ntheorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x :=\n  Iff.rfl\n#align is_self_adjoint_iff isSelfAdjoint_iff\n\n@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n#align is_self_adjoint.star_iff IsSelfAdjoint.star_iff\n\n@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint, star_mul, star_star]\n#align is_self_adjoint.star_mul_self IsSelfAdjoint.star_mul_self\n\n@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n#align is_self_adjoint.mul_star_self IsSelfAdjoint.mul_star_self\n\n\nlemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n\n\ntheorem starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S] [StarHomClass F R S]\n    {x : R} (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x) :=\n  show star (f x) = f x from map_star f x \u25b8 congr_arg f hx\n#align is_self_adjoint.star_hom_apply IsSelfAdjoint.starHom_apply\n\n\ntheorem _root_.isSelfAdjoint_starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S]\n    [StarHomClass F R S] [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x) :=\n  (IsSelfAdjoint.all x).starHom_apply f\n\nsection CommSemigroup\n\nvariable [CommSemigroup R] [StarMul R]\n\n"}
{"name": "smul_mk_zero223", "split": "test", "formal_statement": "theorem smul_mk_zero {\u03b2 : Type*} [Monoid M] [AddMonoid \u03b2] [DistribMulAction M \u03b2] (a : M) (b : \u03b1) :\n    a \u2022 (b, (0 : \u03b2)) = (a \u2022 b, 0) := by", "header": "\nimport Mathlib.Algebra.Group.Prod\nimport Mathlib.GroupTheory.GroupAction.Defs\n\n#align_import group_theory.group_action.prod from \"leanprover-community/mathlib\"@\"aba57d4d3dae35460225919dcd82fe91355162f9\"\n\n\n\nassert_not_exists MonoidWithZero\n\nvariable {M N P E \u03b1 \u03b2 : Type*}\n\nnamespace Prod\n\nsection\n\nvariable [SMul M \u03b1] [SMul M \u03b2] [SMul N \u03b1] [SMul N \u03b2] (a : M) (x : \u03b1 \u00d7 \u03b2)\n\n@[to_additive]\ninstance smul : SMul M (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun a p => (a \u2022 p.1, a \u2022 p.2)\u27e9\n\n@[to_additive (attr := simp)]\ntheorem smul_fst : (a \u2022 x).1 = a \u2022 x.1 :=\n  rfl\n#align prod.smul_fst Prod.smul_fst\n#align prod.vadd_fst Prod.vadd_fst\n\n@[to_additive (attr := simp)]\ntheorem smul_snd : (a \u2022 x).2 = a \u2022 x.2 :=\n  rfl\n#align prod.smul_snd Prod.smul_snd\n#align prod.vadd_snd Prod.vadd_snd\n\n@[to_additive (attr := simp)]\ntheorem smul_mk (a : M) (b : \u03b1) (c : \u03b2) : a \u2022 (b, c) = (a \u2022 b, a \u2022 c) :=\n  rfl\n#align prod.smul_mk Prod.smul_mk\n#align prod.vadd_mk Prod.vadd_mk\n\n@[to_additive]\ntheorem smul_def (a : M) (x : \u03b1 \u00d7 \u03b2) : a \u2022 x = (a \u2022 x.1, a \u2022 x.2) :=\n  rfl\n#align prod.smul_def Prod.smul_def\n#align prod.vadd_def Prod.vadd_def\n\n@[to_additive (attr := simp)]\ntheorem smul_swap : (a \u2022 x).swap = a \u2022 x.swap :=\n  rfl\n#align prod.smul_swap Prod.smul_swap\n#align prod.vadd_swap Prod.vadd_swap\n\ntheorem smul_zero_mk {\u03b1 : Type*} [Monoid M] [AddMonoid \u03b1] [DistribMulAction M \u03b1] (a : M) (c : \u03b2) :\n    a \u2022 ((0 : \u03b1), c) = (0, a \u2022 c) := by rw [Prod.smul_mk, smul_zero]\n#align prod.smul_zero_mk Prod.smul_zero_mk\n\n"}
{"name": "jacobiTheta_S_smul224", "split": "test", "formal_statement": "theorem jacobiTheta_S_smul (\u03c4 : \u210d) :\n    jacobiTheta \u2191(ModularGroup.S \u2022 \u03c4) = (-I * \u03c4) ^ (1 / 2 : \u2102) * jacobiTheta \u03c4 := by", "header": "\nimport Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable\nimport Mathlib.Analysis.Complex.UpperHalfPlane.Basic\n\n#align_import number_theory.modular_forms.jacobi_theta.basic from \"leanprover-community/mathlib\"@\"57f9349f2fe19d2de7207e99b0341808d977cdcf\"\n\n\n\nopen Complex Real Asymptotics Filter Topology\n\nopen scoped Real UpperHalfPlane\n\n\nnoncomputable def jacobiTheta (\u03c4 : \u2102) : \u2102 := \u2211' n : \u2124, cexp (\u03c0 * I * (n : \u2102) ^ 2 * \u03c4)\n#align jacobi_theta jacobiTheta\n\nlemma jacobiTheta_eq_jacobiTheta\u2082 (\u03c4 : \u2102) : jacobiTheta \u03c4 = jacobiTheta\u2082 0 \u03c4 :=\n  tsum_congr (by simp [jacobiTheta\u2082_term])\n\ntheorem jacobiTheta_two_add (\u03c4 : \u2102) : jacobiTheta (2 + \u03c4) = jacobiTheta \u03c4 := by\n  simp_rw [jacobiTheta_eq_jacobiTheta\u2082, add_comm, jacobiTheta\u2082_add_right]\n#align jacobi_theta_two_add jacobiTheta_two_add\n\ntheorem jacobiTheta_T_sq_smul (\u03c4 : \u210d) : jacobiTheta (ModularGroup.T ^ 2 \u2022 \u03c4 :) = jacobiTheta \u03c4 := by\n  suffices (ModularGroup.T ^ 2 \u2022 \u03c4 :) = (2 : \u2102) + \u2191\u03c4 by simp_rw [this, jacobiTheta_two_add]\n  have : ModularGroup.T ^ (2 : \u2115) = ModularGroup.T ^ (2 : \u2124) := rfl\n  simp_rw [this, UpperHalfPlane.modular_T_zpow_smul, UpperHalfPlane.coe_vadd]\n  norm_cast\nset_option linter.uppercaseLean3 false in\n#align jacobi_theta_T_sq_smul jacobiTheta_T_sq_smul\n\n"}
{"name": "funext225", "split": "test", "formal_statement": "theorem funext {\u03c3 : Type*} {p q : MvPolynomial \u03c3 R} (h : \u2200 x : \u03c3 \u2192 R, eval x p = eval x q) :\n    p = q := by", "header": "\nimport Mathlib.Algebra.Polynomial.RingDivision\nimport Mathlib.Algebra.MvPolynomial.Polynomial\nimport Mathlib.Algebra.MvPolynomial.Rename\nimport Mathlib.RingTheory.Polynomial.Basic\n\n#align_import data.mv_polynomial.funext from \"leanprover-community/mathlib\"@\"0b89934139d3be96f9dab477f10c20f9f93da580\"\n\n\n\nnamespace MvPolynomial\n\nvariable {R : Type*} [CommRing R] [IsDomain R] [Infinite R]\n\nprivate theorem funext_fin {n : \u2115} {p : MvPolynomial (Fin n) R}\n    (h : \u2200 x : Fin n \u2192 R, eval x p = 0) : p = 0 := by\n  induction' n with n ih\n  \u00b7 apply (MvPolynomial.isEmptyRingEquiv R (Fin 0)).injective\n    rw [RingEquiv.map_zero]\n    convert h finZeroElim\n  \u00b7 apply (finSuccEquiv R n).injective\n    simp only [AlgEquiv.map_zero]\n    refine Polynomial.funext fun q => ?_\n    rw [Polynomial.eval_zero]\n    apply ih fun x => ?_\n    calc _ = _ := eval_polynomial_eval_finSuccEquiv p _\n         _ = 0 := h _\n\n\n"}
{"name": "ceil_eq_self_of_mem226", "split": "test", "formal_statement": "theorem ceil_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (ceil b m : E) = m := by", "header": "\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n\n\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\ntheorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by simp [span_span_of_tower]\n\n\ndef fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}\n#align zspan.fundamental_domain Zspan.fundamentalDomain\n\n@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1 := Iff.rfl\n#align zspan.mem_fundamental_domain Zspan.mem_fundamentalDomain\n\ntheorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f) := by\n  ext x\n  rw [mem_fundamentalDomain, Basis.map_repr, LinearEquiv.trans_apply, \u2190 mem_fundamentalDomain,\n    show f.symm x = f.toEquiv.symm x by rfl, \u2190 Set.mem_image_equiv]\n  rfl\n\n@[simp]\ntheorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b := by\n  ext\n  simp_rw [mem_fundamentalDomain, Basis.repr_reindex_apply]\n  rw [Equiv.forall_congr' e]\n  simp_rw [implies_true]\n\nlemma fundamentalDomain_pi_basisFun [Fintype \u03b9] :\n    fundamentalDomain (Pi.basisFun \u211d \u03b9) = Set.pi Set.univ fun _ : \u03b9 \u21a6 Set.Ico (0 : \u211d) 1 := by\n  ext; simp\n\nvariable [FloorRing K]\n\nsection Fintype\n\nvariable [Fintype \u03b9]\n\n\ndef floor (m : E) : span \u2124 (Set.range b) := \u2211 i, \u230ab.repr m i\u230b \u2022 b.restrictScalars \u2124 i\n#align zspan.floor Zspan.floor\n\n\ndef ceil (m : E) : span \u2124 (Set.range b) := \u2211 i, \u2308b.repr m i\u2309 \u2022 b.restrictScalars \u2124 i\n#align zspan.ceil Zspan.ceil\n\n@[simp]\ntheorem repr_floor_apply (m : E) (i : \u03b9) : b.repr (floor b m) i = \u230ab.repr m i\u230b := by\n  classical simp only [floor, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_floor_apply Zspan.repr_floor_apply\n\n@[simp]\ntheorem repr_ceil_apply (m : E) (i : \u03b9) : b.repr (ceil b m) i = \u2308b.repr m i\u2309 := by\n  classical simp only [ceil, zsmul_eq_smul_cast K, b.repr.map_smul, Finsupp.single_apply,\n    Finset.sum_apply', Basis.repr_self, Finsupp.smul_single', mul_one, Finset.sum_ite_eq', coe_sum,\n    Finset.mem_univ, if_true, coe_smul_of_tower, Basis.restrictScalars_apply, map_sum]\n#align zspan.repr_ceil_apply Zspan.repr_ceil_apply\n\n@[simp]\ntheorem floor_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (floor b m : E) = m := by\n  apply b.ext_elem\n  simp_rw [repr_floor_apply b]\n  intro i\n  obtain \u27e8z, hz\u27e9 := (b.mem_span_iff_repr_mem \u2124 _).mp h i\n  rw [\u2190 hz]\n  exact congr_arg (Int.cast : \u2124 \u2192 K) (Int.floor_intCast z)\n#align zspan.floor_eq_self_of_mem Zspan.floor_eq_self_of_mem\n\n@[simp]\n"}
{"name": "isSheaf_yoneda_obj227", "split": "test", "formal_statement": "theorem isSheaf_yoneda_obj (W : C) : Presieve.IsSheaf (coherentTopology C) (yoneda.obj W) := by", "header": "\nimport Mathlib.CategoryTheory.Sites.Canonical\nimport Mathlib.CategoryTheory.Sites.Coherent.Basic\nimport Mathlib.CategoryTheory.Sites.EffectiveEpimorphic\n\n\nnamespace CategoryTheory\n\nvariable {C : Type*} [Category C] [Precoherent C]\n\nuniverse w in\nlemma isSheaf_coherent (P : C\u1d52\u1d56 \u2964 Type w) :\n    Presieve.IsSheaf (coherentTopology C) P \u2194\n    (\u2200 (B : C) (\u03b1 : Type) [Finite \u03b1] (X : \u03b1 \u2192 C) (\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B)),\n      EffectiveEpiFamily X \u03c0 \u2192 (Presieve.ofArrows X \u03c0).IsSheafFor P) := by\n  constructor\n  \u00b7 intro hP B \u03b1 _ X \u03c0 h\n    simp only [coherentTopology, Presieve.isSheaf_coverage] at hP\n    apply hP\n    exact \u27e8\u03b1, inferInstance, X, \u03c0, rfl, h\u27e9\n  \u00b7 intro h\n    simp only [coherentTopology, Presieve.isSheaf_coverage]\n    rintro B S \u27e8\u03b1, _, X, \u03c0, rfl, hS\u27e9\n    exact h _ _ _ _ hS\n\nnamespace coherentTopology\n\n\n"}
{"name": "LocallyIntegrableOn.mono228", "split": "test", "formal_statement": "theorem LocallyIntegrableOn.mono (hf : LocallyIntegrableOn f s \u03bc) {g : X \u2192 F}\n    (hg : AEStronglyMeasurable g \u03bc) (h : \u2200\u1d50 x \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016) :\n    LocallyIntegrableOn g s \u03bc := by", "header": "\nimport Mathlib.MeasureTheory.Integral.IntegrableOn\n\n#align_import measure_theory.function.locally_integrable from \"leanprover-community/mathlib\"@\"08a4542bec7242a5c60f179e4e49de8c0d677b1b\"\n\n\n\nopen MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology\n\nopen scoped Topology Interval ENNReal\n\nvariable {X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]\nvariable [MeasurableSpace Y] [TopologicalSpace Y]\nvariable [NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}\n\nnamespace MeasureTheory\n\nsection LocallyIntegrableOn\n\n\ndef LocallyIntegrableOn (f : X \u2192 E) (s : Set X) (\u03bc : Measure X := by volume_tac) : Prop :=\n  \u2200 x : X, x \u2208 s \u2192 IntegrableAtFilter f (\ud835\udcdd[s] x) \u03bc\n#align measure_theory.locally_integrable_on MeasureTheory.LocallyIntegrableOn\n\ntheorem LocallyIntegrableOn.mono_set (hf : LocallyIntegrableOn f s \u03bc) {t : Set X}\n    (hst : t \u2286 s) : LocallyIntegrableOn f t \u03bc := fun x hx =>\n  (hf x <| hst hx).filter_mono (nhdsWithin_mono x hst)\n#align measure_theory.locally_integrable_on.mono MeasureTheory.LocallyIntegrableOn.mono_set\n\ntheorem LocallyIntegrableOn.norm (hf : LocallyIntegrableOn f s \u03bc) :\n    LocallyIntegrableOn (fun x => \u2016f x\u2016) s \u03bc := fun t ht =>\n  let \u27e8U, hU_nhd, hU_int\u27e9 := hf t ht\n  \u27e8U, hU_nhd, hU_int.norm\u27e9\n#align measure_theory.locally_integrable_on.norm MeasureTheory.LocallyIntegrableOn.norm\n\n"}
{"name": "generateFrom_eq_prod229", "split": "test", "formal_statement": "theorem generateFrom_eq_prod {C : Set (Set \u03b1)} {D : Set (Set \u03b2)} (hC : generateFrom C = \u2039_\u203a)\n    (hD : generateFrom D = \u2039_\u203a) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) :\n    generateFrom (image2 (\u00b7 \u00d7\u02e2 \u00b7) C D) = Prod.instMeasurableSpace := by", "header": "\nimport Mathlib.MeasureTheory.Measure.GiryMonad\nimport Mathlib.Dynamics.Ergodic.MeasurePreserving\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.OpenPos\n\n#align_import measure_theory.constructions.prod.basic from \"leanprover-community/mathlib\"@\"00abe0695d8767201e6d008afa22393978bb324d\"\n\n\n\n\nnoncomputable section\n\nopen scoped Classical\nopen Topology ENNReal MeasureTheory\n\nopen Set Function Real ENNReal\n\nopen MeasureTheory MeasurableSpace MeasureTheory.Measure\n\nopen TopologicalSpace hiding generateFrom\n\nopen Filter hiding prod_eq map\n\nvariable {\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 E : Type*}\n\n\ntheorem IsPiSystem.prod {C : Set (Set \u03b1)} {D : Set (Set \u03b2)} (hC : IsPiSystem C)\n    (hD : IsPiSystem D) : IsPiSystem (image2 (\u00b7 \u00d7\u02e2 \u00b7) C D) := by\n  rintro _ \u27e8s\u2081, hs\u2081, t\u2081, ht\u2081, rfl\u27e9 _ \u27e8s\u2082, hs\u2082, t\u2082, ht\u2082, rfl\u27e9 hst\n  rw [prod_inter_prod] at hst \u22a2; rw [prod_nonempty_iff] at hst\n  exact mem_image2_of_mem (hC _ hs\u2081 _ hs\u2082 hst.1) (hD _ ht\u2081 _ ht\u2082 hst.2)\n#align is_pi_system.prod IsPiSystem.prod\n\n\ntheorem IsCountablySpanning.prod {C : Set (Set \u03b1)} {D : Set (Set \u03b2)} (hC : IsCountablySpanning C)\n    (hD : IsCountablySpanning D) : IsCountablySpanning (image2 (\u00b7 \u00d7\u02e2 \u00b7) C D) := by\n  rcases hC, hD with \u27e8\u27e8s, h1s, h2s\u27e9, t, h1t, h2t\u27e9\n  refine \u27e8fun n => s n.unpair.1 \u00d7\u02e2 t n.unpair.2, fun n => mem_image2_of_mem (h1s _) (h1t _), ?_\u27e9\n  rw [iUnion_unpair_prod, h2s, h2t, univ_prod_univ]\n#align is_countably_spanning.prod IsCountablySpanning.prod\n\nvariable [MeasurableSpace \u03b1] [MeasurableSpace \u03b1'] [MeasurableSpace \u03b2] [MeasurableSpace \u03b2']\nvariable [MeasurableSpace \u03b3]\nvariable {\u03bc \u03bc' : Measure \u03b1} {\u03bd \u03bd' : Measure \u03b2} {\u03c4 : Measure \u03b3}\nvariable [NormedAddCommGroup E]\n\n\n\n\ntheorem generateFrom_prod_eq {\u03b1 \u03b2} {C : Set (Set \u03b1)} {D : Set (Set \u03b2)} (hC : IsCountablySpanning C)\n    (hD : IsCountablySpanning D) :\n    @Prod.instMeasurableSpace _ _ (generateFrom C) (generateFrom D) =\n      generateFrom (image2 (\u00b7 \u00d7\u02e2 \u00b7) C D) := by\n  apply le_antisymm\n  \u00b7 refine sup_le ?_ ?_ <;> rw [comap_generateFrom] <;> apply generateFrom_le <;>\n      rintro _ \u27e8s, hs, rfl\u27e9\n    \u00b7 rcases hD with \u27e8t, h1t, h2t\u27e9\n      rw [\u2190 prod_univ, \u2190 h2t, prod_iUnion]\n      apply MeasurableSet.iUnion\n      intro n\n      apply measurableSet_generateFrom\n      exact \u27e8s, hs, t n, h1t n, rfl\u27e9\n    \u00b7 rcases hC with \u27e8t, h1t, h2t\u27e9\n      rw [\u2190 univ_prod, \u2190 h2t, iUnion_prod_const]\n      apply MeasurableSet.iUnion\n      rintro n\n      apply measurableSet_generateFrom\n      exact mem_image2_of_mem (h1t n) hs\n  \u00b7 apply generateFrom_le\n    rintro _ \u27e8s, hs, t, ht, rfl\u27e9\n    dsimp only\n    rw [prod_eq]\n    apply (measurable_fst _).inter (measurable_snd _)\n    \u00b7 exact measurableSet_generateFrom hs\n    \u00b7 exact measurableSet_generateFrom ht\n#align generate_from_prod_eq generateFrom_prod_eq\n\n\n"}
{"name": "homEquiv_leftAdjointUniq_hom_app230", "split": "test", "formal_statement": "theorem homEquiv_leftAdjointUniq_hom_app {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G)\n    (x : C) : adj1.homEquiv _ _ ((leftAdjointUniq adj1 adj2).hom.app x) = adj2.unit.app x := by", "header": "\nimport Mathlib.CategoryTheory.Adjunction.Basic\n\n\nopen CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D]\n\nnamespace CategoryTheory.Adjunction\n\n\n@[simps]\ndef natTransEquiv {F F' : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G') :\n    (G \u27f6 G') \u2243 (F' \u27f6 F) where\n  toFun f := {\n    app := fun X \u21a6 F'.map ((adj1.unit \u226b whiskerLeft F f).app X) \u226b adj2.counit.app _\n    naturality := by\n      intro X Y g\n      simp only [\u2190 Category.assoc, \u2190 Functor.map_comp]\n      erw [(adj1.unit \u226b (whiskerLeft F f)).naturality]\n      simp\n  }\n  invFun f := {\n    app := fun X \u21a6 adj2.unit.app (G.obj X) \u226b G'.map (f.app (G.obj X) \u226b adj1.counit.app X)\n    naturality := by\n      intro X Y g\n      erw [\u2190 adj2.unit_naturality_assoc]\n      simp only [\u2190 Functor.map_comp]\n      simp\n  }\n  left_inv f := by\n    ext X\n    simp only [Functor.comp_obj, NatTrans.comp_app, Functor.id_obj, whiskerLeft_app,\n      Functor.map_comp, Category.assoc, unit_naturality_assoc, right_triangle_components_assoc]\n    erw [\u2190 f.naturality (adj1.counit.app X), \u2190 Category.assoc]\n    simp\n  right_inv f := by\n    ext\n    simp\n\n@[simp]\nlemma natTransEquiv_id {F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G) :\n    natTransEquiv adj adj (\ud835\udfd9 _) = \ud835\udfd9 _ := by ext; simp\n\n@[simp]\nlemma natTransEquiv_id_symm {F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G) :\n    (natTransEquiv adj adj).symm (\ud835\udfd9 _) = \ud835\udfd9 _ := by ext; simp\n\n@[simp]\nlemma natTransEquiv_comp {F F' F'' : C \u2964 D} {G G' G'' : D \u2964 C}\n    (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G') (adj3 : F'' \u22a3 G'') (f : G \u27f6 G') (g : G' \u27f6 G'') :\n    natTransEquiv adj2 adj3 g \u226b natTransEquiv adj1 adj2 f = natTransEquiv adj1 adj3 (f \u226b g) := by\n  apply (natTransEquiv adj1 adj3).symm.injective\n  ext X\n  simp only [natTransEquiv_symm_apply_app, Functor.comp_obj, NatTrans.comp_app,\n    natTransEquiv_apply_app, Functor.id_obj, whiskerLeft_app, Functor.map_comp, Category.assoc,\n    unit_naturality_assoc, right_triangle_components_assoc, Equiv.symm_apply_apply,\n    \u2190 g.naturality_assoc, \u2190 g.naturality]\n  simp only [\u2190 Category.assoc, unit_naturality, Functor.comp_obj, right_triangle_components,\n    Category.comp_id, \u2190 f.naturality, Category.id_comp]\n\n@[simp]\nlemma natTransEquiv_comp_symm {F F' F'' : C \u2964 D} {G G' G'' : D \u2964 C}\n    (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G') (adj3 : F'' \u22a3 G'') (f : F' \u27f6 F) (g : F'' \u27f6 F') :\n    (natTransEquiv adj1 adj2).symm f \u226b (natTransEquiv adj2 adj3).symm g =\n      (natTransEquiv adj1 adj3).symm (g \u226b f) := by\n  apply (natTransEquiv adj1 adj3).injective\n  ext\n  simp\n\n\n@[simps]\ndef natIsoEquiv {F F' : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G') :\n    (G \u2245 G') \u2243 (F' \u2245 F) where\n  toFun i := {\n    hom := natTransEquiv adj1 adj2 i.hom\n    inv := natTransEquiv adj2 adj1 i.inv\n  }\n  invFun i := {\n    hom := (natTransEquiv adj1 adj2).symm i.hom\n    inv := (natTransEquiv adj2 adj1).symm i.inv }\n  left_inv i := by simp\n  right_inv i := by simp\n\n\ndef leftAdjointUniq {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G) : F \u2245 F' :=\n  (natIsoEquiv adj1 adj2 (Iso.refl _)).symm\n#align category_theory.adjunction.left_adjoint_uniq CategoryTheory.Adjunction.leftAdjointUniq\n\n-- Porting note (#10618): removed simp as simp can prove this\n"}
{"name": "find_le_iff231", "split": "test", "formal_statement": "theorem find_le_iff (n : \u2115+) : PNat.find h \u2264 n \u2194 \u2203 m \u2264 n, p m := by", "header": "\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.find from \"leanprover-community/mathlib\"@\"207cfac9fcd06138865b5d04f7091e46d9320432\"\n\n\n\n\nnamespace PNat\n\nvariable {p q : \u2115+ \u2192 Prop} [DecidablePred p] [DecidablePred q] (h : \u2203 n, p n)\n\ninstance decidablePredExistsNat : DecidablePred fun n' : \u2115 => \u2203 (n : \u2115+) (_ : n' = n), p n :=\n  fun n' =>\n  decidable_of_iff' (\u2203 h : 0 < n', p \u27e8n', h\u27e9) <|\n    Subtype.exists.trans <| by\n      simp_rw [mk_coe, @exists_comm (_ < _) (_ = _), exists_prop, exists_eq_left']\n#align pnat.decidable_pred_exists_nat PNat.decidablePredExistsNat\n\n\nprotected def findX : { n // p n \u2227 \u2200 m : \u2115+, m < n \u2192 \u00acp m } := by\n  have : \u2203 (n' : \u2115) (n : \u2115+) (_ : n' = n), p n := Exists.elim h fun n hn => \u27e8n, n, rfl, hn\u27e9\n  have n := Nat.findX this\n  refine \u27e8\u27e8n, ?_\u27e9, ?_, fun m hm pm => ?_\u27e9\n  \u00b7 obtain \u27e8n', hn', -\u27e9 := n.prop.1\n    rw [hn']\n    exact n'.prop\n  \u00b7 obtain \u27e8n', hn', pn'\u27e9 := n.prop.1\n    simpa [hn', Subtype.coe_eta] using pn'\n  \u00b7 exact n.prop.2 m hm \u27e8m, rfl, pm\u27e9\n#align pnat.find_x PNat.findX\n\n\nprotected def find : \u2115+ :=\n  PNat.findX h\n#align pnat.find PNat.find\n\nprotected theorem find_spec : p (PNat.find h) :=\n  (PNat.findX h).prop.left\n#align pnat.find_spec PNat.find_spec\n\nprotected theorem find_min : \u2200 {m : \u2115+}, m < PNat.find h \u2192 \u00acp m :=\n  @(PNat.findX h).prop.right\n#align pnat.find_min PNat.find_min\n\nprotected theorem find_min' {m : \u2115+} (hm : p m) : PNat.find h \u2264 m :=\n  le_of_not_lt fun l => PNat.find_min h l hm\n#align pnat.find_min' PNat.find_min'\n\nvariable {n m : \u2115+}\n\ntheorem find_eq_iff : PNat.find h = m \u2194 p m \u2227 \u2200 n < m, \u00acp n := by\n  constructor\n  \u00b7 rintro rfl\n    exact \u27e8PNat.find_spec h, fun _ => PNat.find_min h\u27e9\n  \u00b7 rintro \u27e8hm, hlt\u27e9\n    exact le_antisymm (PNat.find_min' h hm) (not_lt.1 <| imp_not_comm.1 (hlt _) <| PNat.find_spec h)\n#align pnat.find_eq_iff PNat.find_eq_iff\n\n@[simp]\ntheorem find_lt_iff (n : \u2115+) : PNat.find h < n \u2194 \u2203 m < n, p m :=\n  \u27e8fun h2 => \u27e8PNat.find h, h2, PNat.find_spec h\u27e9, fun \u27e8_, hmn, hm\u27e9 =>\n    (PNat.find_min' h hm).trans_lt hmn\u27e9\n#align pnat.find_lt_iff PNat.find_lt_iff\n\n@[simp]\n"}
{"name": "mem_posTangentConeAt_of_segment_subset'232", "split": "test", "formal_statement": "theorem mem_posTangentConeAt_of_segment_subset' {s : Set E} {x y : E}\n    (h : segment \u211d x (x + y) \u2286 s) : y \u2208 posTangentConeAt s x := by", "header": "\nimport Mathlib.Analysis.Calculus.Deriv.Add\n\n#align_import analysis.calculus.local_extr from \"leanprover-community/mathlib\"@\"3bce8d800a6f2b8f63fe1e588fd76a9ff4adcebe\"\n\n\n\n\nuniverse u v\n\nopen Filter Set\n\nopen scoped Topology Classical\n\nsection Module\n\nvariable {E : Type u} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {a : E} {f' : E \u2192L[\u211d] \u211d}\n\n\n\n\ndef posTangentConeAt (s : Set E) (x : E) : Set E :=\n  { y : E | \u2203 (c : \u2115 \u2192 \u211d) (d : \u2115 \u2192 E), (\u2200\u1da0 n in atTop, x + d n \u2208 s) \u2227\n    Tendsto c atTop atTop \u2227 Tendsto (fun n => c n \u2022 d n) atTop (\ud835\udcdd y) }\n#align pos_tangent_cone_at posTangentConeAt\n\ntheorem posTangentConeAt_mono : Monotone fun s => posTangentConeAt s a := by\n  rintro s t hst y \u27e8c, d, hd, hc, hcd\u27e9\n  exact \u27e8c, d, mem_of_superset hd fun h hn => hst hn, hc, hcd\u27e9\n#align pos_tangent_cone_at_mono posTangentConeAt_mono\n\ntheorem mem_posTangentConeAt_of_segment_subset {s : Set E} {x y : E} (h : segment \u211d x y \u2286 s) :\n    y - x \u2208 posTangentConeAt s x := by\n  let c := fun n : \u2115 => (2 : \u211d) ^ n\n  let d := fun n : \u2115 => (c n)\u207b\u00b9 \u2022 (y - x)\n  refine \u27e8c, d, Filter.univ_mem' fun n => h ?_, tendsto_pow_atTop_atTop_of_one_lt one_lt_two, ?_\u27e9\n  \u00b7 show x + d n \u2208 segment \u211d x y\n    rw [segment_eq_image']\n    refine \u27e8(c n)\u207b\u00b9, \u27e8?_, ?_\u27e9, rfl\u27e9\n    exacts [inv_nonneg.2 (pow_nonneg zero_le_two _), inv_le_one (one_le_pow_of_one_le one_le_two _)]\n  \u00b7 show Tendsto (fun n => c n \u2022 d n) atTop (\ud835\udcdd (y - x))\n    exact tendsto_const_nhds.congr fun n \u21a6 (smul_inv_smul\u2080 (pow_ne_zero _ two_ne_zero) _).symm\n#align mem_pos_tangent_cone_at_of_segment_subset mem_posTangentConeAt_of_segment_subset\n\n"}
{"name": "nadd_le_nadd_right233", "split": "test", "formal_statement": "theorem nadd_le_nadd_right (h : b \u2264 c) (a) : b \u266f a \u2264 c \u266f a := by", "header": "\nimport Mathlib.SetTheory.Ordinal.Arithmetic\nimport Mathlib.Tactic.Abel\n\n#align_import set_theory.ordinal.natural_ops from \"leanprover-community/mathlib\"@\"31b269b60935483943542d547a6dd83a66b37dc7\"\n\n\n\nset_option autoImplicit true\n\n\nuniverse u v\n\nopen Function Order\n\nnoncomputable section\n\n\n\n\ndef NatOrdinal : Type _ :=\n  -- Porting note: used to derive LinearOrder & SuccOrder but need to manually define\n  Ordinal deriving Zero, Inhabited, One, WellFoundedRelation\n#align nat_ordinal NatOrdinal\n\ninstance NatOrdinal.linearOrder : LinearOrder NatOrdinal := {Ordinal.linearOrder with}\n\ninstance NatOrdinal.succOrder : SuccOrder NatOrdinal := {Ordinal.succOrder with}\n\n\n@[match_pattern]\ndef Ordinal.toNatOrdinal : Ordinal \u2243o NatOrdinal :=\n  OrderIso.refl _\n#align ordinal.to_nat_ordinal Ordinal.toNatOrdinal\n\n\n@[match_pattern]\ndef NatOrdinal.toOrdinal : NatOrdinal \u2243o Ordinal :=\n  OrderIso.refl _\n#align nat_ordinal.to_ordinal NatOrdinal.toOrdinal\n\nnamespace Ordinal\n\nvariable {a b c : Ordinal.{u}}\n\n@[simp]\ntheorem toNatOrdinal_symm_eq : toNatOrdinal.symm = NatOrdinal.toOrdinal :=\n  rfl\n#align ordinal.to_nat_ordinal_symm_eq Ordinal.toNatOrdinal_symm_eq\n\n@[simp]\ntheorem toNatOrdinal_toOrdinal (a : Ordinal) :  NatOrdinal.toOrdinal (toNatOrdinal a) = a :=\n  rfl\n#align ordinal.to_nat_ordinal_to_ordinal Ordinal.toNatOrdinal_toOrdinal\n\n@[simp]\ntheorem toNatOrdinal_zero : toNatOrdinal 0 = 0 :=\n  rfl\n#align ordinal.to_nat_ordinal_zero Ordinal.toNatOrdinal_zero\n\n@[simp]\ntheorem toNatOrdinal_one : toNatOrdinal 1 = 1 :=\n  rfl\n#align ordinal.to_nat_ordinal_one Ordinal.toNatOrdinal_one\n\n@[simp]\ntheorem toNatOrdinal_eq_zero (a) : toNatOrdinal a = 0 \u2194 a = 0 :=\n  Iff.rfl\n#align ordinal.to_nat_ordinal_eq_zero Ordinal.toNatOrdinal_eq_zero\n\n@[simp]\ntheorem toNatOrdinal_eq_one (a) : toNatOrdinal a = 1 \u2194 a = 1 :=\n  Iff.rfl\n#align ordinal.to_nat_ordinal_eq_one Ordinal.toNatOrdinal_eq_one\n\n@[simp]\ntheorem toNatOrdinal_max (a b : Ordinal) :\n    toNatOrdinal (max a b) = max (toNatOrdinal a) (toNatOrdinal b) :=\n  rfl\n#align ordinal.to_nat_ordinal_max Ordinal.toNatOrdinal_max\n\n@[simp]\ntheorem toNatOrdinal_min (a b : Ordinal) :\n    toNatOrdinal (linearOrder.min a b) = linearOrder.min (toNatOrdinal a) (toNatOrdinal b) :=\n  rfl\n#align ordinal.to_nat_ordinal_min Ordinal.toNatOrdinal_min\n\n\n\n\nnoncomputable def nadd : Ordinal \u2192 Ordinal \u2192 Ordinal\n  | a, b =>\n    max (blsub.{u, u} a fun a' _ => nadd a' b) (blsub.{u, u} b fun b' _ => nadd a b')\n  termination_by o\u2081 o\u2082 => (o\u2081, o\u2082)\n#align ordinal.nadd Ordinal.nadd\n\n@[inherit_doc]\nscoped[NaturalOps] infixl:65 \" \u266f \" => Ordinal.nadd\n\nopen NaturalOps\n\n\nnoncomputable def nmul : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\n  | a, b => sInf {c | \u2200 a' < a, \u2200 b' < b, nmul a' b \u266f nmul a b' < c \u266f nmul a' b'}\ntermination_by a b => (a, b)\n#align ordinal.nmul Ordinal.nmul\n\n@[inherit_doc]\nscoped[NaturalOps] infixl:70 \" \u2a33 \" => Ordinal.nmul\n\n\n\ntheorem nadd_def (a b : Ordinal) :\n    a \u266f b = max (blsub.{u, u} a fun a' _ => a' \u266f b) (blsub.{u, u} b fun b' _ => a \u266f b') := by\n  rw [nadd]\n#align ordinal.nadd_def Ordinal.nadd_def\n\ntheorem lt_nadd_iff : a < b \u266f c \u2194 (\u2203 b' < b, a \u2264 b' \u266f c) \u2228 \u2203 c' < c, a \u2264 b \u266f c' := by\n  rw [nadd_def]\n  simp [lt_blsub_iff]\n#align ordinal.lt_nadd_iff Ordinal.lt_nadd_iff\n\ntheorem nadd_le_iff : b \u266f c \u2264 a \u2194 (\u2200 b' < b, b' \u266f c < a) \u2227 \u2200 c' < c, b \u266f c' < a := by\n  rw [nadd_def]\n  simp [blsub_le_iff]\n#align ordinal.nadd_le_iff Ordinal.nadd_le_iff\n\ntheorem nadd_lt_nadd_left (h : b < c) (a) : a \u266f b < a \u266f c :=\n  lt_nadd_iff.2 (Or.inr \u27e8b, h, le_rfl\u27e9)\n#align ordinal.nadd_lt_nadd_left Ordinal.nadd_lt_nadd_left\n\ntheorem nadd_lt_nadd_right (h : b < c) (a) : b \u266f a < c \u266f a :=\n  lt_nadd_iff.2 (Or.inl \u27e8b, h, le_rfl\u27e9)\n#align ordinal.nadd_lt_nadd_right Ordinal.nadd_lt_nadd_right\n\ntheorem nadd_le_nadd_left (h : b \u2264 c) (a) : a \u266f b \u2264 a \u266f c := by\n  rcases lt_or_eq_of_le h with (h | rfl)\n  \u00b7 exact (nadd_lt_nadd_left h a).le\n  \u00b7 exact le_rfl\n#align ordinal.nadd_le_nadd_left Ordinal.nadd_le_nadd_left\n\n"}
{"name": "angle_zero_left234", "split": "test", "formal_statement": "theorem angle_zero_left (x : V) : angle 0 x = \u03c0 / 2 := by", "header": "\nimport Mathlib.Analysis.InnerProductSpace.Basic\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Inverse\n\n#align_import geometry.euclidean.angle.unoriented.basic from \"leanprover-community/mathlib\"@\"46b633fd842bef9469441c0209906f6dddd2b4f5\"\n\n\n\n\nassert_not_exists HasFDerivAt\n\nassert_not_exists ConformalAt\n\nnoncomputable section\n\nopen Real Set\n\nopen Real\n\nopen RealInnerProductSpace\n\nnamespace InnerProductGeometry\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] {x y : V}\n\n\ndef angle (x y : V) : \u211d :=\n  Real.arccos (\u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016))\n#align inner_product_geometry.angle InnerProductGeometry.angle\n\ntheorem continuousAt_angle {x : V \u00d7 V} (hx1 : x.1 \u2260 0) (hx2 : x.2 \u2260 0) :\n    ContinuousAt (fun y : V \u00d7 V => angle y.1 y.2) x :=\n  Real.continuous_arccos.continuousAt.comp <|\n    continuous_inner.continuousAt.div\n      ((continuous_norm.comp continuous_fst).mul (continuous_norm.comp continuous_snd)).continuousAt\n      (by simp [hx1, hx2])\n#align inner_product_geometry.continuous_at_angle InnerProductGeometry.continuousAt_angle\n\ntheorem angle_smul_smul {c : \u211d} (hc : c \u2260 0) (x y : V) : angle (c \u2022 x) (c \u2022 y) = angle x y := by\n  have : c * c \u2260 0 := mul_ne_zero hc hc\n  rw [angle, angle, real_inner_smul_left, inner_smul_right, norm_smul, norm_smul, Real.norm_eq_abs,\n    mul_mul_mul_comm _ \u2016x\u2016, abs_mul_abs_self, \u2190 mul_assoc c c, mul_div_mul_left _ _ this]\n#align inner_product_geometry.angle_smul_smul InnerProductGeometry.angle_smul_smul\n\n@[simp]\ntheorem _root_.LinearIsometry.angle_map {E F : Type*} [NormedAddCommGroup E] [NormedAddCommGroup F]\n    [InnerProductSpace \u211d E] [InnerProductSpace \u211d F] (f : E \u2192\u2097\u1d62[\u211d] F) (u v : E) :\n    angle (f u) (f v) = angle u v := by\n  rw [angle, angle, f.inner_map_map, f.norm_map, f.norm_map]\n#align linear_isometry.angle_map LinearIsometry.angle_map\n\n@[simp, norm_cast]\ntheorem _root_.Submodule.angle_coe {s : Submodule \u211d V} (x y : s) :\n    angle (x : V) (y : V) = angle x y :=\n  s.subtype\u2097\u1d62.angle_map x y\n#align submodule.angle_coe Submodule.angle_coe\n\n\ntheorem cos_angle (x y : V) : Real.cos (angle x y) = \u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016) :=\n  Real.cos_arccos (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).1\n    (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x y)).2\n#align inner_product_geometry.cos_angle InnerProductGeometry.cos_angle\n\n\ntheorem angle_comm (x y : V) : angle x y = angle y x := by\n  unfold angle\n  rw [real_inner_comm, mul_comm]\n#align inner_product_geometry.angle_comm InnerProductGeometry.angle_comm\n\n\n@[simp]\ntheorem angle_neg_neg (x y : V) : angle (-x) (-y) = angle x y := by\n  unfold angle\n  rw [inner_neg_neg, norm_neg, norm_neg]\n#align inner_product_geometry.angle_neg_neg InnerProductGeometry.angle_neg_neg\n\n\ntheorem angle_nonneg (x y : V) : 0 \u2264 angle x y :=\n  Real.arccos_nonneg _\n#align inner_product_geometry.angle_nonneg InnerProductGeometry.angle_nonneg\n\n\ntheorem angle_le_pi (x y : V) : angle x y \u2264 \u03c0 :=\n  Real.arccos_le_pi _\n#align inner_product_geometry.angle_le_pi InnerProductGeometry.angle_le_pi\n\n\ntheorem angle_neg_right (x y : V) : angle x (-y) = \u03c0 - angle x y := by\n  unfold angle\n  rw [\u2190 Real.arccos_neg, norm_neg, inner_neg_right, neg_div]\n#align inner_product_geometry.angle_neg_right InnerProductGeometry.angle_neg_right\n\n\ntheorem angle_neg_left (x y : V) : angle (-x) y = \u03c0 - angle x y := by\n  rw [\u2190 angle_neg_neg, neg_neg, angle_neg_right]\n#align inner_product_geometry.angle_neg_left InnerProductGeometry.angle_neg_left\n\nproof_wanted angle_triangle (x y z : V) : angle x z \u2264 angle x y + angle y z\n\n\n@[simp]\n"}
{"name": "angle_smul_smul235", "split": "test", "formal_statement": "theorem angle_smul_smul {c : \u211d} (hc : c \u2260 0) (x y : V) : angle (c \u2022 x) (c \u2022 y) = angle x y := by", "header": "\nimport Mathlib.Analysis.InnerProductSpace.Basic\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Inverse\n\n#align_import geometry.euclidean.angle.unoriented.basic from \"leanprover-community/mathlib\"@\"46b633fd842bef9469441c0209906f6dddd2b4f5\"\n\n\n\n\nassert_not_exists HasFDerivAt\n\nassert_not_exists ConformalAt\n\nnoncomputable section\n\nopen Real Set\n\nopen Real\n\nopen RealInnerProductSpace\n\nnamespace InnerProductGeometry\n\nvariable {V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] {x y : V}\n\n\ndef angle (x y : V) : \u211d :=\n  Real.arccos (\u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016))\n#align inner_product_geometry.angle InnerProductGeometry.angle\n\ntheorem continuousAt_angle {x : V \u00d7 V} (hx1 : x.1 \u2260 0) (hx2 : x.2 \u2260 0) :\n    ContinuousAt (fun y : V \u00d7 V => angle y.1 y.2) x :=\n  Real.continuous_arccos.continuousAt.comp <|\n    continuous_inner.continuousAt.div\n      ((continuous_norm.comp continuous_fst).mul (continuous_norm.comp continuous_snd)).continuousAt\n      (by simp [hx1, hx2])\n#align inner_product_geometry.continuous_at_angle InnerProductGeometry.continuousAt_angle\n\n"}
{"name": "IsMinOn.of_isLocalMinOn_of_convexOn236", "split": "test", "formal_statement": "theorem IsMinOn.of_isLocalMinOn_of_convexOn {f : E \u2192 \u03b2} {a : E} (a_in_s : a \u2208 s)\n    (h_localmin : IsLocalMinOn f s a) (h_conv : ConvexOn \u211d s f) : IsMinOn f s a := by", "header": "\nimport Mathlib.Analysis.Convex.Function\nimport Mathlib.Topology.Algebra.Affine\nimport Mathlib.Topology.MetricSpace.PseudoMetric\nimport Mathlib.Topology.Order.LocalExtr\n\n#align_import analysis.convex.extrema from \"leanprover-community/mathlib\"@\"f2ce6086713c78a7f880485f7917ea547a215982\"\n\n\n\n\nvariable {E \u03b2 : Type*} [AddCommGroup E] [TopologicalSpace E] [Module \u211d E] [TopologicalAddGroup E]\n  [ContinuousSMul \u211d E] [OrderedAddCommGroup \u03b2] [Module \u211d \u03b2] [OrderedSMul \u211d \u03b2] {s : Set E}\n\nopen Set Filter Function\n\nopen scoped Classical\nopen Topology\n\n\ntheorem IsMinOn.of_isLocalMinOn_of_convexOn_Icc {f : \u211d \u2192 \u03b2} {a b : \u211d} (a_lt_b : a < b)\n    (h_local_min : IsLocalMinOn f (Icc a b) a) (h_conv : ConvexOn \u211d (Icc a b) f) :\n    IsMinOn f (Icc a b) a := by\n  rintro c hc\n  dsimp only [mem_setOf_eq]\n  rw [IsLocalMinOn, nhdsWithin_Icc_eq_nhdsWithin_Ici a_lt_b] at h_local_min\n  rcases hc.1.eq_or_lt with (rfl | a_lt_c)\n  \u00b7 exact le_rfl\n  have H\u2081 : \u2200\u1da0 y in \ud835\udcdd[>] a, f a \u2264 f y :=\n    h_local_min.filter_mono (nhdsWithin_mono _ Ioi_subset_Ici_self)\n  have H\u2082 : \u2200\u1da0 y in \ud835\udcdd[>] a, y \u2208 Ioc a c := Ioc_mem_nhdsWithin_Ioi (left_mem_Ico.2 a_lt_c)\n  rcases (H\u2081.and H\u2082).exists with \u27e8y, hfy, hy_ac\u27e9\n  rcases (Convex.mem_Ioc a_lt_c).mp hy_ac with \u27e8ya, yc, ya\u2080, yc\u2080, yac, rfl\u27e9\n  suffices ya \u2022 f a + yc \u2022 f a \u2264 ya \u2022 f a + yc \u2022 f c from\n    (smul_le_smul_iff_of_pos_left yc\u2080).1 (le_of_add_le_add_left this)\n  calc\n    ya \u2022 f a + yc \u2022 f a = f a := by rw [\u2190 add_smul, yac, one_smul]\n    _ \u2264 f (ya * a + yc * c) := hfy\n    _ \u2264 ya \u2022 f a + yc \u2022 f c := h_conv.2 (left_mem_Icc.2 a_lt_b.le) hc ya\u2080 yc\u2080.le yac\n#align is_min_on.of_is_local_min_on_of_convex_on_Icc IsMinOn.of_isLocalMinOn_of_convexOn_Icc\n\n\n"}
{"name": "jacobiSymNat.zero_right237", "split": "test", "formal_statement": "theorem jacobiSymNat.zero_right (a : \u2115) : jacobiSymNat a 0 = 1 := by", "header": "\nimport Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol\n\n#align_import number_theory.legendre_symbol.norm_num from \"leanprover-community/mathlib\"@\"e2621d935895abe70071ab828a4ee6e26a52afe4\"\n\n\n\n\nsection Lemmas\n\nnamespace Mathlib.Meta.NormNum\n\n\ndef jacobiSymNat (a b : \u2115) : \u2124 :=\n  jacobiSym a b\n#align norm_num.jacobi_sym_nat Mathlib.Meta.NormNum.jacobiSymNat\n\n\n\n\n\n"}
{"name": "convergents_succ238", "split": "test", "formal_statement": "theorem convergents_succ (n : \u2115) :\n    (of v).convergents (n + 1) = \u230av\u230b + 1 / (of (Int.fract v)\u207b\u00b9).convergents n := by", "header": "\nimport Mathlib.Algebra.ContinuedFractions.Computation.Approximations\nimport Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv\nimport Mathlib.Algebra.Order.Archimedean\nimport Mathlib.Tactic.GCongr\nimport Mathlib.Topology.Order.LeftRightNhds\n\n#align_import algebra.continued_fractions.computation.approximation_corollaries from \"leanprover-community/mathlib\"@\"f0c8bf9245297a541f468be517f1bde6195105e9\"\n\n\n\n\nvariable {K : Type*} (v : K) [LinearOrderedField K] [FloorRing K]\n\nopen GeneralizedContinuedFraction (of)\nopen GeneralizedContinuedFraction\nopen scoped Topology\n\ntheorem GeneralizedContinuedFraction.of_isSimpleContinuedFraction :\n    (of v).IsSimpleContinuedFraction := fun _ _ nth_part_num_eq =>\n  of_part_num_eq_one nth_part_num_eq\n#align generalized_continued_fraction.of_is_simple_continued_fraction GeneralizedContinuedFraction.of_isSimpleContinuedFraction\n\n\nnonrec def SimpleContinuedFraction.of : SimpleContinuedFraction K :=\n  \u27e8of v, GeneralizedContinuedFraction.of_isSimpleContinuedFraction v\u27e9\n#align simple_continued_fraction.of SimpleContinuedFraction.of\n\ntheorem SimpleContinuedFraction.of_isContinuedFraction :\n    (SimpleContinuedFraction.of v).IsContinuedFraction := fun _ _ nth_part_denom_eq =>\n  lt_of_lt_of_le zero_lt_one (of_one_le_get?_part_denom nth_part_denom_eq)\n#align simple_continued_fraction.of_is_continued_fraction SimpleContinuedFraction.of_isContinuedFraction\n\n\ndef ContinuedFraction.of : ContinuedFraction K :=\n  \u27e8SimpleContinuedFraction.of v, SimpleContinuedFraction.of_isContinuedFraction v\u27e9\n#align continued_fraction.of ContinuedFraction.of\n\nnamespace GeneralizedContinuedFraction\n\ntheorem of_convergents_eq_convergents' : (of v).convergents = (of v).convergents' :=\n  @ContinuedFraction.convergents_eq_convergents' _ _ (ContinuedFraction.of v)\n#align generalized_continued_fraction.of_convergents_eq_convergents' GeneralizedContinuedFraction.of_convergents_eq_convergents'\n\n\n"}
{"name": "normalize_mul_left239", "split": "test", "formal_statement": "theorem normalize_mul_left {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (\u2191a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0 := by", "header": "\nimport Batteries.Data.Rat.Basic\nimport Batteries.Tactic.SeqFocus\n\n\n\nnamespace Rat\n\ntheorem ext : {p q : Rat} \u2192 p.num = q.num \u2192 p.den = q.den \u2192 p = q\n  | \u27e8_,_,_,_\u27e9, \u27e8_,_,_,_\u27e9, rfl, rfl => rfl\n\n@[simp] theorem mk_den_one {r : Int} :\n    \u27e8r, 1, Nat.one_ne_zero, (Nat.coprime_one_right _)\u27e9 = (r : Rat) := rfl\n\n@[simp] theorem zero_num : (0 : Rat).num = 0 := rfl\n@[simp] theorem zero_den : (0 : Rat).den = 1 := rfl\n@[simp] theorem one_num : (1 : Rat).num = 1 := rfl\n@[simp] theorem one_den : (1 : Rat).den = 1 := rfl\n\n@[simp] theorem maybeNormalize_eq {num den g} (den_nz reduced) :\n    maybeNormalize num den g den_nz reduced =\n    { num := num.div g, den := den / g, den_nz, reduced } := by\n  unfold maybeNormalize; split\n  \u00b7 subst g; simp\n  \u00b7 rfl\n\ntheorem normalize.reduced' {num : Int} {den g : Nat} (den_nz : den \u2260 0)\n    (e : g = num.natAbs.gcd den) : (num / g).natAbs.Coprime (den / g) := by\n  rw [\u2190 Int.div_eq_ediv_of_dvd (e \u25b8 Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n  exact normalize.reduced den_nz e\n\ntheorem normalize_eq {num den} (den_nz) : normalize num den den_nz =\n    { num := num / num.natAbs.gcd den\n      den := den / num.natAbs.gcd den\n      den_nz := normalize.den_nz den_nz rfl\n      reduced := normalize.reduced' den_nz rfl } := by\n  simp only [normalize, maybeNormalize_eq,\n    Int.div_eq_ediv_of_dvd (Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n\n@[simp] theorem normalize_zero (nz) : normalize 0 d nz = 0 := by\n  simp [normalize, Int.zero_div, Int.natAbs_zero, Nat.div_self (Nat.pos_of_ne_zero nz)]; rfl\n\ntheorem mk_eq_normalize (num den nz c) : \u27e8num, den, nz, c\u27e9 = normalize num den nz := by\n  simp [normalize_eq, c.gcd_eq_one]\n\ntheorem normalize_self (r : Rat) : normalize r.num r.den r.den_nz = r := (mk_eq_normalize ..).symm\n\n"}
{"name": "LocallyIntegrableOn.exists_nat_integrableOn240", "split": "test", "formal_statement": "theorem LocallyIntegrableOn.exists_nat_integrableOn [SecondCountableTopology X]\n    (hf : LocallyIntegrableOn f s \u03bc) : \u2203 u : \u2115 \u2192 Set X,\n    (\u2200 n, IsOpen (u n)) \u2227 (s \u2286 \u22c3 n, u n) \u2227 (\u2200 n, IntegrableOn f (u n \u2229 s) \u03bc) := by", "header": "\nimport Mathlib.MeasureTheory.Integral.IntegrableOn\n\n#align_import measure_theory.function.locally_integrable from \"leanprover-community/mathlib\"@\"08a4542bec7242a5c60f179e4e49de8c0d677b1b\"\n\n\n\nopen MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology\n\nopen scoped Topology Interval ENNReal\n\nvariable {X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]\nvariable [MeasurableSpace Y] [TopologicalSpace Y]\nvariable [NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}\n\nnamespace MeasureTheory\n\nsection LocallyIntegrableOn\n\n\ndef LocallyIntegrableOn (f : X \u2192 E) (s : Set X) (\u03bc : Measure X := by volume_tac) : Prop :=\n  \u2200 x : X, x \u2208 s \u2192 IntegrableAtFilter f (\ud835\udcdd[s] x) \u03bc\n#align measure_theory.locally_integrable_on MeasureTheory.LocallyIntegrableOn\n\ntheorem LocallyIntegrableOn.mono_set (hf : LocallyIntegrableOn f s \u03bc) {t : Set X}\n    (hst : t \u2286 s) : LocallyIntegrableOn f t \u03bc := fun x hx =>\n  (hf x <| hst hx).filter_mono (nhdsWithin_mono x hst)\n#align measure_theory.locally_integrable_on.mono MeasureTheory.LocallyIntegrableOn.mono_set\n\ntheorem LocallyIntegrableOn.norm (hf : LocallyIntegrableOn f s \u03bc) :\n    LocallyIntegrableOn (fun x => \u2016f x\u2016) s \u03bc := fun t ht =>\n  let \u27e8U, hU_nhd, hU_int\u27e9 := hf t ht\n  \u27e8U, hU_nhd, hU_int.norm\u27e9\n#align measure_theory.locally_integrable_on.norm MeasureTheory.LocallyIntegrableOn.norm\n\ntheorem LocallyIntegrableOn.mono (hf : LocallyIntegrableOn f s \u03bc) {g : X \u2192 F}\n    (hg : AEStronglyMeasurable g \u03bc) (h : \u2200\u1d50 x \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016) :\n    LocallyIntegrableOn g s \u03bc := by\n  intro x hx\n  rcases hf x hx with \u27e8t, t_mem, ht\u27e9\n  exact \u27e8t, t_mem, Integrable.mono ht hg.restrict (ae_restrict_of_ae h)\u27e9\n\ntheorem IntegrableOn.locallyIntegrableOn (hf : IntegrableOn f s \u03bc) : LocallyIntegrableOn f s \u03bc :=\n  fun _ _ => \u27e8s, self_mem_nhdsWithin, hf\u27e9\n#align measure_theory.integrable_on.locally_integrable_on MeasureTheory.IntegrableOn.locallyIntegrableOn\n\n\ntheorem LocallyIntegrableOn.integrableOn_isCompact (hf : LocallyIntegrableOn f s \u03bc)\n    (hs : IsCompact s) : IntegrableOn f s \u03bc :=\n  IsCompact.induction_on hs integrableOn_empty (fun _u _v huv hv => hv.mono_set huv)\n    (fun _u _v hu hv => integrableOn_union.mpr \u27e8hu, hv\u27e9) hf\n#align measure_theory.locally_integrable_on.integrable_on_is_compact MeasureTheory.LocallyIntegrableOn.integrableOn_isCompact\n\ntheorem LocallyIntegrableOn.integrableOn_compact_subset (hf : LocallyIntegrableOn f s \u03bc) {t : Set X}\n    (hst : t \u2286 s) (ht : IsCompact t) : IntegrableOn f t \u03bc :=\n  (hf.mono_set hst).integrableOn_isCompact ht\n#align measure_theory.locally_integrable_on.integrable_on_compact_subset MeasureTheory.LocallyIntegrableOn.integrableOn_compact_subset\n\n\ntheorem LocallyIntegrableOn.exists_countable_integrableOn [SecondCountableTopology X]\n    (hf : LocallyIntegrableOn f s \u03bc) : \u2203 T : Set (Set X), T.Countable \u2227\n    (\u2200 u \u2208 T, IsOpen u) \u2227 (s \u2286 \u22c3 u \u2208 T, u) \u2227 (\u2200 u \u2208 T, IntegrableOn f (u \u2229 s) \u03bc) := by\n  have : \u2200 x : s, \u2203 u, IsOpen u \u2227 x.1 \u2208 u \u2227 IntegrableOn f (u \u2229 s) \u03bc := by\n    rintro \u27e8x, hx\u27e9\n    rcases hf x hx with \u27e8t, ht, h't\u27e9\n    rcases mem_nhdsWithin.1 ht with \u27e8u, u_open, x_mem, u_sub\u27e9\n    exact \u27e8u, u_open, x_mem, h't.mono_set u_sub\u27e9\n  choose u u_open xu hu using this\n  obtain \u27e8T, T_count, hT\u27e9 : \u2203 T : Set s, T.Countable \u2227 s \u2286 \u22c3 i \u2208 T, u i := by\n    have : s \u2286 \u22c3 x : s, u x := fun y hy => mem_iUnion_of_mem \u27e8y, hy\u27e9 (xu \u27e8y, hy\u27e9)\n    obtain \u27e8T, hT_count, hT_un\u27e9 := isOpen_iUnion_countable u u_open\n    exact \u27e8T, hT_count, by rwa [hT_un]\u27e9\n  refine \u27e8u '' T, T_count.image _, ?_, by rwa [biUnion_image], ?_\u27e9\n  \u00b7 rintro v \u27e8w, -, rfl\u27e9\n    exact u_open _\n  \u00b7 rintro v \u27e8w, -, rfl\u27e9\n    exact hu _\n\n\n"}
{"name": "inertiaDeg_of_subsingleton241", "split": "test", "formal_statement": "theorem inertiaDeg_of_subsingleton [hp : p.IsMaximal] [hQ : Subsingleton (S \u29f8 P)] :\n    inertiaDeg f p P = 0 := by", "header": "\nimport Mathlib.RingTheory.DedekindDomain.Ideal\n\n#align_import number_theory.ramification_inertia from \"leanprover-community/mathlib\"@\"039a089d2a4b93c761b234f3e5f5aeb752bac60f\"\n\n\n\n\nnamespace Ideal\n\nuniverse u v\n\nvariable {R : Type u} [CommRing R]\nvariable {S : Type v} [CommRing S] (f : R \u2192+* S)\nvariable (p : Ideal R) (P : Ideal S)\n\nopen FiniteDimensional\n\nopen UniqueFactorizationMonoid\n\nsection DecEq\n\nopen scoped Classical\n\n\nnoncomputable def ramificationIdx : \u2115 := sSup {n | map f p \u2264 P ^ n}\n#align ideal.ramification_idx Ideal.ramificationIdx\n\nvariable {f p P}\n\ntheorem ramificationIdx_eq_find (h : \u2203 n, \u2200 k, map f p \u2264 P ^ k \u2192 k \u2264 n) :\n    ramificationIdx f p P = Nat.find h :=\n  Nat.sSup_def h\n#align ideal.ramification_idx_eq_find Ideal.ramificationIdx_eq_find\n\ntheorem ramificationIdx_eq_zero (h : \u2200 n : \u2115, \u2203 k, map f p \u2264 P ^ k \u2227 n < k) :\n    ramificationIdx f p P = 0 :=\n  dif_neg (by push_neg; exact h)\n#align ideal.ramification_idx_eq_zero Ideal.ramificationIdx_eq_zero\n\ntheorem ramificationIdx_spec {n : \u2115} (hle : map f p \u2264 P ^ n) (hgt : \u00acmap f p \u2264 P ^ (n + 1)) :\n    ramificationIdx f p P = n := by\n  let Q : \u2115 \u2192 Prop := fun m => \u2200 k : \u2115, map f p \u2264 P ^ k \u2192 k \u2264 m\n  have : Q n := by\n    intro k hk\n    refine le_of_not_lt fun hnk => ?_\n    exact hgt (hk.trans (Ideal.pow_le_pow_right hnk))\n  rw [ramificationIdx_eq_find \u27e8n, this\u27e9]\n  refine le_antisymm (Nat.find_min' _ this) (le_of_not_gt fun h : Nat.find _ < n => ?_)\n  obtain this' := Nat.find_spec \u27e8n, this\u27e9\n  exact h.not_le (this' _ hle)\n#align ideal.ramification_idx_spec Ideal.ramificationIdx_spec\n\ntheorem ramificationIdx_lt {n : \u2115} (hgt : \u00acmap f p \u2264 P ^ n) : ramificationIdx f p P < n := by\n  cases' n with n n\n  \u00b7 simp at hgt\n  \u00b7 rw [Nat.lt_succ_iff]\n    have : \u2200 k, map f p \u2264 P ^ k \u2192 k \u2264 n := by\n      refine fun k hk => le_of_not_lt fun hnk => ?_\n      exact hgt (hk.trans (Ideal.pow_le_pow_right hnk))\n    rw [ramificationIdx_eq_find \u27e8n, this\u27e9]\n    exact Nat.find_min' \u27e8n, this\u27e9 this\n#align ideal.ramification_idx_lt Ideal.ramificationIdx_lt\n\n@[simp]\ntheorem ramificationIdx_bot : ramificationIdx f \u22a5 P = 0 :=\n  dif_neg <| not_exists.mpr fun n hn => n.lt_succ_self.not_le (hn _ (by simp))\n#align ideal.ramification_idx_bot Ideal.ramificationIdx_bot\n\n@[simp]\ntheorem ramificationIdx_of_not_le (h : \u00acmap f p \u2264 P) : ramificationIdx f p P = 0 :=\n  ramificationIdx_spec (by simp) (by simpa using h)\n#align ideal.ramification_idx_of_not_le Ideal.ramificationIdx_of_not_le\n\ntheorem ramificationIdx_ne_zero {e : \u2115} (he : e \u2260 0) (hle : map f p \u2264 P ^ e)\n    (hnle : \u00acmap f p \u2264 P ^ (e + 1)) : ramificationIdx f p P \u2260 0 := by\n  rwa [ramificationIdx_spec hle hnle]\n#align ideal.ramification_idx_ne_zero Ideal.ramificationIdx_ne_zero\n\ntheorem le_pow_of_le_ramificationIdx {n : \u2115} (hn : n \u2264 ramificationIdx f p P) :\n    map f p \u2264 P ^ n := by\n  contrapose! hn\n  exact ramificationIdx_lt hn\n#align ideal.le_pow_of_le_ramification_idx Ideal.le_pow_of_le_ramificationIdx\n\ntheorem le_pow_ramificationIdx : map f p \u2264 P ^ ramificationIdx f p P :=\n  le_pow_of_le_ramificationIdx (le_refl _)\n#align ideal.le_pow_ramification_idx Ideal.le_pow_ramificationIdx\n\ntheorem le_comap_pow_ramificationIdx : p \u2264 comap f (P ^ ramificationIdx f p P) :=\n  map_le_iff_le_comap.mp le_pow_ramificationIdx\n#align ideal.le_comap_pow_ramification_idx Ideal.le_comap_pow_ramificationIdx\n\ntheorem le_comap_of_ramificationIdx_ne_zero (h : ramificationIdx f p P \u2260 0) : p \u2264 comap f P :=\n  Ideal.map_le_iff_le_comap.mp <| le_pow_ramificationIdx.trans <| Ideal.pow_le_self <| h\n#align ideal.le_comap_of_ramification_idx_ne_zero Ideal.le_comap_of_ramificationIdx_ne_zero\n\nvariable (f p P)\n\nattribute [local instance] Ideal.Quotient.field\n\n\nnoncomputable def inertiaDeg [p.IsMaximal] : \u2115 :=\n  if hPp : comap f P = p then\n    @finrank (R \u29f8 p) (S \u29f8 P) _ _ <|\n      @Algebra.toModule _ _ _ _ <|\n        RingHom.toAlgebra <|\n          Ideal.Quotient.lift p ((Ideal.Quotient.mk P).comp f) fun _ ha =>\n            Quotient.eq_zero_iff_mem.mpr <| mem_comap.mp <| hPp.symm \u25b8 ha\n  else 0\n#align ideal.inertia_deg Ideal.inertiaDeg\n\n-- Useful for the `nontriviality` tactic using `comap_eq_of_scalar_tower_quotient`.\n@[simp]\n"}
{"name": "numDerangements_sum242", "split": "test", "formal_statement": "theorem numDerangements_sum (n : \u2115) :\n    (numDerangements n : \u2124) =\n      \u2211 k \u2208 Finset.range (n + 1), (-1 : \u2124) ^ k * Nat.ascFactorial (k + 1) (n - k) := by", "header": "\nimport Mathlib.Algebra.BigOperators.Ring\nimport Mathlib.Combinatorics.Derangements.Basic\nimport Mathlib.Data.Fintype.BigOperators\nimport Mathlib.Tactic.Ring\n\n#align_import combinatorics.derangements.finite from \"leanprover-community/mathlib\"@\"c3019c79074b0619edb4b27553a91b2e82242395\"\n\n\n\n\nopen derangements Equiv Fintype\n\nvariable {\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1]\n\ninstance : DecidablePred (derangements \u03b1) := fun _ => Fintype.decidableForallFintype\n\n-- Porting note: used to use the tactic delta_instance\ninstance : Fintype (derangements \u03b1) := Subtype.fintype (fun (_ : Perm \u03b1) => \u2200 (x_1 : \u03b1), \u00ac_ = x_1)\n\ntheorem card_derangements_invariant {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b1] [Fintype \u03b2]\n    [DecidableEq \u03b2] (h : card \u03b1 = card \u03b2) : card (derangements \u03b1) = card (derangements \u03b2) :=\n  Fintype.card_congr (Equiv.derangementsCongr <| equivOfCardEq h)\n#align card_derangements_invariant card_derangements_invariant\n\ntheorem card_derangements_fin_add_two (n : \u2115) :\n    card (derangements (Fin (n + 2))) =\n      (n + 1) * card (derangements (Fin n)) + (n + 1) * card (derangements (Fin (n + 1))) := by\n  -- get some basic results about the size of fin (n+1) plus or minus an element\n  have h1 : \u2200 a : Fin (n + 1), card ({a}\u1d9c : Set (Fin (n + 1))) = card (Fin n) := by\n    intro a\n    simp only [Fintype.card_fin, Finset.card_fin, Fintype.card_ofFinset, Finset.filter_ne' _ a,\n      Set.mem_compl_singleton_iff, Finset.card_erase_of_mem (Finset.mem_univ a),\n      add_tsub_cancel_right]\n  have h2 : card (Fin (n + 2)) = card (Option (Fin (n + 1))) := by simp only [card_fin, card_option]\n  -- rewrite the LHS and substitute in our fintype-level equivalence\n  simp only [card_derangements_invariant h2,\n    card_congr\n      (@derangementsRecursionEquiv (Fin (n + 1))\n        _),-- push the cardinality through the \u03a3 and \u2295 so that we can use `card_n`\n    card_sigma,\n    card_sum, card_derangements_invariant (h1 _), Finset.sum_const, nsmul_eq_mul, Finset.card_fin,\n    mul_add, Nat.cast_id]\n#align card_derangements_fin_add_two card_derangements_fin_add_two\n\n\ndef numDerangements : \u2115 \u2192 \u2115\n  | 0 => 1\n  | 1 => 0\n  | n + 2 => (n + 1) * (numDerangements n + numDerangements (n + 1))\n#align num_derangements numDerangements\n\n@[simp]\ntheorem numDerangements_zero : numDerangements 0 = 1 :=\n  rfl\n#align num_derangements_zero numDerangements_zero\n\n@[simp]\ntheorem numDerangements_one : numDerangements 1 = 0 :=\n  rfl\n#align num_derangements_one numDerangements_one\n\ntheorem numDerangements_add_two (n : \u2115) :\n    numDerangements (n + 2) = (n + 1) * (numDerangements n + numDerangements (n + 1)) :=\n  rfl\n#align num_derangements_add_two numDerangements_add_two\n\ntheorem numDerangements_succ (n : \u2115) :\n    (numDerangements (n + 1) : \u2124) = (n + 1) * (numDerangements n : \u2124) - (-1) ^ n := by\n  induction' n with n hn\n  \u00b7 rfl\n  \u00b7 simp only [numDerangements_add_two, hn, pow_succ, Int.ofNat_mul, Int.ofNat_add, Int.ofNat_succ]\n    ring\n#align num_derangements_succ numDerangements_succ\n\ntheorem card_derangements_fin_eq_numDerangements {n : \u2115} :\n    card (derangements (Fin n)) = numDerangements n := by\n  induction' n using Nat.strong_induction_on with n hyp\n  rcases n with _ | _ | n\n  -- knock out cases 0 and 1\n  \u00b7 rfl\n  \u00b7 rfl\n  -- now we have n \u2265 2. rewrite everything in terms of card_derangements, so that we can use\n  -- `card_derangements_fin_add_two`\n  rw [numDerangements_add_two, card_derangements_fin_add_two, mul_add, hyp, hyp] <;> omega\n#align card_derangements_fin_eq_num_derangements card_derangements_fin_eq_numDerangements\n\ntheorem card_derangements_eq_numDerangements (\u03b1 : Type*) [Fintype \u03b1] [DecidableEq \u03b1] :\n    card (derangements \u03b1) = numDerangements (card \u03b1) := by\n  rw [\u2190 card_derangements_invariant (card_fin _)]\n  exact card_derangements_fin_eq_numDerangements\n#align card_derangements_eq_num_derangements card_derangements_eq_numDerangements\n\n"}
{"name": "effectiveEpi_tfae243", "split": "test", "formal_statement": "theorem effectiveEpi_tfae\n    {B X : CompHaus.{u}} (\u03c0 : X \u27f6 B) :\n    TFAE\n    [ EffectiveEpi \u03c0\n    , Epi \u03c0\n    , Function.Surjective \u03c0\n    ] := by", "header": "\nimport Mathlib.CategoryTheory.Sites.Coherent.Comparison\nimport Mathlib.Topology.Category.CompHaus.Limits\n\n\nuniverse u\n\n\nattribute [local instance] CategoryTheory.ConcreteCategory.instFunLike\n\nopen CategoryTheory Limits\n\nnamespace CompHaus\n\n\nnoncomputable\ndef struct {B X : CompHaus.{u}} (\u03c0 : X \u27f6 B) (h\u03c0 : Function.Surjective \u03c0) :\n    EffectiveEpiStruct \u03c0 where\n  desc e h := (QuotientMap.of_surjective_continuous h\u03c0 \u03c0.continuous).lift e fun a b hab \u21a6\n    DFunLike.congr_fun (h \u27e8fun _ \u21a6 a, continuous_const\u27e9 \u27e8fun _ \u21a6 b, continuous_const\u27e9\n    (by ext; exact hab)) a\n  fac e h := ((QuotientMap.of_surjective_continuous h\u03c0 \u03c0.continuous).lift_comp e\n    fun a b hab \u21a6 DFunLike.congr_fun (h \u27e8fun _ \u21a6 a, continuous_const\u27e9 \u27e8fun _ \u21a6 b, continuous_const\u27e9\n    (by ext; exact hab)) a)\n  uniq e h g hm := by\n    suffices g = (QuotientMap.of_surjective_continuous h\u03c0 \u03c0.continuous).liftEquiv \u27e8e,\n      fun a b hab \u21a6 DFunLike.congr_fun\n        (h \u27e8fun _ \u21a6 a, continuous_const\u27e9 \u27e8fun _ \u21a6 b, continuous_const\u27e9 (by ext; exact hab))\n        a\u27e9 by assumption\n    rw [\u2190 Equiv.symm_apply_eq (QuotientMap.of_surjective_continuous h\u03c0 \u03c0.continuous).liftEquiv]\n    ext\n    simp only [QuotientMap.liftEquiv_symm_apply_coe, ContinuousMap.comp_apply, \u2190 hm]\n    rfl\n\nopen List in\n"}
{"name": "get_ofFn244", "split": "test", "formal_statement": "theorem get_ofFn {n} (f : Fin n \u2192 \u03b1) (i) : get (ofFn f) i = f i := by", "header": "\nimport Mathlib.Algebra.BigOperators.Group.List\nimport Mathlib.Data.Vector.Defs\nimport Mathlib.Data.List.Nodup\nimport Mathlib.Data.List.OfFn\nimport Mathlib.Data.List.InsertNth\nimport Mathlib.Control.Applicative\nimport Mathlib.Control.Traversable.Basic\n\n#align_import data.vector.basic from \"leanprover-community/mathlib\"@\"f694c7dead66f5d4c80f446c796a5aad14707f0e\"\n\n\n\nset_option autoImplicit true\n\n\nuniverse u\n\nvariable {n : \u2115}\n\nnamespace Vector\n\nvariable {\u03b1 : Type*}\n\n@[inherit_doc]\ninfixr:67 \" ::\u1d65 \" => Vector.cons\n\nattribute [simp] head_cons tail_cons\n\ninstance [Inhabited \u03b1] : Inhabited (Vector \u03b1 n) :=\n  \u27e8ofFn default\u27e9\n\ntheorem toList_injective : Function.Injective (@toList \u03b1 n) :=\n  Subtype.val_injective\n#align vector.to_list_injective Vector.toList_injective\n\n\n@[ext]\ntheorem ext : \u2200 {v w : Vector \u03b1 n} (_ : \u2200 m : Fin n, Vector.get v m = Vector.get w m), v = w\n  | \u27e8v, hv\u27e9, \u27e8w, hw\u27e9, h =>\n    Subtype.eq (List.ext_get (by rw [hv, hw]) fun m hm _ => h \u27e8m, hv \u25b8 hm\u27e9)\n#align vector.ext Vector.ext\n\n\ninstance zero_subsingleton : Subsingleton (Vector \u03b1 0) :=\n  \u27e8fun _ _ => Vector.ext fun m => Fin.elim0 m\u27e9\n#align vector.zero_subsingleton Vector.zero_subsingleton\n\n@[simp]\ntheorem cons_val (a : \u03b1) : \u2200 v : Vector \u03b1 n, (a ::\u1d65 v).val = a :: v.val\n  | \u27e8_, _\u27e9 => rfl\n#align vector.cons_val Vector.cons_val\n\n#align vector.cons_head Vector.head_cons\n#align vector.cons_tail Vector.tail_cons\n\ntheorem eq_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v = a ::\u1d65 v' \u2194 v.head = a \u2227 v.tail = v' :=\n  \u27e8fun h => h.symm \u25b8 \u27e8head_cons a v', tail_cons a v'\u27e9, fun h =>\n    _root_.trans (cons_head_tail v).symm (by rw [h.1, h.2])\u27e9\n#align vector.eq_cons_iff Vector.eq_cons_iff\n\ntheorem ne_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v \u2260 a ::\u1d65 v' \u2194 v.head \u2260 a \u2228 v.tail \u2260 v' := by rw [Ne, eq_cons_iff a v v', not_and_or]\n#align vector.ne_cons_iff Vector.ne_cons_iff\n\ntheorem exists_eq_cons (v : Vector \u03b1 n.succ) : \u2203 (a : \u03b1) (as : Vector \u03b1 n), v = a ::\u1d65 as :=\n  \u27e8v.head, v.tail, (eq_cons_iff v.head v v.tail).2 \u27e8rfl, rfl\u27e9\u27e9\n#align vector.exists_eq_cons Vector.exists_eq_cons\n\n@[simp]\ntheorem toList_ofFn : \u2200 {n} (f : Fin n \u2192 \u03b1), toList (ofFn f) = List.ofFn f\n  | 0, f => by rw [ofFn, List.ofFn_zero, toList, nil]\n  | n + 1, f => by rw [ofFn, List.ofFn_succ, toList_cons, toList_ofFn]\n#align vector.to_list_of_fn Vector.toList_ofFn\n\n@[simp]\ntheorem mk_toList : \u2200 (v : Vector \u03b1 n) (h), (\u27e8toList v, h\u27e9 : Vector \u03b1 n) = v\n  | \u27e8_, _\u27e9, _ => rfl\n#align vector.mk_to_list Vector.mk_toList\n\n\n@[simp] theorem length_val (v : Vector \u03b1 n) : v.val.length = n := v.2\n\n-- Porting note: not used in mathlib and coercions done differently in Lean 4\n-- @[simp]\n-- theorem length_coe (v : Vector \u03b1 n) :\n--     ((coe : { l : List \u03b1 // l.length = n } \u2192 List \u03b1) v).length = n :=\n--   v.2\n#noalign vector.length_coe\n\n@[simp]\ntheorem toList_map {\u03b2 : Type*} (v : Vector \u03b1 n) (f : \u03b1 \u2192 \u03b2) :\n    (v.map f).toList = v.toList.map f := by cases v; rfl\n#align vector.to_list_map Vector.toList_map\n\n@[simp]\ntheorem head_map {\u03b2 : Type*} (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) : (v.map f).head = f v.head := by\n  obtain \u27e8a, v', h\u27e9 := Vector.exists_eq_cons v\n  rw [h, map_cons, head_cons, head_cons]\n#align vector.head_map Vector.head_map\n\n@[simp]\ntheorem tail_map {\u03b2 : Type*} (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) :\n    (v.map f).tail = v.tail.map f := by\n  obtain \u27e8a, v', h\u27e9 := Vector.exists_eq_cons v\n  rw [h, map_cons, tail_cons, tail_cons]\n#align vector.tail_map Vector.tail_map\n\ntheorem get_eq_get (v : Vector \u03b1 n) (i : Fin n) :\n    v.get i = v.toList.get (Fin.cast v.toList_length.symm i) :=\n  rfl\n#align vector.nth_eq_nth_le Vector.get_eq_get\u2093\n\n@[simp]\ntheorem get_replicate (a : \u03b1) (i : Fin n) : (Vector.replicate n a).get i = a := by\n  apply List.get_replicate\n#align vector.nth_repeat Vector.get_replicate\n\n@[simp]\ntheorem get_map {\u03b2 : Type*} (v : Vector \u03b1 n) (f : \u03b1 \u2192 \u03b2) (i : Fin n) :\n    (v.map f).get i = f (v.get i) := by\n  cases v; simp [Vector.map, get_eq_get]; rfl\n#align vector.nth_map Vector.get_map\n\n@[simp]\ntheorem map\u2082_nil (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Vector.map\u2082 f nil nil = nil :=\n  rfl\n\n@[simp]\ntheorem map\u2082_cons (hd\u2081 : \u03b1) (tl\u2081 : Vector \u03b1 n) (hd\u2082 : \u03b2) (tl\u2082 : Vector \u03b2 n) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    Vector.map\u2082 f (hd\u2081 ::\u1d65 tl\u2081) (hd\u2082 ::\u1d65 tl\u2082) = f hd\u2081 hd\u2082 ::\u1d65 (Vector.map\u2082 f tl\u2081 tl\u2082) :=\n  rfl\n\n@[simp]\n"}
{"name": "exists_unique_nilpotent_sub_and_aeval_eq_zero245", "split": "test", "formal_statement": "theorem exists_unique_nilpotent_sub_and_aeval_eq_zero\n    (h : IsNilpotent (aeval x P)) (h' : IsUnit (aeval x <| derivative P)) :\n    \u2203! r, IsNilpotent (x - r) \u2227 aeval r P = 0 := by", "header": "\nimport Mathlib.Algebra.Polynomial.AlgebraMap\nimport Mathlib.Algebra.Polynomial.Identities\nimport Mathlib.RingTheory.Nilpotent.Lemmas\nimport Mathlib.RingTheory.Polynomial.Nilpotent\nimport Mathlib.RingTheory.Polynomial.Tower\n\n\n\nopen Set Function\n\nnoncomputable section\n\nnamespace Polynomial\n\nvariable {R S : Type*} [CommRing R] [CommRing S] [Algebra R S] (P : R[X]) {x : S}\n\n\ndef newtonMap (x : S) : S :=\n  x - (Ring.inverse <| aeval x (derivative P)) * aeval x P\n\ntheorem newtonMap_apply :\n    P.newtonMap x = x - (Ring.inverse <| aeval x (derivative P)) * (aeval x P) :=\n  rfl\n\nvariable {P}\n\ntheorem newtonMap_apply_of_isUnit (h : IsUnit <| aeval x (derivative P)) :\n    P.newtonMap x = x - h.unit\u207b\u00b9 * aeval x P := by\n  simp [newtonMap_apply, Ring.inverse, h]\n\ntheorem newtonMap_apply_of_not_isUnit (h : \u00ac (IsUnit <| aeval x (derivative P))) :\n    P.newtonMap x = x := by\n  simp [newtonMap_apply, Ring.inverse, h]\n\ntheorem isNilpotent_iterate_newtonMap_sub_of_isNilpotent (h : IsNilpotent <| aeval x P) (n : \u2115) :\n    IsNilpotent <| P.newtonMap^[n] x - x := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [iterate_succ', comp_apply, newtonMap_apply, sub_right_comm]\n    refine (Commute.all _ _).isNilpotent_sub ih <| (Commute.all _ _).isNilpotent_mul_right ?_\n    simpa using Commute.isNilpotent_add (Commute.all _ _)\n      (isNilpotent_aeval_sub_of_isNilpotent_sub P ih) h\n\ntheorem isFixedPt_newtonMap_of_aeval_eq_zero (h : aeval x P = 0) :\n    IsFixedPt P.newtonMap x := by\n  rw [IsFixedPt, newtonMap_apply, h, mul_zero, sub_zero]\n\ntheorem isFixedPt_newtonMap_of_isUnit_iff (h : IsUnit <| aeval x (derivative P)) :\n    IsFixedPt P.newtonMap x \u2194 aeval x P = 0 := by\n  rw [IsFixedPt, newtonMap_apply, sub_eq_self, Ring.inverse_mul_eq_iff_eq_mul _ _ _ h, mul_zero]\n\n\ntheorem aeval_pow_two_pow_dvd_aeval_iterate_newtonMap\n    (h : IsNilpotent (aeval x P)) (h' : IsUnit (aeval x <| derivative P)) (n : \u2115) :\n    (aeval x P) ^ (2 ^ n) \u2223 aeval (P.newtonMap^[n] x) P := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    have \u27e8d, hd\u27e9 := binomExpansion (P.map (algebraMap R S)) (P.newtonMap^[n] x)\n      (-Ring.inverse (aeval (P.newtonMap^[n] x) <| derivative P) * aeval (P.newtonMap^[n] x) P)\n    rw [eval_map_algebraMap, eval_map_algebraMap] at hd\n    rw [iterate_succ', comp_apply, newtonMap_apply, sub_eq_add_neg, neg_mul_eq_neg_mul, hd]\n    refine dvd_add ?_ (dvd_mul_of_dvd_right ?_ _)\n    \u00b7 convert dvd_zero _\n      have : IsUnit (aeval (P.newtonMap^[n] x) <| derivative P) :=\n        isUnit_aeval_of_isUnit_aeval_of_isNilpotent_sub h' <|\n        isNilpotent_iterate_newtonMap_sub_of_isNilpotent h n\n      rw [derivative_map, eval_map_algebraMap, \u2190 mul_assoc, mul_neg, Ring.mul_inverse_cancel _ this,\n        neg_mul, one_mul, add_right_neg]\n    \u00b7 rw [neg_mul, even_two.neg_pow, mul_pow, pow_succ, pow_mul]\n      exact dvd_mul_of_dvd_right (pow_dvd_pow_of_dvd ih 2) _\n\n\n"}
{"name": "edgeFinset_sdiff246", "split": "test", "formal_statement": "theorem edgeFinset_sdiff [DecidableEq V] :\n    (G\u2081 \\ G\u2082).edgeFinset = G\u2081.edgeFinset \\ G\u2082.edgeFinset := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Combinatorics.SimpleGraph.Basic\nimport Mathlib.Data.Sym.Card\n\n\n\n\nopen Finset Function\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V) {e : Sym2 V}\n\nsection EdgeFinset\n\nvariable {G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]\n\n\nabbrev edgeFinset : Finset (Sym2 V) :=\n  Set.toFinset G.edgeSet\n#align simple_graph.edge_finset SimpleGraph.edgeFinset\n\n@[norm_cast]\ntheorem coe_edgeFinset : (G.edgeFinset : Set (Sym2 V)) = G.edgeSet :=\n  Set.coe_toFinset _\n#align simple_graph.coe_edge_finset SimpleGraph.coe_edgeFinset\n\nvariable {G}\n\ntheorem mem_edgeFinset : e \u2208 G.edgeFinset \u2194 e \u2208 G.edgeSet :=\n  Set.mem_toFinset\n#align simple_graph.mem_edge_finset SimpleGraph.mem_edgeFinset\n\ntheorem not_isDiag_of_mem_edgeFinset : e \u2208 G.edgeFinset \u2192 \u00ace.IsDiag :=\n  not_isDiag_of_mem_edgeSet _ \u2218 mem_edgeFinset.1\n#align simple_graph.not_is_diag_of_mem_edge_finset SimpleGraph.not_isDiag_of_mem_edgeFinset\n\ntheorem edgeFinset_inj : G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082 := by simp\n#align simple_graph.edge_finset_inj SimpleGraph.edgeFinset_inj\n\ntheorem edgeFinset_subset_edgeFinset : G\u2081.edgeFinset \u2286 G\u2082.edgeFinset \u2194 G\u2081 \u2264 G\u2082 := by simp\n#align simple_graph.edge_finset_subset_edge_finset SimpleGraph.edgeFinset_subset_edgeFinset\n\ntheorem edgeFinset_ssubset_edgeFinset : G\u2081.edgeFinset \u2282 G\u2082.edgeFinset \u2194 G\u2081 < G\u2082 := by simp\n#align simple_graph.edge_finset_ssubset_edge_finset SimpleGraph.edgeFinset_ssubset_edgeFinset\n\n@[gcongr] alias \u27e8_, edgeFinset_mono\u27e9 := edgeFinset_subset_edgeFinset\n#align simple_graph.edge_finset_mono SimpleGraph.edgeFinset_mono\n\nalias \u27e8_, edgeFinset_strict_mono\u27e9 := edgeFinset_ssubset_edgeFinset\n#align simple_graph.edge_finset_strict_mono SimpleGraph.edgeFinset_strict_mono\n\nattribute [mono] edgeFinset_mono edgeFinset_strict_mono\n\n@[simp]\ntheorem edgeFinset_bot : (\u22a5 : SimpleGraph V).edgeFinset = \u2205 := by simp [edgeFinset]\n#align simple_graph.edge_finset_bot SimpleGraph.edgeFinset_bot\n\n@[simp]\ntheorem edgeFinset_sup [Fintype (edgeSet (G\u2081 \u2294 G\u2082))] [DecidableEq V] :\n    (G\u2081 \u2294 G\u2082).edgeFinset = G\u2081.edgeFinset \u222a G\u2082.edgeFinset := by simp [edgeFinset]\n#align simple_graph.edge_finset_sup SimpleGraph.edgeFinset_sup\n\n@[simp]\ntheorem edgeFinset_inf [DecidableEq V] : (G\u2081 \u2293 G\u2082).edgeFinset = G\u2081.edgeFinset \u2229 G\u2082.edgeFinset := by\n  simp [edgeFinset]\n#align simple_graph.edge_finset_inf SimpleGraph.edgeFinset_inf\n\n@[simp]\n"}
{"name": "factors_two247", "split": "test", "formal_statement": "theorem factors_two : factors 2 = [2] := by", "header": "\nimport Mathlib.Algebra.BigOperators.Ring.List\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.List.Prime\nimport Mathlib.Data.List.Sort\nimport Mathlib.Data.List.Chain\n\n#align_import data.nat.factors from \"leanprover-community/mathlib\"@\"008205aa645b3f194c1da47025c5f110c8406eab\"\n\n\n\nopen Bool Subtype\n\nopen Nat\n\nnamespace Nat\n\nattribute [instance 0] instBEqNat\n\n\ndef factors : \u2115 \u2192 List \u2115\n  | 0 => []\n  | 1 => []\n  | k + 2 =>\n    let m := minFac (k + 2)\n    m :: factors ((k + 2) / m)\ndecreasing_by show (k + 2) / m < (k + 2); exact factors_lemma\n#align nat.factors Nat.factors\n\n@[simp]\ntheorem factors_zero : factors 0 = [] := by rw [factors]\n#align nat.factors_zero Nat.factors_zero\n\n@[simp]\ntheorem factors_one : factors 1 = [] := by rw [factors]\n#align nat.factors_one Nat.factors_one\n\n@[simp]\n"}
{"name": "integral_norm_le_of_forall_fin_meas_integral_eq248", "split": "test", "formal_statement": "theorem integral_norm_le_of_forall_fin_meas_integral_eq (hm : m \u2264 m0) {f g : \u03b1 \u2192 \u211d}\n    (hf : StronglyMeasurable f) (hfi : IntegrableOn f s \u03bc) (hg : StronglyMeasurable[m] g)\n    (hgi : IntegrableOn g s \u03bc)\n    (hgf : \u2200 t, MeasurableSet[m] t \u2192 \u03bc t < \u221e \u2192 \u222b x in t, g x \u2202\u03bc = \u222b x in t, f x \u2202\u03bc)\n    (hs : MeasurableSet[m] s) (h\u03bcs : \u03bc s \u2260 \u221e) : (\u222b x in s, \u2016g x\u2016 \u2202\u03bc) \u2264 \u222b x in s, \u2016f x\u2016 \u2202\u03bc := by", "header": "\nimport Mathlib.MeasureTheory.Function.AEEqOfIntegral\nimport Mathlib.MeasureTheory.Function.ConditionalExpectation.AEMeasurable\n\n#align_import measure_theory.function.conditional_expectation.unique from \"leanprover-community/mathlib\"@\"d8bbb04e2d2a44596798a9207ceefc0fb236e41e\"\n\n\n\nset_option linter.uppercaseLean3 false\n\nopen scoped ENNReal MeasureTheory\n\nnamespace MeasureTheory\n\nvariable {\u03b1 E' F' \ud835\udd5c : Type*} {p : \u211d\u22650\u221e} {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [RCLike \ud835\udd5c]\n  -- \ud835\udd5c for \u211d or \u2102\n  -- E' for an inner product space on which we compute integrals\n  [NormedAddCommGroup E']\n  [InnerProductSpace \ud835\udd5c E'] [CompleteSpace E'] [NormedSpace \u211d E']\n  -- F' for integrals on a Lp submodule\n  [NormedAddCommGroup F']\n  [NormedSpace \ud835\udd5c F'] [NormedSpace \u211d F'] [CompleteSpace F']\n\nsection IntegralNormLE\n\nvariable {s : Set \u03b1}\n\n\n"}
{"name": "proj_comp_of_subset249", "split": "test", "formal_statement": "theorem proj_comp_of_subset (h : \u2200 i, J i \u2192 K i) : (Proj J \u2218 Proj K) =\n    (Proj J : (I \u2192 Bool) \u2192 (I \u2192 Bool)) := by", "header": "\nimport Mathlib.Algebra.Category.ModuleCat.Free\nimport Mathlib.Topology.Category.Profinite.CofilteredLimit\nimport Mathlib.Topology.Category.Profinite.Product\nimport Mathlib.Topology.LocallyConstant.Algebra\nimport Mathlib.Init.Data.Bool.Lemmas\n\n\n\nuniverse u\n\nnamespace Profinite\n\nnamespace NobelingProof\n\nvariable {I : Type u} [LinearOrder I] [IsWellOrder I (\u00b7<\u00b7)] (C : Set (I \u2192 Bool))\n\nopen Profinite ContinuousMap CategoryTheory Limits Opposite Submodule\n\nsection Projections\n\n\nvariable (J K L : I \u2192 Prop) [\u2200 i, Decidable (J i)] [\u2200 i, Decidable (K i)] [\u2200 i, Decidable (L i)]\n\n\ndef Proj : (I \u2192 Bool) \u2192 (I \u2192 Bool) :=\n  fun c i \u21a6 if J i then c i else false\n\n@[simp]\ntheorem continuous_proj :\n    Continuous (Proj J : (I \u2192 Bool) \u2192 (I \u2192 Bool)) := by\n  dsimp (config := { unfoldPartialApp := true }) [Proj]\n  apply continuous_pi\n  intro i\n  split\n  \u00b7 apply continuous_apply\n  \u00b7 apply continuous_const\n\n\ndef \u03c0 : Set (I \u2192 Bool) := (Proj J) '' C\n\n\n@[simps!]\ndef ProjRestrict : C \u2192 \u03c0 C J :=\n  Set.MapsTo.restrict (Proj J) _ _ (Set.mapsTo_image _ _)\n\n@[simp]\ntheorem continuous_projRestrict : Continuous (ProjRestrict C J) :=\n  Continuous.restrict _ (continuous_proj _)\n\ntheorem proj_eq_self {x : I \u2192 Bool} (h : \u2200 i, x i \u2260 false \u2192 J i) : Proj J x = x := by\n  ext i\n  simp only [Proj, ite_eq_left_iff]\n  contrapose!\n  simpa only [ne_comm] using h i\n\ntheorem proj_prop_eq_self (hh : \u2200 i x, x \u2208 C \u2192 x i \u2260 false \u2192 J i) : \u03c0 C J = C := by\n  ext x\n  refine \u27e8fun \u27e8y, hy, h\u27e9 \u21a6 ?_, fun h \u21a6 \u27e8x, h, ?_\u27e9\u27e9\n  \u00b7 rwa [\u2190 h, proj_eq_self]; exact (hh \u00b7 y hy)\n  \u00b7 rw [proj_eq_self]; exact (hh \u00b7 x h)\n\n"}
{"name": "RemoveNone.fiber_none250", "split": "test", "formal_statement": "theorem RemoveNone.fiber_none : RemoveNone.fiber (@none \u03b1) = \u2205 := by", "header": "\nimport Mathlib.Dynamics.FixedPoints.Basic\nimport Mathlib.GroupTheory.Perm.Option\nimport Mathlib.Logic.Equiv.Defs\nimport Mathlib.Logic.Equiv.Option\n\n#align_import combinatorics.derangements.basic from \"leanprover-community/mathlib\"@\"9407b03373c8cd201df99d6bc5514fc2db44054f\"\n\n\n\n\nopen Equiv Function\n\n\ndef derangements (\u03b1 : Type*) : Set (Perm \u03b1) :=\n  { f : Perm \u03b1 | \u2200 x : \u03b1, f x \u2260 x }\n#align derangements derangements\n\nvariable {\u03b1 \u03b2 : Type*}\n\ntheorem mem_derangements_iff_fixedPoints_eq_empty {f : Perm \u03b1} :\n    f \u2208 derangements \u03b1 \u2194 fixedPoints f = \u2205 :=\n  Set.eq_empty_iff_forall_not_mem.symm\n#align mem_derangements_iff_fixed_points_eq_empty mem_derangements_iff_fixedPoints_eq_empty\n\n\ndef Equiv.derangementsCongr (e : \u03b1 \u2243 \u03b2) : derangements \u03b1 \u2243 derangements \u03b2 :=\n  e.permCongr.subtypeEquiv fun {f} => e.forall_congr <| by\n   intro b; simp only [ne_eq, permCongr_apply, symm_apply_apply, EmbeddingLike.apply_eq_iff_eq]\n#align equiv.derangements_congr Equiv.derangementsCongr\n\nnamespace derangements\n\n\nprotected def subtypeEquiv (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    derangements (Subtype p) \u2243 { f : Perm \u03b1 // \u2200 a, \u00acp a \u2194 a \u2208 fixedPoints f } :=\n  calc\n    derangements (Subtype p) \u2243 { f : { f : Perm \u03b1 // \u2200 a, \u00acp a \u2192 a \u2208 fixedPoints f } //\n        \u2200 a, a \u2208 fixedPoints f \u2192 \u00acp a } := by\n      refine (Perm.subtypeEquivSubtypePerm p).subtypeEquiv fun f => \u27e8fun hf a hfa ha => ?_, ?_\u27e9\n      \u00b7 refine hf \u27e8a, ha\u27e9 (Subtype.ext ?_)\n        simp_rw [mem_fixedPoints, IsFixedPt, Perm.subtypeEquivSubtypePerm,\n        Equiv.coe_fn_mk, Perm.ofSubtype_apply_of_mem _ ha] at hfa\n        assumption\n      rintro hf \u27e8a, ha\u27e9 hfa\n      refine hf _ ?_ ha\n      simp only [Perm.subtypeEquivSubtypePerm_apply_coe, mem_fixedPoints]\n      dsimp [IsFixedPt]\n      simp_rw [Perm.ofSubtype_apply_of_mem _ ha, hfa]\n    _ \u2243 { f : Perm \u03b1 // \u2203 _h : \u2200 a, \u00acp a \u2192 a \u2208 fixedPoints f, \u2200 a, a \u2208 fixedPoints f \u2192 \u00acp a } :=\n      subtypeSubtypeEquivSubtypeExists _ _\n    _ \u2243 { f : Perm \u03b1 // \u2200 a, \u00acp a \u2194 a \u2208 fixedPoints f } :=\n      subtypeEquivRight fun f => by\n        simp_rw [exists_prop, \u2190 forall_and, \u2190 iff_iff_implies_and_implies]\n#align derangements.subtype_equiv derangements.subtypeEquiv\n\nuniverse u\n\ndef atMostOneFixedPointEquivSum_derangements [DecidableEq \u03b1] (a : \u03b1) :\n    { f : Perm \u03b1 // fixedPoints f \u2286 {a} } \u2243 Sum (derangements ({a}\u1d9c : Set \u03b1)) (derangements \u03b1) :=\n  calc\n    { f : Perm \u03b1 // fixedPoints f \u2286 {a} } \u2243\n        Sum { f : { f : Perm \u03b1 // fixedPoints f \u2286 {a} } // a \u2208 fixedPoints f }\n          { f : { f : Perm \u03b1 // fixedPoints f \u2286 {a} } // a \u2209 fixedPoints f } :=\n      (Equiv.sumCompl _).symm\n    _ \u2243 Sum { f : Perm \u03b1 // fixedPoints f \u2286 {a} \u2227 a \u2208 fixedPoints f }\n          { f : Perm \u03b1 // fixedPoints f \u2286 {a} \u2227 a \u2209 fixedPoints f } := by\n      -- Porting note: `subtypeSubtypeEquivSubtypeInter` no longer works with placeholder `_`s.\n      refine Equiv.sumCongr ?_ ?_\n      \u00b7 exact subtypeSubtypeEquivSubtypeInter\n          (fun x : Perm \u03b1 => fixedPoints x \u2286 {a})\n          (a \u2208 fixedPoints \u00b7)\n      \u00b7 exact subtypeSubtypeEquivSubtypeInter\n          (fun x : Perm \u03b1 => fixedPoints x \u2286 {a})\n          (\u00aca \u2208 fixedPoints \u00b7)\n    _ \u2243 Sum { f : Perm \u03b1 // fixedPoints f = {a} } { f : Perm \u03b1 // fixedPoints f = \u2205 } := by\n      refine Equiv.sumCongr (subtypeEquivRight fun f => ?_) (subtypeEquivRight fun f => ?_)\n      \u00b7 rw [Set.eq_singleton_iff_unique_mem, and_comm]\n        rfl\n      \u00b7 rw [Set.eq_empty_iff_forall_not_mem]\n        exact \u27e8fun h x hx => h.2 (h.1 hx \u25b8 hx), fun h => \u27e8fun x hx => (h _ hx).elim, h _\u27e9\u27e9\n    _ \u2243 Sum (derangements ({a}\u1d9c : Set \u03b1)) (derangements \u03b1) := by\n      -- Porting note: was `subtypeEquiv _` but now needs the placeholder to be provided explicitly\n      refine\n        Equiv.sumCongr ((derangements.subtypeEquiv (\u00b7 \u2208 ({a}\u1d9c : Set \u03b1))).trans <|\n            subtypeEquivRight fun x => ?_).symm\n          (subtypeEquivRight fun f => mem_derangements_iff_fixedPoints_eq_empty.symm)\n      rw [eq_comm, Set.ext_iff]\n      simp_rw [Set.mem_compl_iff, Classical.not_not]\n#align derangements.at_most_one_fixed_point_equiv_sum_derangements derangements.atMostOneFixedPointEquivSum_derangements\n\nnamespace Equiv\n\nvariable [DecidableEq \u03b1]\n\n\ndef RemoveNone.fiber (a : Option \u03b1) : Set (Perm \u03b1) :=\n  { f : Perm \u03b1 | (a, f) \u2208 Equiv.Perm.decomposeOption '' derangements (Option \u03b1) }\n#align derangements.equiv.remove_none.fiber derangements.Equiv.RemoveNone.fiber\n\ntheorem RemoveNone.mem_fiber (a : Option \u03b1) (f : Perm \u03b1) :\n    f \u2208 RemoveNone.fiber a \u2194\n      \u2203 F : Perm (Option \u03b1), F \u2208 derangements (Option \u03b1) \u2227 F none = a \u2227 removeNone F = f := by\n  simp [RemoveNone.fiber, derangements]\n#align derangements.equiv.remove_none.mem_fiber derangements.Equiv.RemoveNone.mem_fiber\n\n"}
{"name": "support_eq_inter_preimage251", "split": "test", "formal_statement": "theorem support_eq_inter_preimage :\n    support f = (chartAt H c).source \u2229 extChartAt I c \u207b\u00b9' ball (extChartAt I c c) f.rOut := by", "header": "\nimport Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension\nimport Mathlib.Geometry.Manifold.ContMDiff.Atlas\nimport Mathlib.Geometry.Manifold.ContMDiff.NormedSpace\n\n#align_import geometry.manifold.bump_function from \"leanprover-community/mathlib\"@\"b018406ad2f2a73223a3a9e198ccae61e6f05318\"\n\n\n\nuniverse uE uF uH uM\n\nvariable {E : Type uE} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\n  {H : Type uH} [TopologicalSpace H] (I : ModelWithCorners \u211d E H) {M : Type uM} [TopologicalSpace M]\n  [ChartedSpace H M] [SmoothManifoldWithCorners I M]\n\nopen Function Filter FiniteDimensional Set Metric\n\nopen scoped Topology Manifold Classical Filter\n\nnoncomputable section\n\n\n\n\nstructure SmoothBumpFunction (c : M) extends ContDiffBump (extChartAt I c c) where\n  closedBall_subset : closedBall (extChartAt I c c) rOut \u2229 range I \u2286 (extChartAt I c).target\n#align smooth_bump_function SmoothBumpFunction\n\nnamespace SmoothBumpFunction\n\nvariable {c : M} (f : SmoothBumpFunction I c) {x : M} {I}\n\n\n@[coe] def toFun : M \u2192 \u211d :=\n  indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c)\n#align smooth_bump_function.to_fun SmoothBumpFunction.toFun\n\ninstance : CoeFun (SmoothBumpFunction I c) fun _ => M \u2192 \u211d :=\n  \u27e8toFun\u27e9\n\ntheorem coe_def : \u21d1f = indicator (chartAt H c).source (f.toContDiffBump \u2218 extChartAt I c) :=\n  rfl\n#align smooth_bump_function.coe_def SmoothBumpFunction.coe_def\n\ntheorem rOut_pos : 0 < f.rOut :=\n  f.toContDiffBump.rOut_pos\nset_option linter.uppercaseLean3 false in\n#align smooth_bump_function.R_pos SmoothBumpFunction.rOut_pos\n\ntheorem ball_subset : ball (extChartAt I c c) f.rOut \u2229 range I \u2286 (extChartAt I c).target :=\n  Subset.trans (inter_subset_inter_left _ ball_subset_closedBall) f.closedBall_subset\n#align smooth_bump_function.ball_subset SmoothBumpFunction.ball_subset\n\ntheorem ball_inter_range_eq_ball_inter_target :\n    ball (extChartAt I c c) f.rOut \u2229 range I =\n      ball (extChartAt I c c) f.rOut \u2229 (extChartAt I c).target :=\n  (subset_inter inter_subset_left f.ball_subset).antisymm <| inter_subset_inter_right _ <|\n    extChartAt_target_subset_range _ _\n\ntheorem eqOn_source : EqOn f (f.toContDiffBump \u2218 extChartAt I c) (chartAt H c).source :=\n  eqOn_indicator\n#align smooth_bump_function.eq_on_source SmoothBumpFunction.eqOn_source\n\ntheorem eventuallyEq_of_mem_source (hx : x \u2208 (chartAt H c).source) :\n    f =\u1da0[\ud835\udcdd x] f.toContDiffBump \u2218 extChartAt I c :=\n  f.eqOn_source.eventuallyEq_of_mem <| (chartAt H c).open_source.mem_nhds hx\n#align smooth_bump_function.eventually_eq_of_mem_source SmoothBumpFunction.eventuallyEq_of_mem_source\n\ntheorem one_of_dist_le (hs : x \u2208 (chartAt H c).source)\n    (hd : dist (extChartAt I c x) (extChartAt I c c) \u2264 f.rIn) : f x = 1 := by\n  simp only [f.eqOn_source hs, (\u00b7 \u2218 \u00b7), f.one_of_mem_closedBall hd]\n#align smooth_bump_function.one_of_dist_le SmoothBumpFunction.one_of_dist_le\n\n"}
{"name": "edgeFinset_inj252", "split": "test", "formal_statement": "theorem edgeFinset_inj : G\u2081.edgeFinset = G\u2082.edgeFinset \u2194 G\u2081 = G\u2082 := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Combinatorics.SimpleGraph.Basic\nimport Mathlib.Data.Sym.Card\n\n\n\n\nopen Finset Function\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (G : SimpleGraph V) {e : Sym2 V}\n\nsection EdgeFinset\n\nvariable {G\u2081 G\u2082 : SimpleGraph V} [Fintype G.edgeSet] [Fintype G\u2081.edgeSet] [Fintype G\u2082.edgeSet]\n\n\nabbrev edgeFinset : Finset (Sym2 V) :=\n  Set.toFinset G.edgeSet\n#align simple_graph.edge_finset SimpleGraph.edgeFinset\n\n@[norm_cast]\ntheorem coe_edgeFinset : (G.edgeFinset : Set (Sym2 V)) = G.edgeSet :=\n  Set.coe_toFinset _\n#align simple_graph.coe_edge_finset SimpleGraph.coe_edgeFinset\n\nvariable {G}\n\ntheorem mem_edgeFinset : e \u2208 G.edgeFinset \u2194 e \u2208 G.edgeSet :=\n  Set.mem_toFinset\n#align simple_graph.mem_edge_finset SimpleGraph.mem_edgeFinset\n\ntheorem not_isDiag_of_mem_edgeFinset : e \u2208 G.edgeFinset \u2192 \u00ace.IsDiag :=\n  not_isDiag_of_mem_edgeSet _ \u2218 mem_edgeFinset.1\n#align simple_graph.not_is_diag_of_mem_edge_finset SimpleGraph.not_isDiag_of_mem_edgeFinset\n\n"}
{"name": "frequently_mod_eq253", "split": "test", "formal_statement": "theorem frequently_mod_eq {d n : \u2115} (h : d < n) : \u2203\u1da0 m in atTop, m % n = d := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Abs\nimport Mathlib.Data.Nat.ModEq\nimport Mathlib.Order.Filter.AtTopBot\n\n#align_import order.filter.modeq from \"leanprover-community/mathlib\"@\"f7fc89d5d5ff1db2d1242c7bb0e9062ce47ef47c\"\n\n\n\n\nopen Filter\n\nnamespace Nat\n\n\ntheorem frequently_modEq {n : \u2115} (h : n \u2260 0) (d : \u2115) : \u2203\u1da0 m in atTop, m \u2261 d [MOD n] :=\n  ((tendsto_add_atTop_nat d).comp (tendsto_id.nsmul_atTop h.bot_lt)).frequently <|\n    frequently_of_forall fun m => by simp [Nat.modEq_iff_dvd, \u2190 sub_sub]\n#align nat.frequently_modeq Nat.frequently_modEq\n\n"}
{"name": "mono254", "split": "test", "formal_statement": "theorem mono (K\u2081 K\u2082 : Compacts G) (h : (K\u2081 : Set G) \u2286 K\u2082) : \u03bc K\u2081 \u2264 \u03bc K\u2082 := by", "header": "\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport Mathlib.MeasureTheory.Measure.Regular\nimport Mathlib.Topology.Sets.Compacts\n\n#align_import measure_theory.measure.content from \"leanprover-community/mathlib\"@\"d39590fc8728fbf6743249802486f8c91ffe07bc\"\n\n\n\n\nuniverse u v w\n\nnoncomputable section\n\nopen Set TopologicalSpace\n\nopen NNReal ENNReal MeasureTheory\n\nnamespace MeasureTheory\n\nvariable {G : Type w} [TopologicalSpace G]\n\n\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G \u2192 \u211d\u22650\n  mono' : \u2200 K\u2081 K\u2082 : Compacts G, (K\u2081 : Set G) \u2286 K\u2082 \u2192 toFun K\u2081 \u2264 toFun K\u2082\n  sup_disjoint' :\n    \u2200 K\u2081 K\u2082 : Compacts G, Disjoint (K\u2081 : Set G) K\u2082 \u2192 IsClosed (K\u2081 : Set G) \u2192 IsClosed (K\u2082 : Set G)\n      \u2192 toFun (K\u2081 \u2294 K\u2082) = toFun K\u2081 + toFun K\u2082\n  sup_le' : \u2200 K\u2081 K\u2082 : Compacts G, toFun (K\u2081 \u2294 K\u2082) \u2264 toFun K\u2081 + toFun K\u2082\n#align measure_theory.content MeasureTheory.Content\n\ninstance : Inhabited (Content G) :=\n  \u27e8{  toFun := fun _ => 0\n      mono' := by simp\n      sup_disjoint' := by simp\n      sup_le' := by simp }\u27e9\n\n\ninstance : CoeFun (Content G) fun _ => Compacts G \u2192 \u211d\u22650\u221e :=\n  \u27e8fun \u03bc s => \u03bc.toFun s\u27e9\n\nnamespace Content\n\nvariable (\u03bc : Content G)\n\ntheorem apply_eq_coe_toFun (K : Compacts G) : \u03bc K = \u03bc.toFun K :=\n  rfl\n#align measure_theory.content.apply_eq_coe_to_fun MeasureTheory.Content.apply_eq_coe_toFun\n\n"}
{"name": "IsG\u03b4.sInter255", "split": "test", "formal_statement": "theorem IsG\u03b4.sInter {S : Set (Set X)} (h : \u2200 s \u2208 S, IsG\u03b4 s) (hS : S.Countable) : IsG\u03b4 (\u22c2\u2080 S) := by", "header": "\nimport Mathlib.Topology.UniformSpace.Basic\nimport Mathlib.Topology.Separation\nimport Mathlib.Order.Filter.CountableInter\n\n#align_import topology.G_delta from \"leanprover-community/mathlib\"@\"b9e46fe101fc897fb2e7edaf0bf1f09ea49eb81a\"\n\n\n\n\nnoncomputable section\n\nopen Topology TopologicalSpace Filter Encodable Set\nopen scoped Uniformity\n\nvariable {X Y \u03b9 : Type*} {\u03b9' : Sort*}\n\nset_option linter.uppercaseLean3 false\n\nsection IsG\u03b4\n\nvariable [TopologicalSpace X]\n\n\ndef IsG\u03b4 (s : Set X) : Prop :=\n  \u2203 T : Set (Set X), (\u2200 t \u2208 T, IsOpen t) \u2227 T.Countable \u2227 s = \u22c2\u2080 T\n#align is_G\u03b4 IsG\u03b4\n\n\ntheorem IsOpen.isG\u03b4 {s : Set X} (h : IsOpen s) : IsG\u03b4 s :=\n  \u27e8{s}, by simp [h], countable_singleton _, (Set.sInter_singleton _).symm\u27e9\n#align is_open.is_G\u03b4 IsOpen.isG\u03b4\n\n@[simp]\nprotected theorem IsG\u03b4.empty : IsG\u03b4 (\u2205 : Set X) :=\n  isOpen_empty.isG\u03b4\n#align is_G\u03b4_empty IsG\u03b4.empty\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_empty := IsG\u03b4.empty\n\n@[simp]\nprotected theorem IsG\u03b4.univ : IsG\u03b4 (univ : Set X) :=\n  isOpen_univ.isG\u03b4\n#align is_G\u03b4_univ IsG\u03b4.univ\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_univ := IsG\u03b4.univ\n\ntheorem IsG\u03b4.biInter_of_isOpen {I : Set \u03b9} (hI : I.Countable) {f : \u03b9 \u2192 Set X}\n    (hf : \u2200 i \u2208 I, IsOpen (f i)) : IsG\u03b4 (\u22c2 i \u2208 I, f i) :=\n  \u27e8f '' I, by rwa [forall_mem_image], hI.image _, by rw [sInter_image]\u27e9\n#align is_G\u03b4_bInter_of_open IsG\u03b4.biInter_of_isOpen\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_biInter_of_isOpen := IsG\u03b4.biInter_of_isOpen\n\ntheorem IsG\u03b4.iInter_of_isOpen [Countable \u03b9'] {f : \u03b9' \u2192 Set X} (hf : \u2200 i, IsOpen (f i)) :\n    IsG\u03b4 (\u22c2 i, f i) :=\n  \u27e8range f, by rwa [forall_mem_range], countable_range _, by rw [sInter_range]\u27e9\n#align is_G\u03b4_Inter_of_open IsG\u03b4.iInter_of_isOpen\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_iInter_of_isOpen := IsG\u03b4.iInter_of_isOpen\n\nlemma isG\u03b4_iff_eq_iInter_nat {s : Set X} :\n    IsG\u03b4 s \u2194 \u2203 (f : \u2115 \u2192 Set X), (\u2200 n, IsOpen (f n)) \u2227 s = \u22c2 n, f n := by\n  refine \u27e8?_, ?_\u27e9\n  \u00b7 rintro \u27e8T, hT, T_count, rfl\u27e9\n    rcases Set.eq_empty_or_nonempty T with rfl|hT\n    \u00b7 exact \u27e8fun _n \u21a6 univ, fun _n \u21a6 isOpen_univ, by simp\u27e9\n    \u00b7 obtain \u27e8f, hf\u27e9 : \u2203 (f : \u2115 \u2192 Set X), T = range f := Countable.exists_eq_range T_count hT\n      exact \u27e8f, by aesop, by simp [hf]\u27e9\n  \u00b7 rintro \u27e8f, hf, rfl\u27e9\n    exact .iInter_of_isOpen hf\n\nalias \u27e8IsG\u03b4.eq_iInter_nat, _\u27e9 := isG\u03b4_iff_eq_iInter_nat\n\n\nprotected theorem IsG\u03b4.iInter [Countable \u03b9'] {s : \u03b9' \u2192 Set X} (hs : \u2200 i, IsG\u03b4 (s i)) :\n    IsG\u03b4 (\u22c2 i, s i) := by\n  choose T hTo hTc hTs using hs\n  obtain rfl : s = fun i => \u22c2\u2080 T i := funext hTs\n  refine \u27e8\u22c3 i, T i, ?_, countable_iUnion hTc, (sInter_iUnion _).symm\u27e9\n  simpa [@forall_swap \u03b9'] using hTo\n#align is_G\u03b4_Inter IsG\u03b4.iInter\n\n@[deprecated] alias isG\u03b4_iInter := IsG\u03b4.iInter\n\ntheorem IsG\u03b4.biInter {s : Set \u03b9} (hs : s.Countable) {t : \u2200 i \u2208 s, Set X}\n    (ht : \u2200 (i) (hi : i \u2208 s), IsG\u03b4 (t i hi)) : IsG\u03b4 (\u22c2 i \u2208 s, t i \u2039_\u203a) := by\n  rw [biInter_eq_iInter]\n  haveI := hs.to_subtype\n  exact .iInter fun x => ht x x.2\n#align is_G\u03b4_bInter IsG\u03b4.biInter\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_biInter := IsG\u03b4.biInter\n\n\n"}
{"name": "IsTrail.even_countP_edges_iff256", "split": "test", "formal_statement": "theorem IsTrail.even_countP_edges_iff {u v : V} {p : G.Walk u v} (ht : p.IsTrail) (x : V) :\n    Even (p.edges.countP fun e => x \u2208 e) \u2194 u \u2260 v \u2192 x \u2260 u \u2227 x \u2260 v := by", "header": "\nimport Mathlib.Algebra.Ring.Parity\nimport Mathlib.Combinatorics.SimpleGraph.Connectivity\n\n#align_import combinatorics.simple_graph.trails from \"leanprover-community/mathlib\"@\"edaaaa4a5774e6623e0ddd919b2f2db49c65add4\"\n\n\n\n\nnamespace SimpleGraph\n\nvariable {V : Type*} {G : SimpleGraph V}\n\nnamespace Walk\n\n\nabbrev IsTrail.edgesFinset {u v : V} {p : G.Walk u v} (h : p.IsTrail) : Finset (Sym2 V) :=\n  \u27e8p.edges, h.edges_nodup\u27e9\n#align simple_graph.walk.is_trail.edges_finset SimpleGraph.Walk.IsTrail.edgesFinset\n\nvariable [DecidableEq V]\n\n"}
{"name": "map_algebraMap_mul257", "split": "test", "formal_statement": "theorem map_algebraMap_mul (f : A \u2192\u2097[R] B) (a : A) (r : R) :\n    f (algebraMap R A r * a) = algebraMap R B r * f a := by", "header": "\nimport Mathlib.Algebra.Algebra.Defs\nimport Mathlib.Algebra.CharZero.Lemmas\nimport Mathlib.Algebra.Module.Submodule.Ker\nimport Mathlib.Algebra.Module.Submodule.RestrictScalars\nimport Mathlib.Algebra.Module.ULift\nimport Mathlib.Algebra.Ring.Subring.Basic\nimport Mathlib.Data.Int.CharZero\nimport Mathlib.Data.Rat.Cast.CharZero\n\n#align_import algebra.algebra.basic from \"leanprover-community/mathlib\"@\"36b8aa61ea7c05727161f96a0532897bd72aedab\"\n\n\n\nuniverse u v w u\u2081 v\u2081\n\nnamespace Algebra\n\nvariable {R : Type u} {S : Type v} {A : Type w} {B : Type*}\n\nsection Semiring\n\nvariable [CommSemiring R] [CommSemiring S]\nvariable [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]\n\nopen scoped Algebra\n\nnamespace LinearMap\n\nvariable {R : Type*} {A : Type*} {B : Type*} [CommSemiring R] [Semiring A] [Semiring B]\n  [Algebra R A] [Algebra R B]\n\n\n"}
{"name": "Convex.openSegment_interior_closure_subset_interior258", "split": "test", "formal_statement": "theorem Convex.openSegment_interior_closure_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 closure s) : openSegment \ud835\udd5c x y \u2286 interior s := by", "header": "\nimport Mathlib.Analysis.Convex.Combination\nimport Mathlib.Analysis.Convex.Strict\nimport Mathlib.Topology.Connected.PathConnected\nimport Mathlib.Topology.Algebra.Affine\nimport Mathlib.Topology.Algebra.Module.Basic\n\n#align_import analysis.convex.topology from \"leanprover-community/mathlib\"@\"0e3aacdc98d25e0afe035c452d876d28cbffaa7e\"\n\n\n\nassert_not_exists Norm\n\nopen Metric Bornology Set Pointwise Convex\n\nvariable {\u03b9 \ud835\udd5c E : Type*}\n\ntheorem Real.convex_iff_isPreconnected {s : Set \u211d} : Convex \u211d s \u2194 IsPreconnected s :=\n  convex_iff_ordConnected.trans isPreconnected_iff_ordConnected.symm\n#align real.convex_iff_is_preconnected Real.convex_iff_isPreconnected\n\nalias \u27e8_, IsPreconnected.convex\u27e9 := Real.convex_iff_isPreconnected\n#align is_preconnected.convex IsPreconnected.convex\n\n\n\n\n\nsection ContinuousConstSMul\n\nvariable [LinearOrderedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]\n  [TopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]\n\n\ntheorem Convex.combo_interior_closure_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) : a \u2022 interior s + b \u2022 closure s \u2286 interior s :=\n  interior_smul\u2080 ha.ne' s \u25b8\n    calc\n      interior (a \u2022 s) + b \u2022 closure s \u2286 interior (a \u2022 s) + closure (b \u2022 s) :=\n        add_subset_add Subset.rfl (smul_closure_subset b s)\n      _ = interior (a \u2022 s) + b \u2022 s := by rw [isOpen_interior.add_closure (b \u2022 s)]\n      _ \u2286 interior (a \u2022 s + b \u2022 s) := subset_interior_add_left\n      _ \u2286 interior s := interior_mono <| hs.set_combo_subset ha.le hb hab\n\n#align convex.combo_interior_closure_subset_interior Convex.combo_interior_closure_subset_interior\n\n\ntheorem Convex.combo_interior_self_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) : a \u2022 interior s + b \u2022 s \u2286 interior s :=\n  calc\n    a \u2022 interior s + b \u2022 s \u2286 a \u2022 interior s + b \u2022 closure s :=\n      add_subset_add Subset.rfl <| image_subset _ subset_closure\n    _ \u2286 interior s := hs.combo_interior_closure_subset_interior ha hb hab\n\n#align convex.combo_interior_self_subset_interior Convex.combo_interior_self_subset_interior\n\n\ntheorem Convex.combo_closure_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) : a \u2022 closure s + b \u2022 interior s \u2286 interior s := by\n  rw [add_comm]\n  exact hs.combo_interior_closure_subset_interior hb ha (add_comm a b \u25b8 hab)\n#align convex.combo_closure_interior_subset_interior Convex.combo_closure_interior_subset_interior\n\n\ntheorem Convex.combo_self_interior_subset_interior {s : Set E} (hs : Convex \ud835\udd5c s) {a b : \ud835\udd5c}\n    (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) : a \u2022 s + b \u2022 interior s \u2286 interior s := by\n  rw [add_comm]\n  exact hs.combo_interior_self_subset_interior hb ha (add_comm a b \u25b8 hab)\n#align convex.combo_self_interior_subset_interior Convex.combo_self_interior_subset_interior\n\ntheorem Convex.combo_interior_closure_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 closure s) {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 \u2264 b)\n    (hab : a + b = 1) : a \u2022 x + b \u2022 y \u2208 interior s :=\n  hs.combo_interior_closure_subset_interior ha hb hab <|\n    add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n#align convex.combo_interior_closure_mem_interior Convex.combo_interior_closure_mem_interior\n\ntheorem Convex.combo_interior_self_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 interior s) (hy : y \u2208 s) {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) :\n    a \u2022 x + b \u2022 y \u2208 interior s :=\n  hs.combo_interior_closure_mem_interior hx (subset_closure hy) ha hb hab\n#align convex.combo_interior_self_mem_interior Convex.combo_interior_self_mem_interior\n\ntheorem Convex.combo_closure_interior_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 closure s) (hy : y \u2208 interior s) {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 < b)\n    (hab : a + b = 1) : a \u2022 x + b \u2022 y \u2208 interior s :=\n  hs.combo_closure_interior_subset_interior ha hb hab <|\n    add_mem_add (smul_mem_smul_set hx) (smul_mem_smul_set hy)\n#align convex.combo_closure_interior_mem_interior Convex.combo_closure_interior_mem_interior\n\ntheorem Convex.combo_self_interior_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s)\n    (hy : y \u2208 interior s) {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) :\n    a \u2022 x + b \u2022 y \u2208 interior s :=\n  hs.combo_closure_interior_mem_interior (subset_closure hx) hy ha hb hab\n#align convex.combo_self_interior_mem_interior Convex.combo_self_interior_mem_interior\n\n"}
{"name": "normalize_num_den259", "split": "test", "formal_statement": "theorem normalize_num_den (h : normalize n d z = \u27e8n', d', z', c\u27e9) :\n    \u2203 m : Nat, m \u2260 0 \u2227 n = n' * m \u2227 d = d' * m := by", "header": "\nimport Batteries.Data.Rat.Basic\nimport Batteries.Tactic.SeqFocus\n\n\n\nnamespace Rat\n\ntheorem ext : {p q : Rat} \u2192 p.num = q.num \u2192 p.den = q.den \u2192 p = q\n  | \u27e8_,_,_,_\u27e9, \u27e8_,_,_,_\u27e9, rfl, rfl => rfl\n\n@[simp] theorem mk_den_one {r : Int} :\n    \u27e8r, 1, Nat.one_ne_zero, (Nat.coprime_one_right _)\u27e9 = (r : Rat) := rfl\n\n@[simp] theorem zero_num : (0 : Rat).num = 0 := rfl\n@[simp] theorem zero_den : (0 : Rat).den = 1 := rfl\n@[simp] theorem one_num : (1 : Rat).num = 1 := rfl\n@[simp] theorem one_den : (1 : Rat).den = 1 := rfl\n\n@[simp] theorem maybeNormalize_eq {num den g} (den_nz reduced) :\n    maybeNormalize num den g den_nz reduced =\n    { num := num.div g, den := den / g, den_nz, reduced } := by\n  unfold maybeNormalize; split\n  \u00b7 subst g; simp\n  \u00b7 rfl\n\ntheorem normalize.reduced' {num : Int} {den g : Nat} (den_nz : den \u2260 0)\n    (e : g = num.natAbs.gcd den) : (num / g).natAbs.Coprime (den / g) := by\n  rw [\u2190 Int.div_eq_ediv_of_dvd (e \u25b8 Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n  exact normalize.reduced den_nz e\n\ntheorem normalize_eq {num den} (den_nz) : normalize num den den_nz =\n    { num := num / num.natAbs.gcd den\n      den := den / num.natAbs.gcd den\n      den_nz := normalize.den_nz den_nz rfl\n      reduced := normalize.reduced' den_nz rfl } := by\n  simp only [normalize, maybeNormalize_eq,\n    Int.div_eq_ediv_of_dvd (Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]\n\n@[simp] theorem normalize_zero (nz) : normalize 0 d nz = 0 := by\n  simp [normalize, Int.zero_div, Int.natAbs_zero, Nat.div_self (Nat.pos_of_ne_zero nz)]; rfl\n\ntheorem mk_eq_normalize (num den nz c) : \u27e8num, den, nz, c\u27e9 = normalize num den nz := by\n  simp [normalize_eq, c.gcd_eq_one]\n\ntheorem normalize_self (r : Rat) : normalize r.num r.den r.den_nz = r := (mk_eq_normalize ..).symm\n\ntheorem normalize_mul_left {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (\u2191a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0 := by\n  simp [normalize_eq, mk'.injEq, Int.natAbs_mul, Nat.gcd_mul_left,\n    Nat.mul_div_mul_left _ _ (Nat.pos_of_ne_zero a0), Int.ofNat_mul,\n    Int.mul_ediv_mul_of_pos _ _ (Int.ofNat_pos.2 <| Nat.pos_of_ne_zero a0)]\n\ntheorem normalize_mul_right {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0 := by\n  rw [\u2190 normalize_mul_left (d0 := d0) a0]; congr 1 <;> [apply Int.mul_comm; apply Nat.mul_comm]\n\ntheorem normalize_eq_iff (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    normalize n\u2081 d\u2081 z\u2081 = normalize n\u2082 d\u2082 z\u2082 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081 := by\n  constructor <;> intro h\n  \u00b7 simp only [normalize_eq, mk'.injEq] at h\n    have' hn\u2081 := Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left n\u2081.natAbs d\u2081\n    have' hn\u2082 := Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left n\u2082.natAbs d\u2082\n    have' hd\u2081 := Int.ofNat_dvd.2 <| Nat.gcd_dvd_right n\u2081.natAbs d\u2081\n    have' hd\u2082 := Int.ofNat_dvd.2 <| Nat.gcd_dvd_right n\u2082.natAbs d\u2082\n    rw [\u2190 Int.ediv_mul_cancel (Int.dvd_trans hd\u2082 (Int.dvd_mul_left ..)),\n      Int.mul_ediv_assoc _ hd\u2082, \u2190 Int.ofNat_ediv, \u2190 h.2, Int.ofNat_ediv,\n      \u2190 Int.mul_ediv_assoc _ hd\u2081, Int.mul_ediv_assoc' _ hn\u2081,\n      Int.mul_right_comm, h.1, Int.ediv_mul_cancel hn\u2082]\n  \u00b7 rw [\u2190 normalize_mul_right _ z\u2082, \u2190 normalize_mul_left z\u2082 z\u2081, Int.mul_comm d\u2081, h]\n\ntheorem maybeNormalize_eq_normalize {num : Int} {den g : Nat} (den_nz reduced)\n    (hn : \u2191g \u2223 num) (hd : g \u2223 den) :\n    maybeNormalize num den g den_nz reduced = normalize num den (mt (by simp [\u00b7]) den_nz) := by\n  simp only [maybeNormalize_eq, mk_eq_normalize, Int.div_eq_ediv_of_dvd hn]\n  have : g \u2260 0 := mt (by simp [\u00b7]) den_nz\n  rw [\u2190 normalize_mul_right _ this, Int.ediv_mul_cancel hn]\n  congr 1; exact Nat.div_mul_cancel hd\n\n@[simp] theorem normalize_eq_zero (d0 : d \u2260 0) : normalize n d d0 = 0 \u2194 n = 0 := by\n  have' := normalize_eq_iff d0 Nat.one_ne_zero\n  rw [normalize_zero (d := 1)] at this; rw [this]; simp\n\ntheorem normalize_num_den' (num den nz) : \u2203 d : Nat, d \u2260 0 \u2227\n    num = (normalize num den nz).num * d \u2227 den = (normalize num den nz).den * d := by\n  refine \u27e8num.natAbs.gcd den, Nat.gcd_ne_zero_right nz, ?_\u27e9\n  simp [normalize_eq, Int.ediv_mul_cancel (Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left ..),\n    Nat.div_mul_cancel (Nat.gcd_dvd_right ..)]\n\n"}
{"name": "ContinuousSMul.of_nhds_zero260", "split": "test", "formal_statement": "theorem ContinuousSMul.of_nhds_zero [TopologicalRing R] [TopologicalAddGroup M]\n    (hmul : Tendsto (fun p : R \u00d7 M => p.1 \u2022 p.2) (\ud835\udcdd 0 \u00d7\u02e2 \ud835\udcdd 0) (\ud835\udcdd 0))\n    (hmulleft : \u2200 m : M, Tendsto (fun a : R => a \u2022 m) (\ud835\udcdd 0) (\ud835\udcdd 0))\n    (hmulright : \u2200 a : R, Tendsto (fun m : M => a \u2022 m) (\ud835\udcdd 0) (\ud835\udcdd 0)) : ContinuousSMul R M where\n  continuous_smul := by", "header": "\nimport Mathlib.Topology.Algebra.Ring.Basic\nimport Mathlib.Topology.Algebra.MulAction\nimport Mathlib.Topology.Algebra.UniformGroup\nimport Mathlib.Topology.ContinuousFunction.Basic\nimport Mathlib.Topology.UniformSpace.UniformEmbedding\nimport Mathlib.Algebra.Algebra.Defs\nimport Mathlib.LinearAlgebra.Projection\nimport Mathlib.LinearAlgebra.Pi\nimport Mathlib.LinearAlgebra.Finsupp\n\n#align_import topology.algebra.module.basic from \"leanprover-community/mathlib\"@\"6285167a053ad0990fc88e56c48ccd9fae6550eb\"\n\n\n\nopen LinearMap (ker range)\nopen Topology Filter Pointwise\n\nuniverse u v w u'\n\nsection\n\nvariable {R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]\n  [AddCommGroup M] [Module R M]\n\n"}
{"name": "innerContent_iSup_nat261", "split": "test", "formal_statement": "theorem innerContent_iSup_nat [R1Space G] (U : \u2115 \u2192 Opens G) :\n    \u03bc.innerContent (\u2a06 i : \u2115, U i) \u2264 \u2211' i : \u2115, \u03bc.innerContent (U i) := by", "header": "\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport Mathlib.MeasureTheory.Measure.Regular\nimport Mathlib.Topology.Sets.Compacts\n\n#align_import measure_theory.measure.content from \"leanprover-community/mathlib\"@\"d39590fc8728fbf6743249802486f8c91ffe07bc\"\n\n\n\n\nuniverse u v w\n\nnoncomputable section\n\nopen Set TopologicalSpace\n\nopen NNReal ENNReal MeasureTheory\n\nnamespace MeasureTheory\n\nvariable {G : Type w} [TopologicalSpace G]\n\n\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G \u2192 \u211d\u22650\n  mono' : \u2200 K\u2081 K\u2082 : Compacts G, (K\u2081 : Set G) \u2286 K\u2082 \u2192 toFun K\u2081 \u2264 toFun K\u2082\n  sup_disjoint' :\n    \u2200 K\u2081 K\u2082 : Compacts G, Disjoint (K\u2081 : Set G) K\u2082 \u2192 IsClosed (K\u2081 : Set G) \u2192 IsClosed (K\u2082 : Set G)\n      \u2192 toFun (K\u2081 \u2294 K\u2082) = toFun K\u2081 + toFun K\u2082\n  sup_le' : \u2200 K\u2081 K\u2082 : Compacts G, toFun (K\u2081 \u2294 K\u2082) \u2264 toFun K\u2081 + toFun K\u2082\n#align measure_theory.content MeasureTheory.Content\n\ninstance : Inhabited (Content G) :=\n  \u27e8{  toFun := fun _ => 0\n      mono' := by simp\n      sup_disjoint' := by simp\n      sup_le' := by simp }\u27e9\n\n\ninstance : CoeFun (Content G) fun _ => Compacts G \u2192 \u211d\u22650\u221e :=\n  \u27e8fun \u03bc s => \u03bc.toFun s\u27e9\n\nnamespace Content\n\nvariable (\u03bc : Content G)\n\ntheorem apply_eq_coe_toFun (K : Compacts G) : \u03bc K = \u03bc.toFun K :=\n  rfl\n#align measure_theory.content.apply_eq_coe_to_fun MeasureTheory.Content.apply_eq_coe_toFun\n\ntheorem mono (K\u2081 K\u2082 : Compacts G) (h : (K\u2081 : Set G) \u2286 K\u2082) : \u03bc K\u2081 \u2264 \u03bc K\u2082 := by\n  simp [apply_eq_coe_toFun, \u03bc.mono' _ _ h]\n#align measure_theory.content.mono MeasureTheory.Content.mono\n\ntheorem sup_disjoint (K\u2081 K\u2082 : Compacts G) (h : Disjoint (K\u2081 : Set G) K\u2082)\n    (h\u2081 : IsClosed (K\u2081 : Set G)) (h\u2082 : IsClosed (K\u2082 : Set G)) :\n    \u03bc (K\u2081 \u2294 K\u2082) = \u03bc K\u2081 + \u03bc K\u2082 := by\n  simp [apply_eq_coe_toFun, \u03bc.sup_disjoint' _ _ h]\n#align measure_theory.content.sup_disjoint MeasureTheory.Content.sup_disjoint\n\ntheorem sup_le (K\u2081 K\u2082 : Compacts G) : \u03bc (K\u2081 \u2294 K\u2082) \u2264 \u03bc K\u2081 + \u03bc K\u2082 := by\n  simp only [apply_eq_coe_toFun]\n  norm_cast\n  exact \u03bc.sup_le' _ _\n#align measure_theory.content.sup_le MeasureTheory.Content.sup_le\n\ntheorem lt_top (K : Compacts G) : \u03bc K < \u221e :=\n  ENNReal.coe_lt_top\n#align measure_theory.content.lt_top MeasureTheory.Content.lt_top\n\ntheorem empty : \u03bc \u22a5 = 0 := by\n  have := \u03bc.sup_disjoint' \u22a5 \u22a5\n  simpa [apply_eq_coe_toFun] using this\n#align measure_theory.content.empty MeasureTheory.Content.empty\n\n\ndef innerContent (U : Opens G) : \u211d\u22650\u221e :=\n  \u2a06 (K : Compacts G) (_ : (K : Set G) \u2286 U), \u03bc K\n#align measure_theory.content.inner_content MeasureTheory.Content.innerContent\n\ntheorem le_innerContent (K : Compacts G) (U : Opens G) (h2 : (K : Set G) \u2286 U) :\n    \u03bc K \u2264 \u03bc.innerContent U :=\n  le_iSup_of_le K <| le_iSup (fun _ \u21a6 (\u03bc.toFun K : \u211d\u22650\u221e)) h2\n#align measure_theory.content.le_inner_content MeasureTheory.Content.le_innerContent\n\ntheorem innerContent_le (U : Opens G) (K : Compacts G) (h2 : (U : Set G) \u2286 K) :\n    \u03bc.innerContent U \u2264 \u03bc K :=\n  iSup\u2082_le fun _ hK' => \u03bc.mono _ _ (Subset.trans hK' h2)\n#align measure_theory.content.inner_content_le MeasureTheory.Content.innerContent_le\n\ntheorem innerContent_of_isCompact {K : Set G} (h1K : IsCompact K) (h2K : IsOpen K) :\n    \u03bc.innerContent \u27e8K, h2K\u27e9 = \u03bc \u27e8K, h1K\u27e9 :=\n  le_antisymm (iSup\u2082_le fun _ hK' => \u03bc.mono _ \u27e8K, h1K\u27e9 hK') (\u03bc.le_innerContent _ _ Subset.rfl)\n#align measure_theory.content.inner_content_of_is_compact MeasureTheory.Content.innerContent_of_isCompact\n\ntheorem innerContent_bot : \u03bc.innerContent \u22a5 = 0 := by\n  refine le_antisymm ?_ (zero_le _)\n  rw [\u2190 \u03bc.empty]\n  refine iSup\u2082_le fun K hK => ?_\n  have : K = \u22a5 := by\n    ext1\n    rw [subset_empty_iff.mp hK, Compacts.coe_bot]\n  rw [this]\n#align measure_theory.content.inner_content_bot MeasureTheory.Content.innerContent_bot\n\n\ntheorem innerContent_mono \u2983U V : Set G\u2984 (hU : IsOpen U) (hV : IsOpen V) (h2 : U \u2286 V) :\n    \u03bc.innerContent \u27e8U, hU\u27e9 \u2264 \u03bc.innerContent \u27e8V, hV\u27e9 :=\n  biSup_mono fun _ hK => hK.trans h2\n#align measure_theory.content.inner_content_mono MeasureTheory.Content.innerContent_mono\n\ntheorem innerContent_exists_compact {U : Opens G} (hU : \u03bc.innerContent U \u2260 \u221e) {\u03b5 : \u211d\u22650}\n    (h\u03b5 : \u03b5 \u2260 0) : \u2203 K : Compacts G, (K : Set G) \u2286 U \u2227 \u03bc.innerContent U \u2264 \u03bc K + \u03b5 := by\n  have h'\u03b5 := ENNReal.coe_ne_zero.2 h\u03b5\n  rcases le_or_lt (\u03bc.innerContent U) \u03b5 with h | h\n  \u00b7 exact \u27e8\u22a5, empty_subset _, le_add_left h\u27e9\n  have h\u2082 := ENNReal.sub_lt_self hU h.ne_bot h'\u03b5\n  conv at h\u2082 => rhs; rw [innerContent]\n  simp only [lt_iSup_iff] at h\u2082\n  rcases h\u2082 with \u27e8U, h1U, h2U\u27e9; refine \u27e8U, h1U, ?_\u27e9\n  rw [\u2190 tsub_le_iff_right]; exact le_of_lt h2U\n#align measure_theory.content.inner_content_exists_compact MeasureTheory.Content.innerContent_exists_compact\n\n\n"}
{"name": "le_find_iff262", "split": "test", "formal_statement": "theorem le_find_iff (n : \u2115+) : n \u2264 PNat.find h \u2194 \u2200 m < n, \u00acp m := by", "header": "\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.find from \"leanprover-community/mathlib\"@\"207cfac9fcd06138865b5d04f7091e46d9320432\"\n\n\n\n\nnamespace PNat\n\nvariable {p q : \u2115+ \u2192 Prop} [DecidablePred p] [DecidablePred q] (h : \u2203 n, p n)\n\ninstance decidablePredExistsNat : DecidablePred fun n' : \u2115 => \u2203 (n : \u2115+) (_ : n' = n), p n :=\n  fun n' =>\n  decidable_of_iff' (\u2203 h : 0 < n', p \u27e8n', h\u27e9) <|\n    Subtype.exists.trans <| by\n      simp_rw [mk_coe, @exists_comm (_ < _) (_ = _), exists_prop, exists_eq_left']\n#align pnat.decidable_pred_exists_nat PNat.decidablePredExistsNat\n\n\nprotected def findX : { n // p n \u2227 \u2200 m : \u2115+, m < n \u2192 \u00acp m } := by\n  have : \u2203 (n' : \u2115) (n : \u2115+) (_ : n' = n), p n := Exists.elim h fun n hn => \u27e8n, n, rfl, hn\u27e9\n  have n := Nat.findX this\n  refine \u27e8\u27e8n, ?_\u27e9, ?_, fun m hm pm => ?_\u27e9\n  \u00b7 obtain \u27e8n', hn', -\u27e9 := n.prop.1\n    rw [hn']\n    exact n'.prop\n  \u00b7 obtain \u27e8n', hn', pn'\u27e9 := n.prop.1\n    simpa [hn', Subtype.coe_eta] using pn'\n  \u00b7 exact n.prop.2 m hm \u27e8m, rfl, pm\u27e9\n#align pnat.find_x PNat.findX\n\n\nprotected def find : \u2115+ :=\n  PNat.findX h\n#align pnat.find PNat.find\n\nprotected theorem find_spec : p (PNat.find h) :=\n  (PNat.findX h).prop.left\n#align pnat.find_spec PNat.find_spec\n\nprotected theorem find_min : \u2200 {m : \u2115+}, m < PNat.find h \u2192 \u00acp m :=\n  @(PNat.findX h).prop.right\n#align pnat.find_min PNat.find_min\n\nprotected theorem find_min' {m : \u2115+} (hm : p m) : PNat.find h \u2264 m :=\n  le_of_not_lt fun l => PNat.find_min h l hm\n#align pnat.find_min' PNat.find_min'\n\nvariable {n m : \u2115+}\n\ntheorem find_eq_iff : PNat.find h = m \u2194 p m \u2227 \u2200 n < m, \u00acp n := by\n  constructor\n  \u00b7 rintro rfl\n    exact \u27e8PNat.find_spec h, fun _ => PNat.find_min h\u27e9\n  \u00b7 rintro \u27e8hm, hlt\u27e9\n    exact le_antisymm (PNat.find_min' h hm) (not_lt.1 <| imp_not_comm.1 (hlt _) <| PNat.find_spec h)\n#align pnat.find_eq_iff PNat.find_eq_iff\n\n@[simp]\ntheorem find_lt_iff (n : \u2115+) : PNat.find h < n \u2194 \u2203 m < n, p m :=\n  \u27e8fun h2 => \u27e8PNat.find h, h2, PNat.find_spec h\u27e9, fun \u27e8_, hmn, hm\u27e9 =>\n    (PNat.find_min' h hm).trans_lt hmn\u27e9\n#align pnat.find_lt_iff PNat.find_lt_iff\n\n@[simp]\ntheorem find_le_iff (n : \u2115+) : PNat.find h \u2264 n \u2194 \u2203 m \u2264 n, p m := by\n  simp only [exists_prop, \u2190 lt_add_one_iff, find_lt_iff]\n#align pnat.find_le_iff PNat.find_le_iff\n\n@[simp]\n"}
{"name": "Coprime.gcd_mul_left_cancel263", "split": "test", "formal_statement": "theorem Coprime.gcd_mul_left_cancel (m : \u2115+) {n k : \u2115+} :\n    k.Coprime n \u2192 (k * m).gcd n = m.gcd n := by", "header": "\nimport Mathlib.Data.Nat.Prime\nimport Mathlib.Data.PNat.Basic\n\n#align_import data.pnat.prime from \"leanprover-community/mathlib\"@\"09597669f02422ed388036273d8848119699c22f\"\n\n\n\n\nnamespace PNat\n\nopen Nat\n\n\ndef gcd (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.gcd (n : \u2115) (m : \u2115), Nat.gcd_pos_of_pos_left (m : \u2115) n.pos\u27e9\n#align pnat.gcd PNat.gcd\n\n\ndef lcm (n m : \u2115+) : \u2115+ :=\n  \u27e8Nat.lcm (n : \u2115) (m : \u2115), by\n    let h := mul_pos n.pos m.pos\n    rw [\u2190 gcd_mul_lcm (n : \u2115) (m : \u2115), mul_comm] at h\n    exact pos_of_dvd_of_pos (Dvd.intro (Nat.gcd (n : \u2115) (m : \u2115)) rfl) h\u27e9\n#align pnat.lcm PNat.lcm\n\n@[simp, norm_cast]\ntheorem gcd_coe (n m : \u2115+) : (gcd n m : \u2115) = Nat.gcd n m :=\n  rfl\n#align pnat.gcd_coe PNat.gcd_coe\n\n@[simp, norm_cast]\ntheorem lcm_coe (n m : \u2115+) : (lcm n m : \u2115) = Nat.lcm n m :=\n  rfl\n#align pnat.lcm_coe PNat.lcm_coe\n\ntheorem gcd_dvd_left (n m : \u2115+) : gcd n m \u2223 n :=\n  dvd_iff.2 (Nat.gcd_dvd_left (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_left PNat.gcd_dvd_left\n\ntheorem gcd_dvd_right (n m : \u2115+) : gcd n m \u2223 m :=\n  dvd_iff.2 (Nat.gcd_dvd_right (n : \u2115) (m : \u2115))\n#align pnat.gcd_dvd_right PNat.gcd_dvd_right\n\ntheorem dvd_gcd {m n k : \u2115+} (hm : k \u2223 m) (hn : k \u2223 n) : k \u2223 gcd m n :=\n  dvd_iff.2 (Nat.dvd_gcd (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.dvd_gcd PNat.dvd_gcd\n\ntheorem dvd_lcm_left (n m : \u2115+) : n \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_left (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_left PNat.dvd_lcm_left\n\ntheorem dvd_lcm_right (n m : \u2115+) : m \u2223 lcm n m :=\n  dvd_iff.2 (Nat.dvd_lcm_right (n : \u2115) (m : \u2115))\n#align pnat.dvd_lcm_right PNat.dvd_lcm_right\n\ntheorem lcm_dvd {m n k : \u2115+} (hm : m \u2223 k) (hn : n \u2223 k) : lcm m n \u2223 k :=\n  dvd_iff.2 (@Nat.lcm_dvd (m : \u2115) (n : \u2115) (k : \u2115) (dvd_iff.1 hm) (dvd_iff.1 hn))\n#align pnat.lcm_dvd PNat.lcm_dvd\n\ntheorem gcd_mul_lcm (n m : \u2115+) : gcd n m * lcm n m = n * m :=\n  Subtype.eq (Nat.gcd_mul_lcm (n : \u2115) (m : \u2115))\n#align pnat.gcd_mul_lcm PNat.gcd_mul_lcm\n\ntheorem eq_one_of_lt_two {n : \u2115+} : n < 2 \u2192 n = 1 := by\n  intro h; apply le_antisymm; swap\n  \u00b7 apply PNat.one_le\n  \u00b7 exact PNat.lt_add_one_iff.1 h\n#align pnat.eq_one_of_lt_two PNat.eq_one_of_lt_two\n\nsection Coprime\n\n\n\n\n\ndef Coprime (m n : \u2115+) : Prop :=\n  m.gcd n = 1\n#align pnat.coprime PNat.Coprime\n\n@[simp, norm_cast]\ntheorem coprime_coe {m n : \u2115+} : Nat.Coprime \u2191m \u2191n \u2194 m.Coprime n := by\n  unfold Nat.Coprime Coprime\n  rw [\u2190 coe_inj]\n  simp\n#align pnat.coprime_coe PNat.coprime_coe\n\ntheorem Coprime.mul {k m n : \u2115+} : m.Coprime k \u2192 n.Coprime k \u2192 (m * n).Coprime k := by\n  repeat rw [\u2190 coprime_coe]\n  rw [mul_coe]\n  apply Nat.Coprime.mul\n#align pnat.coprime.mul PNat.Coprime.mul\n\ntheorem Coprime.mul_right {k m n : \u2115+} : k.Coprime m \u2192 k.Coprime n \u2192 k.Coprime (m * n) := by\n  repeat rw [\u2190 coprime_coe]\n  rw [mul_coe]\n  apply Nat.Coprime.mul_right\n#align pnat.coprime.mul_right PNat.Coprime.mul_right\n\ntheorem gcd_comm {m n : \u2115+} : m.gcd n = n.gcd m := by\n  apply eq\n  simp only [gcd_coe]\n  apply Nat.gcd_comm\n#align pnat.gcd_comm PNat.gcd_comm\n\ntheorem gcd_eq_left_iff_dvd {m n : \u2115+} : m \u2223 n \u2194 m.gcd n = m := by\n  rw [dvd_iff]\n  rw [Nat.gcd_eq_left_iff_dvd]\n  rw [\u2190 coe_inj]\n  simp\n#align pnat.gcd_eq_left_iff_dvd PNat.gcd_eq_left_iff_dvd\n\ntheorem gcd_eq_right_iff_dvd {m n : \u2115+} : m \u2223 n \u2194 n.gcd m = m := by\n  rw [gcd_comm]\n  apply gcd_eq_left_iff_dvd\n#align pnat.gcd_eq_right_iff_dvd PNat.gcd_eq_right_iff_dvd\n\n"}
{"name": "_root_.isSelfAdjoint_add_star_self264", "split": "test", "formal_statement": "theorem _root_.isSelfAdjoint_add_star_self (x : R) : IsSelfAdjoint (x + star x) := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Basic\nimport Mathlib.Algebra.Module.Defs\nimport Mathlib.Algebra.Star.Pi\n\n#align_import algebra.star.self_adjoint from \"leanprover-community/mathlib\"@\"a6ece35404f60597c651689c1b46ead86de5ac1b\"\n\n\n\nopen Function\n\nvariable {R A : Type*}\n\n\ndef IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x\n#align is_self_adjoint IsSelfAdjoint\n\n\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x\n#align is_star_normal IsStarNormal\n\nexport IsStarNormal (star_comm_self)\n\ntheorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n#align star_comm_self' star_comm_self'\n\nnamespace IsSelfAdjoint\n\n-- named to match `Commute.all\u2093`\n\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n#align is_self_adjoint.all IsSelfAdjoint.all\n\ntheorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n#align is_self_adjoint.star_eq IsSelfAdjoint.star_eq\n\ntheorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x :=\n  Iff.rfl\n#align is_self_adjoint_iff isSelfAdjoint_iff\n\n@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n#align is_self_adjoint.star_iff IsSelfAdjoint.star_iff\n\n@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint, star_mul, star_star]\n#align is_self_adjoint.star_mul_self IsSelfAdjoint.star_mul_self\n\n@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n#align is_self_adjoint.mul_star_self IsSelfAdjoint.mul_star_self\n\n\nlemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n\n\ntheorem starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S] [StarHomClass F R S]\n    {x : R} (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x) :=\n  show star (f x) = f x from map_star f x \u25b8 congr_arg f hx\n#align is_self_adjoint.star_hom_apply IsSelfAdjoint.starHom_apply\n\n\ntheorem _root_.isSelfAdjoint_starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S]\n    [StarHomClass F R S] [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x) :=\n  (IsSelfAdjoint.all x).starHom_apply f\n\nsection AddCommMonoid\n\nvariable [AddCommMonoid R] [StarAddMonoid R]\n\n"}
{"name": "laurentAux_algebraMap265", "split": "test", "formal_statement": "theorem laurentAux_algebraMap : laurentAux r (algebraMap _ _ p) = algebraMap _ _ (taylor r p) := by", "header": "\nimport Mathlib.Algebra.Polynomial.Taylor\nimport Mathlib.FieldTheory.RatFunc.AsPolynomial\n\n#align_import field_theory.laurent from \"leanprover-community/mathlib\"@\"70fd9563a21e7b963887c9360bd29b2393e6225a\"\n\n\n\n\nuniverse u\n\nnamespace RatFunc\n\nnoncomputable section\n\nopen Polynomial\n\nopen scoped Classical nonZeroDivisors Polynomial\n\nvariable {R : Type u} [CommRing R] [hdomain : IsDomain R] (r s : R) (p q : R[X]) (f : RatFunc R)\n\ntheorem taylor_mem_nonZeroDivisors (hp : p \u2208 R[X]\u2070) : taylor r p \u2208 R[X]\u2070 := by\n  rw [mem_nonZeroDivisors_iff]\n  intro x hx\n  have : x = taylor (r - r) x := by simp\n  rwa [this, sub_eq_add_neg, \u2190 taylor_taylor, \u2190 taylor_mul,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _), mul_right_mem_nonZeroDivisors_eq_zero_iff hp,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _)] at hx\n#align ratfunc.taylor_mem_non_zero_divisors RatFunc.taylor_mem_nonZeroDivisors\n\n\ndef laurentAux : RatFunc R \u2192+* RatFunc R :=\n  RatFunc.mapRingHom\n    ( { toFun := taylor r\n        map_add' := map_add (taylor r)\n        map_mul' := taylor_mul _\n        map_zero' := map_zero (taylor r)\n        map_one' := taylor_one r } : R[X] \u2192+* R[X])\n    (taylor_mem_nonZeroDivisors _)\n#align ratfunc.laurent_aux RatFunc.laurentAux\n\ntheorem laurentAux_ofFractionRing_mk (q : R[X]\u2070) :\n    laurentAux r (ofFractionRing (Localization.mk p q)) =\n      ofFractionRing (.mk (taylor r p) \u27e8taylor r q, taylor_mem_nonZeroDivisors r q q.prop\u27e9) :=\n  map_apply_ofFractionRing_mk _ _ _ _\n#align ratfunc.laurent_aux_of_fraction_ring_mk RatFunc.laurentAux_ofFractionRing_mk\n\ntheorem laurentAux_div :\n    laurentAux r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q) :=\n  -- Porting note: added `by exact taylor_mem_nonZeroDivisors r`\n  map_apply_div _ (by exact taylor_mem_nonZeroDivisors r) _ _\n#align ratfunc.laurent_aux_div RatFunc.laurentAux_div\n\n@[simp]\n"}
{"name": "aemeasurable_withDensity_iff266", "split": "test", "formal_statement": "theorem aemeasurable_withDensity_iff {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [SecondCountableTopology E] [MeasurableSpace E] [BorelSpace E] {f : \u03b1 \u2192 \u211d\u22650}\n    (hf : Measurable f) {g : \u03b1 \u2192 E} :\n    AEMeasurable g (\u03bc.withDensity fun x => (f x : \u211d\u22650\u221e)) \u2194\n      AEMeasurable (fun x => (f x : \u211d) \u2022 g x) \u03bc := by", "header": "\nimport Mathlib.MeasureTheory.Measure.WithDensity\nimport Mathlib.Analysis.NormedSpace.Basic\n\n#align_import measure_theory.integral.lebesgue_normed_space from \"leanprover-community/mathlib\"@\"bf6a01357ff5684b1ebcd0f1a13be314fc82c0bf\"\n\n\n\n\nopen MeasureTheory Filter ENNReal Set\n\nopen NNReal ENNReal\n\nvariable {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {m : MeasurableSpace \u03b1} {\u03bc : MeasureTheory.Measure \u03b1}\n\n"}
{"name": "mul_right267", "split": "test", "formal_statement": "theorem mul_right (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :\n    SemiconjBy a (x * x') (y * y') := by", "header": "\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Init.Logic\nimport Mathlib.Tactic.Cases\n\n#align_import algebra.group.semiconj from \"leanprover-community/mathlib\"@\"a148d797a1094ab554ad4183a4ad6f130358ef64\"\n\n\n\nassert_not_exists MonoidWithZero\nassert_not_exists DenselyOrdered\n\nvariable {S M G : Type*}\n\n\n@[to_additive \"`x` is additive semiconjugate to `y` by `a` if `a + x = y + a`\"]\ndef SemiconjBy [Mul M] (a x y : M) : Prop :=\n  a * x = y * a\n#align semiconj_by SemiconjBy\n#align add_semiconj_by AddSemiconjBy\n\nnamespace SemiconjBy\n\n\n@[to_additive \"Equality behind `AddSemiconjBy a x y`; useful for rewriting.\"]\nprotected theorem eq [Mul S] {a x y : S} (h : SemiconjBy a x y) : a * x = y * a :=\n  h\n#align semiconj_by.eq SemiconjBy.eq\n#align add_semiconj_by.eq AddSemiconjBy.eq\n\nsection Semigroup\n\nvariable [Semigroup S] {a b x y z x' y' : S}\n\n\n@[to_additive (attr := simp) \"If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x + x'` to `y + y'`.\"]\n"}
{"name": "innerContent_exists_compact268", "split": "test", "formal_statement": "theorem innerContent_exists_compact {U : Opens G} (hU : \u03bc.innerContent U \u2260 \u221e) {\u03b5 : \u211d\u22650}\n    (h\u03b5 : \u03b5 \u2260 0) : \u2203 K : Compacts G, (K : Set G) \u2286 U \u2227 \u03bc.innerContent U \u2264 \u03bc K + \u03b5 := by", "header": "\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport Mathlib.MeasureTheory.Measure.Regular\nimport Mathlib.Topology.Sets.Compacts\n\n#align_import measure_theory.measure.content from \"leanprover-community/mathlib\"@\"d39590fc8728fbf6743249802486f8c91ffe07bc\"\n\n\n\n\nuniverse u v w\n\nnoncomputable section\n\nopen Set TopologicalSpace\n\nopen NNReal ENNReal MeasureTheory\n\nnamespace MeasureTheory\n\nvariable {G : Type w} [TopologicalSpace G]\n\n\nstructure Content (G : Type w) [TopologicalSpace G] where\n  toFun : Compacts G \u2192 \u211d\u22650\n  mono' : \u2200 K\u2081 K\u2082 : Compacts G, (K\u2081 : Set G) \u2286 K\u2082 \u2192 toFun K\u2081 \u2264 toFun K\u2082\n  sup_disjoint' :\n    \u2200 K\u2081 K\u2082 : Compacts G, Disjoint (K\u2081 : Set G) K\u2082 \u2192 IsClosed (K\u2081 : Set G) \u2192 IsClosed (K\u2082 : Set G)\n      \u2192 toFun (K\u2081 \u2294 K\u2082) = toFun K\u2081 + toFun K\u2082\n  sup_le' : \u2200 K\u2081 K\u2082 : Compacts G, toFun (K\u2081 \u2294 K\u2082) \u2264 toFun K\u2081 + toFun K\u2082\n#align measure_theory.content MeasureTheory.Content\n\ninstance : Inhabited (Content G) :=\n  \u27e8{  toFun := fun _ => 0\n      mono' := by simp\n      sup_disjoint' := by simp\n      sup_le' := by simp }\u27e9\n\n\ninstance : CoeFun (Content G) fun _ => Compacts G \u2192 \u211d\u22650\u221e :=\n  \u27e8fun \u03bc s => \u03bc.toFun s\u27e9\n\nnamespace Content\n\nvariable (\u03bc : Content G)\n\ntheorem apply_eq_coe_toFun (K : Compacts G) : \u03bc K = \u03bc.toFun K :=\n  rfl\n#align measure_theory.content.apply_eq_coe_to_fun MeasureTheory.Content.apply_eq_coe_toFun\n\ntheorem mono (K\u2081 K\u2082 : Compacts G) (h : (K\u2081 : Set G) \u2286 K\u2082) : \u03bc K\u2081 \u2264 \u03bc K\u2082 := by\n  simp [apply_eq_coe_toFun, \u03bc.mono' _ _ h]\n#align measure_theory.content.mono MeasureTheory.Content.mono\n\ntheorem sup_disjoint (K\u2081 K\u2082 : Compacts G) (h : Disjoint (K\u2081 : Set G) K\u2082)\n    (h\u2081 : IsClosed (K\u2081 : Set G)) (h\u2082 : IsClosed (K\u2082 : Set G)) :\n    \u03bc (K\u2081 \u2294 K\u2082) = \u03bc K\u2081 + \u03bc K\u2082 := by\n  simp [apply_eq_coe_toFun, \u03bc.sup_disjoint' _ _ h]\n#align measure_theory.content.sup_disjoint MeasureTheory.Content.sup_disjoint\n\ntheorem sup_le (K\u2081 K\u2082 : Compacts G) : \u03bc (K\u2081 \u2294 K\u2082) \u2264 \u03bc K\u2081 + \u03bc K\u2082 := by\n  simp only [apply_eq_coe_toFun]\n  norm_cast\n  exact \u03bc.sup_le' _ _\n#align measure_theory.content.sup_le MeasureTheory.Content.sup_le\n\ntheorem lt_top (K : Compacts G) : \u03bc K < \u221e :=\n  ENNReal.coe_lt_top\n#align measure_theory.content.lt_top MeasureTheory.Content.lt_top\n\ntheorem empty : \u03bc \u22a5 = 0 := by\n  have := \u03bc.sup_disjoint' \u22a5 \u22a5\n  simpa [apply_eq_coe_toFun] using this\n#align measure_theory.content.empty MeasureTheory.Content.empty\n\n\ndef innerContent (U : Opens G) : \u211d\u22650\u221e :=\n  \u2a06 (K : Compacts G) (_ : (K : Set G) \u2286 U), \u03bc K\n#align measure_theory.content.inner_content MeasureTheory.Content.innerContent\n\ntheorem le_innerContent (K : Compacts G) (U : Opens G) (h2 : (K : Set G) \u2286 U) :\n    \u03bc K \u2264 \u03bc.innerContent U :=\n  le_iSup_of_le K <| le_iSup (fun _ \u21a6 (\u03bc.toFun K : \u211d\u22650\u221e)) h2\n#align measure_theory.content.le_inner_content MeasureTheory.Content.le_innerContent\n\ntheorem innerContent_le (U : Opens G) (K : Compacts G) (h2 : (U : Set G) \u2286 K) :\n    \u03bc.innerContent U \u2264 \u03bc K :=\n  iSup\u2082_le fun _ hK' => \u03bc.mono _ _ (Subset.trans hK' h2)\n#align measure_theory.content.inner_content_le MeasureTheory.Content.innerContent_le\n\ntheorem innerContent_of_isCompact {K : Set G} (h1K : IsCompact K) (h2K : IsOpen K) :\n    \u03bc.innerContent \u27e8K, h2K\u27e9 = \u03bc \u27e8K, h1K\u27e9 :=\n  le_antisymm (iSup\u2082_le fun _ hK' => \u03bc.mono _ \u27e8K, h1K\u27e9 hK') (\u03bc.le_innerContent _ _ Subset.rfl)\n#align measure_theory.content.inner_content_of_is_compact MeasureTheory.Content.innerContent_of_isCompact\n\ntheorem innerContent_bot : \u03bc.innerContent \u22a5 = 0 := by\n  refine le_antisymm ?_ (zero_le _)\n  rw [\u2190 \u03bc.empty]\n  refine iSup\u2082_le fun K hK => ?_\n  have : K = \u22a5 := by\n    ext1\n    rw [subset_empty_iff.mp hK, Compacts.coe_bot]\n  rw [this]\n#align measure_theory.content.inner_content_bot MeasureTheory.Content.innerContent_bot\n\n\ntheorem innerContent_mono \u2983U V : Set G\u2984 (hU : IsOpen U) (hV : IsOpen V) (h2 : U \u2286 V) :\n    \u03bc.innerContent \u27e8U, hU\u27e9 \u2264 \u03bc.innerContent \u27e8V, hV\u27e9 :=\n  biSup_mono fun _ hK => hK.trans h2\n#align measure_theory.content.inner_content_mono MeasureTheory.Content.innerContent_mono\n\n"}
{"name": "add269", "split": "test", "formal_statement": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Basic\nimport Mathlib.Algebra.Module.Defs\nimport Mathlib.Algebra.Star.Pi\n\n#align_import algebra.star.self_adjoint from \"leanprover-community/mathlib\"@\"a6ece35404f60597c651689c1b46ead86de5ac1b\"\n\n\n\nopen Function\n\nvariable {R A : Type*}\n\n\ndef IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x\n#align is_self_adjoint IsSelfAdjoint\n\n\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x\n#align is_star_normal IsStarNormal\n\nexport IsStarNormal (star_comm_self)\n\ntheorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n#align star_comm_self' star_comm_self'\n\nnamespace IsSelfAdjoint\n\n-- named to match `Commute.all\u2093`\n\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n#align is_self_adjoint.all IsSelfAdjoint.all\n\ntheorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n#align is_self_adjoint.star_eq IsSelfAdjoint.star_eq\n\ntheorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x :=\n  Iff.rfl\n#align is_self_adjoint_iff isSelfAdjoint_iff\n\n@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n#align is_self_adjoint.star_iff IsSelfAdjoint.star_iff\n\n@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint, star_mul, star_star]\n#align is_self_adjoint.star_mul_self IsSelfAdjoint.star_mul_self\n\n@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n#align is_self_adjoint.mul_star_self IsSelfAdjoint.mul_star_self\n\n\nlemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n\n\ntheorem starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S] [StarHomClass F R S]\n    {x : R} (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x) :=\n  show star (f x) = f x from map_star f x \u25b8 congr_arg f hx\n#align is_self_adjoint.star_hom_apply IsSelfAdjoint.starHom_apply\n\n\ntheorem _root_.isSelfAdjoint_starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S]\n    [StarHomClass F R S] [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x) :=\n  (IsSelfAdjoint.all x).starHom_apply f\n\nsection AddMonoid\n\nvariable [AddMonoid R] [StarAddMonoid R]\nvariable (R)\n\n@[simp] theorem _root_.isSelfAdjoint_zero : IsSelfAdjoint (0 : R) := star_zero R\n#align is_self_adjoint_zero isSelfAdjoint_zero\n\nvariable {R}\n\n"}
{"name": "projRestricts_eq_id270", "split": "test", "formal_statement": "theorem projRestricts_eq_id : ProjRestricts C (fun i (h : J i) \u21a6 h) = id := by", "header": "\nimport Mathlib.Algebra.Category.ModuleCat.Free\nimport Mathlib.Topology.Category.Profinite.CofilteredLimit\nimport Mathlib.Topology.Category.Profinite.Product\nimport Mathlib.Topology.LocallyConstant.Algebra\nimport Mathlib.Init.Data.Bool.Lemmas\n\n\n\nuniverse u\n\nnamespace Profinite\n\nnamespace NobelingProof\n\nvariable {I : Type u} [LinearOrder I] [IsWellOrder I (\u00b7<\u00b7)] (C : Set (I \u2192 Bool))\n\nopen Profinite ContinuousMap CategoryTheory Limits Opposite Submodule\n\nsection Projections\n\n\nvariable (J K L : I \u2192 Prop) [\u2200 i, Decidable (J i)] [\u2200 i, Decidable (K i)] [\u2200 i, Decidable (L i)]\n\n\ndef Proj : (I \u2192 Bool) \u2192 (I \u2192 Bool) :=\n  fun c i \u21a6 if J i then c i else false\n\n@[simp]\ntheorem continuous_proj :\n    Continuous (Proj J : (I \u2192 Bool) \u2192 (I \u2192 Bool)) := by\n  dsimp (config := { unfoldPartialApp := true }) [Proj]\n  apply continuous_pi\n  intro i\n  split\n  \u00b7 apply continuous_apply\n  \u00b7 apply continuous_const\n\n\ndef \u03c0 : Set (I \u2192 Bool) := (Proj J) '' C\n\n\n@[simps!]\ndef ProjRestrict : C \u2192 \u03c0 C J :=\n  Set.MapsTo.restrict (Proj J) _ _ (Set.mapsTo_image _ _)\n\n@[simp]\ntheorem continuous_projRestrict : Continuous (ProjRestrict C J) :=\n  Continuous.restrict _ (continuous_proj _)\n\ntheorem proj_eq_self {x : I \u2192 Bool} (h : \u2200 i, x i \u2260 false \u2192 J i) : Proj J x = x := by\n  ext i\n  simp only [Proj, ite_eq_left_iff]\n  contrapose!\n  simpa only [ne_comm] using h i\n\ntheorem proj_prop_eq_self (hh : \u2200 i x, x \u2208 C \u2192 x i \u2260 false \u2192 J i) : \u03c0 C J = C := by\n  ext x\n  refine \u27e8fun \u27e8y, hy, h\u27e9 \u21a6 ?_, fun h \u21a6 \u27e8x, h, ?_\u27e9\u27e9\n  \u00b7 rwa [\u2190 h, proj_eq_self]; exact (hh \u00b7 y hy)\n  \u00b7 rw [proj_eq_self]; exact (hh \u00b7 x h)\n\ntheorem proj_comp_of_subset (h : \u2200 i, J i \u2192 K i) : (Proj J \u2218 Proj K) =\n    (Proj J : (I \u2192 Bool) \u2192 (I \u2192 Bool)) := by\n  ext x i; dsimp [Proj]; aesop\n\ntheorem proj_eq_of_subset (h : \u2200 i, J i \u2192 K i) : \u03c0 (\u03c0 C K) J = \u03c0 C J := by\n  ext x\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 obtain \u27e8y, \u27e8z, hz, rfl\u27e9, rfl\u27e9 := h\n    refine \u27e8z, hz, (?_ : _ = (Proj J \u2218 Proj K) z)\u27e9\n    rw [proj_comp_of_subset J K h]\n  \u00b7 obtain \u27e8y, hy, rfl\u27e9 := h\n    dsimp [\u03c0]\n    rw [\u2190 Set.image_comp]\n    refine \u27e8y, hy, ?_\u27e9\n    rw [proj_comp_of_subset J K h]\n\nvariable {J K L}\n\n\n@[simps!]\ndef ProjRestricts (h : \u2200 i, J i \u2192 K i) : \u03c0 C K \u2192 \u03c0 C J :=\n  Homeomorph.setCongr (proj_eq_of_subset C J K h) \u2218 ProjRestrict (\u03c0 C K) J\n\n@[simp]\ntheorem continuous_projRestricts (h : \u2200 i, J i \u2192 K i) : Continuous (ProjRestricts C h) :=\n  Continuous.comp (Homeomorph.continuous _) (continuous_projRestrict _ _)\n\ntheorem surjective_projRestricts (h : \u2200 i, J i \u2192 K i) : Function.Surjective (ProjRestricts C h) :=\n  (Homeomorph.surjective _).comp (Set.surjective_mapsTo_image_restrict _ _)\n\nvariable (J) in\n"}
{"name": "dickson_two271", "split": "test", "formal_statement": "theorem dickson_two : dickson k a 2 = X ^ 2 - C a * (3 - k : R[X]) := by", "header": "\nimport Mathlib.Algebra.CharP.Invertible\nimport Mathlib.Data.ZMod.Basic\nimport Mathlib.RingTheory.Localization.FractionRing\nimport Mathlib.RingTheory.Polynomial.Chebyshev\nimport Mathlib.RingTheory.Ideal.LocalRing\n\n#align_import ring_theory.polynomial.dickson from \"leanprover-community/mathlib\"@\"70fd9563a21e7b963887c9360bd29b2393e6225a\"\n\n\n\n\nnoncomputable section\n\nnamespace Polynomial\n\nopen Polynomial\n\nvariable {R S : Type*} [CommRing R] [CommRing S] (k : \u2115) (a : R)\n\n\nnoncomputable def dickson : \u2115 \u2192 R[X]\n  | 0 => 3 - k\n  | 1 => X\n  | n + 2 => X * dickson (n + 1) - C a * dickson n\n#align polynomial.dickson Polynomial.dickson\n\n@[simp]\ntheorem dickson_zero : dickson k a 0 = 3 - k :=\n  rfl\n#align polynomial.dickson_zero Polynomial.dickson_zero\n\n@[simp]\ntheorem dickson_one : dickson k a 1 = X :=\n  rfl\n#align polynomial.dickson_one Polynomial.dickson_one\n\n"}
{"name": "dotProduct_mulVec_degMatrix272", "split": "test", "formal_statement": "theorem dotProduct_mulVec_degMatrix [CommRing R] (x : V \u2192 R) :\n    x \u2b1d\u1d65 (G.degMatrix R *\u1d65 x) = \u2211 i : V, G.degree i * x i * x i := by", "header": "\nimport Mathlib.Combinatorics.SimpleGraph.AdjMatrix\nimport Mathlib.LinearAlgebra.Matrix.PosDef\n\n\n\n\nopen Finset Matrix\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (R : Type*)\nvariable [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]\n\n\ndef degMatrix [AddMonoidWithOne R] : Matrix V V R := Matrix.diagonal (G.degree \u00b7)\n\n\ndef lapMatrix [AddGroupWithOne R] : Matrix V V R := G.degMatrix R - G.adjMatrix R\n\nvariable {R}\n\ntheorem isSymm_degMatrix [AddMonoidWithOne R] : (G.degMatrix R).IsSymm :=\n  isSymm_diagonal _\n\ntheorem isSymm_lapMatrix [AddGroupWithOne R] : (G.lapMatrix R).IsSymm :=\n  (isSymm_degMatrix _).sub (isSymm_adjMatrix _)\n\ntheorem degMatrix_mulVec_apply [NonAssocSemiring R] (v : V) (vec : V \u2192 R) :\n    (G.degMatrix R *\u1d65 vec) v = G.degree v * vec v := by\n  rw [degMatrix, mulVec_diagonal]\n\ntheorem lapMatrix_mulVec_apply [NonAssocRing R] (v : V) (vec : V \u2192 R) :\n    (G.lapMatrix R *\u1d65 vec) v = G.degree v * vec v - \u2211 u \u2208 G.neighborFinset v, vec u := by\n  simp_rw [lapMatrix, sub_mulVec, Pi.sub_apply, degMatrix_mulVec_apply, adjMatrix_mulVec_apply]\n\ntheorem lapMatrix_mulVec_const_eq_zero [Ring R] : mulVec (G.lapMatrix R) (fun _ \u21a6 1) = 0 := by\n  ext1 i\n  rw [lapMatrix_mulVec_apply]\n  simp\n\n"}
{"name": "moment_zero273", "split": "test", "formal_statement": "theorem moment_zero (hp : p \u2260 0) : moment 0 p \u03bc = 0 := by", "header": "\nimport Mathlib.Probability.Variance\n\n#align_import probability.moments from \"leanprover-community/mathlib\"@\"85453a2a14be8da64caf15ca50930cf4c6e5d8de\"\n\n\n\n\nopen MeasureTheory Filter Finset Real\n\nnoncomputable section\n\nopen scoped MeasureTheory ProbabilityTheory ENNReal NNReal\n\nnamespace ProbabilityTheory\n\nvariable {\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}\n\n\ndef moment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d :=\n  \u03bc[X ^ p]\n#align probability_theory.moment ProbabilityTheory.moment\n\n\ndef centralMoment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d := by\n  have m := fun (x : \u03a9) => \u03bc[X] -- Porting note: Lean deems `\u03bc[(X - fun x => \u03bc[X]) ^ p]` ambiguous\n  exact \u03bc[(X - m) ^ p]\n#align probability_theory.central_moment ProbabilityTheory.centralMoment\n\n@[simp]\n"}
{"name": "star_\u03b9274", "split": "test", "formal_statement": "theorem star_\u03b9 (x : X) : star (\u03b9 R x) = \u03b9 R x := by", "header": "\nimport Mathlib.Algebra.Star.Basic\nimport Mathlib.Algebra.FreeAlgebra\n\n#align_import algebra.star.free from \"leanprover-community/mathlib\"@\"07c3cf2d851866ff7198219ed3fedf42e901f25c\"\n\n\n\n\nnamespace FreeAlgebra\n\nvariable {R : Type*} [CommSemiring R] {X : Type*}\n\n\ninstance : StarRing (FreeAlgebra R X) where\n  star := MulOpposite.unop \u2218 lift R (MulOpposite.op \u2218 \u03b9 R)\n  star_involutive x := by\n    unfold Star.star\n    simp only [Function.comp_apply]\n    let y := lift R (X := X) (MulOpposite.op \u2218 \u03b9 R)\n    apply induction (C := fun x \u21a6 (y (y x).unop).unop = x) _ _ _ _ x\n    \u00b7 intros\n      simp only [AlgHom.commutes, MulOpposite.algebraMap_apply, MulOpposite.unop_op]\n    \u00b7 intros\n      simp only [y, lift_\u03b9_apply, Function.comp_apply, MulOpposite.unop_op]\n    \u00b7 intros\n      simp only [*, map_mul, MulOpposite.unop_mul]\n    \u00b7 intros\n      simp only [*, map_add, MulOpposite.unop_add]\n  star_mul a b := by simp only [Function.comp_apply, map_mul, MulOpposite.unop_mul]\n  star_add a b := by simp only [Function.comp_apply, map_add, MulOpposite.unop_add]\n\n@[simp]\n"}
{"name": "RemoveNone.mem_fiber275", "split": "test", "formal_statement": "theorem RemoveNone.mem_fiber (a : Option \u03b1) (f : Perm \u03b1) :\n    f \u2208 RemoveNone.fiber a \u2194\n      \u2203 F : Perm (Option \u03b1), F \u2208 derangements (Option \u03b1) \u2227 F none = a \u2227 removeNone F = f := by", "header": "\nimport Mathlib.Dynamics.FixedPoints.Basic\nimport Mathlib.GroupTheory.Perm.Option\nimport Mathlib.Logic.Equiv.Defs\nimport Mathlib.Logic.Equiv.Option\n\n#align_import combinatorics.derangements.basic from \"leanprover-community/mathlib\"@\"9407b03373c8cd201df99d6bc5514fc2db44054f\"\n\n\n\n\nopen Equiv Function\n\n\ndef derangements (\u03b1 : Type*) : Set (Perm \u03b1) :=\n  { f : Perm \u03b1 | \u2200 x : \u03b1, f x \u2260 x }\n#align derangements derangements\n\nvariable {\u03b1 \u03b2 : Type*}\n\ntheorem mem_derangements_iff_fixedPoints_eq_empty {f : Perm \u03b1} :\n    f \u2208 derangements \u03b1 \u2194 fixedPoints f = \u2205 :=\n  Set.eq_empty_iff_forall_not_mem.symm\n#align mem_derangements_iff_fixed_points_eq_empty mem_derangements_iff_fixedPoints_eq_empty\n\n\ndef Equiv.derangementsCongr (e : \u03b1 \u2243 \u03b2) : derangements \u03b1 \u2243 derangements \u03b2 :=\n  e.permCongr.subtypeEquiv fun {f} => e.forall_congr <| by\n   intro b; simp only [ne_eq, permCongr_apply, symm_apply_apply, EmbeddingLike.apply_eq_iff_eq]\n#align equiv.derangements_congr Equiv.derangementsCongr\n\nnamespace derangements\n\n\nprotected def subtypeEquiv (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    derangements (Subtype p) \u2243 { f : Perm \u03b1 // \u2200 a, \u00acp a \u2194 a \u2208 fixedPoints f } :=\n  calc\n    derangements (Subtype p) \u2243 { f : { f : Perm \u03b1 // \u2200 a, \u00acp a \u2192 a \u2208 fixedPoints f } //\n        \u2200 a, a \u2208 fixedPoints f \u2192 \u00acp a } := by\n      refine (Perm.subtypeEquivSubtypePerm p).subtypeEquiv fun f => \u27e8fun hf a hfa ha => ?_, ?_\u27e9\n      \u00b7 refine hf \u27e8a, ha\u27e9 (Subtype.ext ?_)\n        simp_rw [mem_fixedPoints, IsFixedPt, Perm.subtypeEquivSubtypePerm,\n        Equiv.coe_fn_mk, Perm.ofSubtype_apply_of_mem _ ha] at hfa\n        assumption\n      rintro hf \u27e8a, ha\u27e9 hfa\n      refine hf _ ?_ ha\n      simp only [Perm.subtypeEquivSubtypePerm_apply_coe, mem_fixedPoints]\n      dsimp [IsFixedPt]\n      simp_rw [Perm.ofSubtype_apply_of_mem _ ha, hfa]\n    _ \u2243 { f : Perm \u03b1 // \u2203 _h : \u2200 a, \u00acp a \u2192 a \u2208 fixedPoints f, \u2200 a, a \u2208 fixedPoints f \u2192 \u00acp a } :=\n      subtypeSubtypeEquivSubtypeExists _ _\n    _ \u2243 { f : Perm \u03b1 // \u2200 a, \u00acp a \u2194 a \u2208 fixedPoints f } :=\n      subtypeEquivRight fun f => by\n        simp_rw [exists_prop, \u2190 forall_and, \u2190 iff_iff_implies_and_implies]\n#align derangements.subtype_equiv derangements.subtypeEquiv\n\nuniverse u\n\ndef atMostOneFixedPointEquivSum_derangements [DecidableEq \u03b1] (a : \u03b1) :\n    { f : Perm \u03b1 // fixedPoints f \u2286 {a} } \u2243 Sum (derangements ({a}\u1d9c : Set \u03b1)) (derangements \u03b1) :=\n  calc\n    { f : Perm \u03b1 // fixedPoints f \u2286 {a} } \u2243\n        Sum { f : { f : Perm \u03b1 // fixedPoints f \u2286 {a} } // a \u2208 fixedPoints f }\n          { f : { f : Perm \u03b1 // fixedPoints f \u2286 {a} } // a \u2209 fixedPoints f } :=\n      (Equiv.sumCompl _).symm\n    _ \u2243 Sum { f : Perm \u03b1 // fixedPoints f \u2286 {a} \u2227 a \u2208 fixedPoints f }\n          { f : Perm \u03b1 // fixedPoints f \u2286 {a} \u2227 a \u2209 fixedPoints f } := by\n      -- Porting note: `subtypeSubtypeEquivSubtypeInter` no longer works with placeholder `_`s.\n      refine Equiv.sumCongr ?_ ?_\n      \u00b7 exact subtypeSubtypeEquivSubtypeInter\n          (fun x : Perm \u03b1 => fixedPoints x \u2286 {a})\n          (a \u2208 fixedPoints \u00b7)\n      \u00b7 exact subtypeSubtypeEquivSubtypeInter\n          (fun x : Perm \u03b1 => fixedPoints x \u2286 {a})\n          (\u00aca \u2208 fixedPoints \u00b7)\n    _ \u2243 Sum { f : Perm \u03b1 // fixedPoints f = {a} } { f : Perm \u03b1 // fixedPoints f = \u2205 } := by\n      refine Equiv.sumCongr (subtypeEquivRight fun f => ?_) (subtypeEquivRight fun f => ?_)\n      \u00b7 rw [Set.eq_singleton_iff_unique_mem, and_comm]\n        rfl\n      \u00b7 rw [Set.eq_empty_iff_forall_not_mem]\n        exact \u27e8fun h x hx => h.2 (h.1 hx \u25b8 hx), fun h => \u27e8fun x hx => (h _ hx).elim, h _\u27e9\u27e9\n    _ \u2243 Sum (derangements ({a}\u1d9c : Set \u03b1)) (derangements \u03b1) := by\n      -- Porting note: was `subtypeEquiv _` but now needs the placeholder to be provided explicitly\n      refine\n        Equiv.sumCongr ((derangements.subtypeEquiv (\u00b7 \u2208 ({a}\u1d9c : Set \u03b1))).trans <|\n            subtypeEquivRight fun x => ?_).symm\n          (subtypeEquivRight fun f => mem_derangements_iff_fixedPoints_eq_empty.symm)\n      rw [eq_comm, Set.ext_iff]\n      simp_rw [Set.mem_compl_iff, Classical.not_not]\n#align derangements.at_most_one_fixed_point_equiv_sum_derangements derangements.atMostOneFixedPointEquivSum_derangements\n\nnamespace Equiv\n\nvariable [DecidableEq \u03b1]\n\n\ndef RemoveNone.fiber (a : Option \u03b1) : Set (Perm \u03b1) :=\n  { f : Perm \u03b1 | (a, f) \u2208 Equiv.Perm.decomposeOption '' derangements (Option \u03b1) }\n#align derangements.equiv.remove_none.fiber derangements.Equiv.RemoveNone.fiber\n\n"}
{"name": "derivWithin_inv276", "split": "test", "formal_statement": "theorem derivWithin_inv (x_ne_zero : x \u2260 0) (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    derivWithin (fun x => x\u207b\u00b9) s x = -(x ^ 2)\u207b\u00b9 := by", "header": "\nimport Mathlib.Analysis.Calculus.Deriv.Mul\nimport Mathlib.Analysis.Calculus.Deriv.Comp\n\n#align_import analysis.calculus.deriv.inv from \"leanprover-community/mathlib\"@\"3bce8d800a6f2b8f63fe1e588fd76a9ff4adcebe\"\n\n\n\n\nuniverse u v w\n\nopen scoped Classical\nopen Topology Filter ENNReal\n\nopen Filter Asymptotics Set\n\nopen ContinuousLinearMap (smulRight smulRight_one_eq_iff)\n\nvariable {\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]\nvariable {F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]\nvariable {E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\nvariable {f f\u2080 f\u2081 g : \ud835\udd5c \u2192 F}\nvariable {f' f\u2080' f\u2081' g' : F}\nvariable {x : \ud835\udd5c}\nvariable {s t : Set \ud835\udd5c}\nvariable {L : Filter \ud835\udd5c}\n\nsection Inverse\n\n\n\ntheorem hasStrictDerivAt_inv (hx : x \u2260 0) : HasStrictDerivAt Inv.inv (-(x ^ 2)\u207b\u00b9) x := by\n  suffices\n    (fun p : \ud835\udd5c \u00d7 \ud835\udd5c => (p.1 - p.2) * ((x * x)\u207b\u00b9 - (p.1 * p.2)\u207b\u00b9)) =o[\ud835\udcdd (x, x)] fun p =>\n      (p.1 - p.2) * 1 by\n    refine this.congr' ?_ (eventually_of_forall fun _ => mul_one _)\n    refine Eventually.mono ((isOpen_ne.prod isOpen_ne).mem_nhds \u27e8hx, hx\u27e9) ?_\n    rintro \u27e8y, z\u27e9 \u27e8hy, hz\u27e9\n    simp only [mem_setOf_eq] at hy hz\n    -- hy : y \u2260 0, hz : z \u2260 0\n    field_simp [hx, hy, hz]\n    ring\n  refine (isBigO_refl (fun p : \ud835\udd5c \u00d7 \ud835\udd5c => p.1 - p.2) _).mul_isLittleO ((isLittleO_one_iff \ud835\udd5c).2 ?_)\n  rw [\u2190 sub_self (x * x)\u207b\u00b9]\n  exact tendsto_const_nhds.sub ((continuous_mul.tendsto (x, x)).inv\u2080 <| mul_ne_zero hx hx)\n#align has_strict_deriv_at_inv hasStrictDerivAt_inv\n\ntheorem hasDerivAt_inv (x_ne_zero : x \u2260 0) : HasDerivAt (fun y => y\u207b\u00b9) (-(x ^ 2)\u207b\u00b9) x :=\n  (hasStrictDerivAt_inv x_ne_zero).hasDerivAt\n#align has_deriv_at_inv hasDerivAt_inv\n\ntheorem hasDerivWithinAt_inv (x_ne_zero : x \u2260 0) (s : Set \ud835\udd5c) :\n    HasDerivWithinAt (fun x => x\u207b\u00b9) (-(x ^ 2)\u207b\u00b9) s x :=\n  (hasDerivAt_inv x_ne_zero).hasDerivWithinAt\n#align has_deriv_within_at_inv hasDerivWithinAt_inv\n\ntheorem differentiableAt_inv : DifferentiableAt \ud835\udd5c (fun x => x\u207b\u00b9) x \u2194 x \u2260 0 :=\n  \u27e8fun H => NormedField.continuousAt_inv.1 H.continuousAt, fun H =>\n    (hasDerivAt_inv H).differentiableAt\u27e9\n#align differentiable_at_inv differentiableAt_inv\n\ntheorem differentiableWithinAt_inv (x_ne_zero : x \u2260 0) :\n    DifferentiableWithinAt \ud835\udd5c (fun x => x\u207b\u00b9) s x :=\n  (differentiableAt_inv.2 x_ne_zero).differentiableWithinAt\n#align differentiable_within_at_inv differentiableWithinAt_inv\n\ntheorem differentiableOn_inv : DifferentiableOn \ud835\udd5c (fun x : \ud835\udd5c => x\u207b\u00b9) { x | x \u2260 0 } := fun _x hx =>\n  differentiableWithinAt_inv hx\n#align differentiable_on_inv differentiableOn_inv\n\ntheorem deriv_inv : deriv (fun x => x\u207b\u00b9) x = -(x ^ 2)\u207b\u00b9 := by\n  rcases eq_or_ne x 0 with (rfl | hne)\n  \u00b7 simp [deriv_zero_of_not_differentiableAt (mt differentiableAt_inv.1 (not_not.2 rfl))]\n  \u00b7 exact (hasDerivAt_inv hne).deriv\n#align deriv_inv deriv_inv\n\n@[simp]\ntheorem deriv_inv' : (deriv fun x : \ud835\udd5c => x\u207b\u00b9) = fun x => -(x ^ 2)\u207b\u00b9 :=\n  funext fun _ => deriv_inv\n#align deriv_inv' deriv_inv'\n\n"}
{"name": "unit_leftAdjointUniq_hom277", "split": "test", "formal_statement": "theorem unit_leftAdjointUniq_hom {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G) :\n    adj1.unit \u226b whiskerRight (leftAdjointUniq adj1 adj2).hom G = adj2.unit := by", "header": "\nimport Mathlib.CategoryTheory.Adjunction.Basic\n\n\nopen CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D]\n\nnamespace CategoryTheory.Adjunction\n\n\n@[simps]\ndef natTransEquiv {F F' : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G') :\n    (G \u27f6 G') \u2243 (F' \u27f6 F) where\n  toFun f := {\n    app := fun X \u21a6 F'.map ((adj1.unit \u226b whiskerLeft F f).app X) \u226b adj2.counit.app _\n    naturality := by\n      intro X Y g\n      simp only [\u2190 Category.assoc, \u2190 Functor.map_comp]\n      erw [(adj1.unit \u226b (whiskerLeft F f)).naturality]\n      simp\n  }\n  invFun f := {\n    app := fun X \u21a6 adj2.unit.app (G.obj X) \u226b G'.map (f.app (G.obj X) \u226b adj1.counit.app X)\n    naturality := by\n      intro X Y g\n      erw [\u2190 adj2.unit_naturality_assoc]\n      simp only [\u2190 Functor.map_comp]\n      simp\n  }\n  left_inv f := by\n    ext X\n    simp only [Functor.comp_obj, NatTrans.comp_app, Functor.id_obj, whiskerLeft_app,\n      Functor.map_comp, Category.assoc, unit_naturality_assoc, right_triangle_components_assoc]\n    erw [\u2190 f.naturality (adj1.counit.app X), \u2190 Category.assoc]\n    simp\n  right_inv f := by\n    ext\n    simp\n\n@[simp]\nlemma natTransEquiv_id {F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G) :\n    natTransEquiv adj adj (\ud835\udfd9 _) = \ud835\udfd9 _ := by ext; simp\n\n@[simp]\nlemma natTransEquiv_id_symm {F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G) :\n    (natTransEquiv adj adj).symm (\ud835\udfd9 _) = \ud835\udfd9 _ := by ext; simp\n\n@[simp]\nlemma natTransEquiv_comp {F F' F'' : C \u2964 D} {G G' G'' : D \u2964 C}\n    (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G') (adj3 : F'' \u22a3 G'') (f : G \u27f6 G') (g : G' \u27f6 G'') :\n    natTransEquiv adj2 adj3 g \u226b natTransEquiv adj1 adj2 f = natTransEquiv adj1 adj3 (f \u226b g) := by\n  apply (natTransEquiv adj1 adj3).symm.injective\n  ext X\n  simp only [natTransEquiv_symm_apply_app, Functor.comp_obj, NatTrans.comp_app,\n    natTransEquiv_apply_app, Functor.id_obj, whiskerLeft_app, Functor.map_comp, Category.assoc,\n    unit_naturality_assoc, right_triangle_components_assoc, Equiv.symm_apply_apply,\n    \u2190 g.naturality_assoc, \u2190 g.naturality]\n  simp only [\u2190 Category.assoc, unit_naturality, Functor.comp_obj, right_triangle_components,\n    Category.comp_id, \u2190 f.naturality, Category.id_comp]\n\n@[simp]\nlemma natTransEquiv_comp_symm {F F' F'' : C \u2964 D} {G G' G'' : D \u2964 C}\n    (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G') (adj3 : F'' \u22a3 G'') (f : F' \u27f6 F) (g : F'' \u27f6 F') :\n    (natTransEquiv adj1 adj2).symm f \u226b (natTransEquiv adj2 adj3).symm g =\n      (natTransEquiv adj1 adj3).symm (g \u226b f) := by\n  apply (natTransEquiv adj1 adj3).injective\n  ext\n  simp\n\n\n@[simps]\ndef natIsoEquiv {F F' : C \u2964 D} {G G' : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G') :\n    (G \u2245 G') \u2243 (F' \u2245 F) where\n  toFun i := {\n    hom := natTransEquiv adj1 adj2 i.hom\n    inv := natTransEquiv adj2 adj1 i.inv\n  }\n  invFun i := {\n    hom := (natTransEquiv adj1 adj2).symm i.hom\n    inv := (natTransEquiv adj2 adj1).symm i.inv }\n  left_inv i := by simp\n  right_inv i := by simp\n\n\ndef leftAdjointUniq {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G) : F \u2245 F' :=\n  (natIsoEquiv adj1 adj2 (Iso.refl _)).symm\n#align category_theory.adjunction.left_adjoint_uniq CategoryTheory.Adjunction.leftAdjointUniq\n\n-- Porting note (#10618): removed simp as simp can prove this\ntheorem homEquiv_leftAdjointUniq_hom_app {F F' : C \u2964 D} {G : D \u2964 C} (adj1 : F \u22a3 G) (adj2 : F' \u22a3 G)\n    (x : C) : adj1.homEquiv _ _ ((leftAdjointUniq adj1 adj2).hom.app x) = adj2.unit.app x := by\n  simp [leftAdjointUniq]\n#align category_theory.adjunction.hom_equiv_left_adjoint_uniq_hom_app CategoryTheory.Adjunction.homEquiv_leftAdjointUniq_hom_app\n\n@[reassoc (attr := simp)]\n"}
{"name": "add_eq_right_iff_le278", "split": "test", "formal_statement": "theorem add_eq_right_iff_le : a + b = b \u2194 a \u2264 b := by", "header": "\nimport Mathlib.Algebra.Ring.Pi\nimport Mathlib.Algebra.Ring.Prod\nimport Mathlib.Algebra.Ring.InjSurj\nimport Mathlib.Tactic.Monotonicity.Attr\n\n#align_import algebra.order.kleene from \"leanprover-community/mathlib\"@\"98e83c3d541c77cdb7da20d79611a780ff8e7d90\"\n\n\n\n\nopen Function\n\nuniverse u\n\nvariable {\u03b1 \u03b2 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*}\n\n\nclass IdemSemiring (\u03b1 : Type u) extends Semiring \u03b1, SemilatticeSup \u03b1 where\n  protected sup := (\u00b7 + \u00b7)\n  protected add_eq_sup : \u2200 a b : \u03b1, a + b = a \u2294 b := by\n    intros\n    rfl\n  \n  protected bot : \u03b1 := 0\n  protected bot_le : \u2200 a, bot \u2264 a\n#align idem_semiring IdemSemiring\n\n\nclass IdemCommSemiring (\u03b1 : Type u) extends CommSemiring \u03b1, IdemSemiring \u03b1\n#align idem_comm_semiring IdemCommSemiring\n\n\nclass KStar (\u03b1 : Type*) where\n  \n  protected kstar : \u03b1 \u2192 \u03b1\n#align has_kstar KStar\n\n@[inherit_doc] scoped[Computability] postfix:1024 \"\u2217\" => KStar.kstar\n\nopen Computability\n\n\nclass KleeneAlgebra (\u03b1 : Type*) extends IdemSemiring \u03b1, KStar \u03b1 where\n  protected one_le_kstar : \u2200 a : \u03b1, 1 \u2264 a\u2217\n  protected mul_kstar_le_kstar : \u2200 a : \u03b1, a * a\u2217 \u2264 a\u2217\n  protected kstar_mul_le_kstar : \u2200 a : \u03b1, a\u2217 * a \u2264 a\u2217\n  protected mul_kstar_le_self : \u2200 a b : \u03b1, b * a \u2264 b \u2192 b * a\u2217 \u2264 b\n  protected kstar_mul_le_self : \u2200 a b : \u03b1, a * b \u2264 b \u2192 a\u2217 * b \u2264 b\n#align kleene_algebra KleeneAlgebra\n\n-- See note [lower instance priority]\ninstance (priority := 100) IdemSemiring.toOrderBot [IdemSemiring \u03b1] : OrderBot \u03b1 :=\n  { \u2039IdemSemiring \u03b1\u203a with }\n#align idem_semiring.to_order_bot IdemSemiring.toOrderBot\n\n-- See note [reducible non-instances]\n\nabbrev IdemSemiring.ofSemiring [Semiring \u03b1] (h : \u2200 a : \u03b1, a + a = a) : IdemSemiring \u03b1 :=\n  { \u2039Semiring \u03b1\u203a with\n    le := fun a b \u21a6 a + b = b\n    le_refl := h\n    le_trans := fun a b c hab hbc \u21a6 by\n      simp only\n      rw [\u2190 hbc, \u2190 add_assoc, hab]\n    le_antisymm := fun a b hab hba \u21a6 by rwa [\u2190 hba, add_comm]\n    sup := (\u00b7 + \u00b7)\n    le_sup_left := fun a b \u21a6 by\n      simp only\n      rw [\u2190 add_assoc, h]\n    le_sup_right := fun a b \u21a6 by\n      simp only\n      rw [add_comm, add_assoc, h]\n    sup_le := fun a b c hab hbc \u21a6 by\n      simp only\n      rwa [add_assoc, hbc]\n    bot := 0\n    bot_le := zero_add }\n#align idem_semiring.of_semiring IdemSemiring.ofSemiring\n\nsection IdemSemiring\n\nvariable [IdemSemiring \u03b1] {a b c : \u03b1}\n\ntheorem add_eq_sup (a b : \u03b1) : a + b = a \u2294 b :=\n  IdemSemiring.add_eq_sup _ _\n#align add_eq_sup add_eq_sup\n\n-- Porting note: This simp theorem often leads to timeout when `\u03b1` has rich structure.\n--               So, this theorem should be scoped.\nscoped[Computability] attribute [simp] add_eq_sup\n\ntheorem add_idem (a : \u03b1) : a + a = a := by simp\n#align add_idem add_idem\n\ntheorem nsmul_eq_self : \u2200 {n : \u2115} (_ : n \u2260 0) (a : \u03b1), n \u2022 a = a\n  | 0, h => (h rfl).elim\n  | 1, _ => one_nsmul\n  | n + 2, _ => fun a \u21a6 by rw [succ_nsmul, nsmul_eq_self n.succ_ne_zero, add_idem]\n#align nsmul_eq_self nsmul_eq_self\n\ntheorem add_eq_left_iff_le : a + b = a \u2194 b \u2264 a := by simp\n#align add_eq_left_iff_le add_eq_left_iff_le\n\n"}
{"name": "le_max_right279", "split": "test", "formal_statement": "theorem le_max_right (a b : \u03b1) : b \u2264 max a b := by", "header": "\nimport Mathlib.Init.Order.Defs\n\n#align_import init.algebra.functions from \"leanprover-community/lean\"@\"c2bcdbcbe741ed37c361a30d38e179182b989f76\"\n\n\n\nuniverse u\n\nsection\n\nopen Decidable\n\nvariable {\u03b1 : Type u} [LinearOrder \u03b1]\n\ntheorem min_def (a b : \u03b1) : min a b = if a \u2264 b then a else b := by\n  rw [LinearOrder.min_def a]\n#align min_def min_def\n\ntheorem max_def (a b : \u03b1) : max a b = if a \u2264 b then b else a := by\n  rw [LinearOrder.max_def a]\n#align max_def max_def\n\ntheorem min_le_left (a b : \u03b1) : min a b \u2264 a := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h, le_refl]\n  else simp [min_def, if_neg h]; exact le_of_not_le h\n#align min_le_left min_le_left\n\ntheorem min_le_right (a b : \u03b1) : min a b \u2264 b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h]; exact h\n  else simp [min_def, if_neg h, le_refl]\n#align min_le_right min_le_right\n\ntheorem le_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) : c \u2264 min a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h]; exact h\u2081\n  else simp [min_def, if_neg h]; exact h\u2082\n#align le_min le_min\n\ntheorem le_max_left (a b : \u03b1) : a \u2264 max a b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [max_def, if_pos h]; exact h\n  else simp [max_def, if_neg h, le_refl]\n#align le_max_left le_max_left\n\n"}
{"name": "not_isOfFinOrder_of_injective_pow280", "split": "test", "formal_statement": "theorem not_isOfFinOrder_of_injective_pow {x : G} (h : Injective fun n : \u2115 => x ^ n) :\n    \u00acIsOfFinOrder x := by", "header": "\nimport Mathlib.Algebra.CharP.Defs\nimport Mathlib.Algebra.GroupPower.IterateHom\nimport Mathlib.Algebra.GroupWithZero.Divisibility\nimport Mathlib.Data.Int.ModEq\nimport Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.Dynamics.PeriodicPts\nimport Mathlib.GroupTheory.Index\nimport Mathlib.Order.Interval.Finset.Nat\nimport Mathlib.Order.Interval.Set.Infinite\n\n#align_import group_theory.order_of_element from \"leanprover-community/mathlib\"@\"d07245fd37786daa997af4f1a73a49fa3b748408\"\n\n\n\nopen Function Fintype Nat Pointwise Subgroup Submonoid\n\nvariable {G H A \u03b1 \u03b2 : Type*}\n\nsection Monoid\nvariable [Monoid G] {a b x y : G} {n m : \u2115}\n\nsection IsOfFinOrder\n\n-- Porting note(#12129): additional beta reduction needed\n@[to_additive]\ntheorem isPeriodicPt_mul_iff_pow_eq_one (x : G) : IsPeriodicPt (x * \u00b7) n 1 \u2194 x ^ n = 1 := by\n  rw [IsPeriodicPt, IsFixedPt, mul_left_iterate]; beta_reduce; rw [mul_one]\n#align is_periodic_pt_mul_iff_pow_eq_one isPeriodicPt_mul_iff_pow_eq_one\n#align is_periodic_pt_add_iff_nsmul_eq_zero isPeriodicPt_add_iff_nsmul_eq_zero\n\n\n@[to_additive \"`IsOfFinAddOrder` is a predicate on an element `a` of an\nadditive monoid to be of finite order, i.e. there exists `n \u2265 1` such that `n \u2022 a = 0`.\"]\ndef IsOfFinOrder (x : G) : Prop :=\n  (1 : G) \u2208 periodicPts (x * \u00b7)\n#align is_of_fin_order IsOfFinOrder\n#align is_of_fin_add_order IsOfFinAddOrder\n\ntheorem isOfFinAddOrder_ofMul_iff : IsOfFinAddOrder (Additive.ofMul x) \u2194 IsOfFinOrder x :=\n  Iff.rfl\n#align is_of_fin_add_order_of_mul_iff isOfFinAddOrder_ofMul_iff\n\ntheorem isOfFinOrder_ofAdd_iff {\u03b1 : Type*} [AddMonoid \u03b1] {x : \u03b1} :\n    IsOfFinOrder (Multiplicative.ofAdd x) \u2194 IsOfFinAddOrder x := Iff.rfl\n#align is_of_fin_order_of_add_iff isOfFinOrder_ofAdd_iff\n\n@[to_additive]\ntheorem isOfFinOrder_iff_pow_eq_one : IsOfFinOrder x \u2194 \u2203 n, 0 < n \u2227 x ^ n = 1 := by\n  simp [IsOfFinOrder, mem_periodicPts, isPeriodicPt_mul_iff_pow_eq_one]\n#align is_of_fin_order_iff_pow_eq_one isOfFinOrder_iff_pow_eq_one\n#align is_of_fin_add_order_iff_nsmul_eq_zero isOfFinAddOrder_iff_nsmul_eq_zero\n\n@[to_additive] alias \u27e8IsOfFinOrder.exists_pow_eq_one, _\u27e9 := isOfFinOrder_iff_pow_eq_one\n\n@[to_additive]\nlemma isOfFinOrder_iff_zpow_eq_one {G} [Group G] {x : G} :\n    IsOfFinOrder x \u2194 \u2203 (n : \u2124), n \u2260 0 \u2227 x ^ n = 1 := by\n  rw [isOfFinOrder_iff_pow_eq_one]\n  refine \u27e8fun \u27e8n, hn, hn'\u27e9 \u21a6 \u27e8n, Int.natCast_ne_zero_iff_pos.mpr hn, zpow_natCast x n \u25b8 hn'\u27e9,\n    fun \u27e8n, hn, hn'\u27e9 \u21a6 \u27e8n.natAbs, Int.natAbs_pos.mpr hn, ?_\u27e9\u27e9\n  cases' (Int.natAbs_eq_iff (a := n)).mp rfl with h h\n  \u00b7 rwa [h, zpow_natCast] at hn'\n  \u00b7 rwa [h, zpow_neg, inv_eq_one, zpow_natCast] at hn'\n\n\n@[to_additive \"See also `injective_nsmul_iff_not_isOfFinAddOrder`.\"]\n"}
{"name": "add_le_iff281", "split": "test", "formal_statement": "theorem add_le_iff : a + b \u2264 c \u2194 a \u2264 c \u2227 b \u2264 c := by", "header": "\nimport Mathlib.Algebra.Ring.Pi\nimport Mathlib.Algebra.Ring.Prod\nimport Mathlib.Algebra.Ring.InjSurj\nimport Mathlib.Tactic.Monotonicity.Attr\n\n#align_import algebra.order.kleene from \"leanprover-community/mathlib\"@\"98e83c3d541c77cdb7da20d79611a780ff8e7d90\"\n\n\n\n\nopen Function\n\nuniverse u\n\nvariable {\u03b1 \u03b2 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*}\n\n\nclass IdemSemiring (\u03b1 : Type u) extends Semiring \u03b1, SemilatticeSup \u03b1 where\n  protected sup := (\u00b7 + \u00b7)\n  protected add_eq_sup : \u2200 a b : \u03b1, a + b = a \u2294 b := by\n    intros\n    rfl\n  \n  protected bot : \u03b1 := 0\n  protected bot_le : \u2200 a, bot \u2264 a\n#align idem_semiring IdemSemiring\n\n\nclass IdemCommSemiring (\u03b1 : Type u) extends CommSemiring \u03b1, IdemSemiring \u03b1\n#align idem_comm_semiring IdemCommSemiring\n\n\nclass KStar (\u03b1 : Type*) where\n  \n  protected kstar : \u03b1 \u2192 \u03b1\n#align has_kstar KStar\n\n@[inherit_doc] scoped[Computability] postfix:1024 \"\u2217\" => KStar.kstar\n\nopen Computability\n\n\nclass KleeneAlgebra (\u03b1 : Type*) extends IdemSemiring \u03b1, KStar \u03b1 where\n  protected one_le_kstar : \u2200 a : \u03b1, 1 \u2264 a\u2217\n  protected mul_kstar_le_kstar : \u2200 a : \u03b1, a * a\u2217 \u2264 a\u2217\n  protected kstar_mul_le_kstar : \u2200 a : \u03b1, a\u2217 * a \u2264 a\u2217\n  protected mul_kstar_le_self : \u2200 a b : \u03b1, b * a \u2264 b \u2192 b * a\u2217 \u2264 b\n  protected kstar_mul_le_self : \u2200 a b : \u03b1, a * b \u2264 b \u2192 a\u2217 * b \u2264 b\n#align kleene_algebra KleeneAlgebra\n\n-- See note [lower instance priority]\ninstance (priority := 100) IdemSemiring.toOrderBot [IdemSemiring \u03b1] : OrderBot \u03b1 :=\n  { \u2039IdemSemiring \u03b1\u203a with }\n#align idem_semiring.to_order_bot IdemSemiring.toOrderBot\n\n-- See note [reducible non-instances]\n\nabbrev IdemSemiring.ofSemiring [Semiring \u03b1] (h : \u2200 a : \u03b1, a + a = a) : IdemSemiring \u03b1 :=\n  { \u2039Semiring \u03b1\u203a with\n    le := fun a b \u21a6 a + b = b\n    le_refl := h\n    le_trans := fun a b c hab hbc \u21a6 by\n      simp only\n      rw [\u2190 hbc, \u2190 add_assoc, hab]\n    le_antisymm := fun a b hab hba \u21a6 by rwa [\u2190 hba, add_comm]\n    sup := (\u00b7 + \u00b7)\n    le_sup_left := fun a b \u21a6 by\n      simp only\n      rw [\u2190 add_assoc, h]\n    le_sup_right := fun a b \u21a6 by\n      simp only\n      rw [add_comm, add_assoc, h]\n    sup_le := fun a b c hab hbc \u21a6 by\n      simp only\n      rwa [add_assoc, hbc]\n    bot := 0\n    bot_le := zero_add }\n#align idem_semiring.of_semiring IdemSemiring.ofSemiring\n\nsection IdemSemiring\n\nvariable [IdemSemiring \u03b1] {a b c : \u03b1}\n\ntheorem add_eq_sup (a b : \u03b1) : a + b = a \u2294 b :=\n  IdemSemiring.add_eq_sup _ _\n#align add_eq_sup add_eq_sup\n\n-- Porting note: This simp theorem often leads to timeout when `\u03b1` has rich structure.\n--               So, this theorem should be scoped.\nscoped[Computability] attribute [simp] add_eq_sup\n\ntheorem add_idem (a : \u03b1) : a + a = a := by simp\n#align add_idem add_idem\n\ntheorem nsmul_eq_self : \u2200 {n : \u2115} (_ : n \u2260 0) (a : \u03b1), n \u2022 a = a\n  | 0, h => (h rfl).elim\n  | 1, _ => one_nsmul\n  | n + 2, _ => fun a \u21a6 by rw [succ_nsmul, nsmul_eq_self n.succ_ne_zero, add_idem]\n#align nsmul_eq_self nsmul_eq_self\n\ntheorem add_eq_left_iff_le : a + b = a \u2194 b \u2264 a := by simp\n#align add_eq_left_iff_le add_eq_left_iff_le\n\ntheorem add_eq_right_iff_le : a + b = b \u2194 a \u2264 b := by simp\n#align add_eq_right_iff_le add_eq_right_iff_le\n\nalias \u27e8_, LE.le.add_eq_left\u27e9 := add_eq_left_iff_le\n#align has_le.le.add_eq_left LE.le.add_eq_left\n\nalias \u27e8_, LE.le.add_eq_right\u27e9 := add_eq_right_iff_le\n#align has_le.le.add_eq_right LE.le.add_eq_right\n\n"}
{"name": "measurable_measure_prod_mk_left_finite282", "split": "test", "formal_statement": "theorem measurable_measure_prod_mk_left_finite [IsFiniteMeasure \u03bd] {s : Set (\u03b1 \u00d7 \u03b2)}\n    (hs : MeasurableSet s) : Measurable fun x => \u03bd (Prod.mk x \u207b\u00b9' s) := by", "header": "\nimport Mathlib.MeasureTheory.Measure.GiryMonad\nimport Mathlib.Dynamics.Ergodic.MeasurePreserving\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Mathlib.MeasureTheory.Measure.OpenPos\n\n#align_import measure_theory.constructions.prod.basic from \"leanprover-community/mathlib\"@\"00abe0695d8767201e6d008afa22393978bb324d\"\n\n\n\n\nnoncomputable section\n\nopen scoped Classical\nopen Topology ENNReal MeasureTheory\n\nopen Set Function Real ENNReal\n\nopen MeasureTheory MeasurableSpace MeasureTheory.Measure\n\nopen TopologicalSpace hiding generateFrom\n\nopen Filter hiding prod_eq map\n\nvariable {\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 E : Type*}\n\n\ntheorem IsPiSystem.prod {C : Set (Set \u03b1)} {D : Set (Set \u03b2)} (hC : IsPiSystem C)\n    (hD : IsPiSystem D) : IsPiSystem (image2 (\u00b7 \u00d7\u02e2 \u00b7) C D) := by\n  rintro _ \u27e8s\u2081, hs\u2081, t\u2081, ht\u2081, rfl\u27e9 _ \u27e8s\u2082, hs\u2082, t\u2082, ht\u2082, rfl\u27e9 hst\n  rw [prod_inter_prod] at hst \u22a2; rw [prod_nonempty_iff] at hst\n  exact mem_image2_of_mem (hC _ hs\u2081 _ hs\u2082 hst.1) (hD _ ht\u2081 _ ht\u2082 hst.2)\n#align is_pi_system.prod IsPiSystem.prod\n\n\ntheorem IsCountablySpanning.prod {C : Set (Set \u03b1)} {D : Set (Set \u03b2)} (hC : IsCountablySpanning C)\n    (hD : IsCountablySpanning D) : IsCountablySpanning (image2 (\u00b7 \u00d7\u02e2 \u00b7) C D) := by\n  rcases hC, hD with \u27e8\u27e8s, h1s, h2s\u27e9, t, h1t, h2t\u27e9\n  refine \u27e8fun n => s n.unpair.1 \u00d7\u02e2 t n.unpair.2, fun n => mem_image2_of_mem (h1s _) (h1t _), ?_\u27e9\n  rw [iUnion_unpair_prod, h2s, h2t, univ_prod_univ]\n#align is_countably_spanning.prod IsCountablySpanning.prod\n\nvariable [MeasurableSpace \u03b1] [MeasurableSpace \u03b1'] [MeasurableSpace \u03b2] [MeasurableSpace \u03b2']\nvariable [MeasurableSpace \u03b3]\nvariable {\u03bc \u03bc' : Measure \u03b1} {\u03bd \u03bd' : Measure \u03b2} {\u03c4 : Measure \u03b3}\nvariable [NormedAddCommGroup E]\n\n\n\n\ntheorem generateFrom_prod_eq {\u03b1 \u03b2} {C : Set (Set \u03b1)} {D : Set (Set \u03b2)} (hC : IsCountablySpanning C)\n    (hD : IsCountablySpanning D) :\n    @Prod.instMeasurableSpace _ _ (generateFrom C) (generateFrom D) =\n      generateFrom (image2 (\u00b7 \u00d7\u02e2 \u00b7) C D) := by\n  apply le_antisymm\n  \u00b7 refine sup_le ?_ ?_ <;> rw [comap_generateFrom] <;> apply generateFrom_le <;>\n      rintro _ \u27e8s, hs, rfl\u27e9\n    \u00b7 rcases hD with \u27e8t, h1t, h2t\u27e9\n      rw [\u2190 prod_univ, \u2190 h2t, prod_iUnion]\n      apply MeasurableSet.iUnion\n      intro n\n      apply measurableSet_generateFrom\n      exact \u27e8s, hs, t n, h1t n, rfl\u27e9\n    \u00b7 rcases hC with \u27e8t, h1t, h2t\u27e9\n      rw [\u2190 univ_prod, \u2190 h2t, iUnion_prod_const]\n      apply MeasurableSet.iUnion\n      rintro n\n      apply measurableSet_generateFrom\n      exact mem_image2_of_mem (h1t n) hs\n  \u00b7 apply generateFrom_le\n    rintro _ \u27e8s, hs, t, ht, rfl\u27e9\n    dsimp only\n    rw [prod_eq]\n    apply (measurable_fst _).inter (measurable_snd _)\n    \u00b7 exact measurableSet_generateFrom hs\n    \u00b7 exact measurableSet_generateFrom ht\n#align generate_from_prod_eq generateFrom_prod_eq\n\n\ntheorem generateFrom_eq_prod {C : Set (Set \u03b1)} {D : Set (Set \u03b2)} (hC : generateFrom C = \u2039_\u203a)\n    (hD : generateFrom D = \u2039_\u203a) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) :\n    generateFrom (image2 (\u00b7 \u00d7\u02e2 \u00b7) C D) = Prod.instMeasurableSpace := by\n  rw [\u2190 hC, \u2190 hD, generateFrom_prod_eq h2C h2D]\n#align generate_from_eq_prod generateFrom_eq_prod\n\n\ntheorem generateFrom_prod :\n    generateFrom (image2 (\u00b7 \u00d7\u02e2 \u00b7) { s : Set \u03b1 | MeasurableSet s } { t : Set \u03b2 | MeasurableSet t }) =\n      Prod.instMeasurableSpace :=\n  generateFrom_eq_prod generateFrom_measurableSet generateFrom_measurableSet\n    isCountablySpanning_measurableSet isCountablySpanning_measurableSet\n#align generate_from_prod generateFrom_prod\n\n\ntheorem isPiSystem_prod :\n    IsPiSystem (image2 (\u00b7 \u00d7\u02e2 \u00b7) { s : Set \u03b1 | MeasurableSet s } { t : Set \u03b2 | MeasurableSet t }) :=\n  isPiSystem_measurableSet.prod isPiSystem_measurableSet\n#align is_pi_system_prod isPiSystem_prod\n\n\n"}
{"name": "hasProd_le_inj283", "split": "test", "formal_statement": "theorem hasProd_le_inj {g : \u03ba \u2192 \u03b1} (e : \u03b9 \u2192 \u03ba) (he : Injective e)\n    (hs : \u2200 c, c \u2209 Set.range e \u2192 1 \u2264 g c) (h : \u2200 i, f i \u2264 g (e i)) (hf : HasProd f a\u2081)\n    (hg : HasProd g a\u2082) : a\u2081 \u2264 a\u2082 := by", "header": "\nimport Mathlib.Algebra.Order.Archimedean\nimport Mathlib.Topology.Algebra.InfiniteSum.NatInt\nimport Mathlib.Topology.Algebra.Order.Field\nimport Mathlib.Topology.Order.MonotoneConvergence\n\n#align_import topology.algebra.infinite_sum.order from \"leanprover-community/mathlib\"@\"32253a1a1071173b33dc7d6a218cf722c6feb514\"\n\n\n\n\nopen Finset Filter Function\nopen scoped Classical\n\nvariable {\u03b9 \u03ba \u03b1 : Type*}\n\nsection OrderedCommMonoid\n\nvariable [OrderedCommMonoid \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] {f g : \u03b9 \u2192 \u03b1}\n  {a a\u2081 a\u2082 : \u03b1}\n\n@[to_additive]\ntheorem hasProd_le (h : \u2200 i, f i \u2264 g i) (hf : HasProd f a\u2081) (hg : HasProd g a\u2082) : a\u2081 \u2264 a\u2082 :=\n  le_of_tendsto_of_tendsto' hf hg fun _ \u21a6 prod_le_prod' fun i _ \u21a6 h i\n#align has_sum_le hasSum_le\n\n@[to_additive (attr := mono)]\ntheorem hasProd_mono (hf : HasProd f a\u2081) (hg : HasProd g a\u2082) (h : f \u2264 g) : a\u2081 \u2264 a\u2082 :=\n  hasProd_le h hf hg\n#align has_sum_mono hasSum_mono\n\n@[to_additive]\ntheorem hasProd_le_of_prod_le (hf : HasProd f a) (h : \u2200 s, \u220f i \u2208 s, f i \u2264 a\u2082) : a \u2264 a\u2082 :=\n  le_of_tendsto' hf h\n#align has_sum_le_of_sum_le hasSum_le_of_sum_le\n\n@[to_additive]\ntheorem le_hasProd_of_le_prod (hf : HasProd f a) (h : \u2200 s, a\u2082 \u2264 \u220f i \u2208 s, f i) : a\u2082 \u2264 a :=\n  ge_of_tendsto' hf h\n#align le_has_sum_of_le_sum le_hasSum_of_le_sum\n\n@[to_additive]\n"}
{"name": "smul284", "split": "test", "formal_statement": "theorem smul {r : R} (hr : IsSelfAdjoint r) {x : A} (hx : IsSelfAdjoint x) :\n    IsSelfAdjoint (r \u2022 x) := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Basic\nimport Mathlib.Algebra.Module.Defs\nimport Mathlib.Algebra.Star.Pi\n\n#align_import algebra.star.self_adjoint from \"leanprover-community/mathlib\"@\"a6ece35404f60597c651689c1b46ead86de5ac1b\"\n\n\n\nopen Function\n\nvariable {R A : Type*}\n\n\ndef IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x\n#align is_self_adjoint IsSelfAdjoint\n\n\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x\n#align is_star_normal IsStarNormal\n\nexport IsStarNormal (star_comm_self)\n\ntheorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n#align star_comm_self' star_comm_self'\n\nnamespace IsSelfAdjoint\n\n-- named to match `Commute.all\u2093`\n\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n#align is_self_adjoint.all IsSelfAdjoint.all\n\ntheorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n#align is_self_adjoint.star_eq IsSelfAdjoint.star_eq\n\ntheorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x :=\n  Iff.rfl\n#align is_self_adjoint_iff isSelfAdjoint_iff\n\n@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n#align is_self_adjoint.star_iff IsSelfAdjoint.star_iff\n\n@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint, star_mul, star_star]\n#align is_self_adjoint.star_mul_self IsSelfAdjoint.star_mul_self\n\n@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n#align is_self_adjoint.mul_star_self IsSelfAdjoint.mul_star_self\n\n\nlemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n\n\ntheorem starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S] [StarHomClass F R S]\n    {x : R} (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x) :=\n  show star (f x) = f x from map_star f x \u25b8 congr_arg f hx\n#align is_self_adjoint.star_hom_apply IsSelfAdjoint.starHom_apply\n\n\ntheorem _root_.isSelfAdjoint_starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S]\n    [StarHomClass F R S] [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x) :=\n  (IsSelfAdjoint.all x).starHom_apply f\n\nsection SMul\n\nvariable [Star R] [AddMonoid A] [StarAddMonoid A] [SMul R A] [StarModule R A]\n\n"}
{"name": "head_map285", "split": "test", "formal_statement": "theorem head_map {\u03b2 : Type*} (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) : (v.map f).head = f v.head := by", "header": "\nimport Mathlib.Algebra.BigOperators.Group.List\nimport Mathlib.Data.Vector.Defs\nimport Mathlib.Data.List.Nodup\nimport Mathlib.Data.List.OfFn\nimport Mathlib.Data.List.InsertNth\nimport Mathlib.Control.Applicative\nimport Mathlib.Control.Traversable.Basic\n\n#align_import data.vector.basic from \"leanprover-community/mathlib\"@\"f694c7dead66f5d4c80f446c796a5aad14707f0e\"\n\n\n\nset_option autoImplicit true\n\n\nuniverse u\n\nvariable {n : \u2115}\n\nnamespace Vector\n\nvariable {\u03b1 : Type*}\n\n@[inherit_doc]\ninfixr:67 \" ::\u1d65 \" => Vector.cons\n\nattribute [simp] head_cons tail_cons\n\ninstance [Inhabited \u03b1] : Inhabited (Vector \u03b1 n) :=\n  \u27e8ofFn default\u27e9\n\ntheorem toList_injective : Function.Injective (@toList \u03b1 n) :=\n  Subtype.val_injective\n#align vector.to_list_injective Vector.toList_injective\n\n\n@[ext]\ntheorem ext : \u2200 {v w : Vector \u03b1 n} (_ : \u2200 m : Fin n, Vector.get v m = Vector.get w m), v = w\n  | \u27e8v, hv\u27e9, \u27e8w, hw\u27e9, h =>\n    Subtype.eq (List.ext_get (by rw [hv, hw]) fun m hm _ => h \u27e8m, hv \u25b8 hm\u27e9)\n#align vector.ext Vector.ext\n\n\ninstance zero_subsingleton : Subsingleton (Vector \u03b1 0) :=\n  \u27e8fun _ _ => Vector.ext fun m => Fin.elim0 m\u27e9\n#align vector.zero_subsingleton Vector.zero_subsingleton\n\n@[simp]\ntheorem cons_val (a : \u03b1) : \u2200 v : Vector \u03b1 n, (a ::\u1d65 v).val = a :: v.val\n  | \u27e8_, _\u27e9 => rfl\n#align vector.cons_val Vector.cons_val\n\n#align vector.cons_head Vector.head_cons\n#align vector.cons_tail Vector.tail_cons\n\ntheorem eq_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v = a ::\u1d65 v' \u2194 v.head = a \u2227 v.tail = v' :=\n  \u27e8fun h => h.symm \u25b8 \u27e8head_cons a v', tail_cons a v'\u27e9, fun h =>\n    _root_.trans (cons_head_tail v).symm (by rw [h.1, h.2])\u27e9\n#align vector.eq_cons_iff Vector.eq_cons_iff\n\ntheorem ne_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v \u2260 a ::\u1d65 v' \u2194 v.head \u2260 a \u2228 v.tail \u2260 v' := by rw [Ne, eq_cons_iff a v v', not_and_or]\n#align vector.ne_cons_iff Vector.ne_cons_iff\n\ntheorem exists_eq_cons (v : Vector \u03b1 n.succ) : \u2203 (a : \u03b1) (as : Vector \u03b1 n), v = a ::\u1d65 as :=\n  \u27e8v.head, v.tail, (eq_cons_iff v.head v v.tail).2 \u27e8rfl, rfl\u27e9\u27e9\n#align vector.exists_eq_cons Vector.exists_eq_cons\n\n@[simp]\ntheorem toList_ofFn : \u2200 {n} (f : Fin n \u2192 \u03b1), toList (ofFn f) = List.ofFn f\n  | 0, f => by rw [ofFn, List.ofFn_zero, toList, nil]\n  | n + 1, f => by rw [ofFn, List.ofFn_succ, toList_cons, toList_ofFn]\n#align vector.to_list_of_fn Vector.toList_ofFn\n\n@[simp]\ntheorem mk_toList : \u2200 (v : Vector \u03b1 n) (h), (\u27e8toList v, h\u27e9 : Vector \u03b1 n) = v\n  | \u27e8_, _\u27e9, _ => rfl\n#align vector.mk_to_list Vector.mk_toList\n\n\n@[simp] theorem length_val (v : Vector \u03b1 n) : v.val.length = n := v.2\n\n-- Porting note: not used in mathlib and coercions done differently in Lean 4\n-- @[simp]\n-- theorem length_coe (v : Vector \u03b1 n) :\n--     ((coe : { l : List \u03b1 // l.length = n } \u2192 List \u03b1) v).length = n :=\n--   v.2\n#noalign vector.length_coe\n\n@[simp]\ntheorem toList_map {\u03b2 : Type*} (v : Vector \u03b1 n) (f : \u03b1 \u2192 \u03b2) :\n    (v.map f).toList = v.toList.map f := by cases v; rfl\n#align vector.to_list_map Vector.toList_map\n\n@[simp]\n"}
{"name": "image_cast_int_Iio286", "split": "test", "formal_statement": "theorem image_cast_int_Iio (a : \u2115) : (\u2191) '' Iio a = Ico (0 : \u2124) a := by", "header": "\nimport Mathlib.Algebra.Order.Ring.Int\nimport Mathlib.Data.Nat.Cast.Order\nimport Mathlib.Order.UpperLower.Basic\n\n\n\nopen Set\n\nnamespace Nat\n\n@[simp]\ntheorem range_cast_int : range ((\u2191) : \u2115 \u2192 \u2124) = Ici 0 :=\n  Subset.antisymm (range_subset_iff.2 Int.ofNat_nonneg) CanLift.prf\n\ntheorem image_cast_int_Icc (a b : \u2115) : (\u2191) '' Icc a b = Icc (a : \u2124) b :=\n  (castOrderEmbedding (\u03b1 := \u2124)).image_Icc (by simp [ordConnected_Ici]) a b\n\ntheorem image_cast_int_Ico (a b : \u2115) : (\u2191) '' Ico a b = Ico (a : \u2124) b :=\n  (castOrderEmbedding (\u03b1 := \u2124)).image_Ico (by simp [ordConnected_Ici]) a b\n\ntheorem image_cast_int_Ioc (a b : \u2115) : (\u2191) '' Ioc a b = Ioc (a : \u2124) b :=\n  (castOrderEmbedding (\u03b1 := \u2124)).image_Ioc (by simp [ordConnected_Ici]) a b\n\ntheorem image_cast_int_Ioo (a b : \u2115) : (\u2191) '' Ioo a b = Ioo (a : \u2124) b :=\n  (castOrderEmbedding (\u03b1 := \u2124)).image_Ioo (by simp [ordConnected_Ici]) a b\n\ntheorem image_cast_int_Iic (a : \u2115) : (\u2191) '' Iic a = Icc (0 : \u2124) a := by\n  rw [\u2190 Icc_bot, image_cast_int_Icc]; rfl\n\n"}
{"name": "hasStrictDerivAt_arctan287", "split": "test", "formal_statement": "theorem hasStrictDerivAt_arctan (x : \u211d) : HasStrictDerivAt arctan (1 / (1 + x ^ 2)) x := by", "header": "\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.Arctan\nimport Mathlib.Analysis.SpecialFunctions.Trigonometric.ComplexDeriv\n\n#align_import analysis.special_functions.trigonometric.arctan_deriv from \"leanprover-community/mathlib\"@\"f2ce6086713c78a7f880485f7917ea547a215982\"\n\n\n\n\nnoncomputable section\n\nnamespace Real\n\nopen Set Filter\n\nopen scoped Topology Real\n\ntheorem hasStrictDerivAt_tan {x : \u211d} (h : cos x \u2260 0) : HasStrictDerivAt tan (1 / cos x ^ 2) x :=\n  mod_cast (Complex.hasStrictDerivAt_tan (by exact mod_cast h)).real_of_complex\n#align real.has_strict_deriv_at_tan Real.hasStrictDerivAt_tan\n\ntheorem hasDerivAt_tan {x : \u211d} (h : cos x \u2260 0) : HasDerivAt tan (1 / cos x ^ 2) x :=\n  mod_cast (Complex.hasDerivAt_tan (by exact mod_cast h)).real_of_complex\n#align real.has_deriv_at_tan Real.hasDerivAt_tan\n\ntheorem tendsto_abs_tan_of_cos_eq_zero {x : \u211d} (hx : cos x = 0) :\n    Tendsto (fun x => abs (tan x)) (\ud835\udcdd[\u2260] x) atTop := by\n  have hx : Complex.cos x = 0 := mod_cast hx\n  simp only [\u2190 Complex.abs_ofReal, Complex.ofReal_tan]\n  refine (Complex.tendsto_abs_tan_of_cos_eq_zero hx).comp ?_\n  refine Tendsto.inf Complex.continuous_ofReal.continuousAt ?_\n  exact tendsto_principal_principal.2 fun y => mt Complex.ofReal_inj.1\n#align real.tendsto_abs_tan_of_cos_eq_zero Real.tendsto_abs_tan_of_cos_eq_zero\n\ntheorem tendsto_abs_tan_atTop (k : \u2124) :\n    Tendsto (fun x => abs (tan x)) (\ud835\udcdd[\u2260] ((2 * k + 1) * \u03c0 / 2)) atTop :=\n  tendsto_abs_tan_of_cos_eq_zero <| cos_eq_zero_iff.2 \u27e8k, rfl\u27e9\n#align real.tendsto_abs_tan_at_top Real.tendsto_abs_tan_atTop\n\ntheorem continuousAt_tan {x : \u211d} : ContinuousAt tan x \u2194 cos x \u2260 0 := by\n  refine \u27e8fun hc h\u2080 => ?_, fun h => (hasDerivAt_tan h).continuousAt\u27e9\n  exact not_tendsto_nhds_of_tendsto_atTop (tendsto_abs_tan_of_cos_eq_zero h\u2080) _\n    (hc.norm.tendsto.mono_left inf_le_left)\n#align real.continuous_at_tan Real.continuousAt_tan\n\ntheorem differentiableAt_tan {x : \u211d} : DifferentiableAt \u211d tan x \u2194 cos x \u2260 0 :=\n  \u27e8fun h => continuousAt_tan.1 h.continuousAt, fun h => (hasDerivAt_tan h).differentiableAt\u27e9\n#align real.differentiable_at_tan Real.differentiableAt_tan\n\n@[simp]\ntheorem deriv_tan (x : \u211d) : deriv tan x = 1 / cos x ^ 2 :=\n  if h : cos x = 0 then by\n    have : \u00acDifferentiableAt \u211d tan x := mt differentiableAt_tan.1 (Classical.not_not.2 h)\n    simp [deriv_zero_of_not_differentiableAt this, h, sq]\n  else (hasDerivAt_tan h).deriv\n#align real.deriv_tan Real.deriv_tan\n\n@[simp]\ntheorem contDiffAt_tan {n x} : ContDiffAt \u211d n tan x \u2194 cos x \u2260 0 :=\n  \u27e8fun h => continuousAt_tan.1 h.continuousAt, fun h =>\n    (Complex.contDiffAt_tan.2 <| mod_cast h).real_of_complex\u27e9\n#align real.cont_diff_at_tan Real.contDiffAt_tan\n\ntheorem hasDerivAt_tan_of_mem_Ioo {x : \u211d} (h : x \u2208 Ioo (-(\u03c0 / 2) : \u211d) (\u03c0 / 2)) :\n    HasDerivAt tan (1 / cos x ^ 2) x :=\n  hasDerivAt_tan (cos_pos_of_mem_Ioo h).ne'\n#align real.has_deriv_at_tan_of_mem_Ioo Real.hasDerivAt_tan_of_mem_Ioo\n\ntheorem differentiableAt_tan_of_mem_Ioo {x : \u211d} (h : x \u2208 Ioo (-(\u03c0 / 2) : \u211d) (\u03c0 / 2)) :\n    DifferentiableAt \u211d tan x :=\n  (hasDerivAt_tan_of_mem_Ioo h).differentiableAt\n#align real.differentiable_at_tan_of_mem_Ioo Real.differentiableAt_tan_of_mem_Ioo\n\n"}
{"name": "card_Iio288", "split": "test", "formal_statement": "theorem card_Iio : (Iio b).card = (\u220f i, (Iic (b i)).card) - 1 := by", "header": "\nimport Mathlib.Order.Interval.Finset.Basic\nimport Mathlib.Data.Fintype.BigOperators\n\n#align_import data.pi.interval from \"leanprover-community/mathlib\"@\"1d29de43a5ba4662dd33b5cfeecfc2a27a5a8a29\"\n\n\n\n\nopen Finset Fintype\n\nvariable {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [Fintype \u03b9] [DecidableEq \u03b9] [\u2200 i, DecidableEq (\u03b1 i)]\n\nnamespace Pi\nsection PartialOrder\nvariable [\u2200 i, PartialOrder (\u03b1 i)]\n\nsection LocallyFiniteOrderBot\nvariable [\u2200 i, LocallyFiniteOrderBot (\u03b1 i)] (b : \u2200 i, \u03b1 i)\n\ninstance instLocallyFiniteOrderBot : LocallyFiniteOrderBot (\u2200 i, \u03b1 i) :=\n  .ofIic _ (fun b => piFinset fun i => Iic (b i)) fun b x => by\n    simp_rw [mem_piFinset, mem_Iic, le_def]\n\ntheorem card_Iic : (Iic b).card = \u220f i, (Iic (b i)).card :=\n  card_piFinset _\n#align pi.card_Iic Pi.card_Iic\n\n"}
{"name": "bind\u2081_X_left289", "split": "test", "formal_statement": "theorem bind\u2081_X_left : bind\u2081 (X : \u03c3 \u2192 MvPolynomial \u03c3 R) = AlgHom.id R _ := by", "header": "\nimport Mathlib.Algebra.MvPolynomial.Rename\nimport Mathlib.Algebra.MvPolynomial.Variables\n\n#align_import data.mv_polynomial.monad from \"leanprover-community/mathlib\"@\"2f5b500a507264de86d666a5f87ddb976e2d8de4\"\n\n\n\n\nnoncomputable section\n\nnamespace MvPolynomial\n\nopen Finsupp\n\nvariable {\u03c3 : Type*} {\u03c4 : Type*}\nvariable {R S T : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring T]\n\n\ndef bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R :=\n  aeval f\n#align mv_polynomial.bind\u2081 MvPolynomial.bind\u2081\n\n\ndef bind\u2082 (f : R \u2192+* MvPolynomial \u03c3 S) : MvPolynomial \u03c3 R \u2192+* MvPolynomial \u03c3 S :=\n  eval\u2082Hom f X\n#align mv_polynomial.bind\u2082 MvPolynomial.bind\u2082\n\n\ndef join\u2081 : MvPolynomial (MvPolynomial \u03c3 R) R \u2192\u2090[R] MvPolynomial \u03c3 R :=\n  aeval id\n#align mv_polynomial.join\u2081 MvPolynomial.join\u2081\n\n\ndef join\u2082 : MvPolynomial \u03c3 (MvPolynomial \u03c3 R) \u2192+* MvPolynomial \u03c3 R :=\n  eval\u2082Hom (RingHom.id _) X\n#align mv_polynomial.join\u2082 MvPolynomial.join\u2082\n\n@[simp]\ntheorem aeval_eq_bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : aeval f = bind\u2081 f :=\n  rfl\n#align mv_polynomial.aeval_eq_bind\u2081 MvPolynomial.aeval_eq_bind\u2081\n\n@[simp]\ntheorem eval\u2082Hom_C_eq_bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : eval\u2082Hom C f = bind\u2081 f :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.eval\u2082_hom_C_eq_bind\u2081 MvPolynomial.eval\u2082Hom_C_eq_bind\u2081\n\n@[simp]\ntheorem eval\u2082Hom_eq_bind\u2082 (f : R \u2192+* MvPolynomial \u03c3 S) : eval\u2082Hom f X = bind\u2082 f :=\n  rfl\n#align mv_polynomial.eval\u2082_hom_eq_bind\u2082 MvPolynomial.eval\u2082Hom_eq_bind\u2082\n\nsection\n\nvariable (\u03c3 R)\n\n@[simp]\ntheorem aeval_id_eq_join\u2081 : aeval id = @join\u2081 \u03c3 R _ :=\n  rfl\n#align mv_polynomial.aeval_id_eq_join\u2081 MvPolynomial.aeval_id_eq_join\u2081\n\ntheorem eval\u2082Hom_C_id_eq_join\u2081 (\u03c6 : MvPolynomial (MvPolynomial \u03c3 R) R) :\n    eval\u2082Hom C id \u03c6 = join\u2081 \u03c6 :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.eval\u2082_hom_C_id_eq_join\u2081 MvPolynomial.eval\u2082Hom_C_id_eq_join\u2081\n\n@[simp]\ntheorem eval\u2082Hom_id_X_eq_join\u2082 : eval\u2082Hom (RingHom.id _) X = @join\u2082 \u03c3 R _ :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.eval\u2082_hom_id_X_eq_join\u2082 MvPolynomial.eval\u2082Hom_id_X_eq_join\u2082\n\nend\n\n-- In this file, we don't want to use these simp lemmas,\n-- because we first need to show how these new definitions interact\n-- and the proofs fall back on unfolding the definitions and call simp afterwards\nattribute [-simp]\n  aeval_eq_bind\u2081 eval\u2082Hom_C_eq_bind\u2081 eval\u2082Hom_eq_bind\u2082 aeval_id_eq_join\u2081 eval\u2082Hom_id_X_eq_join\u2082\n\n@[simp]\ntheorem bind\u2081_X_right (f : \u03c3 \u2192 MvPolynomial \u03c4 R) (i : \u03c3) : bind\u2081 f (X i) = f i :=\n  aeval_X f i\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2081_X_right MvPolynomial.bind\u2081_X_right\n\n@[simp]\ntheorem bind\u2082_X_right (f : R \u2192+* MvPolynomial \u03c3 S) (i : \u03c3) : bind\u2082 f (X i) = X i :=\n  eval\u2082Hom_X' f X i\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2082_X_right MvPolynomial.bind\u2082_X_right\n\n@[simp]\n"}
{"name": "degree_eq_sum_if_adj290", "split": "test", "formal_statement": "theorem degree_eq_sum_if_adj [AddCommMonoidWithOne R] (i : V) :\n    (G.degree i : R) = \u2211 j : V, if G.Adj i j then 1 else 0 := by", "header": "\nimport Mathlib.Combinatorics.SimpleGraph.AdjMatrix\nimport Mathlib.LinearAlgebra.Matrix.PosDef\n\n\n\n\nopen Finset Matrix\n\nnamespace SimpleGraph\n\nvariable {V : Type*} (R : Type*)\nvariable [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj]\n\n\ndef degMatrix [AddMonoidWithOne R] : Matrix V V R := Matrix.diagonal (G.degree \u00b7)\n\n\ndef lapMatrix [AddGroupWithOne R] : Matrix V V R := G.degMatrix R - G.adjMatrix R\n\nvariable {R}\n\ntheorem isSymm_degMatrix [AddMonoidWithOne R] : (G.degMatrix R).IsSymm :=\n  isSymm_diagonal _\n\ntheorem isSymm_lapMatrix [AddGroupWithOne R] : (G.lapMatrix R).IsSymm :=\n  (isSymm_degMatrix _).sub (isSymm_adjMatrix _)\n\ntheorem degMatrix_mulVec_apply [NonAssocSemiring R] (v : V) (vec : V \u2192 R) :\n    (G.degMatrix R *\u1d65 vec) v = G.degree v * vec v := by\n  rw [degMatrix, mulVec_diagonal]\n\ntheorem lapMatrix_mulVec_apply [NonAssocRing R] (v : V) (vec : V \u2192 R) :\n    (G.lapMatrix R *\u1d65 vec) v = G.degree v * vec v - \u2211 u \u2208 G.neighborFinset v, vec u := by\n  simp_rw [lapMatrix, sub_mulVec, Pi.sub_apply, degMatrix_mulVec_apply, adjMatrix_mulVec_apply]\n\ntheorem lapMatrix_mulVec_const_eq_zero [Ring R] : mulVec (G.lapMatrix R) (fun _ \u21a6 1) = 0 := by\n  ext1 i\n  rw [lapMatrix_mulVec_apply]\n  simp\n\ntheorem dotProduct_mulVec_degMatrix [CommRing R] (x : V \u2192 R) :\n    x \u2b1d\u1d65 (G.degMatrix R *\u1d65 x) = \u2211 i : V, G.degree i * x i * x i := by\n  simp only [dotProduct, degMatrix, mulVec_diagonal, \u2190 mul_assoc, mul_comm]\n\nvariable (R)\n\n"}
{"name": "nhds_eq_order291", "split": "test", "formal_statement": "theorem nhds_eq_order (a : \u03b1) : \ud835\udcdd a = (\u2a05 b \u2208 Iio a, \ud835\udcdf (Ioi b)) \u2293 \u2a05 b \u2208 Ioi a, \ud835\udcdf (Iio b) := by", "header": "\nimport Mathlib.Order.Filter.Interval\nimport Mathlib.Order.Interval.Set.Pi\nimport Mathlib.Tactic.TFAE\nimport Mathlib.Tactic.NormNum\nimport Mathlib.Topology.Order.LeftRight\nimport Mathlib.Topology.Order.OrderClosed\n\n#align_import topology.order.basic from \"leanprover-community/mathlib\"@\"3efd324a3a31eaa40c9d5bfc669c4fafee5f9423\"\n\n\n\n\nopen Set Filter TopologicalSpace Topology Function\n\nopen OrderDual (toDual ofDual)\n\nuniverse u v w\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}\n\n-- Porting note (#11215): TODO: define `Preorder.topology` before `OrderTopology` and reuse the def\n\nclass OrderTopology (\u03b1 : Type*) [t : TopologicalSpace \u03b1] [Preorder \u03b1] : Prop where\n  \n  topology_eq_generate_intervals : t = generateFrom { s | \u2203 a, s = Ioi a \u2228 s = Iio a }\n#align order_topology OrderTopology\n\n\ndef Preorder.topology (\u03b1 : Type*) [Preorder \u03b1] : TopologicalSpace \u03b1 :=\n  generateFrom { s : Set \u03b1 | \u2203 a : \u03b1, s = { b : \u03b1 | a < b } \u2228 s = { b : \u03b1 | b < a } }\n#align preorder.topology Preorder.topology\n\nsection OrderTopology\n\nsection Preorder\n\nvariable [TopologicalSpace \u03b1] [Preorder \u03b1] [t : OrderTopology \u03b1]\n\ninstance : OrderTopology \u03b1\u1d52\u1d48 :=\n  \u27e8by\n    convert OrderTopology.topology_eq_generate_intervals (\u03b1 := \u03b1) using 6\n    apply or_comm\u27e9\n\ntheorem isOpen_iff_generate_intervals {s : Set \u03b1} :\n    IsOpen s \u2194 GenerateOpen { s | \u2203 a, s = Ioi a \u2228 s = Iio a } s := by\n  rw [t.topology_eq_generate_intervals]; rfl\n#align is_open_iff_generate_intervals isOpen_iff_generate_intervals\n\ntheorem isOpen_lt' (a : \u03b1) : IsOpen { b : \u03b1 | a < b } :=\n  isOpen_iff_generate_intervals.2 <| .basic _ \u27e8a, .inl rfl\u27e9\n#align is_open_lt' isOpen_lt'\n\ntheorem isOpen_gt' (a : \u03b1) : IsOpen { b : \u03b1 | b < a } :=\n  isOpen_iff_generate_intervals.2 <| .basic _ \u27e8a, .inr rfl\u27e9\n#align is_open_gt' isOpen_gt'\n\ntheorem lt_mem_nhds {a b : \u03b1} (h : a < b) : \u2200\u1da0 x in \ud835\udcdd b, a < x :=\n  (isOpen_lt' _).mem_nhds h\n#align lt_mem_nhds lt_mem_nhds\n\ntheorem le_mem_nhds {a b : \u03b1} (h : a < b) : \u2200\u1da0 x in \ud835\udcdd b, a \u2264 x :=\n  (lt_mem_nhds h).mono fun _ => le_of_lt\n#align le_mem_nhds le_mem_nhds\n\ntheorem gt_mem_nhds {a b : \u03b1} (h : a < b) : \u2200\u1da0 x in \ud835\udcdd a, x < b :=\n  (isOpen_gt' _).mem_nhds h\n#align gt_mem_nhds gt_mem_nhds\n\ntheorem ge_mem_nhds {a b : \u03b1} (h : a < b) : \u2200\u1da0 x in \ud835\udcdd a, x \u2264 b :=\n  (gt_mem_nhds h).mono fun _ => le_of_lt\n#align ge_mem_nhds ge_mem_nhds\n\n"}
{"name": "LinearMap.toMatrix_transpose292", "split": "test", "formal_statement": "theorem LinearMap.toMatrix_transpose (u : V\u2081 \u2192\u2097[K] V\u2082) :\n    LinearMap.toMatrix B\u2082.dualBasis B\u2081.dualBasis (Module.Dual.transpose (R := K) u) =\n      (LinearMap.toMatrix B\u2081 B\u2082 u)\u1d40 := by", "header": "\nimport Mathlib.LinearAlgebra.Dual\nimport Mathlib.LinearAlgebra.Matrix.ToLin\n\n#align_import linear_algebra.matrix.dual from \"leanprover-community/mathlib\"@\"738c19f572805cff525a93aa4ffbdf232df05aa8\"\n\n\n\n\nopen Matrix\n\nsection Transpose\n\nvariable {K V\u2081 V\u2082 \u03b9\u2081 \u03b9\u2082 : Type*} [Field K] [AddCommGroup V\u2081] [Module K V\u2081] [AddCommGroup V\u2082]\n  [Module K V\u2082] [Fintype \u03b9\u2081] [Fintype \u03b9\u2082] [DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082] {B\u2081 : Basis \u03b9\u2081 K V\u2081}\n  {B\u2082 : Basis \u03b9\u2082 K V\u2082}\n\n@[simp]\n"}
{"name": "N_one293", "split": "test", "formal_statement": "theorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter := by", "header": "\nimport Mathlib.Order.Filter.Bases\nimport Mathlib.Topology.Algebra.Module.Basic\n\n#align_import topology.algebra.filter_basis from \"leanprover-community/mathlib\"@\"f2ce6086713c78a7f880485f7917ea547a215982\"\n\n\n\n\nopen Filter Set TopologicalSpace Function\n\nopen Topology Filter Pointwise\n\nuniverse u\n\n\nclass GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : \u2200 {U}, U \u2208 sets \u2192 (1 : G) \u2208 U\n  mul' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V * V \u2286 U\n  inv' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u207b\u00b9) \u207b\u00b9' U\n  conj' : \u2200 x\u2080, \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u2080 * x * x\u2080\u207b\u00b9) \u207b\u00b9' U\n#align group_filter_basis GroupFilterBasis\n\n\nclass AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : \u2200 {U}, U \u2208 sets \u2192 (0 : A) \u2208 U\n  add' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V + V \u2286 U\n  neg' : \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 -x) \u207b\u00b9' U\n  conj' : \u2200 x\u2080, \u2200 {U}, U \u2208 sets \u2192 \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u2080 + x + -x\u2080) \u207b\u00b9' U\n#align add_group_filter_basis AddGroupFilterBasis\n\nattribute [to_additive existing] GroupFilterBasis GroupFilterBasis.conj'\n  GroupFilterBasis.toFilterBasis\n\n\n@[to_additive \"`AddGroupFilterBasis` constructor in the additive commutative group case.\"]\ndef groupFilterBasisOfComm {G : Type*} [CommGroup G] (sets : Set (Set G))\n    (nonempty : sets.Nonempty) (inter_sets : \u2200 x y, x \u2208 sets \u2192 y \u2208 sets \u2192 \u2203 z \u2208 sets, z \u2286 x \u2229 y)\n    (one : \u2200 U \u2208 sets, (1 : G) \u2208 U) (mul : \u2200 U \u2208 sets, \u2203 V \u2208 sets, V * V \u2286 U)\n    (inv : \u2200 U \u2208 sets, \u2203 V \u2208 sets, V \u2286 (fun x \u21a6 x\u207b\u00b9) \u207b\u00b9' U) : GroupFilterBasis G :=\n  { sets := sets\n    nonempty := nonempty\n    inter_sets := inter_sets _ _\n    one' := one _\n    mul' := mul _\n    inv' := inv _\n    conj' := fun x U U_in \u21a6 \u27e8U, U_in, by simp only [mul_inv_cancel_comm, preimage_id']; rfl\u27e9 }\n#align group_filter_basis_of_comm groupFilterBasisOfComm\n#align add_group_filter_basis_of_comm addGroupFilterBasisOfComm\n\nnamespace GroupFilterBasis\n\nvariable {G : Type u} [Group G] {B : GroupFilterBasis G}\n\n@[to_additive]\ninstance : Membership (Set G) (GroupFilterBasis G) :=\n  \u27e8fun s f \u21a6 s \u2208 f.sets\u27e9\n\n@[to_additive]\ntheorem one {U : Set G} : U \u2208 B \u2192 (1 : G) \u2208 U :=\n  GroupFilterBasis.one'\n#align group_filter_basis.one GroupFilterBasis.one\n#align add_group_filter_basis.zero AddGroupFilterBasis.zero\n\n@[to_additive]\ntheorem mul {U : Set G} : U \u2208 B \u2192 \u2203 V \u2208 B, V * V \u2286 U :=\n  GroupFilterBasis.mul'\n#align group_filter_basis.mul GroupFilterBasis.mul\n#align add_group_filter_basis.add AddGroupFilterBasis.add\n\n@[to_additive]\ntheorem inv {U : Set G} : U \u2208 B \u2192 \u2203 V \u2208 B, V \u2286 (fun x \u21a6 x\u207b\u00b9) \u207b\u00b9' U :=\n  GroupFilterBasis.inv'\n#align group_filter_basis.inv GroupFilterBasis.inv\n#align add_group_filter_basis.neg AddGroupFilterBasis.neg\n\n@[to_additive]\ntheorem conj : \u2200 x\u2080, \u2200 {U}, U \u2208 B \u2192 \u2203 V \u2208 B, V \u2286 (fun x \u21a6 x\u2080 * x * x\u2080\u207b\u00b9) \u207b\u00b9' U :=\n  GroupFilterBasis.conj'\n#align group_filter_basis.conj GroupFilterBasis.conj\n#align add_group_filter_basis.conj AddGroupFilterBasis.conj\n\n\n@[to_additive \"The trivial additive group filter basis consists of `{0}` only. The associated\ntopology is discrete.\"]\ninstance : Inhabited (GroupFilterBasis G) where\n  default := {\n    sets := {{1}}\n    nonempty := singleton_nonempty _\n    inter_sets := by simp\n    one' := by simp\n    mul' := by simp\n    inv' := by simp\n    conj' := by simp }\n\n@[to_additive]\ntheorem subset_mul_self (B : GroupFilterBasis G) {U : Set G} (h : U \u2208 B) : U \u2286 U * U :=\n  fun x x_in \u21a6 \u27e81, one h, x, x_in, one_mul x\u27e9\n#align group_filter_basis.prod_subset_self GroupFilterBasis.subset_mul_self\n#align add_group_filter_basis.sum_subset_self AddGroupFilterBasis.subset_add_self\n\n\n@[to_additive \"The neighborhood function of an `AddGroupFilterBasis`.\"]\ndef N (B : GroupFilterBasis G) : G \u2192 Filter G :=\n  fun x \u21a6 map (fun y \u21a6 x * y) B.toFilterBasis.filter\nset_option linter.uppercaseLean3 false in\n#align group_filter_basis.N GroupFilterBasis.N\nset_option linter.uppercaseLean3 false in\n#align add_group_filter_basis.N AddGroupFilterBasis.N\n\n@[to_additive (attr := simp)]\n"}
{"name": "conjugate294", "split": "test", "formal_statement": "theorem conjugate {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (z * x * star z) := by", "header": "\nimport Mathlib.Algebra.Group.Subgroup.Basic\nimport Mathlib.Algebra.Module.Defs\nimport Mathlib.Algebra.Star.Pi\n\n#align_import algebra.star.self_adjoint from \"leanprover-community/mathlib\"@\"a6ece35404f60597c651689c1b46ead86de5ac1b\"\n\n\n\nopen Function\n\nvariable {R A : Type*}\n\n\ndef IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x\n#align is_self_adjoint IsSelfAdjoint\n\n\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x\n#align is_star_normal IsStarNormal\n\nexport IsStarNormal (star_comm_self)\n\ntheorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n#align star_comm_self' star_comm_self'\n\nnamespace IsSelfAdjoint\n\n-- named to match `Commute.all\u2093`\n\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n#align is_self_adjoint.all IsSelfAdjoint.all\n\ntheorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n#align is_self_adjoint.star_eq IsSelfAdjoint.star_eq\n\ntheorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x :=\n  Iff.rfl\n#align is_self_adjoint_iff isSelfAdjoint_iff\n\n@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n#align is_self_adjoint.star_iff IsSelfAdjoint.star_iff\n\n@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint, star_mul, star_star]\n#align is_self_adjoint.star_mul_self IsSelfAdjoint.star_mul_self\n\n@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n#align is_self_adjoint.mul_star_self IsSelfAdjoint.mul_star_self\n\n\nlemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n\n\ntheorem starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S] [StarHomClass F R S]\n    {x : R} (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x) :=\n  show star (f x) = f x from map_star f x \u25b8 congr_arg f hx\n#align is_self_adjoint.star_hom_apply IsSelfAdjoint.starHom_apply\n\n\ntheorem _root_.isSelfAdjoint_starHom_apply {F R S : Type*} [Star R] [Star S] [FunLike F R S]\n    [StarHomClass F R S] [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x) :=\n  (IsSelfAdjoint.all x).starHom_apply f\n\nsection Semigroup\n\nvariable [Semigroup R] [StarMul R]\n\n"}
{"name": "mul_left295", "split": "test", "formal_statement": "theorem mul_left (ha : SemiconjBy a y z) (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z := by", "header": "\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Init.Logic\nimport Mathlib.Tactic.Cases\n\n#align_import algebra.group.semiconj from \"leanprover-community/mathlib\"@\"a148d797a1094ab554ad4183a4ad6f130358ef64\"\n\n\n\nassert_not_exists MonoidWithZero\nassert_not_exists DenselyOrdered\n\nvariable {S M G : Type*}\n\n\n@[to_additive \"`x` is additive semiconjugate to `y` by `a` if `a + x = y + a`\"]\ndef SemiconjBy [Mul M] (a x y : M) : Prop :=\n  a * x = y * a\n#align semiconj_by SemiconjBy\n#align add_semiconj_by AddSemiconjBy\n\nnamespace SemiconjBy\n\n\n@[to_additive \"Equality behind `AddSemiconjBy a x y`; useful for rewriting.\"]\nprotected theorem eq [Mul S] {a x y : S} (h : SemiconjBy a x y) : a * x = y * a :=\n  h\n#align semiconj_by.eq SemiconjBy.eq\n#align add_semiconj_by.eq AddSemiconjBy.eq\n\nsection Semigroup\n\nvariable [Semigroup S] {a b x y z x' y' : S}\n\n\n@[to_additive (attr := simp) \"If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x + x'` to `y + y'`.\"]\ntheorem mul_right (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :\n    SemiconjBy a (x * x') (y * y') := by\n  unfold SemiconjBy\n  -- TODO this could be done using `assoc_rw` if/when this is ported to mathlib4\n  rw [\u2190 mul_assoc, h.eq, mul_assoc, h'.eq, \u2190 mul_assoc]\n#align semiconj_by.mul_right SemiconjBy.mul_right\n#align add_semiconj_by.add_right AddSemiconjBy.add_right\n\n\n@[to_additive \"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a + b`\nsemiconjugates `x` to `z`.\"]\n"}
{"name": "le_min296", "split": "test", "formal_statement": "theorem le_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) : c \u2264 min a b := by", "header": "\nimport Mathlib.Init.Order.Defs\n\n#align_import init.algebra.functions from \"leanprover-community/lean\"@\"c2bcdbcbe741ed37c361a30d38e179182b989f76\"\n\n\n\nuniverse u\n\nsection\n\nopen Decidable\n\nvariable {\u03b1 : Type u} [LinearOrder \u03b1]\n\ntheorem min_def (a b : \u03b1) : min a b = if a \u2264 b then a else b := by\n  rw [LinearOrder.min_def a]\n#align min_def min_def\n\ntheorem max_def (a b : \u03b1) : max a b = if a \u2264 b then b else a := by\n  rw [LinearOrder.max_def a]\n#align max_def max_def\n\ntheorem min_le_left (a b : \u03b1) : min a b \u2264 a := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h, le_refl]\n  else simp [min_def, if_neg h]; exact le_of_not_le h\n#align min_le_left min_le_left\n\ntheorem min_le_right (a b : \u03b1) : min a b \u2264 b := by\n  -- Porting note: no `min_tac` tactic\n  if h : a \u2264 b\n  then simp [min_def, if_pos h]; exact h\n  else simp [min_def, if_neg h, le_refl]\n#align min_le_right min_le_right\n\n"}
{"name": "centralMoment_one297", "split": "test", "formal_statement": "theorem centralMoment_one [IsProbabilityMeasure \u03bc] : centralMoment X 1 \u03bc = 0 := by", "header": "\nimport Mathlib.Probability.Variance\n\n#align_import probability.moments from \"leanprover-community/mathlib\"@\"85453a2a14be8da64caf15ca50930cf4c6e5d8de\"\n\n\n\n\nopen MeasureTheory Filter Finset Real\n\nnoncomputable section\n\nopen scoped MeasureTheory ProbabilityTheory ENNReal NNReal\n\nnamespace ProbabilityTheory\n\nvariable {\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}\n\n\ndef moment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d :=\n  \u03bc[X ^ p]\n#align probability_theory.moment ProbabilityTheory.moment\n\n\ndef centralMoment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d := by\n  have m := fun (x : \u03a9) => \u03bc[X] -- Porting note: Lean deems `\u03bc[(X - fun x => \u03bc[X]) ^ p]` ambiguous\n  exact \u03bc[(X - m) ^ p]\n#align probability_theory.central_moment ProbabilityTheory.centralMoment\n\n@[simp]\ntheorem moment_zero (hp : p \u2260 0) : moment 0 p \u03bc = 0 := by\n  simp only [moment, hp, zero_pow, Ne, not_false_iff, Pi.zero_apply, integral_const,\n    smul_eq_mul, mul_zero, integral_zero]\n#align probability_theory.moment_zero ProbabilityTheory.moment_zero\n\n@[simp]\ntheorem centralMoment_zero (hp : p \u2260 0) : centralMoment 0 p \u03bc = 0 := by\n  simp only [centralMoment, hp, Pi.zero_apply, integral_const, smul_eq_mul,\n    mul_zero, zero_sub, Pi.pow_apply, Pi.neg_apply, neg_zero, zero_pow, Ne, not_false_iff]\n#align probability_theory.central_moment_zero ProbabilityTheory.centralMoment_zero\n\ntheorem centralMoment_one' [IsFiniteMeasure \u03bc] (h_int : Integrable X \u03bc) :\n    centralMoment X 1 \u03bc = (1 - (\u03bc Set.univ).toReal) * \u03bc[X] := by\n  simp only [centralMoment, Pi.sub_apply, pow_one]\n  rw [integral_sub h_int (integrable_const _)]\n  simp only [sub_mul, integral_const, smul_eq_mul, one_mul]\n#align probability_theory.central_moment_one' ProbabilityTheory.centralMoment_one'\n\n@[simp]\n"}
{"name": "span_top298", "split": "test", "formal_statement": "theorem span_top : span K (span \u2124 (Set.range b) : Set E) = \u22a4 := by", "header": "\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport Mathlib.MeasureTheory.Group.FundamentalDomain\nimport Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar\nimport Mathlib.RingTheory.Localization.Module\n\n#align_import algebra.module.zlattice from \"leanprover-community/mathlib\"@\"a3e83f0fa4391c8740f7d773a7a9b74e311ae2a3\"\n\n\n\n\nnoncomputable section\n\nnamespace Zspan\n\nopen MeasureTheory MeasurableSet Submodule Bornology\n\nvariable {E \u03b9 : Type*}\n\nsection NormedLatticeField\n\nvariable {K : Type*} [NormedLinearOrderedField K]\nvariable [NormedAddCommGroup E] [NormedSpace K E]\nvariable (b : Basis \u03b9 K E)\n\n"}
{"name": "min_def299", "split": "test", "formal_statement": "theorem min_def (a b : \u03b1) : min a b = if a \u2264 b then a else b := by", "header": "\nimport Mathlib.Init.Order.Defs\n\n#align_import init.algebra.functions from \"leanprover-community/lean\"@\"c2bcdbcbe741ed37c361a30d38e179182b989f76\"\n\n\n\nuniverse u\n\nsection\n\nopen Decidable\n\nvariable {\u03b1 : Type u} [LinearOrder \u03b1]\n\n"}
{"name": "lineMap_one_half300", "split": "test", "formal_statement": "theorem lineMap_one_half {R : Type*} {V P : Type*} [DivisionRing R] [CharZero R] [AddCommGroup V]\n    [Module R V] [AddTorsor V P] (a b : P) : lineMap a b (1 / 2 : R) = midpoint R a b := by", "header": "\nimport Mathlib.Algebra.CharP.Invertible\nimport Mathlib.LinearAlgebra.AffineSpace.Midpoint\n\n#align_import linear_algebra.affine_space.midpoint_zero from \"leanprover-community/mathlib\"@\"78261225eb5cedc61c5c74ecb44e5b385d13b733\"\n\n\n\n\nopen AffineMap AffineEquiv\n\ntheorem lineMap_inv_two {R : Type*} {V P : Type*} [DivisionRing R] [CharZero R] [AddCommGroup V]\n    [Module R V] [AddTorsor V P] (a b : P) : lineMap a b (2\u207b\u00b9 : R) = midpoint R a b :=\n  rfl\n#align line_map_inv_two lineMap_inv_two\n\n"}
{"name": "projRestricts_comp_projRestrict301", "split": "test", "formal_statement": "theorem projRestricts_comp_projRestrict (h : \u2200 i, J i \u2192 K i) :\n    ProjRestricts C h \u2218 ProjRestrict C K = ProjRestrict C J := by", "header": "\nimport Mathlib.Algebra.Category.ModuleCat.Free\nimport Mathlib.Topology.Category.Profinite.CofilteredLimit\nimport Mathlib.Topology.Category.Profinite.Product\nimport Mathlib.Topology.LocallyConstant.Algebra\nimport Mathlib.Init.Data.Bool.Lemmas\n\n\n\nuniverse u\n\nnamespace Profinite\n\nnamespace NobelingProof\n\nvariable {I : Type u} [LinearOrder I] [IsWellOrder I (\u00b7<\u00b7)] (C : Set (I \u2192 Bool))\n\nopen Profinite ContinuousMap CategoryTheory Limits Opposite Submodule\n\nsection Projections\n\n\nvariable (J K L : I \u2192 Prop) [\u2200 i, Decidable (J i)] [\u2200 i, Decidable (K i)] [\u2200 i, Decidable (L i)]\n\n\ndef Proj : (I \u2192 Bool) \u2192 (I \u2192 Bool) :=\n  fun c i \u21a6 if J i then c i else false\n\n@[simp]\ntheorem continuous_proj :\n    Continuous (Proj J : (I \u2192 Bool) \u2192 (I \u2192 Bool)) := by\n  dsimp (config := { unfoldPartialApp := true }) [Proj]\n  apply continuous_pi\n  intro i\n  split\n  \u00b7 apply continuous_apply\n  \u00b7 apply continuous_const\n\n\ndef \u03c0 : Set (I \u2192 Bool) := (Proj J) '' C\n\n\n@[simps!]\ndef ProjRestrict : C \u2192 \u03c0 C J :=\n  Set.MapsTo.restrict (Proj J) _ _ (Set.mapsTo_image _ _)\n\n@[simp]\ntheorem continuous_projRestrict : Continuous (ProjRestrict C J) :=\n  Continuous.restrict _ (continuous_proj _)\n\ntheorem proj_eq_self {x : I \u2192 Bool} (h : \u2200 i, x i \u2260 false \u2192 J i) : Proj J x = x := by\n  ext i\n  simp only [Proj, ite_eq_left_iff]\n  contrapose!\n  simpa only [ne_comm] using h i\n\ntheorem proj_prop_eq_self (hh : \u2200 i x, x \u2208 C \u2192 x i \u2260 false \u2192 J i) : \u03c0 C J = C := by\n  ext x\n  refine \u27e8fun \u27e8y, hy, h\u27e9 \u21a6 ?_, fun h \u21a6 \u27e8x, h, ?_\u27e9\u27e9\n  \u00b7 rwa [\u2190 h, proj_eq_self]; exact (hh \u00b7 y hy)\n  \u00b7 rw [proj_eq_self]; exact (hh \u00b7 x h)\n\ntheorem proj_comp_of_subset (h : \u2200 i, J i \u2192 K i) : (Proj J \u2218 Proj K) =\n    (Proj J : (I \u2192 Bool) \u2192 (I \u2192 Bool)) := by\n  ext x i; dsimp [Proj]; aesop\n\ntheorem proj_eq_of_subset (h : \u2200 i, J i \u2192 K i) : \u03c0 (\u03c0 C K) J = \u03c0 C J := by\n  ext x\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 obtain \u27e8y, \u27e8z, hz, rfl\u27e9, rfl\u27e9 := h\n    refine \u27e8z, hz, (?_ : _ = (Proj J \u2218 Proj K) z)\u27e9\n    rw [proj_comp_of_subset J K h]\n  \u00b7 obtain \u27e8y, hy, rfl\u27e9 := h\n    dsimp [\u03c0]\n    rw [\u2190 Set.image_comp]\n    refine \u27e8y, hy, ?_\u27e9\n    rw [proj_comp_of_subset J K h]\n\nvariable {J K L}\n\n\n@[simps!]\ndef ProjRestricts (h : \u2200 i, J i \u2192 K i) : \u03c0 C K \u2192 \u03c0 C J :=\n  Homeomorph.setCongr (proj_eq_of_subset C J K h) \u2218 ProjRestrict (\u03c0 C K) J\n\n@[simp]\ntheorem continuous_projRestricts (h : \u2200 i, J i \u2192 K i) : Continuous (ProjRestricts C h) :=\n  Continuous.comp (Homeomorph.continuous _) (continuous_projRestrict _ _)\n\ntheorem surjective_projRestricts (h : \u2200 i, J i \u2192 K i) : Function.Surjective (ProjRestricts C h) :=\n  (Homeomorph.surjective _).comp (Set.surjective_mapsTo_image_restrict _ _)\n\nvariable (J) in\ntheorem projRestricts_eq_id : ProjRestricts C (fun i (h : J i) \u21a6 h) = id := by\n  ext \u27e8x, y, hy, rfl\u27e9 i\n  simp (config := { contextual := true }) only [\u03c0, Proj, ProjRestricts_coe, id_eq, if_true]\n\ntheorem projRestricts_eq_comp (hJK : \u2200 i, J i \u2192 K i) (hKL : \u2200 i, K i \u2192 L i) :\n    ProjRestricts C hJK \u2218 ProjRestricts C hKL = ProjRestricts C (fun i \u21a6 hKL i \u2218 hJK i) := by\n  ext x i\n  simp only [\u03c0, Proj, Function.comp_apply, ProjRestricts_coe]\n  aesop\n\n"}
{"name": "join\u2082_map302", "split": "test", "formal_statement": "theorem join\u2082_map (f : R \u2192+* MvPolynomial \u03c3 S) (\u03c6 : MvPolynomial \u03c3 R) :\n    join\u2082 (map f \u03c6) = bind\u2082 f \u03c6 := by", "header": "\nimport Mathlib.Algebra.MvPolynomial.Rename\nimport Mathlib.Algebra.MvPolynomial.Variables\n\n#align_import data.mv_polynomial.monad from \"leanprover-community/mathlib\"@\"2f5b500a507264de86d666a5f87ddb976e2d8de4\"\n\n\n\n\nnoncomputable section\n\nnamespace MvPolynomial\n\nopen Finsupp\n\nvariable {\u03c3 : Type*} {\u03c4 : Type*}\nvariable {R S T : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring T]\n\n\ndef bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R :=\n  aeval f\n#align mv_polynomial.bind\u2081 MvPolynomial.bind\u2081\n\n\ndef bind\u2082 (f : R \u2192+* MvPolynomial \u03c3 S) : MvPolynomial \u03c3 R \u2192+* MvPolynomial \u03c3 S :=\n  eval\u2082Hom f X\n#align mv_polynomial.bind\u2082 MvPolynomial.bind\u2082\n\n\ndef join\u2081 : MvPolynomial (MvPolynomial \u03c3 R) R \u2192\u2090[R] MvPolynomial \u03c3 R :=\n  aeval id\n#align mv_polynomial.join\u2081 MvPolynomial.join\u2081\n\n\ndef join\u2082 : MvPolynomial \u03c3 (MvPolynomial \u03c3 R) \u2192+* MvPolynomial \u03c3 R :=\n  eval\u2082Hom (RingHom.id _) X\n#align mv_polynomial.join\u2082 MvPolynomial.join\u2082\n\n@[simp]\ntheorem aeval_eq_bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : aeval f = bind\u2081 f :=\n  rfl\n#align mv_polynomial.aeval_eq_bind\u2081 MvPolynomial.aeval_eq_bind\u2081\n\n@[simp]\ntheorem eval\u2082Hom_C_eq_bind\u2081 (f : \u03c3 \u2192 MvPolynomial \u03c4 R) : eval\u2082Hom C f = bind\u2081 f :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.eval\u2082_hom_C_eq_bind\u2081 MvPolynomial.eval\u2082Hom_C_eq_bind\u2081\n\n@[simp]\ntheorem eval\u2082Hom_eq_bind\u2082 (f : R \u2192+* MvPolynomial \u03c3 S) : eval\u2082Hom f X = bind\u2082 f :=\n  rfl\n#align mv_polynomial.eval\u2082_hom_eq_bind\u2082 MvPolynomial.eval\u2082Hom_eq_bind\u2082\n\nsection\n\nvariable (\u03c3 R)\n\n@[simp]\ntheorem aeval_id_eq_join\u2081 : aeval id = @join\u2081 \u03c3 R _ :=\n  rfl\n#align mv_polynomial.aeval_id_eq_join\u2081 MvPolynomial.aeval_id_eq_join\u2081\n\ntheorem eval\u2082Hom_C_id_eq_join\u2081 (\u03c6 : MvPolynomial (MvPolynomial \u03c3 R) R) :\n    eval\u2082Hom C id \u03c6 = join\u2081 \u03c6 :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.eval\u2082_hom_C_id_eq_join\u2081 MvPolynomial.eval\u2082Hom_C_id_eq_join\u2081\n\n@[simp]\ntheorem eval\u2082Hom_id_X_eq_join\u2082 : eval\u2082Hom (RingHom.id _) X = @join\u2082 \u03c3 R _ :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.eval\u2082_hom_id_X_eq_join\u2082 MvPolynomial.eval\u2082Hom_id_X_eq_join\u2082\n\nend\n\n-- In this file, we don't want to use these simp lemmas,\n-- because we first need to show how these new definitions interact\n-- and the proofs fall back on unfolding the definitions and call simp afterwards\nattribute [-simp]\n  aeval_eq_bind\u2081 eval\u2082Hom_C_eq_bind\u2081 eval\u2082Hom_eq_bind\u2082 aeval_id_eq_join\u2081 eval\u2082Hom_id_X_eq_join\u2082\n\n@[simp]\ntheorem bind\u2081_X_right (f : \u03c3 \u2192 MvPolynomial \u03c4 R) (i : \u03c3) : bind\u2081 f (X i) = f i :=\n  aeval_X f i\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2081_X_right MvPolynomial.bind\u2081_X_right\n\n@[simp]\ntheorem bind\u2082_X_right (f : R \u2192+* MvPolynomial \u03c3 S) (i : \u03c3) : bind\u2082 f (X i) = X i :=\n  eval\u2082Hom_X' f X i\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2082_X_right MvPolynomial.bind\u2082_X_right\n\n@[simp]\ntheorem bind\u2081_X_left : bind\u2081 (X : \u03c3 \u2192 MvPolynomial \u03c3 R) = AlgHom.id R _ := by\n  ext1 i\n  simp\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2081_X_left MvPolynomial.bind\u2081_X_left\n\nvariable (f : \u03c3 \u2192 MvPolynomial \u03c4 R)\n\ntheorem bind\u2081_C_right (f : \u03c3 \u2192 MvPolynomial \u03c4 R) (x) : bind\u2081 f (C x) = C x := algHom_C _ _\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2081_C_right MvPolynomial.bind\u2081_C_right\n\n@[simp]\ntheorem bind\u2082_C_right (f : R \u2192+* MvPolynomial \u03c3 S) (r : R) : bind\u2082 f (C r) = f r :=\n  eval\u2082Hom_C f X r\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2082_C_right MvPolynomial.bind\u2082_C_right\n\n@[simp]\ntheorem bind\u2082_C_left : bind\u2082 (C : R \u2192+* MvPolynomial \u03c3 R) = RingHom.id _ := by ext : 2 <;> simp\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2082_C_left MvPolynomial.bind\u2082_C_left\n\n@[simp]\ntheorem bind\u2082_comp_C (f : R \u2192+* MvPolynomial \u03c3 S) : (bind\u2082 f).comp C = f :=\n  RingHom.ext <| bind\u2082_C_right _\nset_option linter.uppercaseLean3 false in\n#align mv_polynomial.bind\u2082_comp_C MvPolynomial.bind\u2082_comp_C\n\n@[simp]\n"}
{"name": "PreservesLimitPair.iso_inv_fst303", "split": "test", "formal_statement": "theorem PreservesLimitPair.iso_inv_fst :\n    (PreservesLimitPair.iso G X Y).inv \u226b G.map prod.fst = prod.fst := by", "header": "\nimport Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts\nimport Mathlib.CategoryTheory.Limits.Preserves.Basic\n\n#align_import category_theory.limits.preserves.shapes.binary_products from \"leanprover-community/mathlib\"@\"024a4231815538ac739f52d08dd20a55da0d6b23\"\n\n\n\n\nnoncomputable section\n\nuniverse v\u2081 v\u2082 u\u2081 u\u2082\n\nopen CategoryTheory CategoryTheory.Category CategoryTheory.Limits\n\nvariable {C : Type u\u2081} [Category.{v\u2081} C]\nvariable {D : Type u\u2082} [Category.{v\u2082} D]\nvariable (G : C \u2964 D)\n\nnamespace CategoryTheory.Limits\n\nsection\n\nvariable {P X Y Z : C} (f : P \u27f6 X) (g : P \u27f6 Y)\n\n\ndef isLimitMapConeBinaryFanEquiv :\n    IsLimit (G.mapCone (BinaryFan.mk f g)) \u2243 IsLimit (BinaryFan.mk (G.map f) (G.map g)) :=\n  (IsLimit.postcomposeHomEquiv (diagramIsoPair _) _).symm.trans\n    (IsLimit.equivIsoLimit\n      (Cones.ext (Iso.refl _)\n        (by rintro (_ | _) <;> simp)))\n#align category_theory.limits.is_limit_map_cone_binary_fan_equiv CategoryTheory.Limits.isLimitMapConeBinaryFanEquiv\n\n\ndef mapIsLimitOfPreservesOfIsLimit [PreservesLimit (pair X Y) G] (l : IsLimit (BinaryFan.mk f g)) :\n    IsLimit (BinaryFan.mk (G.map f) (G.map g)) :=\n  isLimitMapConeBinaryFanEquiv G f g (PreservesLimit.preserves l)\n#align category_theory.limits.map_is_limit_of_preserves_of_is_limit CategoryTheory.Limits.mapIsLimitOfPreservesOfIsLimit\n\n\ndef isLimitOfReflectsOfMapIsLimit [ReflectsLimit (pair X Y) G]\n    (l : IsLimit (BinaryFan.mk (G.map f) (G.map g))) : IsLimit (BinaryFan.mk f g) :=\n  ReflectsLimit.reflects ((isLimitMapConeBinaryFanEquiv G f g).symm l)\n#align category_theory.limits.is_limit_of_reflects_of_map_is_limit CategoryTheory.Limits.isLimitOfReflectsOfMapIsLimit\n\nvariable (X Y) [HasBinaryProduct X Y]\n\n\ndef isLimitOfHasBinaryProductOfPreservesLimit [PreservesLimit (pair X Y) G] :\n    IsLimit (BinaryFan.mk (G.map (Limits.prod.fst : X \u2a2f Y \u27f6 X)) (G.map Limits.prod.snd)) :=\n  mapIsLimitOfPreservesOfIsLimit G _ _ (prodIsProd X Y)\n#align category_theory.limits.is_limit_of_has_binary_product_of_preserves_limit CategoryTheory.Limits.isLimitOfHasBinaryProductOfPreservesLimit\n\nvariable [HasBinaryProduct (G.obj X) (G.obj Y)]\n\n\ndef PreservesLimitPair.ofIsoProdComparison [i : IsIso (prodComparison G X Y)] :\n    PreservesLimit (pair X Y) G := by\n  apply preservesLimitOfPreservesLimitCone (prodIsProd X Y)\n  apply (isLimitMapConeBinaryFanEquiv _ _ _).symm _\n  refine @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (pair (G.obj X) (G.obj Y))) ?_\n  apply i\n#align category_theory.limits.preserves_limit_pair.of_iso_prod_comparison CategoryTheory.Limits.PreservesLimitPair.ofIsoProdComparison\n\nvariable [PreservesLimit (pair X Y) G]\n\n\ndef PreservesLimitPair.iso : G.obj (X \u2a2f Y) \u2245 G.obj X \u2a2f G.obj Y :=\n  IsLimit.conePointUniqueUpToIso (isLimitOfHasBinaryProductOfPreservesLimit G X Y) (limit.isLimit _)\n#align category_theory.limits.preserves_limit_pair.iso CategoryTheory.Limits.PreservesLimitPair.iso\n\n@[simp]\ntheorem PreservesLimitPair.iso_hom : (PreservesLimitPair.iso G X Y).hom = prodComparison G X Y :=\n  rfl\n#align category_theory.limits.preserves_limit_pair.iso_hom CategoryTheory.Limits.PreservesLimitPair.iso_hom\n\n@[simp]\n"}
{"name": "IsG\u03b4.inter304", "split": "test", "formal_statement": "theorem IsG\u03b4.inter {s t : Set X} (hs : IsG\u03b4 s) (ht : IsG\u03b4 t) : IsG\u03b4 (s \u2229 t) := by", "header": "\nimport Mathlib.Topology.UniformSpace.Basic\nimport Mathlib.Topology.Separation\nimport Mathlib.Order.Filter.CountableInter\n\n#align_import topology.G_delta from \"leanprover-community/mathlib\"@\"b9e46fe101fc897fb2e7edaf0bf1f09ea49eb81a\"\n\n\n\n\nnoncomputable section\n\nopen Topology TopologicalSpace Filter Encodable Set\nopen scoped Uniformity\n\nvariable {X Y \u03b9 : Type*} {\u03b9' : Sort*}\n\nset_option linter.uppercaseLean3 false\n\nsection IsG\u03b4\n\nvariable [TopologicalSpace X]\n\n\ndef IsG\u03b4 (s : Set X) : Prop :=\n  \u2203 T : Set (Set X), (\u2200 t \u2208 T, IsOpen t) \u2227 T.Countable \u2227 s = \u22c2\u2080 T\n#align is_G\u03b4 IsG\u03b4\n\n\ntheorem IsOpen.isG\u03b4 {s : Set X} (h : IsOpen s) : IsG\u03b4 s :=\n  \u27e8{s}, by simp [h], countable_singleton _, (Set.sInter_singleton _).symm\u27e9\n#align is_open.is_G\u03b4 IsOpen.isG\u03b4\n\n@[simp]\nprotected theorem IsG\u03b4.empty : IsG\u03b4 (\u2205 : Set X) :=\n  isOpen_empty.isG\u03b4\n#align is_G\u03b4_empty IsG\u03b4.empty\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_empty := IsG\u03b4.empty\n\n@[simp]\nprotected theorem IsG\u03b4.univ : IsG\u03b4 (univ : Set X) :=\n  isOpen_univ.isG\u03b4\n#align is_G\u03b4_univ IsG\u03b4.univ\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_univ := IsG\u03b4.univ\n\ntheorem IsG\u03b4.biInter_of_isOpen {I : Set \u03b9} (hI : I.Countable) {f : \u03b9 \u2192 Set X}\n    (hf : \u2200 i \u2208 I, IsOpen (f i)) : IsG\u03b4 (\u22c2 i \u2208 I, f i) :=\n  \u27e8f '' I, by rwa [forall_mem_image], hI.image _, by rw [sInter_image]\u27e9\n#align is_G\u03b4_bInter_of_open IsG\u03b4.biInter_of_isOpen\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_biInter_of_isOpen := IsG\u03b4.biInter_of_isOpen\n\ntheorem IsG\u03b4.iInter_of_isOpen [Countable \u03b9'] {f : \u03b9' \u2192 Set X} (hf : \u2200 i, IsOpen (f i)) :\n    IsG\u03b4 (\u22c2 i, f i) :=\n  \u27e8range f, by rwa [forall_mem_range], countable_range _, by rw [sInter_range]\u27e9\n#align is_G\u03b4_Inter_of_open IsG\u03b4.iInter_of_isOpen\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_iInter_of_isOpen := IsG\u03b4.iInter_of_isOpen\n\nlemma isG\u03b4_iff_eq_iInter_nat {s : Set X} :\n    IsG\u03b4 s \u2194 \u2203 (f : \u2115 \u2192 Set X), (\u2200 n, IsOpen (f n)) \u2227 s = \u22c2 n, f n := by\n  refine \u27e8?_, ?_\u27e9\n  \u00b7 rintro \u27e8T, hT, T_count, rfl\u27e9\n    rcases Set.eq_empty_or_nonempty T with rfl|hT\n    \u00b7 exact \u27e8fun _n \u21a6 univ, fun _n \u21a6 isOpen_univ, by simp\u27e9\n    \u00b7 obtain \u27e8f, hf\u27e9 : \u2203 (f : \u2115 \u2192 Set X), T = range f := Countable.exists_eq_range T_count hT\n      exact \u27e8f, by aesop, by simp [hf]\u27e9\n  \u00b7 rintro \u27e8f, hf, rfl\u27e9\n    exact .iInter_of_isOpen hf\n\nalias \u27e8IsG\u03b4.eq_iInter_nat, _\u27e9 := isG\u03b4_iff_eq_iInter_nat\n\n\nprotected theorem IsG\u03b4.iInter [Countable \u03b9'] {s : \u03b9' \u2192 Set X} (hs : \u2200 i, IsG\u03b4 (s i)) :\n    IsG\u03b4 (\u22c2 i, s i) := by\n  choose T hTo hTc hTs using hs\n  obtain rfl : s = fun i => \u22c2\u2080 T i := funext hTs\n  refine \u27e8\u22c3 i, T i, ?_, countable_iUnion hTc, (sInter_iUnion _).symm\u27e9\n  simpa [@forall_swap \u03b9'] using hTo\n#align is_G\u03b4_Inter IsG\u03b4.iInter\n\n@[deprecated] alias isG\u03b4_iInter := IsG\u03b4.iInter\n\ntheorem IsG\u03b4.biInter {s : Set \u03b9} (hs : s.Countable) {t : \u2200 i \u2208 s, Set X}\n    (ht : \u2200 (i) (hi : i \u2208 s), IsG\u03b4 (t i hi)) : IsG\u03b4 (\u22c2 i \u2208 s, t i \u2039_\u203a) := by\n  rw [biInter_eq_iInter]\n  haveI := hs.to_subtype\n  exact .iInter fun x => ht x x.2\n#align is_G\u03b4_bInter IsG\u03b4.biInter\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_biInter := IsG\u03b4.biInter\n\n\ntheorem IsG\u03b4.sInter {S : Set (Set X)} (h : \u2200 s \u2208 S, IsG\u03b4 s) (hS : S.Countable) : IsG\u03b4 (\u22c2\u2080 S) := by\n  simpa only [sInter_eq_biInter] using IsG\u03b4.biInter hS h\n#align is_G\u03b4_sInter IsG\u03b4.sInter\n\n@[deprecated (since := \"2024-02-15\")] alias isG\u03b4_sInter := IsG\u03b4.sInter\n\n"}
{"name": "_root_.MeasureTheory.Integrable.comp_snd_map_prod_id305", "split": "test", "formal_statement": "theorem _root_.MeasureTheory.Integrable.comp_snd_map_prod_id [NormedAddCommGroup F] (hm : m \u2264 m\u03a9)\n    (hf : Integrable f \u03bc) : Integrable (fun x : \u03a9 \u00d7 \u03a9 => f x.2)\n      (@Measure.map \u03a9 (\u03a9 \u00d7 \u03a9) (m.prod m\u03a9) m\u03a9 (fun \u03c9 => (id \u03c9, id \u03c9)) \u03bc) := by", "header": "\nimport Mathlib.Probability.Kernel.CondDistrib\n\n#align_import probability.kernel.condexp from \"leanprover-community/mathlib\"@\"00abe0695d8767201e6d008afa22393978bb324d\"\n\n\n\n\nopen MeasureTheory Set Filter TopologicalSpace\n\nopen scoped ENNReal MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory\n\nsection AuxLemmas\n\nvariable {\u03a9 F : Type*} {m m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} {f : \u03a9 \u2192 F}\n\ntheorem _root_.MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_id [TopologicalSpace F]\n    (hm : m \u2264 m\u03a9) (hf : AEStronglyMeasurable f \u03bc) : AEStronglyMeasurable (fun x : \u03a9 \u00d7 \u03a9 => f x.2)\n      (@Measure.map \u03a9 (\u03a9 \u00d7 \u03a9) (m.prod m\u03a9) m\u03a9 (fun \u03c9 => (id \u03c9, id \u03c9)) \u03bc) := by\n  rw [\u2190 aestronglyMeasurable_comp_snd_map_prod_mk_iff (measurable_id'' hm)] at hf\n  simp_rw [id] at hf \u22a2\n  exact hf\n#align measure_theory.ae_strongly_measurable.comp_snd_map_prod_id MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_id\n\n"}
{"name": "mgf_zero'306", "split": "test", "formal_statement": "theorem mgf_zero' : mgf X \u03bc 0 = (\u03bc Set.univ).toReal := by", "header": "\nimport Mathlib.Probability.Variance\n\n#align_import probability.moments from \"leanprover-community/mathlib\"@\"85453a2a14be8da64caf15ca50930cf4c6e5d8de\"\n\n\n\n\nopen MeasureTheory Filter Finset Real\n\nnoncomputable section\n\nopen scoped MeasureTheory ProbabilityTheory ENNReal NNReal\n\nnamespace ProbabilityTheory\n\nvariable {\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {p : \u2115} {\u03bc : Measure \u03a9}\n\n\ndef moment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d :=\n  \u03bc[X ^ p]\n#align probability_theory.moment ProbabilityTheory.moment\n\n\ndef centralMoment (X : \u03a9 \u2192 \u211d) (p : \u2115) (\u03bc : Measure \u03a9) : \u211d := by\n  have m := fun (x : \u03a9) => \u03bc[X] -- Porting note: Lean deems `\u03bc[(X - fun x => \u03bc[X]) ^ p]` ambiguous\n  exact \u03bc[(X - m) ^ p]\n#align probability_theory.central_moment ProbabilityTheory.centralMoment\n\n@[simp]\ntheorem moment_zero (hp : p \u2260 0) : moment 0 p \u03bc = 0 := by\n  simp only [moment, hp, zero_pow, Ne, not_false_iff, Pi.zero_apply, integral_const,\n    smul_eq_mul, mul_zero, integral_zero]\n#align probability_theory.moment_zero ProbabilityTheory.moment_zero\n\n@[simp]\ntheorem centralMoment_zero (hp : p \u2260 0) : centralMoment 0 p \u03bc = 0 := by\n  simp only [centralMoment, hp, Pi.zero_apply, integral_const, smul_eq_mul,\n    mul_zero, zero_sub, Pi.pow_apply, Pi.neg_apply, neg_zero, zero_pow, Ne, not_false_iff]\n#align probability_theory.central_moment_zero ProbabilityTheory.centralMoment_zero\n\ntheorem centralMoment_one' [IsFiniteMeasure \u03bc] (h_int : Integrable X \u03bc) :\n    centralMoment X 1 \u03bc = (1 - (\u03bc Set.univ).toReal) * \u03bc[X] := by\n  simp only [centralMoment, Pi.sub_apply, pow_one]\n  rw [integral_sub h_int (integrable_const _)]\n  simp only [sub_mul, integral_const, smul_eq_mul, one_mul]\n#align probability_theory.central_moment_one' ProbabilityTheory.centralMoment_one'\n\n@[simp]\ntheorem centralMoment_one [IsProbabilityMeasure \u03bc] : centralMoment X 1 \u03bc = 0 := by\n  by_cases h_int : Integrable X \u03bc\n  \u00b7 rw [centralMoment_one' h_int]\n    simp only [measure_univ, ENNReal.one_toReal, sub_self, zero_mul]\n  \u00b7 simp only [centralMoment, Pi.sub_apply, pow_one]\n    have : \u00acIntegrable (fun x => X x - integral \u03bc X) \u03bc := by\n      refine fun h_sub => h_int ?_\n      have h_add : X = (fun x => X x - integral \u03bc X) + fun _ => integral \u03bc X := by ext1 x; simp\n      rw [h_add]\n      exact h_sub.add (integrable_const _)\n    rw [integral_undef this]\n#align probability_theory.central_moment_one ProbabilityTheory.centralMoment_one\n\ntheorem centralMoment_two_eq_variance [IsFiniteMeasure \u03bc] (hX : Mem\u2112p X 2 \u03bc) :\n    centralMoment X 2 \u03bc = variance X \u03bc := by rw [hX.variance_eq]; rfl\n#align probability_theory.central_moment_two_eq_variance ProbabilityTheory.centralMoment_two_eq_variance\n\nsection MomentGeneratingFunction\n\nvariable {t : \u211d}\n\n\ndef mgf (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) (t : \u211d) : \u211d :=\n  \u03bc[fun \u03c9 => exp (t * X \u03c9)]\n#align probability_theory.mgf ProbabilityTheory.mgf\n\n\ndef cgf (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) (t : \u211d) : \u211d :=\n  log (mgf X \u03bc t)\n#align probability_theory.cgf ProbabilityTheory.cgf\n\n@[simp]\ntheorem mgf_zero_fun : mgf 0 \u03bc t = (\u03bc Set.univ).toReal := by\n  simp only [mgf, Pi.zero_apply, mul_zero, exp_zero, integral_const, smul_eq_mul, mul_one]\n#align probability_theory.mgf_zero_fun ProbabilityTheory.mgf_zero_fun\n\n@[simp]\ntheorem cgf_zero_fun : cgf 0 \u03bc t = log (\u03bc Set.univ).toReal := by simp only [cgf, mgf_zero_fun]\n#align probability_theory.cgf_zero_fun ProbabilityTheory.cgf_zero_fun\n\n@[simp]\ntheorem mgf_zero_measure : mgf X (0 : Measure \u03a9) t = 0 := by simp only [mgf, integral_zero_measure]\n#align probability_theory.mgf_zero_measure ProbabilityTheory.mgf_zero_measure\n\n@[simp]\ntheorem cgf_zero_measure : cgf X (0 : Measure \u03a9) t = 0 := by\n  simp only [cgf, log_zero, mgf_zero_measure]\n#align probability_theory.cgf_zero_measure ProbabilityTheory.cgf_zero_measure\n\n@[simp]\ntheorem mgf_const' (c : \u211d) : mgf (fun _ => c) \u03bc t = (\u03bc Set.univ).toReal * exp (t * c) := by\n  simp only [mgf, integral_const, smul_eq_mul]\n#align probability_theory.mgf_const' ProbabilityTheory.mgf_const'\n\n-- @[simp] -- Porting note: `simp only` already proves this\ntheorem mgf_const (c : \u211d) [IsProbabilityMeasure \u03bc] : mgf (fun _ => c) \u03bc t = exp (t * c) := by\n  simp only [mgf_const', measure_univ, ENNReal.one_toReal, one_mul]\n#align probability_theory.mgf_const ProbabilityTheory.mgf_const\n\n@[simp]\ntheorem cgf_const' [IsFiniteMeasure \u03bc] (h\u03bc : \u03bc \u2260 0) (c : \u211d) :\n    cgf (fun _ => c) \u03bc t = log (\u03bc Set.univ).toReal + t * c := by\n  simp only [cgf, mgf_const']\n  rw [log_mul _ (exp_pos _).ne']\n  \u00b7 rw [log_exp _]\n  \u00b7 rw [Ne, ENNReal.toReal_eq_zero_iff, Measure.measure_univ_eq_zero]\n    simp only [h\u03bc, measure_ne_top \u03bc Set.univ, or_self_iff, not_false_iff]\n#align probability_theory.cgf_const' ProbabilityTheory.cgf_const'\n\n@[simp]\ntheorem cgf_const [IsProbabilityMeasure \u03bc] (c : \u211d) : cgf (fun _ => c) \u03bc t = t * c := by\n  simp only [cgf, mgf_const, log_exp]\n#align probability_theory.cgf_const ProbabilityTheory.cgf_const\n\n@[simp]\n"}
{"name": "dickson_add_two307", "split": "test", "formal_statement": "theorem dickson_add_two (n : \u2115) :\n    dickson k a (n + 2) = X * dickson k a (n + 1) - C a * dickson k a n := by", "header": "\nimport Mathlib.Algebra.CharP.Invertible\nimport Mathlib.Data.ZMod.Basic\nimport Mathlib.RingTheory.Localization.FractionRing\nimport Mathlib.RingTheory.Polynomial.Chebyshev\nimport Mathlib.RingTheory.Ideal.LocalRing\n\n#align_import ring_theory.polynomial.dickson from \"leanprover-community/mathlib\"@\"70fd9563a21e7b963887c9360bd29b2393e6225a\"\n\n\n\n\nnoncomputable section\n\nnamespace Polynomial\n\nopen Polynomial\n\nvariable {R S : Type*} [CommRing R] [CommRing S] (k : \u2115) (a : R)\n\n\nnoncomputable def dickson : \u2115 \u2192 R[X]\n  | 0 => 3 - k\n  | 1 => X\n  | n + 2 => X * dickson (n + 1) - C a * dickson n\n#align polynomial.dickson Polynomial.dickson\n\n@[simp]\ntheorem dickson_zero : dickson k a 0 = 3 - k :=\n  rfl\n#align polynomial.dickson_zero Polynomial.dickson_zero\n\n@[simp]\ntheorem dickson_one : dickson k a 1 = X :=\n  rfl\n#align polynomial.dickson_one Polynomial.dickson_one\n\ntheorem dickson_two : dickson k a 2 = X ^ 2 - C a * (3 - k : R[X]) := by\n  simp only [dickson, sq]\n#align polynomial.dickson_two Polynomial.dickson_two\n\n@[simp]\n"}
